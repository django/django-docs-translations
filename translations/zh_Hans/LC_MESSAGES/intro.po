# SOME DESCRIPTIVE TITLE.
# Copyright (C) Django Software Foundation and contributors
# This file is distributed under the same license as the Django package.
#
# Translators:
# Stone_Chen <595572594@qq.com>, 2018
# xin.wang <asimplelife@live.com>, 2018
# Bestony <xiqingongzi@gmail.com>, 2018
# Brian Wang <singeeking@gmail.com>, 2017
# Chown Hobby, 2016
# David <huangtao0202@gmail.com>, 2017
# Floyd Li <floyd.li@outlook.com>, 2017
# Fulong Sun <sunfulong@neusoft.edu.cn>, 2016
# Chown Hobby, 2016
# Kevin Lee <rootkitcn@live.com>, 2017
# Kevin Sze <leiarix@gmail.com>, 2014
# Ralph Wen <ralph.wen@gmail.com>, 2013
# spaceoi <zhangzhaoyu@gmail.com>, 2016
# Tuzi.Li <lzjwh1996@foxmail.com>, 2016
# xin.wang <asimplelife@live.com>, 2018
# xinyu liu <happy_lucky52@163.com>, 2017
# spaceoi <zhangzhaoyu@gmail.com>, 2016
# 吴彬 <xiake21x@qq.com>, 2016
# Stone_Chen <595572594@qq.com>, 2018
# 翔 付 <fuxiang2000@live.cn>, 2018
msgid ""
msgstr ""
"Project-Id-Version: django-docs\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-03-22 22:20-0500\n"
"PO-Revision-Date: 2018-03-23 14:17+0000\n"
"Last-Translator: Stone_Chen <595572594@qq.com>\n"
"Language-Team: Chinese (China) (http://www.transifex.com/django/django-docs/"
"language/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

msgid "Writing your first patch for Django"
msgstr "编写你的第一个 Django 补丁"

msgid "Introduction"
msgstr "介绍"

msgid ""
"Interested in giving back to the community a little? Maybe you've found a "
"bug in Django that you'd like to see fixed, or maybe there's a small feature "
"you want added."
msgstr ""
"想为 Django 社区做一点贡献？也许是你发现了一个想修复的 bug，或者想添加一个新"
"的功能。"

msgid ""
"Contributing back to Django itself is the best way to see your own concerns "
"addressed. This may seem daunting at first, but it's really pretty simple. "
"We'll walk you through the entire process, so you can learn by example."
msgstr ""
"回报 Django 这件事本身就是使你的顾虑得到解决的最好方式。一开始这可能会使你怯"
"步，但这真的很简单。整个过程中我们会一步一步为你解说，所以你可以通过例子学"
"习。"

msgid "Who's this tutorial for?"
msgstr "这个教程适合谁？"

msgid ""
"If you are looking for a reference on how to submit patches, see the :doc:`/"
"internals/contributing/writing-code/submitting-patches` documentation."
msgstr ""
"如果你正在寻找一个关于如何提交补丁的说明文档，请查看 :doc:`/internals/"
"contributing/writing-code/submitting-patches`。"

msgid ""
"For this tutorial, we expect that you have at least a basic understanding of "
"how Django works. This means you should be comfortable going through the "
"existing tutorials on :doc:`writing your first Django app</intro/"
"tutorial01>`. In addition, you should have a good understanding of Python "
"itself. But if you don't, `Dive Into Python`__ is a fantastic (and free) "
"online book for beginning Python programmers."
msgstr ""
"使用教程前，我们希望你至少对于 Django 的运行方式有一定的认识。 这意味着你可以"
"很容易地通读 :doc:`编写第一个 Django 应用 </intro/tutorial01>`。 除此之外，你"
"应该对于 Python 有很好的理解。 如果不太熟悉 Python，我们为您推荐  `Dive Into "
"Python`__，对于初学Python的程序员来说这是一本很棒（而且免费）的在线电子书。"

msgid ""
"Those of you who are unfamiliar with version control systems and Trac will "
"find that this tutorial and its links include just enough information to get "
"started. However, you'll probably want to read some more about these "
"different tools if you plan on contributing to Django regularly."
msgstr ""
"那些不熟悉版本控制系统及缺陷跟踪的朋友可以查看这个教程，这个链接包含了足够的"
"信息。如果你打算定期地为 Django 做贡献，你可能期望阅读更多关于这些不同工具的"
"资料。"

msgid ""
"For the most part though, this tutorial tries to explain as much as "
"possible, so that it can be of use to the widest audience."
msgstr ""
"当然对于此教程中的大部分内容，Django 会尽可能做出解释以帮助广大的读者。"

msgid "Where to get help:"
msgstr "从哪里获得帮助："

msgid ""
"If you're having trouble going through this tutorial, please post a message "
"to |django-developers| or drop by `#django-dev on irc.freenode.net`__ to "
"chat with other Django users who might be able to help."
msgstr ""
"如果你在使用本教程时遇到困难, 你可以发信息给 |django-developers| 中的人或登"
"陆 `#django-dev on irc.freenode.net`__ 向其他 Django 使用者寻求帮助。"

msgid "What does this tutorial cover?"
msgstr "这个指南涵盖哪些内容？"

msgid ""
"We'll be walking you through contributing a patch to Django for the first "
"time. By the end of this tutorial, you should have a basic understanding of "
"both the tools and the processes involved. Specifically, we'll be covering "
"the following:"
msgstr ""
"我们将指导你贡献你的第一个 Django 补丁，在本教程完毕时，你将对相关工具及流程"
"有一个基本的认识。特别的，我们将覆盖以下内容："

msgid "Installing Git."
msgstr "安装 Git。"

msgid "How to download a development copy of Django."
msgstr "如何下载 Django 的开发版。"

msgid "Running Django's test suite."
msgstr "运行 Django 的测试套件。"

msgid "Writing a test for your patch."
msgstr "为你的补丁写一个测试。"

msgid "Writing the code for your patch."
msgstr "为你的补丁编写代码。"

msgid "Testing your patch."
msgstr "测试你的补丁。"

msgid "Submitting a pull request."
msgstr "提交一个 pull request（PR）。"

msgid "Where to look for more information."
msgstr "在哪里查找更多的信息。"

msgid ""
"Once you're done with the tutorial, you can look through the rest of :doc:"
"`Django's documentation on contributing</internals/contributing/index>`. It "
"contains lots of great information and is a must read for anyone who'd like "
"to become a regular contributor to Django. If you've got questions, it's "
"probably got the answers."
msgstr ""
"一旦你完成了这份教程，你可以浏览 :doc:`Django 贡献文档 </internals/"
"contributing/index>` 的剩余部分。它包含了大量信息。任何想成为 Django 的正式贡"
"献者的人都必须阅读它。如果你有问题，它也许会给你答案。"

msgid "Python 3 required!"
msgstr "必须Python 3！"

msgid ""
"The current version of Django doesn't support Python 2.7. Get Python 3 at "
"`Python's download page <https://www.python.org/downloads/>`_ or with your "
"operating system's package manager."
msgstr ""
"目前的 Django 版本不再支持 Python 2.7。你可以在 `Python 下载页 <https://www."
"python.org/downloads/>`_ 或通过操作系统的包管理器下载 Python 3。"

msgid "For Windows users"
msgstr "对于 Windows 用户"

msgid ""
"When installing Python on Windows, make sure you check the option \"Add "
"python.exe to Path\", so that it is always available on the command line."
msgstr ""
"在Windows上安装 Python 时，确保勾选在环境变量path中“添加 python.exe 的路径”，"
"这样才可以让它在命令行下总是可用。"

msgid "Code of Conduct"
msgstr "代码规范"

msgid ""
"As a contributor, you can help us keep the Django community open and "
"inclusive. Please read and follow our `Code of Conduct <https://www."
"djangoproject.com/conduct/>`_."
msgstr ""
"作为一个贡献者, 你可以帮助我们保持 Django 的社区开放性和包容性。请仔细阅读并"
"遵守我们的 `行为守则 <https://www.djangoproject.com/conduct/>`_。"

msgid "Installing Git"
msgstr "安装Git"

msgid ""
"For this tutorial, you'll need Git installed to download the current "
"development version of Django and to generate patch files for the changes "
"you make."
msgstr ""
"在本教程中，你需要安装好 Git，用 Git 下载 Django 的最新开发版本并且为你的修改"
"生成补丁文件。"

msgid ""
"To check whether or not you have Git installed, enter ``git`` into the "
"command line. If you get messages saying that this command could not be "
"found, you'll have to download and install it, see `Git's download page`__."
msgstr ""
"要检查你是否已经安装 Git，命令行输入 ``git``。如果提示这个命令无法找到，你必"
"须下载并安装它，参考 `Git's download page`__。"

msgid ""
"When installing Git on Windows, it is recommended that you pick the \"Git "
"Bash\" option so that Git runs in its own shell. This tutorial assumes "
"that's how you have installed it."
msgstr ""
"在 Windows 上安装 Git， 我们推荐勾选 \"Git Bash\" 选项， 以便 Git 能在它的独"
"立 shell 下正常运行。本教程假定你这就是这样安装的。"

msgid ""
"If you're not that familiar with Git, you can always find out more about its "
"commands (once it's installed) by typing ``git help`` into the command line."
msgstr ""
"如果你还不熟悉 Git, 你可以在命令行下输入 ``git help``  了解更多关于 Git 命令"
"的使用方法 (确保已安装) "

msgid "Getting a copy of Django's development version"
msgstr "获得一个 Django 开发版本的副本"

msgid ""
"The first step to contributing to Django is to get a copy of the source "
"code. First, `fork Django on GitHub <https://github.com/django/django/"
"fork>`__. Then, from the command line, use the ``cd`` command to navigate to "
"the directory where you'll want your local copy of Django to live."
msgstr ""
"为 Django 做贡献的第一步就是获取源代码副本。首先， `fork Github 上的 Django "
"项目 <https://github.com/django/django/fork>`。接下来，在命令行中，使用 "
"``cd`` 命令切换至某个你想存放 Django 源码的目录。"

msgid "Download the Django source code repository using the following command:"
msgstr "使用下面的命令来下载 Django 的源码库："

msgid ""
"Now that you have a local copy of Django, you can install it just like you "
"would install any package using ``pip``. The most convenient way to do so is "
"by using a *virtual environment* (or virtualenv) which is a feature built "
"into Python that allows you to keep a separate directory of installed "
"packages for each of your projects so that they don't interfere with each "
"other."
msgstr ""
"现在，你有了 Django 的本地副本，你可以安装它，就像你用 ``pip`` 安装其它软件包"
"一样。 最方便的方式是通过使用 *虚拟环境* （或 virtualenv）， 这是 Python 的内"
"置功能，可以将每个项目安装的软件包放在不同的目录内，确保它们不会互相干扰。"

msgid ""
"It's a good idea to keep all your virtualenvs in one place, for example in "
"``.virtualenvs/`` in your home directory. Create it if it doesn't exist yet:"
msgstr ""
"将你所有的 virtualenvs 保存在同一个地方是个不错的主意，例如你主目录下的 ``."
"virtualenvs/``。如果这个文件夹不存在的话，创建它："

msgid "Now create a new virtualenv by running:"
msgstr "现在创建新的虚拟运行环境"

msgid "The path is where the new environment will be saved on your computer."
msgstr "该路径就是保存这个新的虚拟运行环境的地方。"

msgid ""
"Using the built-in ``venv`` module will not work if you are also using the "
"Git Bash shell on Windows, since activation scripts are only created for the "
"system shell (``.bat``) and PowerShell (``.ps1``). Use the ``virtualenv`` "
"package instead:"
msgstr ""
"如果你在 Windows 上使用 Git Bash shell，内置的 ``venv`` 模块将不会生效。因为"
"激活脚本仅创建了系统 shell (``.bat``) 和 PowerShell (``.ps1``) 的版本。 转而"
"使用下面安装的 ``virtualenv`` ："

msgid "For Ubuntu users"
msgstr "Ubuntu 用户"

msgid ""
"On some versions of Ubuntu the above command might fail. Use the "
"``virtualenv`` package instead, first making sure you have ``pip3``:"
msgstr ""
"在 Ubuntu 的某些版本使用以上命令可能会失败。可以换成 ``virtualenv`` 这个包名"
"试试，不过，你要先确保已安装 ``pip3``："

msgid "The final step in setting up your virtualenv is to activate it:"
msgstr "最后一步是激活你的 virtualenv 设置："

msgid ""
"If the ``source`` command is not available, you can try using a dot instead:"
msgstr "如果 ``source`` 命令不可用，你可以试试 . ："

msgid "To activate your virtualenv on Windows, run:"
msgstr "在 Windows 上激活你的 virtualenv，运行："

msgid ""
"You have to activate the virtualenv whenever you open a new terminal window. "
"virtualenvwrapper__ is a useful tool for making this more convenient."
msgstr ""
"在你打开一个终端前，你必须先激活 virtualenv。 virtualenvwrapper__ 是个不错的"
"工具，简化了此操作。"

msgid ""
"Anything you install through ``pip`` from now on will be installed in your "
"new virtualenv, isolated from other environments and system-wide packages. "
"Also, the name of the currently activated virtualenv is displayed on the "
"command line to help you keep track of which one you are using. Go ahead and "
"install the previously cloned copy of Django:"
msgstr ""
"从现在开始你通过 ``pip`` 安装的软件包都将被安装在新的 virtualenv ，与其他环境"
"和系统级包隔离。此外，命令行上显示了当前激活的 virtualenv 的名称，以帮助您跟"
"踪您正在使用哪个环境。来吧，安装之前克隆的 Django 副本："

msgid ""
"The installed version of Django is now pointing at your local copy. You will "
"immediately see any changes you make to it, which is of great help when "
"writing your first patch."
msgstr ""
"现在安装的 Django 版本就是你本地副本的版本。你将立刻见到任何你对它的修改，这"
"对你编写第一个补丁很有帮助。"

msgid "Rolling back to a previous revision of Django"
msgstr "回滚至之前的 Django 版本"

msgid ""
"For this tutorial, we'll be using ticket :ticket:`24788` as a case study, so "
"we'll rewind Django's version history in git to before that ticket's patch "
"was applied. This will allow us to go through all of the steps involved in "
"writing that patch from scratch, including running Django's test suite."
msgstr ""
"这个教程中，我们使用工单 :ticket:`24788` 来作为学习用例，所以我们回顾 git 中 "
"Django 的版本历史，找到一个这个问题的补丁没有提交之前的版本。 这样的话我们就"
"可以参与到从草稿到完成补丁的全过程，包括运行 Django 的测试套件。"

msgid ""
"**Keep in mind that while we'll be using an older revision of Django's trunk "
"for the purposes of the tutorial below, you should always use the current "
"development revision of Django when working on your own patch for a ticket!**"
msgstr ""
"**请记住，我们将用 Django 的老版本来到达学习的目的，通常情况下你应当使用当前"
"最新的开发版本来提交补丁并解决工单！**"

msgid ""
"The patch for this ticket was written by Paweł Marczewski, and it was "
"applied to Django as `commit 4df7e8483b2679fc1cba3410f08960bac6f51115`__. "
"Consequently, we'll be using the revision of Django just prior to that, "
"`commit 4ccfc4439a7add24f8db4ef3960d02ef8ae09887`__."
msgstr ""
"这个补丁由 Paweł Marczewski 开发，并 Git  commit 到 Django 源码 `commit "
"4df7e8483b2679fc1cba3410f08960bac6f51115`__。因此, 我们要回到补丁提交之前的版"
"本号， `commit 4ccfc4439a7add24f8db4ef3960d02ef8ae09887`__。"

msgid ""
"Navigate into Django's root directory (that's the one that contains "
"``django``, ``docs``, ``tests``, ``AUTHORS``, etc.). You can then check out "
"the older revision of Django that we'll be using in the tutorial below:"
msgstr ""
"首先打开 Django 源码的根目录（这个目录包含了 ``django``， ``docs``， "
"``tests``， ``AUTHORS``，等等）。然后你可以 check out 下面教程要用的较早版本"
"的 Django ："

msgid "Running Django's test suite for the first time"
msgstr "首先运行 Django 的测试套件"

msgid ""
"When contributing to Django it's very important that your code changes don't "
"introduce bugs into other areas of Django. One way to check that Django "
"still works after you make your changes is by running Django's test suite. "
"If all the tests still pass, then you can be reasonably sure that your "
"changes haven't completely broken Django. If you've never run Django's test "
"suite before, it's a good idea to run it once beforehand just to get "
"familiar with what its output is supposed to look like."
msgstr ""
"当你贡献代码给 Django 的时候，你修改的代码千万不要给其它部分引入新的 bug。 有"
"个办法可以在你更改代码之后检查 Django 是否能正常工作，就是运行 Django 的测试"
"套件。如果所有的测试用例都通过，你就有理由相信你的改动完全没有破坏 Django。如"
"果你从来没有运行过 Django 的测试套件，那么比较好的做法是事先运行一遍，熟悉下"
"正常情况下应该输出什么结果。"

msgid ""
"Before running the test suite, install its dependencies by first ``cd``-ing "
"into the Django ``tests/`` directory and then running:"
msgstr ""
"运行测试套件之前，先 ``cd`` 进入 Django 的 ``test/`` 目录，安装其依赖，运行："

msgid ""
"If you encounter an error during the installation, your system might be "
"missing a dependency for one or more of the Python packages. Consult the "
"failing package's documentation or search the Web with the error message "
"that you encounter."
msgstr ""
"如果安装过程中发生了错误，可能是你的系统缺少一个或多个 Python 依赖包。请参考"
"安装失败的包的文档或者在网上搜索提示的错误信息。"

msgid ""
"Now we are ready to run the test suite. If you're using GNU/Linux, macOS, or "
"some other flavor of Unix, run:"
msgstr ""
"现在你可以运行测试套件。如果你用的是 GNU/Linux， macOS 或者其它类 Unix 系统，"
"运行："

msgid ""
"Now sit back and relax. Django's entire test suite has over 9,600 different "
"tests, so it can take anywhere from 5 to 15 minutes to run, depending on the "
"speed of your computer."
msgstr ""
"现在坐下来放松一下。Django 完整的测试套件有超过 9600 种不同的测试，所以它需要"
"运行 5 到 15 分钟，这取决于你的电脑的速度。"

msgid ""
"While Django's test suite is running, you'll see a stream of characters "
"representing the status of each test as it's run. ``E`` indicates that an "
"error was raised during a test, and ``F`` indicates that a test's assertions "
"failed. Both of these are considered to be test failures. Meanwhile, ``x`` "
"and ``s`` indicated expected failures and skipped tests, respectively. Dots "
"indicate passing tests."
msgstr ""
"Django 的测试套件运行时，您将看到一个字符流代表每个测试的运行的状态。 ``E`` "
"表示测试中出现异常， ``F`` 表示断言失败。这两种情况都被认为测试失败， ``x`` "
"和 ``s`` 分别表示与期望结果不同和跳过测试，点表示测试通过。"

msgid ""
"Skipped tests are typically due to missing external libraries required to "
"run the test; see :ref:`running-unit-tests-dependencies` for a list of "
"dependencies and be sure to install any for tests related to the changes you "
"are making (we won't need any for this tutorial). Some tests are specific to "
"a particular database backend and will be skipped if not testing with that "
"backend. SQLite is the database backend for the default settings. To run the "
"tests using a different backend, see :ref:`running-unit-tests-settings`."
msgstr ""
"缺失外部依赖库通常会导致测试被跳过；查看 :ref:`running-unit-tests-"
"dependencies` 获取依赖库列表，如果你修改了测试代码，请同时安装相关依赖库（本"
"教程无需额外依赖库）。某些测试使用了特定的数据库后端，如果当前测试设置并未使"
"用此数据库后端，那么这些相关的测试也会被跳过。SQLite 是默认的数据库后端。如果"
"想使用其他后端进行测试，查看 :ref:`running-unit-tests-settings`。"

msgid ""
"Once the tests complete, you should be greeted with a message informing you "
"whether the test suite passed or failed. Since you haven't yet made any "
"changes to Django's code, the entire test suite **should** pass. If you get "
"failures or errors make sure you've followed all of the previous steps "
"properly. See :ref:`running-unit-tests` for more information. If you're "
"using Python 3.5+, there will be a couple failures related to deprecation "
"warnings that you can ignore. These failures have since been fixed in Django."
msgstr ""
"一旦测试完成，你将被告知测试通过与否。正因你尚未修改 Django 代码，整个测试套"
"件 **应该** 成功通过。如果遇到失败或错误，请确认是否遵照了之前所有的步骤。查"
"看 :ref:`running-unit-tests` 了解更多。如果你使用的是 Python 3.5+，可能会产生"
"一些和 deprecation 警告相关的失败，可忽略。这些失败已在 Django 中得到修复。"

msgid ""
"Note that the latest Django trunk may not always be stable. When developing "
"against trunk, you can check `Django's continuous integration builds`__ to "
"determine if the failures are specific to your machine or if they are also "
"present in Django's official builds. If you click to view a particular "
"build, you can view the \"Configuration Matrix\" which shows failures broken "
"down by Python version and database backend."
msgstr ""
"注意最新版本 Django 分支不总是稳定的。当在分支上开发时，你可以查看代码持续集"
"成构建页面的信息 `Django's continuous integration builds`__ 来判断测试错误只"
"在你指定的电脑上发生，还是官方版本中也存在该错误。如果点击某个构建信息，可以"
"通过 \"Configuration Matrix\" 查看错误发生时 Python 以及后端数据库的信息。"

msgid ""
"For this tutorial and the ticket we're working on, testing against SQLite is "
"sufficient, however, it's possible (and sometimes necessary) to :ref:`run "
"the tests using a different database <running-unit-tests-settings>`."
msgstr ""
"在本教程以及处理工单所用分支中，测试使用数据库 SQLite 即可，然而在某些情况下"
"需要（有时需要） ，参考 :ref:`run the tests using a different database `。"

msgid "Creating a branch for your patch"
msgstr "为你的补丁创建一个分支"

msgid "Before making any changes, create a new branch for the ticket:"
msgstr "在做出任何修改之前，为你的工单创建一个分支："

msgid ""
"You can choose any name that you want for the branch, \"ticket_24788\" is an "
"example. All changes made in this branch will be specific to the ticket and "
"won't affect the main copy of the code that we cloned earlier."
msgstr ""
"你可以选择任何名称来命名你的分支，\"ticket_24788\" 是一个例子。所有在这个分支"
"的修改只会对特定的工单生效，不会影响我们之前克隆的主分支。"

msgid "Writing some tests for your ticket"
msgstr "为你的工单写一些测试用例"

msgid ""
"In most cases, for a patch to be accepted into Django it has to include "
"tests. For bug fix patches, this means writing a regression test to ensure "
"that the bug is never reintroduced into Django later on. A regression test "
"should be written in such a way that it will fail while the bug still exists "
"and pass once the bug has been fixed. For patches containing new features, "
"you'll need to include tests which ensure that the new features are working "
"correctly. They too should fail when the new feature is not present, and "
"then pass once it has been implemented."
msgstr ""
"大多数情况下，Django 的补丁必需包含测试。Bug 修复补丁的测试是一个回归测试，确"
"保该 Bug 不会再次在 Django 中出现。该测试应该在 Bug 存在时测试失败，在 Bug 已"
"经修复后通过测试。新功能补丁的测试必须验证新功能是否正常运行。新功能的测试将"
"在功能正常时通过测试，功能未执行时测试失败。"

msgid ""
"A good way to do this is to write your new tests first, before making any "
"changes to the code. This style of development is called `test-driven "
"development`__ and can be applied to both entire projects and single "
"patches. After writing your tests, you then run them to make sure that they "
"do indeed fail (since you haven't fixed that bug or added that feature yet). "
"If your new tests don't fail, you'll need to fix them so that they do. After "
"all, a regression test that passes regardless of whether a bug is present is "
"not very helpful at preventing that bug from reoccurring down the road."
msgstr ""
"最好的方式是在修改代码之前写测试单元代码。这种开发风格叫做 `test-driven "
"development`__ 被应用在项目开发和单一补丁开发过程中。单元测试编写完毕后，执行"
"单元测试，此时测试失败（因为目前还没有修复 bug 或添加新功能），如果测试成功通"
"过，你需要重新修改单元测试保证测试失败。因为单元测试并不能阻止 bug 发生。"

msgid "Now for our hands-on example."
msgstr "现在看我们的操作示例。"

msgid "Writing some tests for ticket #24788"
msgstr "为工单 #24788 写测试"

msgid ""
"Ticket :ticket:`24788` proposes a small feature addition: the ability to "
"specify the class level attribute ``prefix`` on Form classes, so that::"
msgstr ""
"工单 :ticket:`24788` 提议增加小特性：为表单类指定类级别的属性 ``prefix``，以"
"便::"

msgid ""
"In order to resolve this ticket, we'll add a ``prefix`` attribute to the "
"``BaseForm`` class. When creating instances of this class, passing a prefix "
"to the ``__init__()`` method will still set that prefix on the created "
"instance. But not passing a prefix (or passing ``None``) will use the class-"
"level prefix. Before we make those changes though, we're going to write a "
"couple tests to verify that our modification functions correctly and "
"continues to function correctly in the future."
msgstr ""
"为解决此工单，我们为 ``BaseForm`` 类添加了 ``prefix`` 属性。当创建该类实例"
"时， 向 ``__init__()`` 方法传递 prefix 时，设置的仍然是实例属性 prefix。当不"
"传递 prefix（或者传递值为 ``None``）时，将会使用类级别的 prefix。 在我们作出"
"修改前，我们先写一些测试来验证我们修改的功能无误，进而确保它在将来也不会出现"
"问题。"

msgid ""
"Navigate to Django's ``tests/forms_tests/tests/`` folder and open the "
"``test_forms.py`` file. Add the following code on line 1674 right before the "
"``test_forms_with_null_boolean`` function::"
msgstr ""
"前往 Django 的 ``tests/forms_tests/tests/`` 目录并打开 ``test_forms.py`` 文"
"件。在 1674 行附近的 ``test_forms_with_null_boolean`` 函数之前插入以下代码："

msgid ""
"This new test checks that setting a class level prefix works as expected, "
"and that passing a ``prefix`` parameter when creating an instance still "
"works too."
msgstr ""
"这个新测试用来检查：按预想设定了类级别的 prefix，创建实例时传递 ``prefix`` 参"
"数仍然有效。"

msgid "But this testing thing looks kinda hard..."
msgstr "但这种测试看起来有点困难……"

msgid ""
"If you've never had to deal with tests before, they can look a little hard "
"to write at first glance. Fortunately, testing is a *very* big subject in "
"computer programming, so there's lots of information out there:"
msgstr ""
"如果你之前从未处理过测试，那他们看起来会有点难以编写。幸运的是，测试是一个计"
"算机编程中 *非常* 大的一个主题，所以这里有大量的相关资料："

msgid ""
"A good first look at writing tests for Django can be found in the "
"documentation on :doc:`/topics/testing/overview`."
msgstr ""
"浏览 :doc:`/topics/testing/overview` 大致看一下如何在 Django 中编写测试。"

msgid ""
"Dive Into Python (a free online book for beginning Python developers) "
"includes a great `introduction to Unit Testing`__."
msgstr ""
"深入理解 Python（一本针对 Python 初学者的免费在线书籍），包含了不错的 "
"`introduction to Unit Testing`__。"

msgid ""
"After reading those, if you want something a little meatier to sink your "
"teeth into, there's always the Python :mod:`unittest` documentation."
msgstr "读到这里，你还想深入了解的话，可以查看 Python :mod:`unittest`。"

msgid "Running your new test"
msgstr "运行你的新测试"

msgid ""
"Remember that we haven't actually made any modifications to ``BaseForm`` "
"yet, so our tests are going to fail. Let's run all the tests in the "
"``forms_tests`` folder to make sure that's really what happens. From the "
"command line, ``cd`` into the Django ``tests/`` directory and run:"
msgstr ""
"事实上，我们还没有对 ``BaseForm`` 做出任何修改，所以我们的测试将会失败。让我"
"们运行 ``forms_tests`` 下所有的测试来看看会发生什么。在命令行中使用 ``cd`` 进"
"入 Django 的 ``tests/`` 目录并运行："

msgid ""
"If the tests ran correctly, you should see one failure corresponding to the "
"test method we added. If all of the tests passed, then you'll want to make "
"sure that you added the new test shown above to the appropriate folder and "
"class."
msgstr ""
"如果测试执行正确，你应该能看到一个错误，正好由我们刚添加的测试方法报告。如果"
"所有测试都通过了，你应该确认下是否将上述新的测试代码加到了合适的文件夹和类"
"里。"

msgid "Writing the code for your ticket"
msgstr "为你的工单编写代码"

msgid ""
"Next we'll be adding the functionality described in ticket :ticket:`24788` "
"to Django."
msgstr "下一步我们将把在工单 :ticket:`24788` 中描述的功能添加进 Django。"

msgid "Writing the code for ticket #24788"
msgstr "为工单 #24788 编写代码"

msgid ""
"Navigate to the ``django/django/forms/`` folder and open the ``forms.py`` "
"file. Find the ``BaseForm`` class on line 72 and add the ``prefix`` class "
"attribute right after the ``field_order`` attribute::"
msgstr ""
"进入 ``django/django/forms/`` 文件夹并打开 ``forms.py`` 文件。找到第 72 行的 "
"``BaseForm`` 类，在 ``field_order`` 属性之后添加 ``prefix`` 类属性::"

msgid "Verifying your test now passes"
msgstr "确保你的测试现在通过了"

msgid ""
"Once you're done modifying Django, we need to make sure that the tests we "
"wrote earlier pass, so we can see whether the code we wrote above is working "
"correctly. To run the tests in the ``forms_tests`` folder, ``cd`` into the "
"Django ``tests/`` directory and run:"
msgstr ""
"修改 Django 源码后，我们通过之前编写的测试方法来验证源码修改是否工作正常。运"
"行测试 ``forms_tests`` 目录下所有的测试方法， ``cd`` 进入  Django 的 ``tests/"
"`` 目录然后运行："

msgid ""
"Oops, good thing we wrote those tests! You should still see one failure with "
"the following exception::"
msgstr "哦，好消息是我们写了这些测试用例！不过，你仍收到一个异常::"

msgid ""
"We forgot to add the conditional statement in the ``__init__`` method. Go "
"ahead and change ``self.prefix = prefix`` that is now on line 87 of ``django/"
"forms/forms.py``, adding a conditional statement::"
msgstr ""
"我们忘了在 ``__init__`` 方法中添加条件语句。在 ``django/forms/forms.py`` 中，"
"更改现在在第 87 行的代码 ``self.prefix = prefix``，添加一个条件语句::"

msgid ""
"Re-run the tests and everything should pass. If it doesn't, make sure you "
"correctly modified the ``BaseForm`` class as shown above and copied the new "
"test correctly."
msgstr ""
"重新运行测试方法会通过所有测试。如果没有通过测试，请重新确认是否按要求修改了"
"上面提到的类 ``BaseForm``，以及新添加的测试方法是否被正确复制到指定位置。"

msgid "Running Django's test suite for the second time"
msgstr "第二次运行 Django 测试套件"

msgid ""
"Once you've verified that your patch and your test are working correctly, "
"it's a good idea to run the entire Django test suite just to verify that "
"your change hasn't introduced any bugs into other areas of Django. While "
"successfully passing the entire test suite doesn't guarantee your code is "
"bug free, it does help identify many bugs and regressions that might "
"otherwise go unnoticed."
msgstr ""
"如果已经确认补丁以及测试结果都正常，就运行 Django 的测试套件，验证你的修改是"
"否导致 Django 的其它部分引入了新的 bug。 虽然测试用例帮助识别容易被人忽略的错"
"误，但测试通过并不能保证完全没有 bug 存在。"

msgid ""
"To run the entire Django test suite, ``cd`` into the Django ``tests/`` "
"directory and run:"
msgstr ""
"运行 Django 完整的测试用例，``cd`` 进入 Django下的  ``tests/`` 目录并运行："

msgid "As long as you don't see any failures, you're good to go."
msgstr "只要没有看到测试异常，你就可以继续下一步。"

msgid "Writing Documentation"
msgstr "书写文档"

msgid ""
"This is a new feature, so it should be documented. Add the following section "
"on line 1068 (at the end of the file) of ``django/docs/ref/forms/api.txt``::"
msgstr ""
"这个新功能信息应该被记录成文档。在 ``django/docs/ref/forms/api.txt`` 第 1068 "
"行（在文件末）添加以下部分内容::"

msgid ""
"Since this new feature will be in an upcoming release it is also added to "
"the release notes for Django 1.9, on line 164 under the \"Forms\" section in "
"the file ``docs/releases/1.9.txt``::"
msgstr ""
"由于一新功能将在未来的某个版本被加入，所以 Django 1.9 的发布说明里加入了相关"
"内容，在文件 ``docs/releases/1.9.txt`` 第 164 行 \"Forms\" 部分::"

msgid ""
"For more information on writing documentation, including an explanation of "
"what the ``versionadded`` bit is all about, see :doc:`/internals/"
"contributing/writing-documentation`. That page also includes an explanation "
"of how to build a copy of the documentation locally, so you can preview the "
"HTML that will be generated."
msgstr ""
"更多关于编写文档和 ``versionadded`` 的解释和信息，请参考 :doc:`/internals/"
"contributing/writing-documentation`。这个页面还介绍了怎么在本地重新生成一份文"
"档，方便你在本地预览文档。"

msgid "Previewing your changes"
msgstr "预览你的修改"

msgid ""
"Now it's time to go through all the changes made in our patch. To display "
"the differences between your current copy of Django (with your changes) and "
"the revision that you initially checked out earlier in the tutorial:"
msgstr ""
"现在让我们检查一下补丁里作出的修改。为列出当前 Django 副本（包含你的修改）和"
"先前教程中签出的初始版本间的差异："

msgid "Use the arrow keys to move up and down."
msgstr "使用方向键上下移动"

msgid ""
"When you're done previewing the patch, hit the ``q`` key to return to the "
"command line. If the patch's content looked okay, it's time to commit the "
"changes."
msgstr ""
"当你检查完补丁后，敲击 ``q`` 键返回到命令行。如果补丁内容看起来没问题，可以提"
"交这些修改了。"

msgid "Committing the changes in the patch"
msgstr "提交补丁中的修改"

msgid "To commit the changes:"
msgstr "为了提交这些修改："

msgid ""
"This opens up a text editor to type the commit message. Follow the :ref:"
"`commit message guidelines <committing-guidelines>` and write a message like:"
msgstr ""
"这会打开文本编辑器以便输入提交信息。参考 :ref:`commit message guidelines "
"<committing-guidelines>` 输入类似这样的信息："

msgid "Pushing the commit and making a pull request"
msgstr "推送这次提交并生成一个 pull 请求"

msgid ""
"After committing the patch, send it to your fork on GitHub (substitute "
"\"ticket_24788\" with the name of your branch if it's different):"
msgstr ""
"提交补丁后，将它发送至你在 GitHub 上 fork 的仓库（用你的分支名替换 "
"\"ticket_24788\"，如果你的分支名不是遵照教程）："

msgid ""
"You can create a pull request by visiting the `Django GitHub page <https://"
"github.com/django/django/>`_. You'll see your branch under \"Your recently "
"pushed branches\". Click \"Compare & pull request\" next to it."
msgstr ""
"你可以访问 `Django GitHub page <https://github.com/django/django/>`_ 创建一"
"个 pull 请求。 你会在“你最近推送的分支”下看到你的分支。 单击旁边的 \"Compare "
"& pull request\"。"

msgid ""
"Please don't do it for this tutorial, but on the next page that displays a "
"preview of the patch, you would click \"Create pull request\"."
msgstr ""
"本教程中请不要这么做。不过，在接下来显示补丁预览的页面，你可以单击 \"Create "
"pull request\"。"

msgid "Next steps"
msgstr "下一步"

msgid ""
"Congratulations, you've learned how to make a pull request to Django! "
"Details of more advanced techniques you may need are in :doc:`/internals/"
"contributing/writing-code/working-with-git`."
msgstr ""
"恭喜，你已经学会了如何为 Django 创建 pull request！如需获知更多高级技巧，参"
"考 :doc:`/internals/contributing/writing-code/working-with-git`。"

msgid ""
"Now you can put those skills to good use by helping to improve Django's "
"codebase."
msgstr "现在你可以活用这些技能帮助改善 Django 的代码库。"

msgid "More information for new contributors"
msgstr "针对新贡献者的更多注意事项"

msgid ""
"Before you get too into writing patches for Django, there's a little more "
"information on contributing that you should probably take a look at:"
msgstr "在你开始为 Django 编写补丁时，这里有些信息，你应该看一看："

msgid ""
"You should make sure to read Django's documentation on :doc:`claiming "
"tickets and submitting patches </internals/contributing/writing-code/"
"submitting-patches>`. It covers Trac etiquette, how to claim tickets for "
"yourself, expected coding style for patches, and many other important "
"details."
msgstr ""
"确保你阅读了 Django 的参考文档 :doc:`创建工单和提交补丁 </internals/"
"contributing/writing-code/submitting-patches>`。它涵盖了Trac 规则，如何创建自"
"己的工单，补丁期望的代码风格和其他一些重要信息。"

msgid ""
"First time contributors should also read Django's :doc:`documentation for "
"first time contributors</internals/contributing/new-contributors/>`. It has "
"lots of good advice for those of us who are new to helping out with Django."
msgstr ""
"初次提交补丁应额外阅读 :doc:`首次贡献者文档</internals/contributing/new-"
"contributors/>`。这里有很多对新手贡献者的建议。"

msgid ""
"After those, if you're still hungry for more information about contributing, "
"you can always browse through the rest of :doc:`Django's documentation on "
"contributing</internals/contributing/index>`. It contains a ton of useful "
"information and should be your first source for answering any questions you "
"might have."
msgstr ""
"接下来，如果你渴望更多关于为 Django 做贡献的信息，可以阅读余下的文档 :doc:`"
"为 Django 文档上作出贡献</internals/contributing/index>`。它包含了大量的有用"
"信息，这里可以解决你可能遇到的所有问题。"

msgid "Finding your first real ticket"
msgstr "寻找你的第一个真正意义上的工单"

msgid ""
"Once you've looked through some of that information, you'll be ready to go "
"out and find a ticket of your own to write a patch for. Pay special "
"attention to tickets with the \"easy pickings\" criterion. These tickets are "
"often much simpler in nature and are great for first time contributors. Once "
"you're familiar with contributing to Django, you can move on to writing "
"patches for more difficult and complicated tickets."
msgstr ""
"一旦你看过了之前那些信息，你便已经具备了走出困境，编写修复自己找到的工单的补"
"丁的能力。对于那些有着“容易获得”标准的工单要尤其注意。这些工单实际上常常很简"
"单而且对于第一次撰写补丁的人很有帮助。一旦你熟悉了给 Django 写补丁，你就可以"
"进一步为更难且更复杂的工单写补丁。"

msgid ""
"If you just want to get started already (and nobody would blame you!), try "
"taking a look at the list of `easy tickets that need patches`__ and the "
"`easy tickets that have patches which need improvement`__. If you're "
"familiar with writing tests, you can also look at the list of `easy tickets "
"that need tests`__. Just remember to follow the guidelines about claiming "
"tickets that were mentioned in the link to Django's documentation on :doc:"
"`claiming tickets and submitting patches </internals/contributing/writing-"
"code/submitting-patches>`."
msgstr ""
"如果你只是想要简单的了解（没人会因此责备你！），那么你可以试着看看 `easy "
"tickets that need patches`__ 和 `easy tickets that have patches which need "
"improvement`__。如果你比较擅长写测试，那么你也可以看看这个 `easy tickets "
"that need tests`__。一定要记得遵循在 Django 的文档声明标签和递交补丁中提到的"
"关于声明标签的指导规则 :doc:`声明标签和提交补丁 </internals/contributing/"
"writing-code/submitting-patches>`."

msgid "What's next after creating a pull request?"
msgstr "创建完 pull request，下一步做什么呢？"

msgid ""
"After a ticket has a patch, it needs to be reviewed by a second set of eyes. "
"After submitting a pull request, update the ticket metadata by setting the "
"flags on the ticket to say \"has patch\", \"doesn't need tests\", etc, so "
"others can find it for review. Contributing doesn't necessarily always mean "
"writing a patch from scratch. Reviewing existing patches is also a very "
"helpful contribution. See :doc:`/internals/contributing/triaging-tickets` "
"for details."
msgstr ""
"工单有了补丁后，需要他人来复审。提交 pull 请求后，为工单打上如“有补丁”，“无需"
"测试”之类的标签，如此他人便可查找到该工单以便复审。从头开始编写补丁固然是贡献"
"的一种方式，但复审已有补丁同样能帮助 Django。 查看 :doc:`/internals/"
"contributing/triaging-tickets` 了解更多。"

msgid "Getting started"
msgstr "开始"

msgid ""
"New to Django? Or to Web development in general? Well, you came to the right "
"place: read this material to quickly get up and running."
msgstr ""
"初识 Django？或为了 Web 开发？好，那你来对地方了：看看这些资料快速上手。"

msgid ""
"If you're new to Python_, you might want to start by getting an idea of what "
"the language is like. Django is 100% Python, so if you've got minimal "
"comfort with Python you'll probably get a lot more out of Django."
msgstr ""
"如果你初次了解 Python_，可能想知道它是怎样一门语言。Django 是 100% 由 Python "
"编写的，所以熟悉 Python 可以加深对 Django 的理解。"

msgid ""
"If you're new to programming entirely, you might want to start with this "
"`list of Python resources for non-programmers`_"
msgstr ""
"如果你毫无编程经验，可能需要从 `适合零编程经验者的 Python 学习资源`_起步"

msgid ""
"If you already know a few other languages and want to get up to speed with "
"Python quickly, we recommend `Dive Into Python`_. If that's not quite your "
"style, there are many other `books about Python`_."
msgstr ""
"如果你已经了解过一门其他的编程语言，并且向快速上手Python，我们向你推荐 `Dive "
"Into Python`_。如果不太适合你的话，还有其它很多 `books about Python`_。"

msgid "Quick install guide"
msgstr "快速安装指南"

msgid ""
"Before you can use Django, you'll need to get it installed. We have a :doc:"
"`complete installation guide </topics/install>` that covers all the "
"possibilities; this guide will guide you to a simple, minimal installation "
"that'll work while you walk through the introduction."
msgstr ""
"开始用 Django 前，需要先进行安装。我们写了 :doc:`complete installation guide "
"</topics/install>` 罗列了各种安装方法；它会指导你完成最小，快速安装。"

msgid "Install Python"
msgstr "安装 Python"

msgid ""
"Being a Python Web framework, Django requires Python. See :ref:`faq-python-"
"version-support` for details. Python includes a lightweight database called "
"SQLite_ so you won't need to set up a database just yet."
msgstr ""
"作为一个 Python Web 框架，Django 需要 Python。更多细节请参见 :ref:`faq-"
"python-version-support`。Python 包含了一个名为 SQLite_ 的轻量级数据库，所以你"
"暂时不必自行设置一个数据库。"

msgid ""
"Get the latest version of Python at https://www.python.org/downloads/ or "
"with your operating system's package manager."
msgstr ""
"最新版本的 Python 可以通过访问 https://www.python.org/downloads/ 或者操作系统"
"的包管理工具获取。"

msgid ""
"You can verify that Python is installed by typing ``python`` from your "
"shell; you should see something like::"
msgstr ""
"你可以在你的 shell 中输入 ``python`` 来确定你是否安装过 Python；你看到的可能"
"是像这样子的::"

msgid "Set up a database"
msgstr "设置数据库"

msgid ""
"This step is only necessary if you'd like to work with a \"large\" database "
"engine like PostgreSQL, MySQL, or Oracle. To install such a database, "
"consult the :ref:`database installation information <database-installation>`."
msgstr ""
"此步骤仅在你打算使用诸如 PostgreSQL, MySQL, 或者 Oracle 这些大型数据库引擎时"
"需要。要安装这种数据库, 请参考 :ref:`database installation information "
"<database-installation>`。"

msgid "Remove any old versions of Django"
msgstr "移除任何老版本的 Django"

msgid ""
"If you are upgrading your installation of Django from a previous version, "
"you will need to :ref:`uninstall the old Django version before installing "
"the new version <removing-old-versions-of-django>`."
msgstr ""
"如果你打算从前一版本的 Django 升级，, 你将需要 :ref:`uninstall the old "
"Django version before installing the new version <removing-old-versions-of-"
"django>`。"

msgid "Install Django"
msgstr "安装 Django"

msgid "You've got three easy options to install Django:"
msgstr "你有三个简单的方法来安装 Django："

msgid ""
":ref:`Install an official release <installing-official-release>`. This is "
"the best approach for most users."
msgstr ""
":ref:`Install an official release <installing-official-release>` 适合大部分用"
"户。"

msgid ""
"Install a version of Django :ref:`provided by your operating system "
"distribution <installing-distribution-package>`."
msgstr ""
"安装 Django :ref:`provided by your operating system distribution <installing-"
"distribution-package>`。"

msgid ""
":ref:`Install the latest development version <installing-development-"
"version>`. This option is for enthusiasts who want the latest-and-greatest "
"features and aren't afraid of running brand new code. You might encounter "
"new bugs in the development version, but reporting them helps the "
"development of Django. Also, releases of third-party packages are less "
"likely to be compatible with the development version than with the latest "
"stable release."
msgstr ""
":ref:`Install the latest development version <installing-development-"
"version>` 这个选择是针对那些想要体验最新和最好的特性的爱好者们，并不怕运行全"
"新代码。你在开发版中可能会遇到新的 bug，可以报告给社区团队帮助 Django 开发。"
"此外，第三方发行的软件包也可能不与开发版进行兼容。"

msgid ""
"Always refer to the documentation that corresponds to the version of Django "
"you're using!"
msgstr "请始终参考与你所使用的版本对应的 Django 文档！"

msgid ""
"If you do either of the first two steps, keep an eye out for parts of the "
"documentation marked **new in development version**. That phrase flags "
"features that are only available in development versions of Django, and they "
"likely won't work with an official release."
msgstr ""
"如果采用了前两种方式进行安装，你需要注意在文档中标明  **在开发版中新增**。这"
"个标记表明这个特性仅适用开发版 Django，并且他们可能不会在官方发布的稳定版中出"
"现。"

msgid "Verifying"
msgstr "验证"

msgid ""
"To verify that Django can be seen by Python, type ``python`` from your "
"shell. Then at the Python prompt, try to import Django:"
msgstr ""
"若要验证 Django 是否能被 Python 识别，可以在 shell 中输入 ``python``。 然后"
"在 Python 提示符下，尝试导入 Django："

msgid "You may have another version of Django installed."
msgstr "当然了，你也可能安装的是其它版本的 Django。"

msgid "That's it!"
msgstr "搞定！"

msgid ""
"That's it -- you can now :doc:`move onto the tutorial </intro/tutorial01>`."
msgstr "搞定，现在你可以 :doc:`move onto the tutorial </intro/tutorial01>`。"

msgid "Django at a glance"
msgstr "初识 Django"

msgid ""
"Because Django was developed in a fast-paced newsroom environment, it was "
"designed to make common Web-development tasks fast and easy. Here's an "
"informal overview of how to write a database-driven Web app with Django."
msgstr ""
"Django 最初被设计用于具有快速开发需求的新闻类站点，目的是要实现简单快捷的网站"
"开发。以下内容简要介绍了如何使用 Django 实现一个数据库驱动的 Web 应用。"

msgid ""
"The goal of this document is to give you enough technical specifics to "
"understand how Django works, but this isn't intended to be a tutorial or "
"reference -- but we've got both! When you're ready to start a project, you "
"can :doc:`start with the tutorial </intro/tutorial01>` or :doc:`dive right "
"into more detailed documentation </topics/index>`."
msgstr ""
"为了让您充分理解 Django 的工作原理，这份文档为您详细描述了相关的技术细节，不"
"过这并不是一份入门教程或者是参考文档（我们当然也为您准备了这些）。如果您想要"
"马上开始一个项目，可以从 :doc:`实例教程 </intro/tutorial01>` 开始入手，或者直"
"接开始阅读详细的 :doc:`参考文档 </topics/index>` 。"

msgid "Design your model"
msgstr "设计模型"

msgid ""
"Although you can use Django without a database, it comes with an `object-"
"relational mapper`_ in which you describe your database layout in Python "
"code."
msgstr ""
"Django 无需数据库就可以使用，它提供了 `对象关系映射器`_ 通过此技术，你可以使"
"用 Python 代码来描述数据库结构。"

msgid ""
"The :doc:`data-model syntax </topics/db/models>` offers many rich ways of "
"representing your models -- so far, it's been solving many years' worth of "
"database-schema problems. Here's a quick example:"
msgstr ""
"你可以使用强大的 :doc:`数据-模型语句</topics/db/models>` 来描述你的数据模型，"
"这解决了数年以来在数据库模式中的难题。以下是一个简明的例子："

msgid "Install it"
msgstr "应用数据模型"

msgid ""
"Next, run the Django command-line utility to create the database tables "
"automatically:"
msgstr "然后，运行 Django 命令行工具来创建数据库表："

msgid ""
"The :djadmin:`migrate` command looks at all your available models and "
"creates tables in your database for whichever tables don't already exist, as "
"well as optionally providing :doc:`much richer schema control </topics/"
"migrations>`."
msgstr ""
"这个 :djadmin:`migrate` 命令查找你所有可用的模型并将在数据库中创建那些不存在"
"的表，还可提供了可选的 :doc:`丰富 schema 控制</topics/migrations>`。"

msgid "Enjoy the free API"
msgstr "享用便捷的 API"

msgid ""
"With that, you've got a free, and rich, :doc:`Python API </topics/db/"
"queries>` to access your data. The API is created on the fly, no code "
"generation necessary:"
msgstr ""
"接下来，你就可以使用一套便捷而丰富的 :doc:`Python API </topics/db/queries>`  "
"访问你的数据。这些 API 是即时创建的，而不用显式的生成代码："

msgid ""
"A dynamic admin interface: it's not just scaffolding -- it's the whole house"
msgstr "一个动态管理接口：并非徒有其表"

msgid ""
"Once your models are defined, Django can automatically create a "
"professional, production ready :doc:`administrative interface </ref/contrib/"
"admin/index>` -- a website that lets authenticated users add, change and "
"delete objects. It's as easy as registering your model in the admin site:"
msgstr ""
"当你的模型完成定义，Django 就会自动生成一个专业的生产级 :doc:`管理接口</ref/"
"contrib/admin/index>`  ——一个允许认证用户添加、更改和删除对象的 Web 站点。你"
"只需简单的在 admin 站点上注册你的模型即可："

msgid ""
"The philosophy here is that your site is edited by a staff, or a client, or "
"maybe just you -- and you don't want to have to deal with creating backend "
"interfaces just to manage content."
msgstr ""
"这样设计所遵循的理念是，站点编辑人员可以是你的员工、你的客户、或者就是你自己"
"——而你大概不会乐意去废半天劲创建一个只有内容管理功能的后台管理界面。"

msgid ""
"One typical workflow in creating Django apps is to create models and get the "
"admin sites up and running as fast as possible, so your staff (or clients) "
"can start populating data. Then, develop the way data is presented to the "
"public."
msgstr ""
"创建 Django 应用的典型流程是，先建立数据模型，然后搭建管理站点，之后你的员工"
"（或者客户）就可以向网站里填充数据了。后面我们会谈到如何展示这些数据。"

msgid "Design your URLs"
msgstr "规划 URLs"

msgid ""
"A clean, elegant URL scheme is an important detail in a high-quality Web "
"application. Django encourages beautiful URL design and doesn't put any "
"cruft in URLs, like ``.php`` or ``.asp``."
msgstr ""
"简洁优雅的 URL 规划对于一个高质量 Web 应用来说至关重要。Django 推崇优美的 "
"URL 设计，所以不要把诸如 ``.php`` 和  ``.asp``  之类的冗余的后缀放到 URL 里。"

msgid ""
"To design URLs for an app, you create a Python module called a :doc:`URLconf "
"</topics/http/urls>`. A table of contents for your app, it contains a simple "
"mapping between URL patterns and Python callback functions. URLconfs also "
"serve to decouple URLs from Python code."
msgstr ""
"为了设计你自己的 :doc:`URLconf </topics/http/urls>` ，你需要创建一个叫做 "
"URLconf 的 Python 模块。这是网站的目录，它包含了一张 URL 和 Python 回调函数之"
"间的映射表。URLconf 也有利于将 Python 代码与 URL 进行解耦（译注：使各个模块分"
"离，独立）。"

msgid ""
"Here's what a URLconf might look like for the ``Reporter``/``Article`` "
"example above:"
msgstr "下面这个 URLconf 适用于前面 ``Reporter``/``Article``  的例子："

msgid ""
"The code above maps URL paths to Python callback functions (\"views\"). The "
"path strings use parameter tags to \"capture\" values from the URLs. When a "
"user requests a page, Django runs through each path, in order, and stops at "
"the first one that matches the requested URL. (If none of them matches, "
"Django calls a special-case 404 view.) This is blazingly fast, because the "
"paths are compiled into regular expressions at load time."
msgstr ""
"上述代码将 URL 路径映射到了 Python 回调函数（“视图”）。路径字符串使用参数标签"
"从URL中“捕获”相应值。当用户请求页面时，Django 依次遍历路径，直至初次匹配到了"
"请求的 URL。(如果无匹配项，Django 会调用 404 视图。) 这个过程非常快，因为路径"
"在加载时就编译成了正则表达式。"

msgid ""
"Once one of the URL patterns matches, Django calls the given view, which is "
"a Python function. Each view gets passed a request object -- which contains "
"request metadata -- and the values captured in the pattern."
msgstr ""
"一旦有 URL 路径匹配成功，Django 会调用相应的视图函数。每个视图函数会接受一个"
"请求对象——包含请求元信息——以及在匹配式中获取的参数值。"

msgid ""
"For example, if a user requested the URL \"/articles/2005/05/39323/\", "
"Django would call the function ``news.views.article_detail(request, "
"year=2005, month=5, pk=39323)``."
msgstr ""
"例如，当用户请求了这样的 URL \"/articles/2005/05/39323/\"，Django 会调用 "
"``news.views.article_detail(request, year=2005, month=5, pk=39323)``。"

msgid "Write your views"
msgstr "编写视图"

msgid ""
"Each view is responsible for doing one of two things: Returning an :class:"
"`~django.http.HttpResponse` object containing the content for the requested "
"page, or raising an exception such as :class:`~django.http.Http404`. The "
"rest is up to you."
msgstr ""
"视图函数的执行结果只可能有两种：返回一个包含请求页面元素的 :class:`~django."
"http.HttpResponse`  对象，或者是抛出 :class:`~django.http.Http404`  这类异"
"常。至于执行过程中的其它的动作则由你决定。"

msgid ""
"Generally, a view retrieves data according to the parameters, loads a "
"template and renders the template with the retrieved data. Here's an example "
"view for ``year_archive`` from above:"
msgstr ""
"通常来说，一个视图的工作就是：从参数获取数据，装载一个模板，然后将根据获取的"
"数据对模板进行渲染。下面是一个 ``year_archive`` 的视图样例："

msgid ""
"This example uses Django's :doc:`template system </topics/templates>`, which "
"has several powerful features but strives to stay simple enough for non-"
"programmers to use."
msgstr ""
"这个例子使用了 Django :doc:`模板系统 </topics/templates>` ，它有着很多强大的"
"功能，而且使用起来足够简单，即使不是程序员也可轻松使用。"

msgid "Design your templates"
msgstr "设计模板"

msgid "The code above loads the ``news/year_archive.html`` template."
msgstr "上面的代码加载了 ``news/year_archive.html`` 模板。"

msgid ""
"Django has a template search path, which allows you to minimize redundancy "
"among templates. In your Django settings, you specify a list of directories "
"to check for templates with :setting:`DIRS <TEMPLATES-DIRS>`. If a template "
"doesn't exist in the first directory, it checks the second, and so on."
msgstr ""
"Django 允许设置搜索模板路径，这样可以最小化模板之间的冗余。在 Django 设置中，"
"你可以通过 :setting:`DIRS <TEMPLATES-DIRS>`  参数指定一个路径列表用于检索模"
"板。如果第一个路径中不包含任何模板，就继续检查第二个，以此类推。"

msgid ""
"Let's say the ``news/year_archive.html`` template was found. Here's what "
"that might look like:"
msgstr ""
"让我们假设 ``news/year_archive.html`` 模板已经找到。它看起来可能是下面这个样"
"子："

msgid ""
"Variables are surrounded by double-curly braces. ``{{ article.headline }}`` "
"means \"Output the value of the article's headline attribute.\" But dots "
"aren't used only for attribute lookup. They also can do dictionary-key "
"lookup, index lookup and function calls."
msgstr ""
"我们看到变量都被双大括号括起来了。 ``{{ article.headline }}``  的意思是“输出 "
"article 的 headline 属性值”。这个“点”还有更多的用途，比如查找字典键值、查找索"
"引和函数调用。"

msgid ""
"Note ``{{ article.pub_date|date:\"F j, Y\" }}`` uses a Unix-style \"pipe"
"\" (the \"|\" character). This is called a template filter, and it's a way "
"to filter the value of a variable. In this case, the date filter formats a "
"Python datetime object in the given format (as found in PHP's date function)."
msgstr ""
"我们注意到 ``{{ article.pub_date|date:\"F j, Y\" }}``  使用了 Unix 风格的“管"
"道符”（“|”字符）。这是一个模板过滤器，用于过滤变量值。在这里过滤器将一个 "
"Python datetime 对象转化为指定的格式（就像 PHP 中的日期函数那样）。"

msgid ""
"You can chain together as many filters as you'd like. You can write :ref:"
"`custom template filters <howto-writing-custom-template-filters>`. You can "
"write :doc:`custom template tags </howto/custom-template-tags>`, which run "
"custom Python code behind the scenes."
msgstr ""
"你可以将多个过滤器连在一起使用。你还可以使用你 :ref:`自定义的模板过滤器 "
"<howto-writing-custom-template-filters>` 。你甚至可以自己编写 :doc:`自定义的"
"模板标签 </howto/custom-template-tags>` ，相关的 Python 代码会在使用标签时在"
"后台运行。"

msgid ""
"Finally, Django uses the concept of \"template inheritance\". That's what "
"the ``{% extends \"base.html\" %}`` does. It means \"First load the template "
"called 'base', which has defined a bunch of blocks, and fill the blocks with "
"the following blocks.\" In short, that lets you dramatically cut down on "
"redundancy in templates: each template has to define only what's unique to "
"that template."
msgstr ""
"Django 使用了 ''模板继承'' 的概念。这就是 ``{% extends \"base.html\" %}`` 的"
"作用。它的含义是''先加载名为 base 的模板，并且用下面的标记块对模板中定义的标"
"记块进行填充''。简而言之，模板继承可以使模板间的冗余内容最小化：每个模板只需"
"包含与其它文档有区别的内容。"

msgid ""
"Here's what the \"base.html\" template, including the use of :doc:`static "
"files </howto/static-files/index>`, might look like:"
msgstr ""
"下面是 base.html 可能的样子，它使用了 :doc:`静态文件 </howto/static-files/"
"index>` ："

msgid ""
"Simplistically, it defines the look-and-feel of the site (with the site's "
"logo), and provides \"holes\" for child templates to fill. This makes a site "
"redesign as easy as changing a single file -- the base template."
msgstr ""
"简而言之，它定义了这个网站的外观（利用网站的 logo），并且给子模板们挖好了可以"
"填的”坑“。这也让网站的改版变得简单无比——你只需更改这个根模板文件即可。"

msgid ""
"It also lets you create multiple versions of a site, with different base "
"templates, while reusing child templates. Django's creators have used this "
"technique to create strikingly different mobile versions of sites -- simply "
"by creating a new base template."
msgstr ""
"它还可以让你利用不同的基础模板并重用子模板创建一个网站的多个版本。Django 的创"
"建者已经利用这一技术来创造了明显不同的手机版本的网站——只需创建一个新的基础模"
"板。"

msgid ""
"Note that you don't have to use Django's template system if you prefer "
"another system. While Django's template system is particularly well-"
"integrated with Django's model layer, nothing forces you to use it. For that "
"matter, you don't have to use Django's database API, either. You can use "
"another database abstraction layer, you can read XML files, you can read "
"files off disk, or anything you want. Each piece of Django -- models, views, "
"templates -- is decoupled from the next."
msgstr ""
"注意，你并不是非得使用 Django 的模板系统，你可以使用其它你喜欢的模板系统。尽"
"管 Django 的模板系统与其模型层能够集成得很好，但这不意味着你必须使用它。同"
"样，你可以不使用 Django 的数据库 API。你可以用其他的数据库抽象层，像是直接读"
"取 XML 文件，亦或直接读取磁盘文件，你可以使用任何方式。Django 的任何组成——模"
"型、视图和模板——都是独立的。"

msgid "This is just the surface"
msgstr "这仅是基本入门知识"

msgid ""
"This has been only a quick overview of Django's functionality. Some more "
"useful features:"
msgstr "以上只是 Django 的功能性概述。Django 还有更多实用的特性："

msgid ""
"A :doc:`caching framework </topics/cache>` that integrates with memcached or "
"other backends."
msgstr ":doc:`缓存框架 </topics/cache>`  可以与 memcached 或其它后端集成。"

msgid ""
"A :doc:`syndication framework </ref/contrib/syndication>` that makes "
"creating RSS and Atom feeds as easy as writing a small Python class."
msgstr ""
":doc:`聚合器框架 </ref/contrib/syndication>`  可以通过简单编写一个 Python 类"
"来推送 RRS 和 Atom。"

msgid ""
"More sexy automatically-generated admin features -- this overview barely "
"scratched the surface."
msgstr "更多令人心动的自动化管理功能：概述里面仅仅浅尝辄止。"

msgid ""
"The next obvious steps are for you to `download Django`_, read :doc:`the "
"tutorial </intro/tutorial01>` and join `the community`_. Thanks for your "
"interest!"
msgstr ""
"接下来您可以 `下载 Django`_ ，阅读 :doc:`实例教程</intro/tutorial01>` ，然后"
"加入我们的 `社区`_ ！感谢您的关注！"

msgid "Advanced tutorial: How to write reusable apps"
msgstr "进阶指南：如何编写可重用程序"

msgid ""
"This advanced tutorial begins where :doc:`Tutorial 7 </intro/tutorial07>` "
"left off. We'll be turning our Web-poll into a standalone Python package you "
"can reuse in new projects and share with other people."
msgstr ""
"这篇进阶指南从 :doc:`Tutorial 7 </intro/tutorial07>` 结尾的地方继续讲起。我们"
"将会把我们的 Web-poll 放进一个独立的 Python 包中，以便你在新的项目中重用它或"
"将它与他人分享。"

msgid ""
"If you haven't recently completed Tutorials 1–7, we encourage you to review "
"these so that your example project matches the one described below."
msgstr ""
"如果你尚未完成教程 1-7，我们推荐你先浏览一遍教程，这样你的样例工程会和下面的"
"一致。"

msgid "Reusability matters"
msgstr "可重用性很重要"

msgid ""
"It's a lot of work to design, build, test and maintain a web application. "
"Many Python and Django projects share common problems. Wouldn't it be great "
"if we could save some of this repeated work?"
msgstr ""
"设计，构建，测试以及维护一个 web 应用要做很多的工作。很多 Python 以及 Django "
"项目都有一些常见问题。如果我们能保存并利用这些重复的工作岂不是更好？"

msgid ""
"Reusability is the way of life in Python. `The Python Package Index (PyPI) "
"<https://pypi.python.org/pypi>`_ has a vast range of packages you can use in "
"your own Python programs. Check out `Django Packages <https://djangopackages."
"org>`_ for existing reusable apps you could incorporate in your project. "
"Django itself is also just a Python package. This means that you can take "
"existing Python packages or Django apps and compose them into your own web "
"project. You only need to write the parts that make your project unique."
msgstr ""
"可重用性是 Python 的生活方式。 `The Python Package Index (PyPI) <https://"
"pypi.python.org/pypi>`_ 有许多允许你在自己的 Python 项目中使用的包。在 "
"`Django Packages <https://djangopackages.org>`_ 中查找已发布的可重用应用，将"
"你可以使用的并入你的项目。Django 本身也是一个 Python 包。 这意味着你可以将已"
"存在的 Python 包或 Django 应用并入你的项目。你只需要确保项目包名的唯一性。"

msgid ""
"Let's say you were starting a new project that needed a polls app like the "
"one we've been working on. How do you make this app reusable? Luckily, "
"you're well on the way already. In :doc:`Tutorial 3 </intro/tutorial03>`, we "
"saw how we could decouple polls from the project-level URLconf using an "
"``include``. In this tutorial, we'll take further steps to make the app easy "
"to use in new projects and ready to publish for others to install and use."
msgstr ""
"假设你现在创建了一个新的项目，并且需要一个类似我们之前做的投票应用。你该如何"
"复用这个应用呢？庆幸的是，其实你已经知道了一些。在 :doc:`教程 3 </intro/"
"tutorial03>`，我们使用过 ``include`` 从项目级别的 URLconf 分割出 polls。在本"
"教程中，我们将进一步使这个应用易用于新的项目中，并发布给其他人安装使用。"

msgid "Package? App?"
msgstr "包？应用？"

msgid ""
"A Python :term:`package` provides a way of grouping related Python code for "
"easy reuse. A package contains one or more files of Python code (also known "
"as \"modules\")."
msgstr ""
"一个 :term:`package` 提供了一组关联的 Python 代码的简单复用方式。一个包（“模"
"块”）包含了一个或多个 Python 代码文件。"

msgid ""
"A package can be imported with ``import foo.bar`` or ``from foo import "
"bar``. For a directory (like ``polls``) to form a package, it must contain a "
"special file ``__init__.py``, even if this file is empty."
msgstr ""
"一个包通过 ``import foo.bar`` 或 ``from foo import bar`` 的形式导入。一个目录"
"（例如 ``polls``）要成为一个包，它必须包含一个特定的文件 ``__init__.py``，即"
"便这个文件是空的。"

msgid ""
"A Django *application* is just a Python package that is specifically "
"intended for use in a Django project. An application may use common Django "
"conventions, such as having ``models``, ``tests``, ``urls``, and ``views`` "
"submodules."
msgstr ""
"Django *应用* 仅仅是专用于 Django 项目的 Python 包。应用会按照 Django 约定，"
"创建好 ``models``,  ``tests``,  ``urls``, 以及 ``views`` 等子模块。"

msgid ""
"Later on we use the term *packaging* to describe the process of making a "
"Python package easy for others to install. It can be a little confusing, we "
"know."
msgstr ""
"稍后，我们将解释术语 *打包* ——为了方便其它人安装 Python 包的处理流程。我知"
"道，这可能会使你感到一点点迷惑。"

msgid "Your project and your reusable app"
msgstr "你的项目和可复用应用"

msgid "After the previous tutorials, our project should look like this::"
msgstr "通过前面的教程，我们的工程应该看起来像这样::"

msgid ""
"You created ``mysite/templates`` in :doc:`Tutorial 7 </intro/tutorial07>`, "
"and ``polls/templates`` in :doc:`Tutorial 3 </intro/tutorial03>`. Now "
"perhaps it is clearer why we chose to have separate template directories for "
"the project and application: everything that is part of the polls "
"application is in ``polls``. It makes the application self-contained and "
"easier to drop into a new project."
msgstr "1"

msgid ""
"The ``polls`` directory could now be copied into a new Django project and "
"immediately reused. It's not quite ready to be published though. For that, "
"we need to package the app to make it easy for others to install."
msgstr ""
"目录 ``polls`` 现在可以被拷贝至一个新的 Django 工程，且立刻被复用。不过现在还"
"不是发布它的时候。为了这样做，我们需要打包这个应用，便于其他人安装它。"

msgid "Installing some prerequisites"
msgstr "安装必须环境"

msgid ""
"The current state of Python packaging is a bit muddled with various tools. "
"For this tutorial, we're going to use setuptools_ to build our package. It's "
"the recommended packaging tool (merged with the ``distribute`` fork). We'll "
"also be using `pip`_ to install and uninstall it. You should install these "
"two packages now. If you need help, you can refer to :ref:`how to install "
"Django with pip<installing-official-release>`. You can install "
"``setuptools`` the same way."
msgstr ""
"目前，打包 Python 程序需要工具，有许多工具可以完成此项工作。在此教程中，我们"
"将使用 setuptools_ 来打包我们的程序。这是推荐的打包工具（与 ``发布`` 分支合"
"并）。我们仍旧使用 `pip`_ 来安装和卸载这个工具。现在，你需要安装这两个包。如"
"果你需要帮助，你可以参考 :ref:`如何通过 pip 安装 Django<installing-official-"
"release>`，你可以通过相同的方式安装 ``setuptools``。"

msgid "Packaging your app"
msgstr "打包你的应用"

msgid ""
"Python *packaging* refers to preparing your app in a specific format that "
"can be easily installed and used. Django itself is packaged very much like "
"this. For a small app like polls, this process isn't too difficult."
msgstr ""
"Python 的 *打包* 将以一种特殊的格式组织你的应用，意在方便安装和使用这个应用。"
"Django 本身就被打包成类似的形式。对于一个小应用，例如 polls，这不会太难。"

msgid ""
"First, create a parent directory for ``polls``, outside of your Django "
"project. Call this directory ``django-polls``."
msgstr ""
"首先，在你的 Django 项目目录外创建一个名为 ``django-polls`` 的文件夹，用于盛"
"放 ``polls``。"

msgid "Choosing a name for your app"
msgstr "为你的应用选择一个名字"

msgid ""
"When choosing a name for your package, check resources like PyPI to avoid "
"naming conflicts with existing packages. It's often useful to prepend "
"``django-`` to your module name when creating a package to distribute. This "
"helps others looking for Django apps identify your app as Django specific."
msgstr ""
"当为你的包选一个名字时，避免使用像 PyPI 这样已存在的包名，否则会导致冲突。当"
"你创建你的发布包时，可以在模块名前增加 ``django-`` 前缀，这是一个很常用也很有"
"用的避免包名冲突的方法。同时也有助于他人在寻找 Django 应用时确认你的 app 是 "
"Django 独有的。"

msgid ""
"Application labels (that is, the final part of the dotted path to "
"application packages) *must* be unique in :setting:`INSTALLED_APPS`. Avoid "
"using the same label as any of the Django :doc:`contrib packages </ref/"
"contrib/index>`, for example ``auth``, ``admin``, or ``messages``."
msgstr ""
"应用标签（指用点分隔的包名的最后一部分）在 :setting:`INSTALLED_APPS` 中 *必须"
"* 是独一无二的。避免使用任何与 Django :doc:`contrib packages </ref/contrib/"
"index>` 文档中相同的标签名，比如 ``auth``，``admin``，``messages``。"

msgid "Move the ``polls`` directory into the ``django-polls`` directory."
msgstr "将 ``polls`` 目录移入 ``django-polls`` 目录。"

msgid "Create a file ``django-polls/README.rst`` with the following contents:"
msgstr "创建一个名为 ``django-polls/README.rst`` 的文件，包含以下内容："

msgid ""
"Create a ``django-polls/LICENSE`` file. Choosing a license is beyond the "
"scope of this tutorial, but suffice it to say that code released publicly "
"without a license is *useless*. Django and many Django-compatible apps are "
"distributed under the BSD license; however, you're free to pick your own "
"license. Just be aware that your licensing choice will affect who is able to "
"use your code."
msgstr ""
"创建一个 ``django-polls/LICENSE`` 文件。选择一个非本教程使用的授权协议，但是"
"要足以说明发布代码没有授权证书是 *不可能的* 。Django 和很多兼容 Django 的应用"
"是以 BSD 授权协议发布的；不过，你可以自己选择一个授权协议。只要确定你选择的协"
"议能够限制未来会使用你的代码的人。"

msgid ""
"Next we'll create a ``setup.py`` file which provides details about how to "
"build and install the app.  A full explanation of this file is beyond the "
"scope of this tutorial, but the `setuptools docs <https://setuptools."
"readthedocs.io/en/latest/>`_ have a good explanation. Create a file ``django-"
"polls/setup.py`` with the following contents:"
msgstr ""
"下一步我们将创建 ``setup.py`` 用于说明如何构建和安装应用的细节。关于此文件的"
"完整介绍超出了此教程的范围，但是 `setuptools docs <https://setuptools."
"readthedocs.io/en/latest/>`_ 有详细的介绍。创建文件 ``django-polls/setup."
"py`` 包含以下内容："

msgid ""
"Only Python modules and packages are included in the package by default. To "
"include additional files, we'll need to create a ``MANIFEST.in`` file. The "
"setuptools docs referred to in the previous step discuss this file in more "
"details. To include the templates, the ``README.rst`` and our ``LICENSE`` "
"file, create a file ``django-polls/MANIFEST.in`` with the following contents:"
msgstr ""
"默认包中只包含 Python 模块和包。为了包含额外文件，我们需要创建一个名为 "
"``MANIFEST.in`` 的文件。上一步中关于 setuptools 的文档详细介绍了这个文件。为"
"了包含模板、``README.rst`` 和我们的 ``LICENSE`` 文件，创建文件 ``django-"
"polls/MANIFEST.in`` 包含以下内容："

msgid ""
"It's optional, but recommended, to include detailed documentation with your "
"app. Create an empty directory ``django-polls/docs`` for future "
"documentation. Add an additional line to ``django-polls/MANIFEST.in``::"
msgstr ""
"在应用中包含详细文档是可选的，但我们推荐你这样做。创建一个空目录 ``django-"
"polls/docs`` 用于未来编写文档。额外添加一行至 ``django-polls/MANIFEST.in`` ::"

msgid ""
"Note that the ``docs`` directory won't be included in your package unless "
"you add some files to it. Many Django apps also provide their documentation "
"online through sites like `readthedocs.org <https://readthedocs.org>`_."
msgstr ""
"注意，现在 ``docs`` 目录不会被加入你的应用包，除非你往这个目录加几个文件。许"
"多 Django 应用也提供他们的在线文档通过类似 `readthedocs.org <https://"
"readthedocs.org>`_ 这样的网站。"

msgid ""
"Try building your package with ``python setup.py sdist`` (run from inside "
"``django-polls``). This creates a directory called ``dist`` and builds your "
"new package, ``django-polls-0.1.tar.gz``."
msgstr ""
"试着构建你自己的应用包通过 ``ptyhon setup.py sdist`` （在 ``django-polls``目"
"录内）。这将创建一个名为 ``dist`` 的目录并构建你自己的应用包， ``django-"
"polls-0.1.tar.gz``。"

msgid ""
"For more information on packaging, see Python's `Tutorial on Packaging and "
"Distributing Projects <https://packaging.python.org/distributing/>`_."
msgstr ""
"更多关于打包的信息，见 Python 的 `关于打包和发布项目的教程 <https://"
"packaging.python.org/distributing/>`_。"

msgid "Using your own package"
msgstr "使用你自己的包名"

msgid ""
"Since we moved the ``polls`` directory out of the project, it's no longer "
"working. We'll now fix this by installing our new ``django-polls`` package."
msgstr ""
"由于我们把 ``polls`` 目录移出了项目，所以它无法工作了。我们现在要通过安装我们"
"的新 ``django-polls`` 应用来修复这个问题。"

msgid "Installing as a user library"
msgstr "作为用户库安装"

msgid ""
"The following steps install ``django-polls`` as a user library. Per-user "
"installs have a lot of advantages over installing the package system-wide, "
"such as being usable on systems where you don't have administrator access as "
"well as preventing the package from affecting system services and other "
"users of the machine."
msgstr ""
"以下步骤将 ``django-polls`` 以用户库的形式安装。与安装整个系统的软件包相比，"
"用户安装具有许多优点，例如可在没有管理员访问权的系统上使用，以及防止应用包影"
"响系统服务和其他用户。"

msgid ""
"Note that per-user installations can still affect the behavior of system "
"tools that run as that user, so ``virtualenv`` is a more robust solution "
"(see below)."
msgstr ""
"注意，用户安装仍然会影响以这个用户身份运行的系统工具，所以 ``virtualenv`` 是"
"一个更强大的解决方案（如下所示）。"

msgid ""
"To install the package, use pip (you already :ref:`installed it <installing-"
"reusable-apps-prerequisites>`, right?)::"
msgstr ""
"为了安装这个包，使用 pip (你早已 :ref:`安装 pip <installing-reusable-apps-"
"prerequisites>`, 对吗？)::"

msgid ""
"With luck, your Django project should now work correctly again. Run the "
"server again to confirm this."
msgstr "幸运的话，你的 Django 项目应该再一次正确运行。启动服务器确认这一点。"

msgid "To uninstall the package, use pip::"
msgstr "通过 pip 卸载包::"

msgid "Publishing your app"
msgstr "发布你的应用"

msgid ""
"Now that we've packaged and tested ``django-polls``, it's ready to share "
"with the world! If this wasn't just an example, you could now:"
msgstr ""
"现在，你已经对 ``django-polls`` 完成了打包和测试，准备好向世界分享它！如果这"
"不是一个例子应用，你现在就可以这样做。"

msgid "Email the package to a friend."
msgstr "通过邮件将你的包发送给朋友。"

msgid "Upload the package on your website."
msgstr "将这个包上传至你的网站。"

msgid ""
"Post the package on a public repository, such as `the Python Package Index "
"(PyPI)`_. `packaging.python.org <https://packaging.python.org>`_ has `a good "
"tutorial <https://packaging.python.org/distributing/#uploading-your-project-"
"to-pypi>`_ for doing this."
msgstr ""
"将你的包发布至公共仓库，比如 `the Python Package Index (PyPI)`_。 `packaging."
"python.org <https://packaging.python.org>`_ 有一个不错的 `教程 <https://"
"packaging.python.org/distributing/#uploading-your-project-to-pypi>`_ 说明如何"
"发布至公共仓库。"

msgid "Installing Python packages with virtualenv"
msgstr "通过 virtualenv 安装 Python 包"

msgid ""
"Earlier, we installed the polls app as a user library. This has some "
"disadvantages:"
msgstr "早些时候，我们以用户库的形式安装了投票应用。这样做有一些缺点。"

msgid ""
"Modifying the user libraries can affect other Python software on your system."
msgstr "修改用户库会影响你系统上的其他 Python 软件。"

msgid ""
"You won't be able to run multiple versions of this package (or others with "
"the same name)."
msgstr "你将不能运行此包的多个版本（或者其它用有相同包名的包）。"

msgid ""
"Typically, these situations only arise once you're maintaining several "
"Django projects. When they do, the best solution is to use `virtualenv "
"<https://virtualenv.pypa.io/>`_. This tool allows you to maintain multiple "
"isolated Python environments, each with its own copy of the libraries and "
"package namespace."
msgstr ""
"一般来说，这些状况只在你同时运行多个 Django 项目时出现。当这个问题出现时，最"
"好的解决办法是使用 `virtualenv <https://virtualenv.pypa.io/>`_。这个工具允许"
"你同时运行多个相互独立的Python环境，每个环境都有各自库和应用包命名空间的拷"
"贝。"

msgid "Writing your first Django app, part 1"
msgstr "编写你的第一个 Django 应用，第 1 部分"

msgid "Let's learn by example."
msgstr "让我们通过示例来学习。"

msgid ""
"Throughout this tutorial, we'll walk you through the creation of a basic "
"poll application."
msgstr "通过这个教程，我们将带着你创建一个基本的投票应用程序。"

msgid "It'll consist of two parts:"
msgstr "它将由两部分组成："

msgid "A public site that lets people view polls and vote in them."
msgstr "一个让人们查看和投票的公共站点。"

msgid "An admin site that lets you add, change, and delete polls."
msgstr "一个让你能添加、修改和删除投票的管理站点。"

msgid ""
"We'll assume you have :doc:`Django installed </intro/install>` already. You "
"can tell Django is installed and which version by running the following "
"command in a shell prompt (indicated by the $ prefix):"
msgstr ""
"我们假定你已经阅读了 :doc:`安装 Django </intro/install>`。你能知道 Django 已"
"被安装，且安装的是哪个版本，通过在命令提示行输入命令（由 $ 前缀）。"

msgid ""
"If Django is installed, you should see the version of your installation. If "
"it isn't, you'll get an error telling \"No module named django\"."
msgstr ""
"如果这行命令输出了一个版本号，证明你已经安装了此版本的 Django；如果你得到的是"
"一个“No module named django”的错误提示，则表明你还未安装。"

msgid ""
"This tutorial is written for Django |version|, which supports Python 3.4 and "
"later. If the Django version doesn't match, you can refer to the tutorial "
"for your version of Django by using the version switcher at the bottom right "
"corner of this page, or update Django to the newest version. If you're using "
"an older version of Python, check :ref:`faq-python-version-support` to find "
"a compatible version of Django."
msgstr ""
"这个教程是为了 Django |version| 写的，它支持 Python 3.4 和后续版本。如果 "
"Django 的版本不匹配，你可以通过页面右下角的版本切换器切换到对应你版本的教程，"
"或更新至最新版本。如果你正在使用一个较老版本的 Python，在  :ref:`faq-python-"
"version-support` 查找一个合适的 Django 版本。"

msgid ""
"See :doc:`How to install Django </topics/install>` for advice on how to "
"remove older versions of Django and install a newer one."
msgstr ""
"你可以查看文档 :doc:`如何安装 Django </topics/install>` 来获得关于移除旧版"
"本，安装新版本的流程和建议。"

msgid ""
"If you're having trouble going through this tutorial, please post a message "
"to |django-users| or drop by `#django on irc.freenode.net <irc://irc."
"freenode.net/django>`_ to chat with other Django users who might be able to "
"help."
msgstr ""
"如果你在阅读或实践本教程中遇到困难, 请发消息给 |django-users| 或加入 "
"`#django on irc.freenode.net <irc://irc.freenode.net/django>`_ 来和其他的 "
"Django 用户交流，他们也许能帮到你。"

msgid "Creating a project"
msgstr "创建项目"

msgid ""
"If this is your first time using Django, you'll have to take care of some "
"initial setup. Namely, you'll need to auto-generate some code that "
"establishes a Django :term:`project` -- a collection of settings for an "
"instance of Django, including database configuration, Django-specific "
"options and application-specific settings."
msgstr ""
"如果这是你第一次使用 Django 的话，你需要一些初始化设置。也就是说，你需要用一"
"些自动生成的代码配置一个 Django :term:`project` —— 即一个  Django 项目实例需"
"要的设置项集合，包括数据库配置、Django 配置和应用程序配置。"

msgid ""
"From the command line, ``cd`` into a directory where you'd like to store "
"your code, then run the following command:"
msgstr "打开命令行，``cd`` 到一个你想放置你代码的目录，然后运行以下命令："

msgid ""
"This will create a ``mysite`` directory in your current directory. If it "
"didn't work, see :ref:`troubleshooting-django-admin`."
msgstr ""
"这行代码将会在当前目录下创建一个 ``mysite`` 目录。如果命令失败了，查看 :ref:"
"`troubleshooting-django-admin`，可能能给你提供帮助。"

msgid ""
"You'll need to avoid naming projects after built-in Python or Django "
"components. In particular, this means you should avoid using names like "
"``django`` (which will conflict with Django itself) or ``test`` (which "
"conflicts with a built-in Python package)."
msgstr ""
"你得避免使用 Python 或 Django 的内部保留字来命名你的项目。具体地说，你得避免"
"使用像 ``django`` (会和 Django 自己产生冲突)或  ``test`` (会和 Python 的内置"
"组件产生冲突)这样的名字。"

msgid "Where should this code live?"
msgstr "我的代码该放在哪？"

msgid ""
"If your background is in plain old PHP (with no use of modern frameworks), "
"you're probably used to putting code under the Web server's document root "
"(in a place such as ``/var/www``). With Django, you don't do that. It's not "
"a good idea to put any of this Python code within your Web server's document "
"root, because it risks the possibility that people may be able to view your "
"code over the Web. That's not good for security."
msgstr ""
"如果你曾经是原生 PHP 程序员（没有使用过现代框架），你可能会习惯于把代码放在 "
"Web 服务器的文档根目录(诸如 ``/var/www``)。当使用 Django 时不需要这样做。把所"
"有 Python 代码放在 Web 服务器的根目录不是个好主意，因为这样会有风险。比如会提"
"高人们在网站上看到你的代码的可能性。这不利于网站的安全。"

msgid ""
"Put your code in some directory **outside** of the document root, such as :"
"file:`/home/mycode`."
msgstr "把你的代码放在文档根目录 **以外** 的某些地方吧，比如 `/home/mycode`。"

msgid "Let's look at what :djadmin:`startproject` created::"
msgstr "让我们看看 :djadmin:`startproject` 创建了些什么::"

msgid "These files are:"
msgstr "这些目录和文件的用处是："

msgid ""
"The outer :file:`mysite/` root directory is just a container for your "
"project. Its name doesn't matter to Django; you can rename it to anything "
"you like."
msgstr ""
"最外层的:file: `mysite/` 根目录只是你项目的容器， Django 不关心它的名字，你可"
"以将它重命名为任何你喜欢的名字。"

msgid ""
":file:`manage.py`: A command-line utility that lets you interact with this "
"Django project in various ways. You can read all the details about :file:"
"`manage.py` in :doc:`/ref/django-admin`."
msgstr ""
":file:`manage.py`: 一个让你用各种方式管理 Django 项目的命令行工具。你可以阅"
"读 :doc:`/ref/django-admin` 获取所有 :file:`manage.py` 的细节。"

msgid ""
"The inner :file:`mysite/` directory is the actual Python package for your "
"project. Its name is the Python package name you'll need to use to import "
"anything inside it (e.g. ``mysite.urls``)."
msgstr ""
"里面一层的 :file:`mysite/`  目录包含你的项目，它是一个纯 Python 包。它的名字"
"就是当你引用它内部任何东西时需要用到的 Python 包名。 (比如 ``mysite.urls``)."

msgid ""
":file:`mysite/__init__.py`: An empty file that tells Python that this "
"directory should be considered a Python package. If you're a Python "
"beginner, read :ref:`more about packages <tut-packages>` in the official "
"Python docs."
msgstr ""
":file:`mysite/__init__.py`：一个空文件，告诉 Python 这个目录应该被认为是一个 "
"Python 包。如果你是 Python 初学者，阅读官方文档中的 :ref:`更多关于包的知识 "
"<tut-packages>`。"

msgid ""
":file:`mysite/settings.py`: Settings/configuration for this Django "
"project.  :doc:`/topics/settings` will tell you all about how settings work."
msgstr ""
":file:`mysite/settings.py`：Django 项目的配置文件。如果你想知道这个文件是如何"
"工作的，请查看 :doc:`/topics/settings` 了解细节。"

msgid ""
":file:`mysite/urls.py`: The URL declarations for this Django project; a "
"\"table of contents\" of your Django-powered site. You can read more about "
"URLs in :doc:`/topics/http/urls`."
msgstr ""
":file:`mysite/urls.py`：Django 项目的 URL 声明，就像你网站的“目录”。阅读 :"
"doc:`/topics/http/urls` 文档来获取更多关于 URL 的内容。"

msgid ""
":file:`mysite/wsgi.py`: An entry-point for WSGI-compatible web servers to "
"serve your project. See :doc:`/howto/deployment/wsgi/index` for more details."
msgstr ""
":file:`mysite/wsgi.py`：作为你的项目的运行在 WSGI 兼容的Web服务器上的入口。阅"
"读 :doc:`/howto/deployment/wsgi/index` 了解更多细节。"

msgid "The development server"
msgstr "用于开发的简易服务器"

msgid ""
"Let's verify your Django project works. Change into the outer :file:`mysite` "
"directory, if you haven't already, and run the following commands:"
msgstr ""
"让我们来确认一下你的 Django 项目是否真的创建成功了。如果你的当前目录不是外层"
"的 :file:`mysite` 目录的话，请切换到此目录，然后运行下面的命令："

msgid "You'll see the following output on the command line:"
msgstr "你应该会看到如下输出："

msgid ""
"Ignore the warning about unapplied database migrations for now; we'll deal "
"with the database shortly."
msgstr "忽略有关未应用最新数据库迁移的警告，稍后我们处理数据库。"

msgid ""
"You've started the Django development server, a lightweight Web server "
"written purely in Python. We've included this with Django so you can develop "
"things rapidly, without having to deal with configuring a production server "
"-- such as Apache -- until you're ready for production."
msgstr ""
"你刚刚启动的是 Django 自带的用于开发的简易服务器，它是一个用纯 Python 写的轻"
"量级的 Web 服务器。我们将这个服务器内置在 Django 中是为了让你能快速的开发出想"
"要的东西，因为你不需要进行配置生产级别的服务器（比如 Apache）方面的工作，除非"
"你已经准备好投入生产环境了。"

msgid ""
"Now's a good time to note: **don't** use this server in anything resembling "
"a production environment. It's intended only for use while developing. "
"(We're in the business of making Web frameworks, not Web servers.)"
msgstr ""
"现在是个提醒你的好时机：**千万不要** 将这个服务器用于和生产环境相关的任何地"
"方。这个服务器只是为了开发而设计的。(我们在 Web 框架方面是专家，在 Web 服务器"
"方面并不是。)"

msgid ""
"Now that the server's running, visit http://127.0.0.1:8000/ with your Web "
"browser. You'll see a \"Congratulations!\" page, with a rocket taking off. "
"It worked!"
msgstr ""
"现在，服务器正在运行，浏览器访问 https://127.0.0.1:8000/。你将会看到一个“祝"
"贺”页面，随着一只火箭发射，服务器已经运行了。"

msgid "Changing the port"
msgstr "更换端口"

msgid ""
"By default, the :djadmin:`runserver` command starts the development server "
"on the internal IP at port 8000."
msgstr ""
"默认情况下，:djadmin:`runserver` 命令会将服务器设置为监听本机内部 IP 的 8000 "
"端口。"

msgid ""
"If you want to change the server's port, pass it as a command-line argument. "
"For instance, this command starts the server on port 8080:"
msgstr ""
"如果你想更换服务器的监听端口，请使用命令行参数。举个例子，下面的命令会使服务"
"器监听 8080 端口： "

msgid ""
"If you want to change the server's IP, pass it along with the port. For "
"example, to listen on all available public IPs (which is useful if you are "
"running Vagrant or want to show off your work on other computers on the "
"network), use:"
msgstr ""
"如果你想要修改服务器监听的IP，在端口之前输入新的。比如，为了监听所有服务器的"
"公开IP（这你运行 Vagrant 或想要向网络上的其它电脑展示你的成果时很有用），使"
"用："

msgid ""
"**0** is a shortcut for **0.0.0.0**. Full docs for the development server "
"can be found in the :djadmin:`runserver` reference."
msgstr ""
"**0** 是 **0.0.0.0** 的简写。完整的关于开发服务器的文档可以在 :djamdin:"
"`runserver` 参考文档中找到。"

msgid "Automatic reloading of :djadmin:`runserver`"
msgstr "会自动重新加载的服务器 :djadmin:`runserver`"

msgid ""
"The development server automatically reloads Python code for each request as "
"needed. You don't need to restart the server for code changes to take "
"effect. However, some actions like adding files don't trigger a restart, so "
"you'll have to restart the server in these cases."
msgstr ""
"用于开发的服务器在需要的情况下会对每一次的访问请求重新载入一遍 Python 代码。"
"所以你不需要为了让修改的代码生效而频繁的重新启动服务器。然而，一些动作，比如"
"添加新文件，将不会触发自动重新加载，这时你得自己手动重启服务器。"

msgid "Creating the Polls app"
msgstr "创建投票应用"

msgid ""
"Now that your environment -- a \"project\" -- is set up, you're set to start "
"doing work."
msgstr "现在你的开发环境——这个“项目” ——已经配置好了，你可以开始干活了。"

msgid ""
"Each application you write in Django consists of a Python package that "
"follows a certain convention. Django comes with a utility that automatically "
"generates the basic directory structure of an app, so you can focus on "
"writing code rather than creating directories."
msgstr ""
"在 Django 中，每一个应用都是一个 Python 包，并且遵循着相同的约定。Django 自带"
"一个工具，可以帮你生成应用的基础目录结构，这样你就能专心写代码，而不是创建目"
"录了。"

msgid "Projects vs. apps"
msgstr "项目 VS 应用"

msgid ""
"What's the difference between a project and an app? An app is a Web "
"application that does something -- e.g., a Weblog system, a database of "
"public records or a simple poll app. A project is a collection of "
"configuration and apps for a particular website. A project can contain "
"multiple apps. An app can be in multiple projects."
msgstr ""
"项目和应用有啥区别？应用是一个专门做某件事的网络应用程序——比如博客系统，或者"
"公共记录的数据库，或者简单的投票程序。项目则是一个网站使用的配置和应用的集"
"合。项目可以包含很多个应用。应用可以被很多个项目使用。"

msgid ""
"Your apps can live anywhere on your :ref:`Python path <tut-searchpath>`. In "
"this tutorial, we'll create our poll app right next to your :file:`manage."
"py` file so that it can be imported as its own top-level module, rather than "
"a submodule of ``mysite``."
msgstr ""
"你的应用可以存放在任何 :ref:`Python path <tut-searchpath>` 中定义的路径。在这"
"个教程中，我们将在你的 :file:`manage.py` 同级目录下创建投票应用。这样它就可以"
"作为顶级模块导入，而不是 ``mysite`` 的子模块。"

msgid ""
"To create your app, make sure you're in the same directory as :file:`manage."
"py` and type this command:"
msgstr ""
"请确定你现在处于 :file:`manage.py` 所在的目录下，然后运行这行命令来创建一个应"
"用："

msgid "That'll create a directory :file:`polls`, which is laid out like this::"
msgstr "这将会创建一个 :file:`polls` 目录，它的目录结构大致如下："

msgid "This directory structure will house the poll application."
msgstr "这个目录结构包括了投票应用的全部内容。"

msgid "Write your first view"
msgstr "编写第一个视图"

msgid ""
"Let's write the first view. Open the file ``polls/views.py`` and put the "
"following Python code in it:"
msgstr ""
"让我们开始编写第一个视图吧。打开 ``polls/views.py``，把下面这些 Python 代码输"
"入进去："

msgid ""
"This is the simplest view possible in Django. To call the view, we need to "
"map it to a URL - and for this we need a URLconf."
msgstr ""
"这是 Django 中最简单的视图。如果想看见效果，我们需要将一个 URL 映射到它——这就"
"是我们需要 URLconf 的原因了。"

msgid ""
"To create a URLconf in the polls directory, create a file called ``urls."
"py``. Your app directory should now look like::"
msgstr ""
"为了创建 URLconf，请在 polls 目录里新建一个 ``urls.py``  文件。你的应用目录现"
"在看起来应该是这样："

msgid "In the ``polls/urls.py`` file include the following code:"
msgstr "在 ``polls/urls.py`` 中，输入如下代码："

msgid ""
"The next step is to point the root URLconf at the ``polls.urls`` module. In "
"``mysite/urls.py``, add an import for ``django.urls.include`` and insert an :"
"func:`~django.urls.include` in the ``urlpatterns`` list, so you have:"
msgstr ""
"下一步是要在根 URLconf 文件中指定我们创建的 ``polls.urls`` 模块。在 ``mysite/"
"urls.py`` 文件的 ``urlpatterns`` 列表里插入一个 :func:`~django.conf.urls."
"include`， 如下："

msgid ""
"The :func:`~django.urls.include` function allows referencing other URLconfs. "
"Whenever Django encounters :func:`~django.urls.include`, it chops off "
"whatever part of the URL matched up to that point and sends the remaining "
"string to the included URLconf for further processing."
msgstr ""
"函数 :func:`~django.urls.include` 允许引用其它 URLconfs。每当 Django 遇到 :"
"func：`~django.urls.include` 时，它会截断与此项匹配的 URL 的部分，并将剩余的"
"字符串发送到 URLconf 以供进一步处理。"

msgid ""
"The idea behind :func:`~django.urls.include` is to make it easy to plug-and-"
"play URLs. Since polls are in their own URLconf (``polls/urls.py``), they "
"can be placed under \"/polls/\", or under \"/fun_polls/\", or under \"/"
"content/polls/\", or any other path root, and the app will still work."
msgstr ""
"我们设计 :func:`~django.urls.include` 的理念是使其可以即插即用。因为投票应用"
"有它自己的 URLconf( ``polls/urls.py`` )，他们能够被放在 \"/polls/\" ， \"/"
"fun_polls/\" ，\"/content/polls/\"，或者其他任何路径下，这个应用都能够正常工"
"作。"

msgid "When to use :func:`~django.urls.include()`"
msgstr "何时使用 :func:`~django.urls.include()`"

msgid ""
"You should always use ``include()`` when you include other URL patterns. "
"``admin.site.urls`` is the only exception to this."
msgstr ""
"当包括其它 URL 模式时你应该总是使用 ``include()`` ， ``admin.site.urls`` 是唯"
"一例外。"

msgid ""
"You have now wired an ``index`` view into the URLconf. Lets verify it's "
"working, run the following command:"
msgstr ""
"你现在把 ``index`` 视图添加进了 URLconf。可以验证是否正常工作，运行下面的命"
"令:"

msgid ""
"Go to http://localhost:8000/polls/ in your browser, and you should see the "
"text \"*Hello, world. You're at the polls index.*\", which you defined in "
"the ``index`` view."
msgstr ""
"用你的浏览器访问 http://localhost:8000/polls/，你应该能够看见 \"*Hello, "
"world. You're at the polls index.*\" ，这是你在 ``index`` 视图中定义的。"

msgid ""
"The :func:`~django.urls.path` function is passed four arguments, two "
"required: ``route`` and ``view``, and two optional: ``kwargs``, and "
"``name``. At this point, it's worth reviewing what these arguments are for."
msgstr ""
"函数 :func:`~django.urls.path` 具有四个参数，两个必须参数：``route`` 和 "
"``view``，两个可选参数：``kwargs`` 和 ``name``。现在，是时候来研究这些参数的"
"含义了。"

msgid ":func:`~django.urls.path` argument: ``route``"
msgstr ":func:`~django.urls.path` 参数： ``route``"

msgid ""
"``route`` is a string that contains a URL pattern. When processing a "
"request, Django starts at the first pattern in ``urlpatterns`` and makes its "
"way down the list, comparing the requested URL against each pattern until it "
"finds one that matches."
msgstr ""
"``route`` 是一个匹配 URL 的准则（类似正则表达式）。当 Django 响应一个请求时，"
"它会从 ``urlpatterns`` 的第一项开始，按顺序依次匹配列表中的项，直到找到匹配的"
"项。"

msgid ""
"Patterns don't search GET and POST parameters, or the domain name. For "
"example, in a request to ``https://www.example.com/myapp/``, the URLconf "
"will look for ``myapp/``. In a request to ``https://www.example.com/myapp/?"
"page=3``, the URLconf will also look for ``myapp/``."
msgstr ""
"这些准则不会匹配 GET 和 POST 参数或域名。例如，URLconf 在处理请求 ``https://"
"www.example.com/myapp/`` 时，它会尝试匹配 ``myapp/`` 。处理请求 ``https://"
"www.example.com/myapp/?page=3`` 时，也只会尝试匹配 ``myapp/``。"

msgid ":func:`~django.urls.path` argument: ``view``"
msgstr ":func:`~django.urls.path` 参数： ``view``"

msgid ""
"When Django finds a matching pattern, it calls the specified view function "
"with an :class:`~django.http.HttpRequest` object as the first argument and "
"any \"captured\" values from the route as keyword arguments. We'll give an "
"example of this in a bit."
msgstr ""
"当 Django 找到了一个匹配的准则，就会调用这个特定的视图函数，并传入一个 :"
"class:`~django.http.HttpRequest` 对象作为第一个参数，被“捕获”的参数以关键字参"
"数的形式传入。稍后，我们会给出一个例子。"

msgid ":func:`~django.urls.path` argument: ``kwargs``"
msgstr ":func:`~django.urls.path` 参数： ``kwargs``"

msgid ""
"Arbitrary keyword arguments can be passed in a dictionary to the target "
"view. We aren't going to use this feature of Django in the tutorial."
msgstr ""
"任意个关键字参数可以作为一个字典传递给目标视图函数。本教程中不会使用这一特"
"性。"

msgid ":func:`~django.urls.path` argument: ``name``"
msgstr ":func:`~django.urls.path` 参数： ``name``"

msgid ""
"Naming your URL lets you refer to it unambiguously from elsewhere in Django, "
"especially from within templates. This powerful feature allows you to make "
"global changes to the URL patterns of your project while only touching a "
"single file."
msgstr ""
"为你的 URL 取名能使你在 Django 的任意地方唯一地引用它，尤其是在模板中。这个有"
"用的特性允许你只改一个文件就能全局地修改某个 URL 模式。"

msgid ""
"When you're comfortable with the basic request and response flow, read :doc:"
"`part 2 of this tutorial </intro/tutorial02>` to start working with the "
"database."
msgstr ""
"当你了解了基本的请求和响应流程后，请阅读 :doc:`教程的第 2 部分 </intro/"
"tutorial02>`  开始使用数据库."

msgid "Writing your first Django app, part 2"
msgstr "编写你的第一个 Django 应用，第 2 部分"

msgid ""
"This tutorial begins where :doc:`Tutorial 1 </intro/tutorial01>` left off. "
"We'll setup the database, create your first model, and get a quick "
"introduction to Django's automatically-generated admin site."
msgstr ""
"这部分教程从 :doc:`教程第 1 部分 </intro/tutorial01>`  结尾的地方继续讲起。我"
"们将建立数据库，创建您的第一个模型，并主要关注 Django 提供的自动生成的管理页"
"面。"

msgid "Database setup"
msgstr "数据库配置"

msgid ""
"Now, open up :file:`mysite/settings.py`. It's a normal Python module with "
"module-level variables representing Django settings."
msgstr ""
"现在，打开 :file:`mysite/settings.py` 。这是个包含了 Django 项目设置的 "
"Python 模块。"

msgid ""
"By default, the configuration uses SQLite. If you're new to databases, or "
"you're just interested in trying Django, this is the easiest choice. SQLite "
"is included in Python, so you won't need to install anything else to support "
"your database. When starting your first real project, however, you may want "
"to use a more scalable database like PostgreSQL, to avoid database-switching "
"headaches down the road."
msgstr ""
"通常，这个配置文件使用 SQLite 作为默认数据库。如果你不熟悉数据库，或者只是想"
"尝试下 Django，这是最简单的选择。Python 内置 SQLite，所以你无需安装额外东西来"
"使用它。当你开始一个真正的项目时，你可能更倾向使用一个更具扩展性的数据库，例"
"如 PostgreSQL，避免中途切换数据库这个令人头疼的问题。"

msgid ""
"If you wish to use another database, install the appropriate :ref:`database "
"bindings <database-installation>` and change the following keys in the :"
"setting:`DATABASES` ``'default'`` item to match your database connection "
"settings:"
msgstr ""
"如果你想使用其他数据库，你需要安装合适的 :ref:`database bindings <database-"
"installation>` ，然后改变设置文件中 :setting:`DATABASES` ``'default'``  项目"
"中的一些键值："

msgid ""
":setting:`ENGINE <DATABASE-ENGINE>` -- Either ``'django.db.backends."
"sqlite3'``, ``'django.db.backends.postgresql'``, ``'django.db.backends."
"mysql'``, or ``'django.db.backends.oracle'``. Other backends are :ref:`also "
"available <third-party-notes>`."
msgstr ""
":setting:`ENGINE <DATABASE-ENGINE>` -- 可选值有 ``'django.db.backends."
"sqlite3'``，``'django.db.backends.postgresql'``，``'django.db.backends."
"mysql'``，或 ``'django.db.backends.oracle'``。其它 :ref:`可用后端 <third-"
"party-notes>`。"

msgid ""
":setting:`NAME` -- The name of your database. If you're using SQLite, the "
"database will be a file on your computer; in that case, :setting:`NAME` "
"should be the full absolute path, including filename, of that file. The "
"default value, ``os.path.join(BASE_DIR, 'db.sqlite3')``, will store the file "
"in your project directory."
msgstr ""
":setting:`NAME`  - 数据库的名称。如果使用的是 SQLite，数据库将是你电脑上的一"
"个文件，在这种情况下， :setting:`NAME`  应该是此文件的绝对路径，包括文件名。"
"默认值 ``os.path.join(BASE_DIR, 'db.sqlite3')`` 将会把数据库文件储存在项目的"
"根目录。"

msgid ""
"If you are not using SQLite as your database, additional settings such as :"
"setting:`USER`, :setting:`PASSWORD`, and :setting:`HOST` must be added. For "
"more details, see the reference documentation for :setting:`DATABASES`."
msgstr ""
"如果你不使用 SQLite，则必须添加一些额外设置，比如 :setting:`USER` 、 :"
"setting:`PASSWORD` 、  :setting:`HOST`  等等。想了解更多数据库设置方面的内"
"容，请看文档：:setting:`DATABASES` 。"

msgid "For databases other than SQLite"
msgstr "SQLite 以外的其它数据库"

msgid ""
"If you're using a database besides SQLite, make sure you've created a "
"database by this point. Do that with \"``CREATE DATABASE database_name;``\" "
"within your database's interactive prompt."
msgstr ""
"如果你使用了 SQLite 以外的数据库，请确认在使用前已经创建了数据库。你可以通过"
"在你的数据库交互式命令行中使用 \"``CREATE DATABASE database_name;``\" 命令来"
"完成这件事。"

msgid ""
"Also make sure that the database user provided in :file:`mysite/settings.py` "
"has \"create database\" privileges. This allows automatic creation of a :ref:"
"`test database <the-test-database>` which will be needed in a later tutorial."
msgstr ""
"另外，还要确保该数据库用户中提供  :file:`mysite/settings.py` 具有 \"create "
"database\"  权限。这使得自动创建的  :ref:`test database <the-test-"
"database>`  能被以后的教程使用。"

msgid ""
"If you're using SQLite, you don't need to create anything beforehand - the "
"database file will be created automatically when it is needed."
msgstr ""
"如果你使用 SQLite，那么你不需要在使用前做任何事——数据库会在需要的时候自动创"
"建。"

msgid ""
"While you're editing :file:`mysite/settings.py`, set :setting:`TIME_ZONE` to "
"your time zone."
msgstr ""
"编辑 :file:`mysite/settings.py` 文件前，先设置 :setting:`TIME_ZONE` 为你自己"
"时区。"

msgid ""
"Also, note the :setting:`INSTALLED_APPS` setting at the top of the file. "
"That holds the names of all Django applications that are activated in this "
"Django instance. Apps can be used in multiple projects, and you can package "
"and distribute them for use by others in their projects."
msgstr ""
"此外，关注一下文件头部的 :setting:`INSTALLED_APPS`  设置项。这里包括了会在你"
"项目中启用的所有 Django 应用。应用能在多个项目中使用，你也可以打包并且发布应"
"用，让别人使用它们。"

msgid ""
"By default, :setting:`INSTALLED_APPS` contains the following apps, all of "
"which come with Django:"
msgstr "通常， :setting:`INSTALLED_APPS`  默认包括了以下 Django 的自带应用："

msgid ":mod:`django.contrib.admin` -- The admin site. You'll use it shortly."
msgstr ":mod:`django.contrib.admin` --  管理员站点， 你很快就会使用它。"

msgid ":mod:`django.contrib.auth` -- An authentication system."
msgstr ":mod:`django.contrib.auth` -- 认证授权系统。"

msgid ":mod:`django.contrib.contenttypes` -- A framework for content types."
msgstr ":mod:`django.contrib.contenttypes` -- 内容类型框架。"

msgid ":mod:`django.contrib.sessions` -- A session framework."
msgstr ":mod:`django.contrib.sessions` -- 会话框架。"

msgid ":mod:`django.contrib.messages` -- A messaging framework."
msgstr ":mod:`django.contrib.messages` -- 消息框架。"

msgid ""
":mod:`django.contrib.staticfiles` -- A framework for managing static files."
msgstr ":mod:`django.contrib.staticfiles` -- 管理静态文件的框架。"

msgid ""
"These applications are included by default as a convenience for the common "
"case."
msgstr "这些应用被默认启用是为了给常规项目提供方便。"

msgid ""
"Some of these applications make use of at least one database table, though, "
"so we need to create the tables in the database before we can use them. To "
"do that, run the following command:"
msgstr ""
"默认开启的某些应用需要至少一个数据表，所以，在使用他们之前需要在数据库中创建"
"一些表。请执行以下命令："

msgid ""
"The :djadmin:`migrate` command looks at the :setting:`INSTALLED_APPS` "
"setting and creates any necessary database tables according to the database "
"settings in your :file:`mysite/settings.py` file and the database migrations "
"shipped with the app (we'll cover those later). You'll see a message for "
"each migration it applies. If you're interested, run the command-line client "
"for your database and type ``\\dt`` (PostgreSQL), ``SHOW TABLES;`` (MySQL), "
"``.schema`` (SQLite), or ``SELECT TABLE_NAME FROM USER_TABLES;`` (Oracle) to "
"display the tables Django created."
msgstr ""
"这个 :djadmin:`migrate`  命令检查 :setting:`INSTALLED_APPS` 设置，为其中的每"
"个应用创建需要的数据表，至于具体会创建什么，这取决于你的 :file:`mysite/"
"settings.py` 设置文件和每个应用的数据库迁移文件（我们稍后会介绍这个）。这个命"
"令所执行的每个迁移操作都会在终端中显示出来。如果你感兴趣的话，运行你数据库的"
"命令行工具，并输入 ``\\dt``  (PostgreSQL)， ``SHOW TABLES;`` (MySQL)， ``."
"schema`` (SQLite)或者 ``SELECT TABLE_NAME FROM USER_TABLES;`` (Oracle) 来看"
"看 Django 到底创建了哪些表。"

msgid "For the minimalists"
msgstr "写给极简主义者"

msgid ""
"Like we said above, the default applications are included for the common "
"case, but not everybody needs them. If you don't need any or all of them, "
"feel free to comment-out or delete the appropriate line(s) from :setting:"
"`INSTALLED_APPS` before running :djadmin:`migrate`. The :djadmin:`migrate` "
"command will only run migrations for apps in :setting:`INSTALLED_APPS`."
msgstr ""
"就像之前说的，为了方便大多数项目，我们默认激活了一些应用，但并不是每个人都需"
"要它们。如果你不需要某个或某些应用，你可以在运行 :djadmin:`migrate` 前毫无顾"
"虑地从 :setting:`INSTALLED_APPS`  里注释或者删除掉它们。 :djadmin:`migrate` "
"命令只会为在 :setting:`INSTALLED_APPS`  里声明了的应用进行数据库迁移。"

msgid "Creating models"
msgstr "创建模型"

msgid ""
"Now we'll define your models -- essentially, your database layout, with "
"additional metadata."
msgstr ""
"在 Django 里写一个数据库驱动的 Web 应用的第一步是定义模型 - 也就是数据库结构"
"设计和附加的其它元数据。"

msgid "Philosophy"
msgstr "设计哲学"

msgid ""
"A model is the single, definitive source of truth about your data. It "
"contains the essential fields and behaviors of the data you're storing. "
"Django follows the :ref:`DRY Principle <dry>`. The goal is to define your "
"data model in one place and automatically derive things from it."
msgstr ""
"模型是真实数据的简单明确的描述。它包含了储存的数据所必要的字段和行为。Django "
"遵循 :ref:`DRY Principle <dry>` 。它的目标是你只需要定义数据模型，然后其它的"
"杂七杂八代码你都不用关心，它们会自动从模型生成。"

msgid ""
"This includes the migrations - unlike in Ruby On Rails, for example, "
"migrations are entirely derived from your models file, and are essentially "
"just a history that Django can roll through to update your database schema "
"to match your current models."
msgstr ""
"来介绍一下迁移 - 举个例子，不像 Ruby On Rails，Django 的迁移代码是由你的模型"
"文件自动生成的，它本质上只是个历史记录，Django 可以用它来进行数据库的滚动更"
"新，通过这种方式使其能够和当前的模型匹配。"

msgid ""
"In our simple poll app, we'll create two models: ``Question`` and "
"``Choice``. A ``Question`` has a question and a publication date. A "
"``Choice`` has two fields: the text of the choice and a vote tally. Each "
"``Choice`` is associated with a ``Question``."
msgstr ""
"在这个简单的投票应用中，需要创建两个模型：问题 ``Question`` 和选项 "
"``Choice``。``Question`` 模型包括问题描述和发布时间。``Choice`` 模型有两个字"
"段，选项描述和当前得票数。每个选项属于一个问题。"

msgid ""
"These concepts are represented by simple Python classes. Edit the :file:"
"`polls/models.py` file so it looks like this:"
msgstr ""
"这些概念可以通过一个简单的 Python 类来描述。按照下面的例子来编辑 :file:"
"`polls/models.py` 文件："

msgid ""
"The code is straightforward. Each model is represented by a class that "
"subclasses :class:`django.db.models.Model`. Each model has a number of class "
"variables, each of which represents a database field in the model."
msgstr ""
"代码非常直白。每个模型被表示为 :class:`django.db.models.Model` 类的子类。每个"
"模型有一些类变量，它们都表示模型里的一个数据库字段。"

msgid ""
"Each field is represented by an instance of a :class:`~django.db.models."
"Field` class -- e.g., :class:`~django.db.models.CharField` for character "
"fields and :class:`~django.db.models.DateTimeField` for datetimes. This "
"tells Django what type of data each field holds."
msgstr ""
"每个字段都是 :class:`~django.db.models.Field` 类的实例 - 比如，字符字段被表示"
"为 :class:`~django.db.models.CharField` ，日期时间字段被表示为 :class:"
"`~django.db.models.DateTimeField` 。这将告诉 Django 每个字段要处理的数据类"
"型。"

msgid ""
"The name of each :class:`~django.db.models.Field` instance (e.g. "
"``question_text`` or ``pub_date``) is the field's name, in machine-friendly "
"format. You'll use this value in your Python code, and your database will "
"use it as the column name."
msgstr ""
"每个 :class:`~django.db.models.Field` 类实例变量的名字（例如 "
"``question_text`` 或 ``pub_date`` ）也是字段名，所以最好使用对机器友好的格"
"式。你将会在 Python 代码里使用它们，而数据库会将它们作为列名。"

msgid ""
"You can use an optional first positional argument to a :class:`~django.db."
"models.Field` to designate a human-readable name. That's used in a couple of "
"introspective parts of Django, and it doubles as documentation. If this "
"field isn't provided, Django will use the machine-readable name. In this "
"example, we've only defined a human-readable name for ``Question.pub_date``. "
"For all other fields in this model, the field's machine-readable name will "
"suffice as its human-readable name."
msgstr ""
"你可以使用可选的选项来为 :class:`~django.db.models.Field`  定义一个人类可读的"
"名字。这个功能在很多 Django 内部组成部分中都被使用了，而且作为文档的一部分。"
"如果某个字段没有提供此名称，Django 将会使用对机器友好的名称，也就是变量名。在"
"上面的例子中，我们只为  ``Question.pub_date`` 定义了对人类友好的名字。对于模"
"型内的其它字段，它们的机器友好名也会被作为人类友好名使用。"

msgid ""
"Some :class:`~django.db.models.Field` classes have required arguments. :"
"class:`~django.db.models.CharField`, for example, requires that you give it "
"a :attr:`~django.db.models.CharField.max_length`. That's used not only in "
"the database schema, but in validation, as we'll soon see."
msgstr ""
"定义某些 :class:`~django.db.models.Field`  类实例需要参数。例如 :class:"
"`~django.db.models.CharField`  需要一个 :attr:`~django.db.models.CharField."
"max_length`  参数。这个参数的用处不止于用来定义数据库结构，也用于验证数据，我"
"们稍后将会看到这方面的内容。"

msgid ""
"A :class:`~django.db.models.Field` can also have various optional arguments; "
"in this case, we've set the :attr:`~django.db.models.Field.default` value of "
"``votes`` to 0."
msgstr ""
":class:`~django.db.models.Field`  也能够接收多个可选参数；在上面的例子中：我"
"们将 ``votes`` 的 :attr:`~django.db.models.Field.default` 也就是默认值，设为"
"0。"

msgid ""
"Finally, note a relationship is defined, using :class:`~django.db.models."
"ForeignKey`. That tells Django each ``Choice`` is related to a single "
"``Question``. Django supports all the common database relationships: many-to-"
"one, many-to-many, and one-to-one."
msgstr ""
"注意在最后，我们使用 :class:`~django.db.models.ForeignKey` 定义了一个关系。这"
"将告诉 Django，每个 ``Choice`` 对象都关联到一个  ``Question``  对象。Django "
"支持所有常用的数据库关系：多对一、多对多和一对一。"

msgid "Activating models"
msgstr "激活模型"

msgid ""
"That small bit of model code gives Django a lot of information. With it, "
"Django is able to:"
msgstr ""
"上面的一小段用于创建模型的代码给了 Django 很多信息，通过这些信息，Django 可"
"以："

msgid "Create a database schema (``CREATE TABLE`` statements) for this app."
msgstr "为这个应用创建数据库 schema（生成 ``CREATE TABLE`` 语句）。"

msgid ""
"Create a Python database-access API for accessing ``Question`` and "
"``Choice`` objects."
msgstr ""
"创建可以与 ``Question`` 和 ``Choice`` 对象进行交互的 Python 数据库 API。"

msgid ""
"But first we need to tell our project that the ``polls`` app is installed."
msgstr "但是首先得把 ``polls`` 应用安装到我们的项目里。"

msgid ""
"Django apps are \"pluggable\": You can use an app in multiple projects, and "
"you can distribute apps, because they don't have to be tied to a given "
"Django installation."
msgstr ""
"Django 应用是“可插拔”的。你可以在多个项目中使用同一个应用。除此之外，你还可以"
"发布自己的应用，因为它们并不会被绑定到当前安装的 Django 上。"

msgid ""
"To include the app in our project, we need to add a reference to its "
"configuration class in the :setting:`INSTALLED_APPS` setting. The "
"``PollsConfig`` class is in the :file:`polls/apps.py` file, so its dotted "
"path is ``'polls.apps.PollsConfig'``. Edit the :file:`mysite/settings.py` "
"file and add that dotted path to the :setting:`INSTALLED_APPS` setting. "
"It'll look like this:"
msgstr ""
"为了在我们的工程中包含这个应用，我们需要在配置类 :setting:`INSTALLED_APPS` 中"
"添加设置。因为 ``PollsConfig`` 类写在文件 :file:`polls/apps.py` 中，所以它的"
"点式路径是 ``'polls.apps.PollsConfig'``。在文件 :file:`mysite/settings.py` "
"中 :setting:`INSTALLED_APPS` 子项添加点式路径后，它看起来像这样："

msgid ""
"Now Django knows to include the ``polls`` app. Let's run another command:"
msgstr "现在你的 Django 项目会包含 ``polls``  应用。接着运行下面的命令："

msgid "You should see something similar to the following:"
msgstr "你将会看到类似于下面这样的输出："

msgid ""
"By running ``makemigrations``, you're telling Django that you've made some "
"changes to your models (in this case, you've made new ones) and that you'd "
"like the changes to be stored as a *migration*."
msgstr ""
"通过运行 ``makemigrations`` 命令，Django 会检测你对模型文件的修改（在这种情况"
"下，你已经取得了新的），并且把修改的部分储存为一次 *迁移*。"

msgid ""
"Migrations are how Django stores changes to your models (and thus your "
"database schema) - they're just files on disk. You can read the migration "
"for your new model if you like; it's the file ``polls/"
"migrations/0001_initial.py``. Don't worry, you're not expected to read them "
"every time Django makes one, but they're designed to be human-editable in "
"case you want to manually tweak how Django changes things."
msgstr ""
"迁移是 Django 对于模型定义（也就是你的数据库结构）的变化的储存形式 - 没那么玄"
"乎，它们其实也只是一些你磁盘上的文件。如果你想的话，你可以阅读一下你模型的迁"
"移数据，它被储存在 ``polls/migrations/0001_initial.py`` 里。别担心，你不需要"
"每次都阅读迁移文件，但是它们被设计成人类可读的形式，这是为了便于你手动修改它"
"们。"

msgid ""
"There's a command that will run the migrations for you and manage your "
"database schema automatically - that's called :djadmin:`migrate`, and we'll "
"come to it in a moment - but first, let's see what SQL that migration would "
"run. The :djadmin:`sqlmigrate` command takes migration names and returns "
"their SQL:"
msgstr ""
"Django 有一个自动执行数据库迁移并同步管理你的数据库结构的命令 - 这个命令是 :"
"djadmin:`migrate`，我们马上就会接触它 - 但是首先，让我们看看迁移命令会执行哪"
"些 SQL 语句。:djadmin:`sqlmigrate`  命令接收一个迁移的名称，然后返回对应的 "
"SQL："

msgid ""
"You should see something similar to the following (we've reformatted it for "
"readability):"
msgstr "你将会看到类似下面这样的输出（我把输出重组成了人类可读的格式）："

msgid "Note the following:"
msgstr "请注意以下几点："

msgid ""
"The exact output will vary depending on the database you are using. The "
"example above is generated for PostgreSQL."
msgstr "输出的内容和你使用的数据库有关，上面的输出示例使用的是 PostgreSQL。"

msgid ""
"Table names are automatically generated by combining the name of the app "
"(``polls``) and the lowercase name of the model -- ``question`` and "
"``choice``. (You can override this behavior.)"
msgstr ""
"数据库的表名是由应用名(``polls``)和模型名的小写形式( ``question`` 和  "
"``choice``)连接而来。（如果需要，你可以自定义此行为。）"

msgid ""
"Primary keys (IDs) are added automatically. (You can override this, too.)"
msgstr "主键(IDs)会被自动创建。(当然，你也可以自定义。)"

msgid ""
"By convention, Django appends ``\"_id\"`` to the foreign key field name. "
"(Yes, you can override this, as well.)"
msgstr ""
"默认的，Django 会在外键字段名后追加字符串 ``\"_id\"`` 。（同样，这也可以自定"
"义。）"

msgid ""
"The foreign key relationship is made explicit by a ``FOREIGN KEY`` "
"constraint. Don't worry about the ``DEFERRABLE`` parts; that's just telling "
"PostgreSQL to not enforce the foreign key until the end of the transaction."
msgstr ""
"外键关系由 ``FOREIGN KEY`` 生成。你不用关心 ``DEFERRABLE``  部分，它只是告诉 "
"PostgreSQL，请在事务全都执行完之后再创建外键关系。"

msgid ""
"It's tailored to the database you're using, so database-specific field types "
"such as ``auto_increment`` (MySQL), ``serial`` (PostgreSQL), or ``integer "
"primary key autoincrement`` (SQLite) are handled for you automatically. Same "
"goes for the quoting of field names -- e.g., using double quotes or single "
"quotes."
msgstr ""
"生成的 SQL 语句是为你所用的数据库定制的，所以那些和数据库有关的字段类型，比"
"如 ``auto_increment`` (MySQL)、 ``serial`` (PostgreSQL)和  ``integer primary "
"key autoincrement`` (SQLite)，Django 会帮你自动处理。那些和引号相关的事情 - "
"例如，是使用单引号还是双引号 - 也一样会被自动处理。"

msgid ""
"The :djadmin:`sqlmigrate` command doesn't actually run the migration on your "
"database - it just prints it to the screen so that you can see what SQL "
"Django thinks is required. It's useful for checking what Django is going to "
"do or if you have database administrators who require SQL scripts for "
"changes."
msgstr ""
"这个 :djadmin:`sqlmigrate` 命令并没有真正在你的数据库中的执行迁移 - 它只是把"
"命令输出到屏幕上，让你看看 Django 认为需要执行哪些 SQL 语句。这在你想看看 "
"Django 到底准备做什么，或者当你是数据库管理员，需要写脚本来批量处理数据库时会"
"很有用。"

msgid ""
"If you're interested, you can also run :djadmin:`python manage.py check "
"<check>`; this checks for any problems in your project without making "
"migrations or touching the database."
msgstr ""
"如果你感兴趣，你也可以试试运行 :djadmin:`python manage.py check <check>` ;这"
"个命令帮助你检查项目中的问题，并且在检查过程中不会对数据库进行任何操作。"

msgid ""
"Now, run :djadmin:`migrate` again to create those model tables in your "
"database:"
msgstr ""
"现在，再次运行 :djadmin:`migrate` 命令，在数据库里创建新定义的模型的数据表："

msgid ""
"The :djadmin:`migrate` command takes all the migrations that haven't been "
"applied (Django tracks which ones are applied using a special table in your "
"database called ``django_migrations``) and runs them against your database - "
"essentially, synchronizing the changes you made to your models with the "
"schema in the database."
msgstr ""
"这个 :djadmin:`migrate` 命令选中所有还没有执行过的迁移（Django 通过在数据库中"
"创建一个特殊的表 ``django_migrations`` 来跟踪执行过哪些迁移）并应用在数据库"
"上 - 也就是将你对模型的更改同步到数据库结构上。"

msgid ""
"Migrations are very powerful and let you change your models over time, as "
"you develop your project, without the need to delete your database or tables "
"and make new ones - it specializes in upgrading your database live, without "
"losing data. We'll cover them in more depth in a later part of the tutorial, "
"but for now, remember the three-step guide to making model changes:"
msgstr ""
"迁移是非常强大的功能，它能让你在开发过程中持续的改变数据库结构而不需要重新删"
"除和创建表 - 它专注于使数据库平滑升级而不会丢失数据。我们会在后面的教程中更加"
"深入的学习这部分内容，现在，你只需要记住，改变模型需要这三步："

msgid "Change your models (in ``models.py``)."
msgstr "编辑 ``models.py`` 文件，改变模型。"

msgid ""
"Run :djadmin:`python manage.py makemigrations <makemigrations>` to create "
"migrations for those changes"
msgstr ""
"运行 :djadmin:`python manage.py makemigrations <makemigrations>`   为模型的改"
"变生成迁移文件。"

msgid ""
"Run :djadmin:`python manage.py migrate <migrate>` to apply those changes to "
"the database."
msgstr ""
"运行  :djadmin:`python manage.py migrate <migrate>`  来应用数据库迁移。"

msgid ""
"The reason that there are separate commands to make and apply migrations is "
"because you'll commit migrations to your version control system and ship "
"them with your app; they not only make your development easier, they're also "
"useable by other developers and in production."
msgstr ""
"数据库迁移被分解成生成和应用两个命令是为了让你能够在代码控制系统上提交迁移数"
"据并使其能在多个应用里使用；这不仅仅会让开发更加简单，也给别的开发者和生产环"
"境中的使用带来方便。"

msgid ""
"Read the :doc:`django-admin documentation </ref/django-admin>` for full "
"information on what the ``manage.py`` utility can do."
msgstr ""
"通过阅读文档 :doc:`Django 后台文档 </ref/django-admin>` ，你可以获得关于  "
"``manage.py`` 工具的更多信息。"

msgid "Playing with the API"
msgstr "初试 API"

msgid ""
"Now, let's hop into the interactive Python shell and play around with the "
"free API Django gives you. To invoke the Python shell, use this command:"
msgstr ""
"现在让我们进入交互式 Python 命令行，尝试一下 Django 为你创建的各种 API。通过"
"以下命令打开 Python 命令行："

msgid ""
"We're using this instead of simply typing \"python\", because :file:`manage."
"py` sets the ``DJANGO_SETTINGS_MODULE`` environment variable, which gives "
"Django the Python import path to your :file:`mysite/settings.py` file."
msgstr ""
"我们使用这个命令而不是简单的使用 \"Python\" 是因为 :file:`manage.py` 会设置 "
"``DJANGO_SETTINGS_MODULE`` 环境变量，这个变量会让 Django 根据 :file:`mysite/"
"settings.py` 文件来设置 Python 包的导入路径。"

msgid ""
"Once you're in the shell, explore the :doc:`database API </topics/db/"
"queries>`::"
msgstr ""
"当你成功进入命令行后，来试试 :doc:`database API </topics/db/queries>`  吧::"

msgid ""
"Wait a minute. ``<Question: Question object (1)>`` isn't a helpful "
"representation of this object. Let's fix that by editing the ``Question`` "
"model (in the ``polls/models.py`` file) and adding a :meth:`~django.db."
"models.Model.__str__` method to both ``Question`` and ``Choice``:"
msgstr ""
"等等。``<Question: Question object (1)>`` 对于我们了解这个对象的细节没什么帮"
"助。让我们通过编辑 ``Question`` 模型的代码（位于 ``polls/models.py`` 中）来修"
"复这个问题。给 ``Question`` 和 ``Choice`` 增加 :meth:`~django.db.models."
"Model.__str__` 方法。"

msgid ""
"It's important to add :meth:`~django.db.models.Model.__str__` methods to "
"your models, not only for your own convenience when dealing with the "
"interactive prompt, but also because objects' representations are used "
"throughout Django's automatically-generated admin."
msgstr ""
"给模型增加 :meth:`~django.db.models.Model.__str__`  方法是很重要的，这不仅仅"
"能给你在命令行里使用带来方便，Django 自动生成的 admin 里也使用这个方法来表示"
"对象。"

msgid ""
"Note these are normal Python methods. Let's add a custom method, just for "
"demonstration:"
msgstr ""
"注意：这些都是常规的 Python方法。让我们添加一个自定义的方法，这只是为了演示："

msgid ""
"Note the addition of ``import datetime`` and ``from django.utils import "
"timezone``, to reference Python's standard :mod:`datetime` module and "
"Django's time-zone-related utilities in :mod:`django.utils.timezone`, "
"respectively. If you aren't familiar with time zone handling in Python, you "
"can learn more in the :doc:`time zone support docs </topics/i18n/timezones>`."
msgstr ""
"新加入的 ``import datetime``  和 ``from django.utils import timezone``  分别"
"导入了 Python 的标准 :mod:`datetime`  模块和 Django 中和时区相关的 :mod:"
"`django.utils.timezone` 工具模块。如果你不太熟悉 Python 中的时区处理，看看 :"
"doc:`时区支持文档 </topics/i18n/timezones>` 吧。"

msgid ""
"Save these changes and start a new Python interactive shell by running "
"``python manage.py shell`` again::"
msgstr ""
"保存文件然后通过 ``python manage.py shell``  命令再次打开 Python 交互式命令"
"行："

msgid ""
"For more information on model relations, see :doc:`Accessing related objects "
"</ref/models/relations>`. For more on how to use double underscores to "
"perform field lookups via the API, see :ref:`Field lookups <field-lookups-"
"intro>`. For full details on the database API, see our :doc:`Database API "
"reference </topics/db/queries>`."
msgstr ""
"阅读  :doc:`访问关系对象 </ref/models/relations>`  文档可以获取关于数据库关系"
"的更多内容。想知道关于双下划线的更多用法，参见 :ref:`查找字段 <field-lookups-"
"intro>` 文档。数据库 API 的所有细节可以在 :doc:`数据库 API 参考 </topics/db/"
"queries>` 文档中找到。"

msgid "Introducing the Django Admin"
msgstr "介绍 Django 管理页面"

msgid ""
"Generating admin sites for your staff or clients to add, change, and delete "
"content is tedious work that doesn't require much creativity. For that "
"reason, Django entirely automates creation of admin interfaces for models."
msgstr ""
"为你的员工或客户生成一个用户添加，修改和删除内容的后台是一项缺乏创造性和乏味"
"的工作。因此，Django 全自动地根据模型创建后台界面。"

msgid ""
"Django was written in a newsroom environment, with a very clear separation "
"between \"content publishers\" and the \"public\" site. Site managers use "
"the system to add news stories, events, sports scores, etc., and that "
"content is displayed on the public site. Django solves the problem of "
"creating a unified interface for site administrators to edit content."
msgstr ""
"Django 产生于一个公众页面和内容发布者页面完全分离的新闻类站点的开发过程中。站"
"点管理人员使用管理系统来添加新闻、事件和体育时讯等，这些添加的内容被显示在公"
"众页面上。Django 通过为站点管理人员创建统一的内容编辑界面解决了这个问题。"

msgid ""
"The admin isn't intended to be used by site visitors. It's for site managers."
msgstr "管理界面不是为了网站的访问者，而是为管理者准备的。"

msgid "Creating an admin user"
msgstr "创建一个管理员账号"

msgid ""
"First we'll need to create a user who can login to the admin site. Run the "
"following command:"
msgstr "首先，我们得创建一个能登录管理页面的用户。请运行下面的命令："

msgid "Enter your desired username and press enter."
msgstr "键入你想要使用的用户名，然后按下回车键："

msgid "You will then be prompted for your desired email address:"
msgstr "然后提示你输入想要使用的邮件地址："

msgid ""
"The final step is to enter your password. You will be asked to enter your "
"password twice, the second time as a confirmation of the first."
msgstr ""
"最后一步是输入密码。你会被要求输入两次密码，第二次的目的是为了确认第一次输入"
"的确实是你想要的密码。"

msgid "Start the development server"
msgstr "启动开发服务器"

msgid ""
"The Django admin site is activated by default. Let's start the development "
"server and explore it."
msgstr ""
"Django 的管理界面默认就是启用的。让我们启动开发服务器，看看它到底是什么样的。"

msgid "If the server is not running start it like so:"
msgstr "如果开发服务器未启动，用以下命令启动它："

msgid ""
"Now, open a Web browser and go to \"/admin/\" on your local domain -- e.g., "
"http://127.0.0.1:8000/admin/. You should see the admin's login screen:"
msgstr ""
"现在，打开浏览器，转到你本地域名的 \"/admin/\" 目录， -- 比如 "
"\"http://127.0.0.1:8000/admin/\"  。你应该会看见管理员登录界面："

msgid ""
"Since :doc:`translation </topics/i18n/translation>` is turned on by default, "
"the login screen may be displayed in your own language, depending on your "
"browser's settings and if Django has a translation for this language."
msgstr ""
"因为 :doc:`翻译 </topics/i18n/translation>`  功能默认是开着的，所以登录界面可"
"能会使用你的语言，取决于你浏览器的设置和 Django 是否拥有你语言的翻译。"

msgid "Enter the admin site"
msgstr "进入管理站点页面"

msgid ""
"Now, try logging in with the superuser account you created in the previous "
"step. You should see the Django admin index page:"
msgstr ""
"现在，试着使用你在上一步中创建的超级用户来登录。然后你将会看到 Django 管理页"
"面的索引页："

msgid ""
"You should see a few types of editable content: groups and users. They are "
"provided by :mod:`django.contrib.auth`, the authentication framework shipped "
"by Django."
msgstr ""
"你将会看到几种可编辑的内容：组和用户。它们是由 :mod:`django.contrib.auth`  提"
"供的，这是 Django 开发的认证框架。"

msgid "Make the poll app modifiable in the admin"
msgstr "向管理页面中加入投票应用"

msgid "But where's our poll app? It's not displayed on the admin index page."
msgstr "但是我们的投票应用在哪呢？它没在索引页面里显示。"

msgid ""
"Just one thing to do: we need to tell the admin that ``Question`` objects "
"have an admin interface. To do this, open the :file:`polls/admin.py` file, "
"and edit it to look like this:"
msgstr ""
"只需要做一件事：我们得告诉管理页面，问题 ``Question`` 对象需要被管理。打开 :"
"file:`polls/admin.py` 文件，把它编辑成下面这样："

msgid "Explore the free admin functionality"
msgstr "体验便捷的管理功能"

msgid ""
"Now that we've registered ``Question``, Django knows that it should be "
"displayed on the admin index page:"
msgstr ""
"现在我们向管理页面注册了问题 ``Question`` 类。Django 知道它应该被显示在索引页"
"里："

msgid ""
"Click \"Questions\". Now you're at the \"change list\" page for questions. "
"This page displays all the questions in the database and lets you choose one "
"to change it. There's the \"What's up?\" question we created earlier:"
msgstr ""
"点击 \"Questions\" 。现在看到是问题 \"Questions\" 对象的列表 \"change list"
"\" 。这个界面会显示所有数据库里的问题 Question 对象，你可以选择一个来修改。这"
"里现在有我们在上一部分中创建的 “What's up?” 问题。"

msgid "Click the \"What's up?\" question to edit it:"
msgstr "点击 “What's up?” 来编辑这个问题（Question）对象："

msgid "Things to note here:"
msgstr "注意事项："

msgid "The form is automatically generated from the ``Question`` model."
msgstr "这个表单是从问题 ``Question`` 模型中自动生成的"

msgid ""
"The different model field types (:class:`~django.db.models.DateTimeField`, :"
"class:`~django.db.models.CharField`) correspond to the appropriate HTML "
"input widget. Each type of field knows how to display itself in the Django "
"admin."
msgstr ""
"不同的字段类型（日期时间字段 :class:`~django.db.models.DateTimeField`  、字符"
"字段 :class:`~django.db.models.CharField`）会生成对应的 HTML 输入控件。每个类"
"型的字段都知道它们该如何在管理页面里显示自己。"

msgid ""
"Each :class:`~django.db.models.DateTimeField` gets free JavaScript "
"shortcuts. Dates get a \"Today\" shortcut and calendar popup, and times get "
"a \"Now\" shortcut and a convenient popup that lists commonly entered times."
msgstr ""
"每个日期时间字段 :class:`~django.db.models.DateTimeField` 都有 JavaScript 写"
"的快捷按钮。日期有转到今天（Today）的快捷按钮和一个弹出式日历界面。时间有设为"
"现在（Now）的快捷按钮和一个列出常用时间的方便的弹出式列表。"

msgid "The bottom part of the page gives you a couple of options:"
msgstr "页面的底部提供了几个选项："

msgid ""
"Save -- Saves changes and returns to the change-list page for this type of "
"object."
msgstr "保存（Save） - 保存改变，然后返回对象列表。"

msgid ""
"Save and continue editing -- Saves changes and reloads the admin page for "
"this object."
msgstr ""
"保存并继续编辑（Save and continue editing） - 保存改变，然后重新载入当前对象"
"的修改界面。"

msgid ""
"Save and add another -- Saves changes and loads a new, blank form for this "
"type of object."
msgstr ""
"保存并新增（Save and add another） - 保存改变，然后添加一个新的空对象并载入修"
"改界面。"

msgid "Delete -- Displays a delete confirmation page."
msgstr "删除（Delete） - 显示一个确认删除页面。"

msgid ""
"If the value of \"Date published\" doesn't match the time when you created "
"the question in :doc:`Tutorial 1</intro/tutorial01>`, it probably means you "
"forgot to set the correct value for the :setting:`TIME_ZONE` setting. Change "
"it, reload the page and check that the correct value appears."
msgstr ""
"如果显示的 “发布日期(Date Published)” 和你在 :doc:`教程 1</intro/"
"tutorial01>` 里创建它们的时间不一致，这意味着你可能没有正确的设置 :setting:"
"`TIME_ZONE` 。改变设置，然后重新载入页面看看是否显示了正确的值。"

msgid ""
"Change the \"Date published\" by clicking the \"Today\" and \"Now\" "
"shortcuts. Then click \"Save and continue editing.\" Then click \"History\" "
"in the upper right. You'll see a page listing all changes made to this "
"object via the Django admin, with the timestamp and username of the person "
"who made the change:"
msgstr ""
"通过点击 “今天(Today)” 和 “现在(Now)” 按钮改变 “发布日期(Date Published)”。然"
"后点击 “保存并继续编辑(Save and add another)”按钮。然后点击右上角的 “历史"
"(History)”按钮。你会看到一个列出了所有通过 Django 管理页面对当前对象进行的改"
"变的页面，其中列出了时间戳和进行修改操作的用户名："

msgid ""
"When you're comfortable with the models API and have familiarized yourself "
"with the admin site, read :doc:`part 3 of this tutorial</intro/tutorial03>` "
"to learn about how to add more views to our polls app."
msgstr ""
"当你熟悉了数据库 API 之后，你就可以开始阅读 :doc:`教程第 3 部分</intro/"
"tutorial03>`  ，下一部分我们将会学习如何为投票应用添加更多视图。"

msgid "Writing your first Django app, part 3"
msgstr "编写你的第一个 Django 应用，第 3 部分"

msgid ""
"This tutorial begins where :doc:`Tutorial 2 </intro/tutorial02>` left off. "
"We're continuing the Web-poll application and will focus on creating the "
"public interface -- \"views.\""
msgstr ""
"这一篇从 :doc:`教程第 2 部分 </intro/tutorial02>` 结尾的地方继续讲起。我们将"
"继续编写投票应用，并且专注于如何创建公用界面——也被称为“视图”。"

msgid "Overview"
msgstr "概况"

msgid ""
"A view is a \"type\" of Web page in your Django application that generally "
"serves a specific function and has a specific template. For example, in a "
"blog application, you might have the following views:"
msgstr ""
"Django 中的视图的概念是「一类具有相同功能和模板的网页的集合」。比如，在一个博"
"客应用中，你可能会创建如下几个视图："

msgid "Blog homepage -- displays the latest few entries."
msgstr "博客首页——展示最近的几项内容。"

msgid "Entry \"detail\" page -- permalink page for a single entry."
msgstr "内容“详情”页——详细展示某项内容。"

msgid ""
"Year-based archive page -- displays all months with entries in the given "
"year."
msgstr "以年为单位的归档页——展示选中的年份里各个月份创建的内容。"

msgid ""
"Month-based archive page -- displays all days with entries in the given "
"month."
msgstr "以月为单位的归档页——展示选中的月份里各天创建的内容。"

msgid "Day-based archive page -- displays all entries in the given day."
msgstr "以天为单位的归档页——展示选中天里创建的所有内容。"

msgid "Comment action -- handles posting comments to a given entry."
msgstr "评论处理器——用于响应为一项内容添加评论的操作。"

msgid "In our poll application, we'll have the following four views:"
msgstr "而在我们的投票应用中，我们需要下列几个视图："

msgid "Question \"index\" page -- displays the latest few questions."
msgstr "问题索引页——展示最近的几个投票问题。"

msgid ""
"Question \"detail\" page -- displays a question text, with no results but "
"with a form to vote."
msgstr "问题详情页——展示某个投票的问题和不带结果的选项列表。"

msgid ""
"Question \"results\" page -- displays results for a particular question."
msgstr "问题结果页——展示某个投票的结果。"

msgid ""
"Vote action -- handles voting for a particular choice in a particular "
"question."
msgstr "投票处理器——用于响应用户为某个问题的特定选项投票的操作。"

msgid ""
"In Django, web pages and other content are delivered by views. Each view is "
"represented by a simple Python function (or method, in the case of class-"
"based views). Django will choose a view by examining the URL that's "
"requested (to be precise, the part of the URL after the domain name)."
msgstr ""
"在 Django 中，网页和其他内容都是从视图派生而来。每一个视图表现为一个简单的 "
"Python 函数（或者说方法，如果是在基于类的视图里的话）。Django 将会根据用户请"
"求的 URL 来选择使用哪个视图（更准确的说，是根据 URL 中域名之后的部分）。"

msgid ""
"Now in your time on the web you may have come across such beauties as \"ME2/"
"Sites/dirmod.asp?sid=&type=gen&mod=Core+Pages&gid=A6CD4967199A42D9B65B1B\". "
"You will be pleased to know that Django allows us much more elegant *URL "
"patterns* than that."
msgstr ""
"在你上网的过程中，很可能看见过像这样美丽的 URL： \"ME2/Sites/dirmod.asp?"
"sid=&type=gen&mod=Core+Pages&gid=A6CD4967199A42D9B65B1B\" 。别担心，Django 里"
"的 *URL 规则* 要比这优雅的多！"

msgid ""
"A URL pattern is simply the general form of a URL - for example: ``/"
"newsarchive/<year>/<month>/``."
msgstr ""
"一个 URL 模式定义了某种 URL 的基本格式——举个例子：``/newsarchive/<year>/"
"<month>/``。"

msgid ""
"To get from a URL to a view, Django uses what are known as 'URLconfs'. A "
"URLconf maps URL patterns to views."
msgstr ""
"为了将 URL 和视图关联起来，Django 使用了 'URLconfs' 来配置。URLconf 将 URL 模"
"式映射到视图。"

msgid ""
"This tutorial provides basic instruction in the use of URLconfs, and you can "
"refer to :doc:`/topics/http/urls` for more information."
msgstr ""
"本教程只会介绍 URLconf 的基础内容，你可以看看 :doc:`/topics/http/urls` 以获取"
"更多内容。"

msgid "Writing more views"
msgstr "编写更多视图"

msgid ""
"Now let's add a few more views to ``polls/views.py``. These views are "
"slightly different, because they take an argument:"
msgstr ""
"现在让我们向 ``polls/views.py`` 里添加更多视图。这些视图有一些不同，因为他们"
"接收参数："

msgid ""
"Wire these new views into the ``polls.urls`` module by adding the following :"
"func:`~django.urls.path` calls:"
msgstr ""
"把这些新视图添加进 ``polls.urls``  模块里，只要添加几个 :func:`~django.conf."
"urls.url`  函数调用就行："

msgid ""
"Take a look in your browser, at \"/polls/34/\". It'll run the ``detail()`` "
"method and display whatever ID you provide in the URL. Try \"/polls/34/"
"results/\" and \"/polls/34/vote/\" too -- these will display the placeholder "
"results and voting pages."
msgstr ""
"然后看看你的浏览器，如果你转到  \"/polls/34/\" ，Django 将会运行 "
"``detail()`` 方法并且展示你在 URL 里提供的问题 ID。再试试 \"/polls/34/vote/"
"\"  和 \"/polls/34/vote/\" ——你将会看到暂时用于占位的结果和投票页。"

msgid ""
"When somebody requests a page from your website -- say, \"/polls/34/\", "
"Django will load the ``mysite.urls`` Python module because it's pointed to "
"by the :setting:`ROOT_URLCONF` setting. It finds the variable named "
"``urlpatterns`` and traverses the patterns in order. After finding the match "
"at ``'polls/'``, it strips off the matching text (``\"polls/\"``) and sends "
"the remaining text -- ``\"34/\"`` -- to the 'polls.urls' URLconf for further "
"processing. There it matches ``'<int:question_id>/'``, resulting in a call "
"to the ``detail()`` view like so::"
msgstr ""
"当某人请求你网站的某一页面时——比如说， \"/polls/34/\" ，Django 将会载入 "
"``mysite.urls`` 模块，因为这在配置项 :setting:`ROOT_URLCONF` 中设置了。然后 "
"Django 寻找名为 ``urlpatterns`` 变量并且按序匹配正则表达式。在找到匹配项 "
"``'polls/'``，它切掉了匹配的文本（``\"polls/\"``），将剩余文本——``\"34/\"``，"
"发送至 'polls.urls' URLconf 做进一步处理。在这里剩余文本匹配了 ``'<int:"
"question_id>/'``，使得我们 Django 以如下形式调用 ``detail()``::"

msgid ""
"The ``question_id=34`` part comes from ``<int:question_id>``. Using angle "
"brackets \"captures\" part of the URL and sends it as a keyword argument to "
"the view function. The ``:question_id>`` part of the string defines the name "
"that will be used to identify the matched pattern, and the ``<int:`` part is "
"a converter that determines what patterns should match this part of the URL "
"path."
msgstr ""
"``question_id=34`` 由 ``<int:question_id>`` 匹配生成。使用尖括号“捕获”这部分 "
"URL，且以关键字参数的形式发送给视图函数。上述字符串的 ``:question_id>`` 部分"
"定义了将被用于区分匹配模式的变量名，而 ``int:`` 则是一个转换器决定了应该以什"
"么变量类型匹配这部分的 URL 路径。"

msgid ""
"There's no need to add URL cruft such as ``.html`` -- unless you want to, in "
"which case you can do something like this::"
msgstr ""
"为每个 URL 加上不必要的东西，例如 ``.html`` ，是没有必要的。不过如果你非要加"
"的话，也是可以的::"

msgid "But, don't do that. It's silly."
msgstr "但是，别这样做，这太傻了。"

msgid "Write views that actually do something"
msgstr "写一个真正有用的视图"

msgid ""
"Each view is responsible for doing one of two things: returning an :class:"
"`~django.http.HttpResponse` object containing the content for the requested "
"page, or raising an exception such as :exc:`~django.http.Http404`. The rest "
"is up to you."
msgstr ""
"每个视图必须要做的只有两件事：返回一个包含被请求页面内容的 :class:`~django."
"http.HttpResponse` 对象，或者抛出一个异常，比如 :exc:`~django.http."
"Http404` 。至于你还想干些什么，随便你。"

msgid ""
"Your view can read records from a database, or not. It can use a template "
"system such as Django's -- or a third-party Python template system -- or "
"not. It can generate a PDF file, output XML, create a ZIP file on the fly, "
"anything you want, using whatever Python libraries you want."
msgstr ""
"你的视图可以从数据库里读取记录，可以使用一个模板引擎（比如 Django 自带的，或"
"者其他第三方的），可以生成一个 PDF 文件，可以输出一个 XML，创建一个 ZIP 文"
"件，你可以做任何你想做的事，使用任何你想用的 Python 库。"

msgid ""
"All Django wants is that :class:`~django.http.HttpResponse`. Or an exception."
msgstr ""
"Django 只要求返回的是一个 :class:`~django.http.HttpResponse` ，或者抛出一个异"
"常。"

msgid ""
"Because it's convenient, let's use Django's own database API, which we "
"covered in :doc:`Tutorial 2 </intro/tutorial02>`. Here's one stab at a new "
"``index()`` view, which displays the latest 5 poll questions in the system, "
"separated by commas, according to publication date:"
msgstr ""
"因为 Django 自带的数据库 API 很方便，我们曾在 :doc:`教程第 2 部分 </intro/"
"tutorial02>` 中学过，所以我们试试在视图里使用它。我们在 ``index()``  函数里插"
"入了一些新内容，让它能展示数据库里以发布日期排序的最近 5 个投票问题，以空格分"
"割："

msgid ""
"There's a problem here, though: the page's design is hard-coded in the view. "
"If you want to change the way the page looks, you'll have to edit this "
"Python code. So let's use Django's template system to separate the design "
"from Python by creating a template that the view can use."
msgstr ""
"这里有个问题：页面的设计写死在视图函数的代码里的。如果你想改变页面的样子，你"
"需要编辑 Python 代码。所以让我们使用 Django 的模板系统，只要创建一个视图，就"
"可以将页面的设计从代码中分离出来。"

msgid ""
"First, create a directory called ``templates`` in your ``polls`` directory. "
"Django will look for templates in there."
msgstr ""
"首先，在你的 ``polls`` 目录里创建一个 ``templates`` 目录。Django 将会在这个目"
"录里查找模板文件。"

msgid ""
"Your project's :setting:`TEMPLATES` setting describes how Django will load "
"and render templates. The default settings file configures a "
"``DjangoTemplates`` backend whose :setting:`APP_DIRS <TEMPLATES-APP_DIRS>` "
"option is set to ``True``. By convention ``DjangoTemplates`` looks for a "
"\"templates\" subdirectory in each of the :setting:`INSTALLED_APPS`."
msgstr ""
"你项目的 :setting:`TEMPLATES` 配置项描述了 Django 如何载入和渲染模板。默认的"
"设置文件设置了 ``DjangoTemplates`` 后端，并将  :setting:`APP_DIRS <TEMPLATES-"
"APP_DIRS>`  设置成了 True。这一选项将会让 ``DjangoTemplates``  在每个 :"
"setting:`INSTALLED_APPS`  文件夹中寻找 \"templates\" 子目录。这就是为什么尽管"
"我们没有像在第二部分中那样修改 DIRS 设置，Django 也能正确找到 polls 的模板位"
"置的原因。"

msgid ""
"Within the ``templates`` directory you have just created, create another "
"directory called ``polls``, and within that create a file called ``index."
"html``. In other words, your template should be at ``polls/templates/polls/"
"index.html``. Because of how the ``app_directories`` template loader works "
"as described above, you can refer to this template within Django simply as "
"``polls/index.html``."
msgstr ""
"在你刚刚创建的 ``templates`` 目录里，再创建一个目录 ``polls``，然后在其中新建"
"一个文件 ``index.html`` 。换句话说，你的模板文件的路径应该是  ``polls/"
"templates/polls/index.html`` 。因为 Django 会寻找到对应的 "
"``app_directories`` ，所以你只需要使用 ``polls/index.html``  就可以引用到这一"
"模板了。"

msgid "Template namespacing"
msgstr "模板命名空间"

msgid ""
"Now we *might* be able to get away with putting our templates directly in "
"``polls/templates`` (rather than creating another ``polls`` subdirectory), "
"but it would actually be a bad idea. Django will choose the first template "
"it finds whose name matches, and if you had a template with the same name in "
"a *different* application, Django would be unable to distinguish between "
"them. We need to be able to point Django at the right one, and the easiest "
"way to ensure this is by *namespacing* them. That is, by putting those "
"templates inside *another* directory named for the application itself."
msgstr ""
"虽然我们现在可以将模板文件直接放在  ``polls/templates`` 文件夹中（而不是再建"
"立一个 ``polls`` 子文件夹），但是这样做不太好。Django 将会选择第一个匹配的模"
"板文件，如果你有一个模板文件正好和另一个应用中的某个模板文件重名，Django 没有"
"办法 *区分* 它们。我们需要帮助 Django 选择正确的模板，最简单的方法就是把他们"
"放入各自的 *命名空间*  中，也就是把这些模板放入一个和 *自身* 应用重名的子文件"
"夹里。"

msgid "Put the following code in that template:"
msgstr "将下面的代码输入到刚刚创建的模板文件中："

msgid ""
"Now let's update our ``index`` view in ``polls/views.py`` to use the "
"template:"
msgstr ""
"然后，让我们更新一下 ``polls/views.py`` 里的 ``index`` 视图来使用模板："

msgid ""
"That code loads the template called  ``polls/index.html`` and passes it a "
"context. The context is a dictionary mapping template variable names to "
"Python objects."
msgstr ""
"上述代码的作用是，载入 ``polls/index.html``  模板文件，并且向它传递一个上下文"
"(context)。这个上下文是一个字典，它将模板内的变量映射为 Python 对象。"

msgid ""
"Load the page by pointing your browser at \"/polls/\", and you should see a "
"bulleted-list containing the \"What's up\" question from :doc:`Tutorial 2 </"
"intro/tutorial02>`. The link points to the question's detail page."
msgstr ""
"用你的浏览器访问 \"/polls/\" ，你将会看见一个无序列表，列出了我们在  :doc:`教"
"程第 2 部分 </intro/tutorial02>` 中添加的 “What's up” 投票问题，链接指向这个"
"投票的详情页。"

msgid "A shortcut: :func:`~django.shortcuts.render`"
msgstr "一个快捷函数： :func:`~django.shortcuts.render`"

msgid ""
"It's a very common idiom to load a template, fill a context and return an :"
"class:`~django.http.HttpResponse` object with the result of the rendered "
"template. Django provides a shortcut. Here's the full ``index()`` view, "
"rewritten:"
msgstr ""
"「载入模板，填充上下文，再返回由它生成的 :class:`~django.http.HttpResponse`  "
"对象」是一个非常常用的操作流程。于是 Django 提供了一个快捷函数，我们用它来重"
"写  ``index()``  视图："

msgid ""
"Note that once we've done this in all these views, we no longer need to "
"import :mod:`~django.template.loader` and :class:`~django.http.HttpResponse` "
"(you'll want to keep ``HttpResponse`` if you still have the stub methods for "
"``detail``, ``results``, and ``vote``)."
msgstr ""
"注意到，我们不再需要导入 :mod:`~django.template.loader`  和 :class:`~django."
"http.HttpResponse` 。不过如果你还有其他函数（比如说 ``detail``, ``results``, "
"和 ``vote`` ）需要用到它的话，就需要保持  ``HttpResponse``   的导入。"

msgid ""
"The :func:`~django.shortcuts.render` function takes the request object as "
"its first argument, a template name as its second argument and a dictionary "
"as its optional third argument. It returns an :class:`~django.http."
"HttpResponse` object of the given template rendered with the given context."
msgstr ""
" :func:`~django.shortcuts.render`  函数的第一个参数是一个请求 :class:"
"`~django.http.HttpResponse` 对象，第二个参数是需要载入的模板的名字。第三个参"
"数是需要用于渲染模板的上下文字典，这个参数是可选的。函数返回一个 :class:"
"`~django.http.HttpResponse`  对象，内容为指定模板用指定上下文渲染后的结果。"

msgid "Raising a 404 error"
msgstr "抛出 404 错误"

msgid ""
"Now, let's tackle the question detail view -- the page that displays the "
"question text for a given poll. Here's the view:"
msgstr ""
"现在，我们来处理投票详情视图——它会显示指定投票的问题标题。下面是这个视图的代"
"码："

msgid ""
"The new concept here: The view raises the :exc:`~django.http.Http404` "
"exception if a question with the requested ID doesn't exist."
msgstr ""
"这里有个新原则。如果指定问题 ID 所对应的问题不存在，这个视图就会抛出一个 :"
"exc:`~django.http.Http404` 异常。"

msgid ""
"We'll discuss what you could put in that ``polls/detail.html`` template a "
"bit later, but if you'd like to quickly get the above example working, a "
"file containing just:"
msgstr ""
"我们稍后再讨论你需要在 ``polls/detail.html``  里输入什么，但是如果你想试试上"
"面这段代码是否正常工作的话，你可以暂时把下面这段输进去："

msgid "will get you started for now."
msgstr "这样你就能测试了。"

msgid "A shortcut: :func:`~django.shortcuts.get_object_or_404`"
msgstr "一个快捷函数： :func:`~django.shortcuts.get_object_or_404` "

msgid ""
"It's a very common idiom to use :meth:`~django.db.models.query.QuerySet.get` "
"and raise :exc:`~django.http.Http404` if the object doesn't exist. Django "
"provides a shortcut. Here's the ``detail()`` view, rewritten:"
msgstr ""
"尝试用 :meth:`~django.db.models.query.QuerySet.get`  函数获取一个对象，如果不"
"存在就抛出 :exc:`~django.http.Http404` 错误也是一个普遍的流程。Django 也提供"
"了一个快捷函数，下面是修改后的详情 ``detail()`` 视图代码："

msgid ""
"The :func:`~django.shortcuts.get_object_or_404` function takes a Django "
"model as its first argument and an arbitrary number of keyword arguments, "
"which it passes to the :meth:`~django.db.models.query.QuerySet.get` function "
"of the model's manager. It raises :exc:`~django.http.Http404` if the object "
"doesn't exist."
msgstr ""
" :func:`~django.shortcuts.get_object_or_404`  函数的第一个参数是一个 Django "
"模型。在此之后可以有任意数量的关键字参数，他们会被直接传递给模型的 :meth:"
"`~django.db.models.query.QuerySet.get` 函数。如果符合要求的对象不存在，此快捷"
"函数将会抛出一个 :exc:`~django.http.Http404`  异常。"

msgid ""
"Why do we use a helper function :func:`~django.shortcuts.get_object_or_404` "
"instead of automatically catching the :exc:`~django.core.exceptions."
"ObjectDoesNotExist` exceptions at a higher level, or having the model API "
"raise :exc:`~django.http.Http404` instead of :exc:`~django.core.exceptions."
"ObjectDoesNotExist`?"
msgstr ""
"为什么我们使用辅助函数 :func:`~django.shortcuts.get_object_or_404` 而不是自己"
"捕获 :exc:`~django.core.exceptions.ObjectDoesNotExist` 异常呢？还有，为什么模"
"型 API 不直接抛出 :exc:`~django.core.exceptions.ObjectDoesNotExist` 而是抛"
"出 :exc:`~django.http.Http404` 呢？"

msgid ""
"Because that would couple the model layer to the view layer. One of the "
"foremost design goals of Django is to maintain loose coupling. Some "
"controlled coupling is introduced in the :mod:`django.shortcuts` module."
msgstr ""
"因为这样做会增加模型层和视图层的耦合性。指导 Django 设计的最重要的思想之一就"
"是要保证松散耦合。一些受控的耦合将会被包含在  :mod:`django.shortcuts` 模块"
"中。"

msgid ""
"There's also a :func:`~django.shortcuts.get_list_or_404` function, which "
"works just as :func:`~django.shortcuts.get_object_or_404` -- except using :"
"meth:`~django.db.models.query.QuerySet.filter` instead of :meth:`~django.db."
"models.query.QuerySet.get`. It raises :exc:`~django.http.Http404` if the "
"list is empty."
msgstr ""
"也有 :func:`~django.shortcuts.get_list_or_404` 函数，工作原理和 :func:"
"`~django.shortcuts.get_object_or_404` 一样，除了 :meth:`~django.db.models."
"query.QuerySet.get` 函数被换成了 :meth:`~django.db.models.query.QuerySet."
"filter` 函数。如果列表为空的话会抛出 :exc:`~django.http.Http404` 异常。"

msgid "Use the template system"
msgstr "使用模板系统"

msgid ""
"Back to the ``detail()`` view for our poll application. Given the context "
"variable ``question``, here's what the ``polls/detail.html`` template might "
"look like:"
msgstr ""
"回过头去看看我们的 ``detail()`` 视图。它向模板传递了上下文变量 "
"``question`` 。下面是 ``polls/detail.html`` 模板里正式的代码："

msgid ""
"The template system uses dot-lookup syntax to access variable attributes. In "
"the example of ``{{ question.question_text }}``, first Django does a "
"dictionary lookup on the object ``question``. Failing that, it tries an "
"attribute lookup -- which works, in this case. If attribute lookup had "
"failed, it would've tried a list-index lookup."
msgstr ""
"模板系统统一使用点符号来访问变量的属性。在示例 ``{{ question.question_text }}"
"`` 中，首先 Django 尝试对  ``question`` 对象使用字典查找（也就是使用 obj."
"get(str) 操作），如果失败了就尝试属性查找（也就是 obj.str 操作），结果是成功"
"了。如果这一操作也失败的话，将会尝试列表查找（也就是 obj[int] 操作）。"

msgid ""
"Method-calling happens in the :ttag:`{% for %}<for>` loop: ``question."
"choice_set.all`` is interpreted as the Python code ``question.choice_set."
"all()``, which returns an iterable of ``Choice`` objects and is suitable for "
"use in the :ttag:`{% for %}<for>` tag."
msgstr ""
"在 :ttag:`{% for %}<for>`  循环中发生的函数调用：``question.choice_set.all`` "
"被解释为 Python 代码 ``question.choice_set.all()`` ，将会返回一个可迭代的 "
"``Choice`` 对象，这一对象可以在 :ttag:`{% for %}<for>`  标签内部使用。"

msgid ""
"See the :doc:`template guide </topics/templates>` for more about templates."
msgstr "查看 :doc:`模板指南 </topics/templates>` 可以了解关于模板的更多信息。"

msgid "Removing hardcoded URLs in templates"
msgstr "去除模板中的硬编码 URL"

msgid ""
"Remember, when we wrote the link to a question in the ``polls/index.html`` "
"template, the link was partially hardcoded like this:"
msgstr ""
"还记得吗，我们在 ``polls/index.html`` 里编写投票链接时，链接是硬编码的："

msgid ""
"The problem with this hardcoded, tightly-coupled approach is that it becomes "
"challenging to change URLs on projects with a lot of templates. However, "
"since you defined the name argument in the :func:`~django.urls.path` "
"functions in the ``polls.urls`` module, you can remove a reliance on "
"specific URL paths defined in your url configurations by using the ``{% url "
"%}`` template tag:"
msgstr ""
"问题在于，硬编码和强耦合的链接，对于一个包含很多应用的项目来说，修改起来是十"
"分困难的。然而，因为你在 ``polls.urls`` 的 :func:`~django.conf.urls.url` 函数"
"中通过 name 参数为 URL 定义了名字，你可以使用  ``{% url %}`` 标签代替它："

msgid ""
"The way this works is by looking up the URL definition as specified in the "
"``polls.urls`` module. You can see exactly where the URL name of 'detail' is "
"defined below::"
msgstr ""
"这个标签的工作方式是在 ``polls.urls`` 模块的 URL 定义中寻具有指定名字的条目。"
"你可以回忆一下，具有名字 'detail'  的 URL 是在如下语句中定义的："

msgid ""
"If you want to change the URL of the polls detail view to something else, "
"perhaps to something like ``polls/specifics/12/`` instead of doing it in the "
"template (or templates) you would change it in ``polls/urls.py``::"
msgstr ""
"如果你想改变投票详情视图的 URL，比如想改成 ``polls/specifics/12/`` ，你不用在"
"模板里修改任何东西（包括其它模板），只要在 ``polls/urls.py`` 里稍微修改一下就"
"行："

msgid "Namespacing URL names"
msgstr "为 URL 名称添加命名空间"

msgid ""
"The tutorial project has just one app, ``polls``. In real Django projects, "
"there might be five, ten, twenty apps or more. How does Django differentiate "
"the URL names between them? For example, the ``polls`` app has a ``detail`` "
"view, and so might an app on the same project that is for a blog. How does "
"one make it so that Django knows which app view to create for a url when "
"using the ``{% url %}`` template tag?"
msgstr ""
"教程项目只有一个应用，``polls`` 。在一个真实的 Django 项目中，可能会有五个，"
"十个，二十个，甚至更多应用。Django 如何分辨重名的 URL 呢？举个例子，"
"``polls``  应用有 ``detail`` 视图，可能另一个博客应用也有同名的视图。Django "
"如何知道 ``{% url %}`` 标签到底对应哪一个应用的 URL 呢？"

msgid ""
"The answer is to add namespaces to your  URLconf. In the ``polls/urls.py`` "
"file, go ahead and add an ``app_name`` to set the application namespace:"
msgstr ""
"答案是：在根 URLconf 中添加命名空间。在 ``polls/urls.py`` 文件中稍作修改，加"
"上 ``app_name`` 设置命名空间："

msgid "Now change your ``polls/index.html`` template from:"
msgstr "现在，编辑 ``polls/index.html`` 文件，从："

msgid "to point at the namespaced detail view:"
msgstr "修改为指向具有命名空间的详细视图："

msgid ""
"When you're comfortable with writing views, read :doc:`part 4 of this "
"tutorial </intro/tutorial04>` to learn about simple form processing and "
"generic views."
msgstr ""
"当你对你写的视图感到满意后，请阅读 :doc:`教程的第 4 部分 </intro/"
"tutorial04>` 了解简单的表单处理和通用视图。"

msgid "Writing your first Django app, part 4"
msgstr "编写你的第一个 Django 应用，第 4 部分"

msgid ""
"This tutorial begins where :doc:`Tutorial 3 </intro/tutorial03>` left off. "
"We're continuing the Web-poll application and will focus on simple form "
"processing and cutting down our code."
msgstr ""
"这一篇从 :doc:`教程第 3 部分 </intro/tutorial03>`  结尾的地方继续讲起。我们将"
"继续编写投票应用，专注于简单的表单处理并且精简我们的代码。"

msgid "Write a simple form"
msgstr "编写一个简单的表单"

msgid ""
"Let's update our poll detail template (\"polls/detail.html\") from the last "
"tutorial, so that the template contains an HTML ``<form>`` element:"
msgstr ""
"让我们更新一下在上一个教程中编写的投票详细页面的模板  (\"polls/detail.html"
"\") ，让它包含一个 HTML ``<form>`` 元素："

msgid "A quick rundown:"
msgstr "简要说明："

msgid ""
"The above template displays a radio button for each question choice. The "
"``value`` of each radio button is the associated question choice's ID. The "
"``name`` of each radio button is ``\"choice\"``. That means, when somebody "
"selects one of the radio buttons and submits the form, it'll send the POST "
"data ``choice=#`` where # is the ID of the selected choice. This is the "
"basic concept of HTML forms."
msgstr ""
"上面的模板在 Question 的每个 Choice 前添加一个单选按钮。 每个单选按钮的 "
"``value`` 属性是对应的各个 Choice 的 ID。每个单选按钮的 ``name`` 是 ``"
"\"choice\"`` 。这意味着，当有人选择一个单选按钮并提交表单提交时，它将发送一"
"个 POST 数据 ``choice=#`` ，其中# 为选择的 Choice 的 ID。这是 HTML 表单的基本"
"概念。"

msgid ""
"We set the form's ``action`` to ``{% url 'polls:vote' question.id %}``, and "
"we set ``method=\"post\"``. Using ``method=\"post\"`` (as opposed to "
"``method=\"get\"``) is very important, because the act of submitting this "
"form will alter data server-side. Whenever you create a form that alters "
"data server-side, use ``method=\"post\"``. This tip isn't specific to "
"Django; it's just good Web development practice."
msgstr ""
"我们设置表单的 ``action`` 为 ``{% url 'polls:vote' question.id %}`` ，并设"
"置  ``method=\"post\"`` 。使用 ``method=\"post\"``（与其相对的是 ``method="
"\"get\"`）是非常重要的，因为这个提交表单的行为会改变服务器端的数据。 无论何"
"时，当你需要创建一个改变服务器端数据的表单时，请使用 ``method=\"post\"`` 。这"
"不是 Django 的特定技巧；这是优秀的网站开发技巧。"

msgid ""
"``forloop.counter`` indicates how many times the :ttag:`for` tag has gone "
"through its loop"
msgstr "``forloop.counter`` 指示 :ttag:`for` 标签已经循环多少次。"

msgid ""
"Since we're creating a POST form (which can have the effect of modifying "
"data), we need to worry about Cross Site Request Forgeries. Thankfully, you "
"don't have to worry too hard, because Django comes with a very easy-to-use "
"system for protecting against it. In short, all POST forms that are targeted "
"at internal URLs should use the :ttag:`{% csrf_token %}<csrf_token>` "
"template tag."
msgstr ""
"由于我们创建一个 POST 表单（它具有修改数据的作用），所以我们需要小心跨站点请"
"求伪造。 谢天谢地，你不必太过担心，因为 Django 已经拥有一个用来防御它的非常容"
"易使用的系统。 简而言之，所有针对内部 URL 的 POST 表单都应该使用  :ttag:`{% "
"csrf_token %}<csrf_token>` 模板标签。"

msgid ""
"Now, let's create a Django view that handles the submitted data and does "
"something with it. Remember, in :doc:`Tutorial 3 </intro/tutorial03>`, we "
"created a URLconf for the polls application that includes this line:"
msgstr ""
"现在，让我们来创建一个 Django 视图来处理提交的数据。记住，在 :doc:`教程第 3 "
"部分 </intro/tutorial03>` 中，我们为投票应用创建了一个 URLconf ，包含这一行："

msgid ""
"We also created a dummy implementation of the ``vote()`` function. Let's "
"create a real version. Add the following to ``polls/views.py``:"
msgstr ""
"我们还创建了一个 ``vote()`` 函数的虚拟实现。让我们来创建一个真实的版本。 将下"
"面的代码添加到 ``polls/views.py`` ："

msgid ""
"This code includes a few things we haven't covered yet in this tutorial:"
msgstr "以上代码中有些内容还未在本教程中提到过："

msgid ""
":attr:`request.POST <django.http.HttpRequest.POST>` is a dictionary-like "
"object that lets you access submitted data by key name. In this case, "
"``request.POST['choice']`` returns the ID of the selected choice, as a "
"string. :attr:`request.POST <django.http.HttpRequest.POST>` values are "
"always strings."
msgstr ""
":attr:`request.POST <django.http.HttpRequest.POST>`  是一个类字典对象，让你可"
"以通过关键字的名字获取提交的数据。 这个例子中， ``request.POST['choice']`` 以"
"字符串形式返回选择的 Choice 的 ID。 :attr:`request.POST <django.http."
"HttpRequest.POST>`  的值永远是字符串。"

msgid ""
"Note that Django also provides :attr:`request.GET <django.http.HttpRequest."
"GET>` for accessing GET data in the same way -- but we're explicitly using :"
"attr:`request.POST <django.http.HttpRequest.POST>` in our code, to ensure "
"that data is only altered via a POST call."
msgstr ""
"注意，Django 还以同样的方式提供 :attr:`request.GET <django.http.HttpRequest."
"GET>`  用于访问 GET 数据 —— 但我们在代码中显式地使用 :attr:`request.POST "
"<django.http.HttpRequest.POST>`  ，以保证数据只能通过 POST 调用改动。"

msgid ""
"``request.POST['choice']`` will raise :exc:`KeyError` if ``choice`` wasn't "
"provided in POST data. The above code checks for :exc:`KeyError` and "
"redisplays the question form with an error message if ``choice`` isn't given."
msgstr ""
"如果在 ``request.POST['choice']``  数据中没有提供 ``choice`` ， POST 将引发一"
"个 :exc:`KeyError` 。上面的代码检查 :exc:`KeyError` ，如果没有给出 "
"``choice`` 将重新显示 Question 表单和一个错误信息。"

msgid ""
"After incrementing the choice count, the code returns an :class:`~django."
"http.HttpResponseRedirect` rather than a normal :class:`~django.http."
"HttpResponse`. :class:`~django.http.HttpResponseRedirect` takes a single "
"argument: the URL to which the user will be redirected (see the following "
"point for how we construct the URL in this case)."
msgstr ""
"在增加 Choice 的得票数之后，代码返回一个 :class:`~django.http."
"HttpResponseRedirect` 而不是常用的 :class:`~django.http.HttpResponse`  、 :"
"class:`~django.http.HttpResponseRedirect`  只接收一个参数：用户将要被重定向"
"的 URL（请继续看下去，我们将会解释如何构造这个例子中的 URL）。"

msgid ""
"As the Python comment above points out, you should always return an :class:"
"`~django.http.HttpResponseRedirect` after successfully dealing with POST "
"data. This tip isn't specific to Django; it's just good Web development "
"practice."
msgstr ""
" 正如上面的 Python 注释指出的，你应该在成功处理 POST 数据后总是返回一个 :"
"class:`~django.http.HttpResponseRedirect` 。 这不是 Django 的特殊要求，这是那"
"些优秀网站在开发实践中形成的共识。"

msgid ""
"We are using the :func:`~django.urls.reverse` function in the :class:"
"`~django.http.HttpResponseRedirect` constructor in this example. This "
"function helps avoid having to hardcode a URL in the view function. It is "
"given the name of the view that we want to pass control to and the variable "
"portion of the URL pattern that points to that view. In this case, using the "
"URLconf we set up in :doc:`Tutorial 3 </intro/tutorial03>`, this :func:"
"`~django.urls.reverse` call will return a string like ::"
msgstr ""
"在这个例子中，我们在 :class:`~django.http.HttpResponseRedirect` 的构造函数中"
"使用 :func:`~django.core.urlresolvers.reverse` 函数。这个函数避免了我们在视图"
"函数中硬编码 URL。它需要我们给出我们想要跳转的视图的名字和该视图所对应的 URL "
"模式中需要给该视图提供的参数。 在本例中，使用在 :doc:`教程第 3 部分 </intro/"
"tutorial03>` 中设定的 URLconf， :func:`~django.core.urlresolvers.reverse` 调"
"用将返回一个这样的字符串："

msgid ""
"where the ``3`` is the value of ``question.id``. This redirected URL will "
"then call the ``'results'`` view to display the final page."
msgstr ""
"其中 ``3`` 是 ``question.id`` 的值。重定向的 URL 将调用 ``'results'`` 视图来"
"显示最终的页面。"

msgid ""
"As mentioned in :doc:`Tutorial 3 </intro/tutorial03>`, ``request`` is an :"
"class:`~django.http.HttpRequest` object. For more on :class:`~django.http."
"HttpRequest` objects, see the :doc:`request and response documentation </ref/"
"request-response>`."
msgstr ""
"正如在 :doc:`教程第 3 部分 </intro/tutorial03>` 中提到的，:class:`~django."
"http.HttpRequest` 是一个 :class:`~django.http.HttpRequest` 对象。更多关于 :"
"class:`~django.http.HttpRequest` 对象的内容，请参见 :doc:`请求和响应的文档 </"
"ref/request-response>` 。"

msgid ""
"After somebody votes in a question, the ``vote()`` view redirects to the "
"results page for the question. Let's write that view:"
msgstr ""
"当有人对 Question 进行投票后，  ``vote()`` 视图将请求重定向到 Question 的结果"
"界面。让我们来编写这个视图："

msgid ""
"This is almost exactly the same as the ``detail()`` view from :doc:`Tutorial "
"3 </intro/tutorial03>`. The only difference is the template name. We'll fix "
"this redundancy later."
msgstr ""
"这和 :doc:`教程第 3 部分 </intro/tutorial03>` 中的  ``detail()`` 视图几乎一模"
"一样。唯一的不同是模板的名字。 我们将在稍后解决这个冗余问题。"

msgid "Now, create a ``polls/results.html`` template:"
msgstr "现在，创建一个 ``polls/results.html``  模板："

msgid ""
"Now, go to ``/polls/1/`` in your browser and vote in the question. You "
"should see a results page that gets updated each time you vote. If you "
"submit the form without having chosen a choice, you should see the error "
"message."
msgstr ""
"现在，在你的浏览器中访问 ``/polls/1/`` 然后为 Question 投票。你应该看到一个投"
"票结果页面，并且在你每次投票之后都会更新。 如果你提交时没有选择任何 Choice，"
"你应该看到错误信息。"

msgid ""
"The code for our ``vote()`` view does have a small problem. It first gets "
"the ``selected_choice`` object from the database, then computes the new "
"value of ``votes``, and then saves it back to the database. If two users of "
"your website try to vote at *exactly the same time*, this might go wrong: "
"The same value, let's say 42, will be retrieved for ``votes``. Then, for "
"both users the new value of 43 is computed and saved, but 44 would be the "
"expected value."
msgstr ""
"我们的 ``vote()`` 视图代码有一个小问题。代码首先从数据库中获取了 "
"``selected_choice`` 对象，接着计算 ``vote`` 的新值，最后把值存回数据库。如果"
"网站有两个方可同时投票在 *同一时间* ，可能会导致问题。同样的值，42，会被 "
"``votes`` 返回。然后，对于两个用户，新值43计算完毕，并被保存，但是期望值是"
"44。"

msgid ""
"This is called a *race condition*. If you are interested, you can read :ref:"
"`avoiding-race-conditions-using-f` to learn how you can solve this issue."
msgstr ""
"这个问题被称为 *竞争条件* 。如果你对此有兴趣，你可以阅读 :ref:`avoiding-race-"
"conditions-using-f` 来学习如何解决这个问题。"

msgid "Use generic views: Less code is better"
msgstr "使用通用视图：代码还是少点好"

msgid ""
"The ``detail()`` (from :doc:`Tutorial 3 </intro/tutorial03>`) and "
"``results()`` views are very simple -- and, as mentioned above, redundant. "
"The ``index()`` view, which displays a list of polls, is similar."
msgstr ""
"``detail()`` （在 :doc:`教程第3部分 </intro/tutorial03>` 中）和 "
"``results()`` 视图都很简单 —— 并且，像上面提到的那样，存在冗余问题。用来显示"
"一个投票列表的 ``index()`` 视图（也在 :doc:`教程第 3 部分 </intro/"
"tutorial03>` 中）和它们类似。"

msgid ""
"These views represent a common case of basic Web development: getting data "
"from the database according to a parameter passed in the URL, loading a "
"template and returning the rendered template. Because this is so common, "
"Django provides a shortcut, called the \"generic views\" system."
msgstr ""
"这些视图反映基本的 Web 开发中的一个常见情况：根据 URL 中的参数从数据库中获取"
"数据、载入模板文件然后返回渲染后的模板。 由于这种情况特别常见，Django 提供一"
"种快捷方式，叫做“通用视图”系统。"

msgid ""
"Generic views abstract common patterns to the point where you don't even "
"need to write Python code to write an app."
msgstr ""
"通用视图将常见的模式抽象化，可以使你在编写应用时甚至不需要编写Python代码。"

msgid ""
"Let's convert our poll app to use the generic views system, so we can delete "
"a bunch of our own code. We'll just have to take a few steps to make the "
"conversion. We will:"
msgstr ""
"让我们将我们的投票应用转换成使用通用视图系统，这样我们可以删除许多我们的代"
"码。我们仅仅需要做以下几步来完成转换，我们将："

msgid "Convert the URLconf."
msgstr "转换 URLconf。"

msgid "Delete some of the old, unneeded views."
msgstr "删除一些旧的、不再需要的视图。"

msgid "Introduce new views based on Django's generic views."
msgstr "基于 Django 的通用视图引入新的视图。"

msgid "Read on for details."
msgstr "请继续阅读来了解详细信息。"

msgid "Why the code-shuffle?"
msgstr "为什么要重构代码？"

msgid ""
"Generally, when writing a Django app, you'll evaluate whether generic views "
"are a good fit for your problem, and you'll use them from the beginning, "
"rather than refactoring your code halfway through. But this tutorial "
"intentionally has focused on writing the views \"the hard way\" until now, "
"to focus on core concepts."
msgstr ""
"一般来说，当编写一个 Django 应用时，你应该先评估一下通用视图是否可以解决你的"
"问题，你应该在一开始使用它，而不是进行到一半时重构代码。本教程目前为止是有意"
"将重点放在以“艰难的方式”编写视图，这是为将重点放在核心概念上。"

msgid "You should know basic math before you start using a calculator."
msgstr "就像在使用计算器之前你需要掌握基础数学一样。"

msgid "Amend URLconf"
msgstr "改良 URLconf"

msgid "First, open the ``polls/urls.py`` URLconf and change it like so:"
msgstr "首先，打开 ``polls/urls.py`` 这个 URLconf 并将它修改成："

msgid ""
"Note that the name of the matched pattern in the path strings of the second "
"and third patterns has changed from ``<question_id>`` to ``<pk>``."
msgstr ""
"注意，第二个和第三个匹配准则中，路径字符串中匹配模式的名称已经由 "
"``<question_id>`` 改为 ``<pk>``。"

msgid "Amend views"
msgstr "改良视图"

msgid ""
"Next, we're going to remove our old ``index``, ``detail``, and ``results`` "
"views and use Django's generic views instead. To do so, open the ``polls/"
"views.py`` file and change it like so:"
msgstr ""
"下一步，我们将删除旧的 ``index``, ``detail``, 和 ``results`` 视图，并用 "
"Django 的通用视图代替。打开 ``polls/views.py`` 文件，并将它修改成："

msgid ""
"We're using two generic views here: :class:`~django.views.generic.list."
"ListView` and :class:`~django.views.generic.detail.DetailView`. "
"Respectively, those two views abstract the concepts of \"display a list of "
"objects\" and \"display a detail page for a particular type of object.\""
msgstr ""
"我们在这里使用两个通用视图： :class:`~django.views.generic.list.ListView` "
"和 :class:`~django.views.generic.detail.DetailView` 。这两个视图分别抽象“显示"
"一个对象列表”和“显示一个特定类型对象的详细信息页面”这两种概念。"

msgid ""
"Each generic view needs to know what model it will be acting upon. This is "
"provided using the ``model`` attribute."
msgstr "每个通用视图需要知道它将作用于哪个模型。 这由 ``model`` 属性提供。"

msgid ""
"The :class:`~django.views.generic.detail.DetailView` generic view expects "
"the primary key value captured from the URL to be called ``\"pk\"``, so "
"we've changed ``question_id`` to ``pk`` for the generic views."
msgstr ""
":class:`~django.views.generic.detail.DetailView`  期望从 URL 中捕获名为   ``"
"\"pk\"`` 的主键值，所以我们为通用视图把 ``question_id`` 改成 ``pk`` 。"

msgid ""
"By default, the :class:`~django.views.generic.detail.DetailView` generic "
"view uses a template called ``<app name>/<model name>_detail.html``. In our "
"case, it would use the template ``\"polls/question_detail.html\"``. The "
"``template_name`` attribute is used to tell Django to use a specific "
"template name instead of the autogenerated default template name. We also "
"specify the ``template_name`` for the ``results`` list view -- this ensures "
"that the results view and the detail view have a different appearance when "
"rendered, even though they're both a :class:`~django.views.generic.detail."
"DetailView` behind the scenes."
msgstr ""
"默认情况下，通用视图 :class:`~django.views.generic.detail.DetailView` 使用一"
"个叫做 ``<app name>/<model name>_detail.html`` 的模板。在我们的例子中，它将使"
"用 ``\"polls/question_detail.html\"`` 模板。``template_name`` 属性是用来告诉 "
"Django 使用一个指定的模板名字，而不是自动生成的默认名字。 我们也为 "
"``results`` 列表视图指定了 ``template_name``  —— 这确保 results 视图和 "
"detail 视图在渲染时具有不同的外观，即使它们在后台都是同一个 :class:`~django."
"views.generic.detail.DetailView` 。"

msgid ""
"Similarly, the :class:`~django.views.generic.list.ListView` generic view "
"uses a default template called ``<app name>/<model name>_list.html``; we use "
"``template_name`` to tell :class:`~django.views.generic.list.ListView` to "
"use our existing ``\"polls/index.html\"`` template."
msgstr ""
"类似地，:class:`~django.views.generic.list.ListView` 使用一个叫做  ``<app "
"name>/<model name>_list.html`` 的默认模板；我们使用 ``template_name`` 来告"
"诉 :class:`~django.views.generic.list.ListView` 使用我们创建的已经存在的 ``"
"\"polls/index.html\"`` 模板。"

msgid ""
"In previous parts of the tutorial, the templates have been provided with a "
"context that contains the ``question`` and ``latest_question_list`` context "
"variables. For ``DetailView`` the ``question`` variable is provided "
"automatically -- since we're using a Django model (``Question``), Django is "
"able to determine an appropriate name for the context variable. However, for "
"ListView, the automatically generated context variable is ``question_list``. "
"To override this we provide the ``context_object_name`` attribute, "
"specifying that we want to use ``latest_question_list`` instead. As an "
"alternative approach, you could change your templates to match the new "
"default context variables -- but it's a lot easier to just tell Django to "
"use the variable you want."
msgstr ""
"在之前的教程中，提供模板文件时都带有一个包含 ``question`` 和 "
"``latest_question_list`` 变量的 context。对于 ``DetailView`` ， "
"``question``  变量会自动提供—— 因为我们使用 Django 的模型 (Question)， "
"Django 能够为 context 变量决定一个合适的名字。然而对于 ListView， 自动生成的 "
"context 变量是 ``question_list``。为了覆盖这个行为，我们提供 "
"``context_object_name`` 属性，表示我们想使用 ``latest_question_list``。作为一"
"种替换方案，你可以改变你的模板来匹配新的 context 变量 —— 这是一种更便捷的方"
"法，告诉 Django 使用你想使用的变量名。"

msgid "Run the server, and use your new polling app based on generic views."
msgstr "启动服务器，使用一下基于通用视图的新投票应用。"

msgid ""
"For full details on generic views, see the :doc:`generic views documentation "
"</topics/class-based-views/index>`."
msgstr ""
"更多关于通用视图的详细信息，请查看 :doc:`通用视图的文档 </topics/class-based-"
"views/index>`"

msgid ""
"When you're comfortable with forms and generic views, read :doc:`part 5 of "
"this tutorial</intro/tutorial05>` to learn about testing our polls app."
msgstr ""
"当你对你所写的表单和通用视图感到满意后，请阅读 :doc:`教程的第 5 部分 </intro/"
"tutorial05>` 来了解如何测试我们的投票应用。"

msgid "Writing your first Django app, part 5"
msgstr "编写你的第一个 Django 应用，第 5 部分"

msgid ""
"This tutorial begins where :doc:`Tutorial 4 </intro/tutorial04>` left off. "
"We've built a Web-poll application, and we'll now create some automated "
"tests for it."
msgstr ""
"这一篇从 :doc:`教程第 4 部分 </intro/tutorial04>` 结尾的地方继续讲起。我们在"
"前几章成功的构建了一个在线投票应用，在这一部分里我们将为它创建一些自动化测"
"试。"

msgid "Introducing automated testing"
msgstr "自动化测试简介"

msgid "What are automated tests?"
msgstr "自动化测试是什么？"

msgid "Tests are simple routines that check the operation of your code."
msgstr "测试，是用来检查代码正确性的一些简单的程序。"

msgid ""
"Testing operates at different levels. Some tests might apply to a tiny "
"detail (*does a particular model method return values as expected?*) while "
"others examine the overall operation of the software (*does a sequence of "
"user inputs on the site produce the desired result?*). That's no different "
"from the kind of testing you did earlier in :doc:`Tutorial 2 </intro/"
"tutorial02>`, using the :djadmin:`shell` to examine the behavior of a "
"method, or running the application and entering data to check how it behaves."
msgstr ""
"测试在不同的层次中都存在。有些测试只关注某个很小的细节（某个模型的某个方法的"
"返回值是否满足预期？），而另一些测试可能检查对某个软件的一系列操作（*某一用户"
"输入序列是否造成了预期的结果？*）。其实这和我们在 :doc:`教程第 2 部分 </"
"intro/tutorial02>`，里做的并没有什么不同，我们使用 :djadmin:`shell` 来测试某"
"一方法的功能，或者运行某个应用并输入数据来检查它的行为。"

msgid ""
"What's different in *automated* tests is that the testing work is done for "
"you by the system. You create a set of tests once, and then as you make "
"changes to your app, you can check that your code still works as you "
"originally intended, without having to perform time consuming manual testing."
msgstr ""
"真正不同的地方在于，*自动化* 测试是由某个系统帮你自动完成的。当你创建好了一系"
"列测试，每次修改应用代码后，就可以自动检查出修改后的代码是否还像你曾经预期的"
"那样正常工作。你不需要花费大量时间来进行手动测试。"

msgid "Why you need to create tests"
msgstr "为什么你需要写测试"

msgid "So why create tests, and why now?"
msgstr "但是，为什么需要测试呢？又为什么是现在呢？"

msgid ""
"You may feel that you have quite enough on your plate just learning Python/"
"Django, and having yet another thing to learn and do may seem overwhelming "
"and perhaps unnecessary. After all, our polls application is working quite "
"happily now; going through the trouble of creating automated tests is not "
"going to make it work any better. If creating the polls application is the "
"last bit of Django programming you will ever do, then true, you don't need "
"to know how to create automated tests. But, if that's not the case, now is "
"an excellent time to learn."
msgstr ""
"你可能觉得学 Python/Django 对你来说已经很满足了，再学一些新东西的话看起来有点"
"负担过重并且没什么必要。毕竟，我们的投票应用看起来已经完美工作了。写一些自动"
"测试并不能让它工作的更好。如果写一个投票应用是你想用 Django 完成的唯一工作，"
"那你确实没必要学写测试。但是如果你还想写更复杂的项目，现在就是学习测试写法的"
"最好时机了。"

msgid "Tests will save you time"
msgstr "测试将节约你的时间"

msgid ""
"Up to a certain point, 'checking that it seems to work' will be a "
"satisfactory test. In a more sophisticated application, you might have "
"dozens of complex interactions between components."
msgstr ""
"在某种程度上，能够「判断出代码是否正常工作」的测试，就称得上是个令人满意的"
"了。在更复杂的应用程序中，组件之间可能会有数十个复杂的交互。"

msgid ""
"A change in any of those components could have unexpected consequences on "
"the application's behavior. Checking that it still 'seems to work' could "
"mean running through your code's functionality with twenty different "
"variations of your test data just to make sure you haven't broken something "
"- not a good use of your time."
msgstr ""
"在更加复杂的应用中，各种组件之间的交互可能会及其的复杂。改变其中某一组件的行"
"为，也有可能会造成意想不到的结果。判断「代码是否正常工作」意味着你需要用大量"
"的数据来完整的测试全部代码的功能，以确保你的小修改没有对应用整体造成破坏——这"
"太费时间了。"

msgid ""
"That's especially true when automated tests could do this for you in "
"seconds. If something's gone wrong, tests will also assist in identifying "
"the code that's causing the unexpected behavior."
msgstr ""
"尤其是当你发现自动化测试能在几秒钟之内帮你完成这件事时，就更会觉得手动测试实"
"在是太浪费时间了。当某人写出错误的代码时，自动化测试还能帮助你定位错误代码的"
"位置。"

msgid ""
"Sometimes it may seem a chore to tear yourself away from your productive, "
"creative programming work to face the unglamorous and unexciting business of "
"writing tests, particularly when you know your code is working properly."
msgstr ""
"有时候你会觉得，和富有创造性和生产力的业务代码比起来，编写枯燥的测试代码实在"
"是太无聊了，特别是当你知道你的代码完全没有问题的时候。"

msgid ""
"However, the task of writing tests is a lot more fulfilling than spending "
"hours testing your application manually or trying to identify the cause of a "
"newly-introduced problem."
msgstr ""
"然而，编写测试还是要比花费几个小时手动测试你的应用，或者为了找到某个小错误而"
"胡乱翻看代码要有意义的多。"

msgid "Tests don't just identify problems, they prevent them"
msgstr "测试不仅能发现错误，而且能预防错误"

msgid ""
"It's a mistake to think of tests merely as a negative aspect of development."
msgstr "「测试是开发的对立面」，这种思想是不对的。"

msgid ""
"Without tests, the purpose or intended behavior of an application might be "
"rather opaque. Even when it's your own code, you will sometimes find "
"yourself poking around in it trying to find out what exactly it's doing."
msgstr ""
"如果没有测试，整个应用的行为意图会变得更加的不清晰。甚至当你在看自己写的代码"
"时也是这样，有时候你需要仔细研读一段代码才能搞清楚它有什么用。"

msgid ""
"Tests change that; they light up your code from the inside, and when "
"something goes wrong, they focus light on the part that has gone wrong - "
"*even if you hadn't even realized it had gone wrong*."
msgstr ""
"而测试的出现改变了这种情况。测试就好像是从内部仔细检查你的代码，当有些地方出"
"错时，这些地方将会变得很显眼——*就算你自己没有意识到那里写错了*。"

msgid "Tests make your code more attractive"
msgstr "测试使你的代码更有吸引力"

msgid ""
"You might have created a brilliant piece of software, but you will find that "
"many other developers will simply refuse to look at it because it lacks "
"tests; without tests, they won't trust it. Jacob Kaplan-Moss, one of "
"Django's original developers, says \"Code without tests is broken by design."
"\""
msgstr ""
"你也许遇到过这种情况：你编写了一个绝赞的软件，但是其他开发者看都不看它一眼，"
"因为它缺少测试。没有测试的代码不值得信任。 Django 最初开发者之一的 Jacob "
"Kaplan-Moss 说过：“项目规划时没有包含测试是不科学的。”"

msgid ""
"That other developers want to see tests in your software before they take it "
"seriously is yet another reason for you to start writing tests."
msgstr ""
"其他的开发者希望在正式使用你的代码前看到它通过了测试，这是你需要写测试的另一"
"个重要原因。"

msgid "Tests help teams work together"
msgstr "测试有利于团队协作"

msgid ""
"The previous points are written from the point of view of a single developer "
"maintaining an application. Complex applications will be maintained by "
"teams. Tests guarantee that colleagues don't inadvertently break your code "
"(and that you don't break theirs without knowing). If you want to make a "
"living as a Django programmer, you must be good at writing tests!"
msgstr ""
"前面的几点都是从单人开发的角度来说的。复杂的应用可能由团队维护。测试的存在保"
"证了协作者不会不小心破坏了了你的代码（也保证你不会不小心弄坏他们的）。如果你"
"想作为一个 Django 程序员谋生的话，你必须擅长编写测试！"

msgid "Basic testing strategies"
msgstr "基础测试策略"

msgid "There are many ways to approach writing tests."
msgstr "有好几种不同的方法可以写测试。"

msgid ""
"Some programmers follow a discipline called \"`test-driven development`_\"; "
"they actually write their tests before they write their code. This might "
"seem counter-intuitive, but in fact it's similar to what most people will "
"often do anyway: they describe a problem, then create some code to solve it. "
"Test-driven development simply formalizes the problem in a Python test case."
msgstr ""
"一些开发者遵循 \"`测试驱动`_\" 的开发原则，他们在写代码之前先写测试。这种方法"
"看起来有点反直觉，但事实上，这和大多数人日常的做法是相吻合的。我们会先描述一"
"个问题，然后写代码来解决它。「测试驱动」的开发方法只是将问题的描述抽象为了 "
"Python 的测试样例。"

msgid ""
"More often, a newcomer to testing will create some code and later decide "
"that it should have some tests. Perhaps it would have been better to write "
"some tests earlier, but it's never too late to get started."
msgstr ""
"更普遍的情况是，一个刚接触自动化测试的新手更倾向于先写代码，然后再写测试。虽"
"然提前写测试可能更好，但是晚点写起码也比没有强。"

msgid ""
"Sometimes it's difficult to figure out where to get started with writing "
"tests. If you have written several thousand lines of Python, choosing "
"something to test might not be easy. In such a case, it's fruitful to write "
"your first test the next time you make a change, either when you add a new "
"feature or fix a bug."
msgstr ""
"有时候很难决定从哪里开始下手写测试。如果你才写了几千行 Python 代码，选择从哪"
"里开始写测试确实不怎么简单。如果是这种情况，那么在你下次修改代码（比如加新功"
"能，或者修复 Bug）之前写个测试是比较合理且有效的。"

msgid "So let's do that right away."
msgstr "所以，我们现在就开始写吧。"

msgid "Writing our first test"
msgstr "开始写我们的第一个测试"

msgid "We identify a bug"
msgstr "首先得有个 Bug"

msgid ""
"Fortunately, there's a little bug in the ``polls`` application for us to fix "
"right away: the ``Question.was_published_recently()`` method returns "
"``True`` if the ``Question`` was published within the last day (which is "
"correct) but also if the ``Question``’s ``pub_date`` field is in the future "
"(which certainly isn't)."
msgstr ""
"幸运的是，我们的 ``polls`` 应用现在就有一个小 bug 需要被修复：我们的要求是如"
"果 Question 是在一天之内发布的， ``Question.was_published_recently()`` 方法将"
"会返回 ``True`` ，然而现在这个方法在 ``Question`` 的 ``pub_date`` 字段比当前"
"时间还晚时也会返回 True（这是个 Bug）。 "

msgid ""
"To check if the bug really exists, using the Admin create a question whose "
"date lies in the future and check the method using the :djadmin:`shell`::"
msgstr ""
"你能从管理页面确认这个 bug 真实存在。在 :djadmin:`shell` 创建一个发布日期是未"
"来某天的投票，在投票列表里你会看到它被标明为最近发布（published recently）::"

msgid "Since things in the future are not 'recent', this is clearly wrong."
msgstr "因为将来发生的是肯定不是最近发生的，所以代码明显是错误的。"

msgid "Create a test to expose the bug"
msgstr "创建一个测试来暴露这个 bug"

msgid ""
"What we've just done in the :djadmin:`shell` to test for the problem is "
"exactly what we can do in an automated test, so let's turn that into an "
"automated test."
msgstr ""
"我们刚刚在 :djadmin:`shell` 里做的测试也就是自动化测试应该做的工作。所以我们"
"来把它改写成自动化的吧。"

msgid ""
"A conventional place for an application's tests is in the application's "
"``tests.py`` file; the testing system will automatically find tests in any "
"file whose name begins with ``test``."
msgstr ""
"按照惯例，Django 应用的测试应该写在应用的 ``tests.py`` 文件里。测试系统会自动"
"的在所有以 ``tests`` 开头的文件里寻找并执行测试代码。"

msgid ""
"Put the following in the ``tests.py`` file in the ``polls`` application:"
msgstr "将下面的代码写入 ``polls`` 应用里的 ``tests.py`` 文件内："

msgid ""
"What we have done here is created a :class:`django.test.TestCase` subclass "
"with a method that creates a ``Question`` instance with a ``pub_date`` in "
"the future. We then check the output of ``was_published_recently()`` - which "
"*ought* to be False."
msgstr ""
"我们创建了一个 :class:`django.test.TestCase` 的子类，并添加了一个方法，此方法"
"创建一个 ``pub_date`` 时未来某天的 ``Question`` 实例。然后检查它的 "
"``was_published_recently()`` 方法的返回值——它 *应该* 是 False。"

msgid "Running tests"
msgstr "运行测试"

msgid "In the terminal, we can run our test::"
msgstr "在终端中，我们通过输入以下代码运行测试::"

msgid "and you'll see something like::"
msgstr "你将会看到运行结果::"

msgid "What happened is this:"
msgstr "发生了什么呢？以下是自动化测试的运行过程："

msgid ""
"``python manage.py test polls`` looked for tests in the ``polls`` application"
msgstr "``python manage.py test polls``  将会寻找  ``polls`` 应用里的测试代码"

msgid "it found a subclass of the :class:`django.test.TestCase` class"
msgstr "它找到了 :class:`django.test.TestCase` 的一个子类"

msgid "it created a special database for the purpose of testing"
msgstr "它创建一个特殊的数据库供测试使用"

msgid "it looked for test methods - ones whose names begin with ``test``"
msgstr "它在类中寻找测试方法——以 ``test`` 开头的方法。"

msgid ""
"in ``test_was_published_recently_with_future_question`` it created a "
"``Question`` instance whose ``pub_date`` field is 30 days in the future"
msgstr ""
"在  ``test_was_published_recently_with_future_question`` 方法中，它创建了一"
"个 ``pub_date`` 值为 30 天后的 ``Question`` 实例。"

msgid ""
"... and using the ``assertIs()`` method, it discovered that its "
"``was_published_recently()`` returns ``True``, though we wanted it to return "
"``False``"
msgstr ""
"接着使用 ``assertls()`` 方法，发现 ``was_published_recently()`` 返回了 "
"``True``，而我们期望它返回 ``False``。"

msgid ""
"The test informs us which test failed and even the line on which the failure "
"occurred."
msgstr "测试系统通知我们哪些测试样例失败了，和造成测试失败的代码所在的行号。"

msgid "Fixing the bug"
msgstr "修复这个 bug"

msgid ""
"We already know what the problem is: ``Question.was_published_recently()`` "
"should return ``False`` if its ``pub_date`` is in the future. Amend the "
"method in ``models.py``, so that it will only return ``True`` if the date is "
"also in the past:"
msgstr ""
"我们早已知道，当 ``pub_date`` 为未来某天时， ``Question."
"was_published_recently()`` 应该返回 ``False``。我们修改 ``models.py`` 里的方"
"法，让它只在日期是过去式的时候才返回 ``True``："

msgid "and run the test again::"
msgstr "然后重新运行测试::"

msgid ""
"After identifying a bug, we wrote a test that exposes it and corrected the "
"bug in the code so our test passes."
msgstr ""
"发现 bug 后，我们编写了能够暴露这个 bug 的自动化测试。在修复 bug 之后，我们的"
"代码顺利的通过了测试。"

msgid ""
"Many other things might go wrong with our application in the future, but we "
"can be sure that we won't inadvertently reintroduce this bug, because simply "
"running the test will warn us immediately. We can consider this little "
"portion of the application pinned down safely forever."
msgstr ""
"将来，我们的应用可能会出现其他的问题，但是我们可以肯定的是，一定不会再次出现"
"这个 bug，因为只要简单的运行一遍测试，就会立刻收到警告。我们可以认为应用的这"
"一小部分代码永远是安全的。"

msgid "More comprehensive tests"
msgstr "更全面的测试"

msgid ""
"While we're here, we can further pin down the ``was_published_recently()`` "
"method; in fact, it would be positively embarrassing if in fixing one bug we "
"had introduced another."
msgstr ""
"我们已经搞定一小部分了，现在可以考虑全面的测试 ``was_published_recently()`` "
"这个方法以确定它的安全性，然后就可以把这个方法稳定下来了。事实上，在修复一个 "
"bug 时不小心引入另一个 bug 会是非常令人尴尬的。"

msgid ""
"Add two more test methods to the same class, to test the behavior of the "
"method more comprehensively:"
msgstr "我们在上次写的类里再增加两个测试，来更全面的测试这个方法："

msgid ""
"And now we have three tests that confirm that ``Question."
"was_published_recently()`` returns sensible values for past, recent, and "
"future questions."
msgstr ""
"现在，我们有三个测试来确保 ``Question.was_published_recently()`` 方法对于过"
"去，最近，和将来的三种情况都返回正确的值。"

msgid ""
"Again, ``polls`` is a simple application, but however complex it grows in "
"the future and whatever other code it interacts with, we now have some "
"guarantee that the method we have written tests for will behave in expected "
"ways."
msgstr ""
"再次申明，尽管  ``polls``  现在是个非常简单的应用，但是无论它以后成长到多么复"
"杂，要和其他代码进行怎样的交互，我们都能保证进行过测试的那些方法的行为永远是"
"符合预期的。"

msgid "Test a view"
msgstr "测试视图"

msgid ""
"The polls application is fairly undiscriminating: it will publish any "
"question, including ones whose ``pub_date`` field lies in the future. We "
"should improve this. Setting a ``pub_date`` in the future should mean that "
"the Question is published at that moment, but invisible until then."
msgstr ""
"我们的投票应用对所有问题都一视同仁：它将会发布所有的问题，也包括那些 "
"``pub_date`` 字段值是未来的问题。我们应该改善这一点。如果 ``pub_date`` 设置为"
"未来某天，这应该被解释为这个问题将在所填写的时间点才被发布，而在之前是不可见"
"的。"

msgid "A test for a view"
msgstr "针对视图的测试"

msgid ""
"When we fixed the bug above, we wrote the test first and then the code to "
"fix it. In fact that was a simple example of test-driven development, but it "
"doesn't really matter in which order we do the work."
msgstr ""
"为了修复上述 bug ，我们这次先编写测试，然后再去改代码。事实上，这是一个简单的"
"「测试驱动」开发模式的实例，但其实这两者的顺序不太重要。"

msgid ""
"In our first test, we focused closely on the internal behavior of the code. "
"For this test, we want to check its behavior as it would be experienced by a "
"user through a web browser."
msgstr ""
"在我们的第一个测试中，我们关注代码的内部行为。我们通过模拟用户使用浏览器访问"
"被测试的应用来检查代码行为是否符合预期。"

msgid ""
"Before we try to fix anything, let's have a look at the tools at our "
"disposal."
msgstr "在我们动手之前，先看看需要用到的工具们。"

msgid "The Django test client"
msgstr "Django 测试工具之 Client"

msgid ""
"Django provides a test :class:`~django.test.Client` to simulate a user "
"interacting with the code at the view level.  We can use it in ``tests.py`` "
"or even in the :djadmin:`shell`."
msgstr ""
"Django 提供了一个供测试使用的 :class:`~django.test.Client` 来模拟用户和视图层"
"代码的交互。我们能在 ``tests.py`` 甚至是  :djadmin:`shell` 中使用它。"

msgid ""
"We will start again with the :djadmin:`shell`, where we need to do a couple "
"of things that won't be necessary in ``tests.py``. The first is to set up "
"the test environment in the :djadmin:`shell`::"
msgstr ""
"我们依照惯例从  :djadmin:`shell` 开始，首先我们要做一些在 ``tests.py`` 里不是"
"必须的准备工作。第一步是在  :djadmin:`shell` 中配置测试环境::"

msgid ""
":meth:`~django.test.utils.setup_test_environment` installs a template "
"renderer which will allow us to examine some additional attributes on "
"responses such as ``response.context`` that otherwise wouldn't be available. "
"Note that this method *does not* setup a test database, so the following "
"will be run against the existing database and the output may differ slightly "
"depending on what questions you already created. You might get unexpected "
"results if your ``TIME_ZONE`` in ``settings.py`` isn't correct. If you don't "
"remember setting it earlier, check it before continuing."
msgstr ""
":meth:`~django.test.utils.setup_test_environment` 提供了一个模板渲染器，允许"
"我们为 responses 添加一些额外的属性，例如 ``response.context``，未安装此 app "
"无法使用此功能。注意，这个方法并 *不会* 配置测试数据库，所以接下来的代码将会"
"在当前存在的数据库上运行，输出的内容可能由于数据库内容的不同而不同。如果你的 "
"``settings.py`` 中关于 ``TIME_ZONE`` 的设置不对，你可能无法获取到期望的结果。"
"如果你之前忘了设置，在继续之前检查一下。"

msgid ""
"Next we need to import the test client class (later in ``tests.py`` we will "
"use the :class:`django.test.TestCase` class, which comes with its own "
"client, so this won't be required)::"
msgstr ""
"然后我们需要导入 :class:`django.test.TestCase` 类（在后续 ``tests.py`` 的实例"
"中我们将会使用 :class:`django.test.TestCase` 类，这个类里包含了自己的 client "
"实例，所以不需要这一步）::"

msgid "With that ready, we can ask the client to do some work for us::"
msgstr "搞定了之后，我们可以要求 client 为我们工作了::"

msgid "Improving our view"
msgstr "改善视图代码"

msgid ""
"The list of polls shows polls that aren't published yet (i.e. those that "
"have a ``pub_date`` in the future). Let's fix that."
msgstr ""
"现在的投票列表会显示将来的投票（ ``pub_date`` 值是未来的某天)。我们来修复这个"
"问题。"

msgid ""
"In :doc:`Tutorial 4 </intro/tutorial04>` we introduced a class-based view, "
"based on :class:`~django.views.generic.list.ListView`:"
msgstr ""
"在 :doc:`教程的第 4 部分 </intro/tutorial04>`  里，我们介绍了基于 :class:"
"`~django.views.generic.list.ListView` 的视图类："

msgid ""
"We need to amend the ``get_queryset()`` method and change it so that it also "
"checks the date by comparing it with ``timezone.now()``. First we need to "
"add an import:"
msgstr ""
"我们需要改进  ``get_queryset()`` 方法，让他它能通过将 Question 的 pub_data 属"
"性与 ``timezone.now()`` 相比较来判断是否应该显示此 Question。首先我们需要一"
"行 import 语句："

msgid "and then we must amend the ``get_queryset`` method like so:"
msgstr "然后我们把  ``get_queryset``  方法改写成下面这样："

msgid ""
"``Question.objects.filter(pub_date__lte=timezone.now())`` returns a queryset "
"containing ``Question``\\s whose ``pub_date`` is less than or equal to - "
"that is, earlier than or equal to - ``timezone.now``."
msgstr ""
" ``Question.objects.filter(pub_date__lte=timezone.now())`` 返回一个由 "
"pub_date 小于或等于（也就是早于或等于） `timezone.now``  的 ``Question`` 组成"
"的集合。 "

msgid "Testing our new view"
msgstr "测试新视图"

msgid ""
"Now you can satisfy yourself that this behaves as expected by firing up the "
"runserver, loading the site in your browser, creating ``Questions`` with "
"dates in the past and future, and checking that only those that have been "
"published are listed.  You don't want to have to do that *every single time "
"you make any change that might affect this* - so let's also create a test, "
"based on our :djadmin:`shell` session above."
msgstr ""
"启动服务器、在浏览器中载入站点、创建一些发布时间在过去和将来的  "
"``Questions`` ，然后检验只有已经发布的  ``Questions``  会展示出来，现在你可以"
"对自己感到满意了。*你不想每次修改可能与这相关的代码时都重复这样做* —— 所以让"
"我们基于以上 :djadmin:`shell`  会话中的内容，再编写一个测试。"

msgid "Add the following to ``polls/tests.py``:"
msgstr "将下面的代码添加到 ``polls/tests.py`` ："

msgid ""
"and we'll create a shortcut function to create questions as well as a new "
"test class:"
msgstr "然后我们写一个公用的快捷函数用于创建投票问题，再为视图创建一个测试类："

msgid "Let's look at some of these more closely."
msgstr "让我们更详细地看下以上这些内容。"

msgid ""
"First is a question shortcut function, ``create_question``, to take some "
"repetition out of the process of creating questions."
msgstr ""
"首先是一个快捷函数 ``create_question``，它封装了创建投票的流程，减少了重复代"
"码。"

msgid ""
"``test_no_questions`` doesn't create any questions, but checks the message: "
"\"No polls are available.\" and verifies the ``latest_question_list`` is "
"empty. Note that the :class:`django.test.TestCase` class provides some "
"additional assertion methods. In these examples, we use :meth:`~django.test."
"SimpleTestCase.assertContains()` and :meth:`~django.test.TransactionTestCase."
"assertQuerysetEqual()`."
msgstr ""
"``test_no_questions`` 方法里没有创建任何投票，它检查返回的网页上有没有 \"No "
"polls are available.\" 这段消息和 ``latest_question_list`` 是否为空。注意到 :"
"class:`django.test.TestCase` 类提供了一些额外的 assertion 方法，在这个例子"
"中，我们使用了 :meth:`~django.test.SimpleTestCase.assertContains()` 和 :meth:"
"`~django.test.TransactionTestCase.assertQuerysetEqual()` 。"

msgid ""
"In ``test_past_question``, we create a question and verify that it appears "
"in the list."
msgstr ""
"在 ``test_past_question`` 方法中，我们创建了一个投票并检查它是否出现在列表"
"中。"

msgid ""
"In ``test_future_question``, we create a question with a ``pub_date`` in the "
"future. The database is reset for each test method, so the first question is "
"no longer there, and so again the index shouldn't have any questions in it."
msgstr ""
"在 ``test_future_question`` 中，我们创建 ``pub_date`` 在未来某天的投票。数据"
"库会在每次调用测试方法前被重置，所以第一个投票已经没了，所以主页中应该没有任"
"何投票。"

msgid ""
"And so on. In effect, we are using the tests to tell a story of admin input "
"and user experience on the site, and checking that at every state and for "
"every new change in the state of the system, the expected results are "
"published."
msgstr ""
"剩下的那些也都差不多。实际上，测试就是假装一些管理员的输入，然后通过用户端的"
"表现是否符合预期来判断新加入的改变是否破坏了原有的系统状态。"

msgid "Testing the ``DetailView``"
msgstr "测试 ``DetailView``"

msgid ""
"What we have works well; however, even though future questions don't appear "
"in the *index*, users can still reach them if they know or guess the right "
"URL. So we need to add a similar  constraint to ``DetailView``:"
msgstr ""
"我们的工作似乎已经很完美了？不，还有一个问题：就算在发布日期时未来的那些投票"
"不会在目录页 *index* 里出现，但是如果用户知道或者猜到正确的 URL ，还是可以访"
"问到它们。所以我们得在 ``DetailView`` 里增加一些约束："

msgid ""
"And of course, we will add some tests, to check that a ``Question`` whose "
"``pub_date`` is in the past can be displayed, and that one with a "
"``pub_date`` in the future is not:"
msgstr ""
"当然，我们将增加一些测试来检验 ``pub_date``  在过去的 ``Question`` 可以显示出"
"来，而  ``pub_date`` 在未来的不可以："

msgid "Ideas for more tests"
msgstr "更多的测试思路"

msgid ""
"We ought to add a similar ``get_queryset`` method to ``ResultsView`` and "
"create a new test class for that view. It'll be very similar to what we have "
"just created; in fact there will be a lot of repetition."
msgstr ""
"我们应该给 ``ResultsView`` 也增加一个类似的 ``get_queryset`` 方法，并且为它创"
"建测试。这和我们之前干的差不多，事实上，基本就是重复一遍。"

msgid ""
"We could also improve our application in other ways, adding tests along the "
"way. For example, it's silly that ``Questions`` can be published on the site "
"that have no ``Choices``. So, our views could check for this, and exclude "
"such ``Questions``. Our tests would create a ``Question`` without "
"``Choices`` and then test that it's not published, as well as create a "
"similar ``Question`` *with* ``Choices``, and test that it *is* published."
msgstr ""
"我们还可以从各个方面改进投票应用，但是测试会一直伴随我们。比方说，在目录页上"
"显示一个没有选项  ``Choices`` 的投票问题就没什么意义。我们可以检查并排除这样"
"的投票题。测试可以创建一个没有选项的投票，然后检查它是否被显示在目录上。当然"
"也要创建一个有选项的投票，然后确认它确实被显示了。"

msgid ""
"Perhaps logged-in admin users should be allowed to see unpublished "
"``Questions``, but not ordinary visitors. Again: whatever needs to be added "
"to the software to accomplish this should be accompanied by a test, whether "
"you write the test first and then make the code pass the test, or work out "
"the logic in your code first and then write a test to prove it."
msgstr ""
"恩，也许你想让管理员能在目录上看见未被发布的那些投票，但是普通用户看不到。不"
"管怎么说，如果你想要增加一个新功能，那么同时一定要为它编写测试。不过你是先写"
"代码还是先写测试那就随你了。"

msgid ""
"At a certain point you are bound to look at your tests and wonder whether "
"your code is suffering from test bloat, which brings us to:"
msgstr ""
"在未来的某个时刻，你一定会去查看测试代码，然后开始怀疑：「这么多的测试不会使"
"代码越来越复杂吗？」。别着急，我们马上就会谈到这一点。"

msgid "When testing, more is better"
msgstr "当需要测试的时候，测试用例越多越好"

msgid ""
"It might seem that our tests are growing out of control. At this rate there "
"will soon be more code in our tests than in our application, and the "
"repetition is unaesthetic, compared to the elegant conciseness of the rest "
"of our code."
msgstr ""
"貌似我们的测试多的快要失去控制了。按照这样发展下去，测试代码就要变得比应用的"
"实际代码还要多了。而且测试代码大多都是重复且不优雅的，特别是在和业务代码比起"
"来的时候，这种感觉更加明显。"

msgid ""
"**It doesn't matter**. Let them grow. For the most part, you can write a "
"test once and then forget about it. It will continue performing its useful "
"function as you continue to develop your program."
msgstr ""
"**但是这没关系！** 就让测试代码继续肆意增长吧。大部分情况下，你写完一个测试之"
"后就可以忘掉它了。在你继续开发的过程中，它会一直默默无闻地为你做贡献的。"

msgid ""
"Sometimes tests will need to be updated. Suppose that we amend our views so "
"that only ``Questions`` with ``Choices`` are published. In that case, many "
"of our existing tests will fail - *telling us exactly which tests need to be "
"amended to bring them up to date*, so to that extent tests help look after "
"themselves."
msgstr ""
"但有时测试也需要更新。想象一下如果我们修改了视图，只显示有选项的那些投票，那"
"么只前写的很多测试就都会失败。*但这也明确地告诉了我们哪些测试需要被更新*，所"
"以测试也会测试自己。"

msgid ""
"At worst, as you continue developing, you might find that you have some "
"tests that are now redundant. Even that's not a problem; in testing "
"redundancy is a *good* thing."
msgstr ""
"最坏的情况是，当你继续开发的时候，发现之前的一些测试现在看来是多余的。但是这"
"也不是什么问题，多做些测试也 *不错*。"

msgid ""
"As long as your tests are sensibly arranged, they won't become unmanageable. "
"Good rules-of-thumb include having:"
msgstr ""
"如果你对测试有个整体规划，那么它们就几乎不会变得混乱。下面有几条好的建议："

msgid "a separate ``TestClass`` for each model or view"
msgstr "对于每个模型和视图都建立单独的 ``TestClass``"

msgid "a separate test method for each set of conditions you want to test"
msgstr "每个测试方法只测试一个功能"

msgid "test method names that describe their function"
msgstr "给每个测试方法起个能描述其功能的名字"

msgid "Further testing"
msgstr "深入代码测试"

msgid ""
"This tutorial only introduces some of the basics of testing. There's a great "
"deal more you can do, and a number of very useful tools at your disposal to "
"achieve some very clever things."
msgstr ""
"在本教程中，我们仅仅是了解了测试的基础知识。你能做的还有很多，而且世界上有很"
"多有用的工具来帮你完成这些有意义的事。"

msgid ""
"For example, while our tests here have covered some of the internal logic of "
"a model and the way our views publish information, you can use an \"in-"
"browser\" framework such as Selenium_ to test the way your HTML actually "
"renders in a browser. These tools allow you to check not just the behavior "
"of your Django code, but also, for example, of your JavaScript. It's quite "
"something to see the tests launch a browser, and start interacting with your "
"site, as if a human being were driving it! Django includes :class:`~django."
"test.LiveServerTestCase` to facilitate integration with tools like Selenium."
msgstr ""
"举个例子，在上述的测试中，我们已经从代码逻辑和视图响应的角度检查了应用的输"
"出，现在你可以从一个更加 \"in-browser\" 的角度来检查最终渲染出的 HTML 是否符"
"合预期，使用 Selenium 可以很轻松的完成这件事。这个工具不仅可以测试 Django 框"
"架里的代码，还可以检查其他部分，比如说你的 JavaScript。它假装成是一个正在和你"
"站点进行交互的浏览器，就好像有个真人在访问网站一样！Django 它提供了  :class:"
"`~django.test.LiveServerTestCase`  来和 Selenium 这样的工具进行交互。"

msgid ""
"If you have a complex application, you may want to run tests automatically "
"with every commit for the purposes of `continuous integration`_, so that "
"quality control is itself - at least partially - automated."
msgstr ""
"如果你在开发一个很复杂的应用的话，你也许想在每次提交代码时自动运行测试，也就"
"是我们所说的持续集成  `continuous integration`_ ，这样就能实现质量控制的自动"
"化，起码是部分自动化。"

msgid ""
"A good way to spot untested parts of your application is to check code "
"coverage. This also helps identify fragile or even dead code. If you can't "
"test a piece of code, it usually means that code should be refactored or "
"removed. Coverage will help to identify dead code. See :ref:`topics-testing-"
"code-coverage` for details."
msgstr ""
"一个找出代码中未被测试部分的方法是检查代码覆盖率。它有助于找出代码中的薄弱部"
"分和无用部分。如果你无法测试一段代码，通常说明这段代码需要被重构或者删除。想"
"知道代码覆盖率和无用代码的详细信息，查看文档 :ref:`topics-testing-code-"
"coverage` 获取详细信息。"

msgid ""
":doc:`Testing in Django </topics/testing/index>` has comprehensive "
"information about testing."
msgstr ""
"文档 :doc:`Django 中的测试 </topics/testing/index>` 里有关于测试的更多信息。"

msgid "What's next?"
msgstr "接下来要做什么？"

msgid ""
"For full details on testing, see :doc:`Testing in Django </topics/testing/"
"index>`."
msgstr ""
"如果你想深入了解测试，就去看 :doc:`Django 中的测试 </topics/testing/"
"index>` 。"

msgid ""
"When you're comfortable with testing Django views, read :doc:`part 6 of this "
"tutorial</intro/tutorial06>` to learn about static files management."
msgstr ""
"当你已经比较熟悉测试 Django 视图的方法后，就可以继续阅读 :doc:`教程第 6 部分"
"</intro/tutorial06>`   ，学习静态文件管理的相关知识。"

msgid "Writing your first Django app, part 6"
msgstr "编写你的第一个 Django 应用，第 6 部分"

msgid ""
"This tutorial begins where :doc:`Tutorial 5 </intro/tutorial05>` left off. "
"We've built a tested Web-poll application, and we'll now add a stylesheet "
"and an image."
msgstr ""
"这一篇从  :doc:`教程第 5 部分 </intro/tutorial05>`  结尾的地方继续讲起。在上"
"一节中我们为网络投票应用编写了测试，而现在我们要为它加上样式和图片。"

msgid ""
"Aside from the HTML generated by the server, web applications generally need "
"to serve additional files — such as images, JavaScript, or CSS — necessary "
"to render the complete web page. In Django, we refer to these files as "
"\"static files\"."
msgstr ""
"除了服务端生成的 HTML 以外，网络应用通常需要一些额外的文件——比如图片，脚本和"
"样式表——来帮助渲染网络页面。在 Django 中，我们把这些文件统称为“静态文件”。"

msgid ""
"For small projects, this isn't a big deal, because you can just keep the "
"static files somewhere your web server can find it. However, in bigger "
"projects -- especially those comprised of multiple apps -- dealing with the "
"multiple sets of static files provided by each application starts to get "
"tricky."
msgstr ""
"对于小项目来说，这个问题没什么大不了的，因为你可以把这些静态文件随便放在哪，"
"只要服务程序能够找到它们就行。然而在大项目——特别是由好几个应用组成的大项目——"
"中，处理不同应用所需要的静态文件的工作就显得有点麻烦了。"

msgid ""
"That's what ``django.contrib.staticfiles`` is for: it collects static files "
"from each of your applications (and any other places you specify) into a "
"single location that can easily be served in production."
msgstr ""
"这就是 ``django.contrib.staticfiles`` 存在的意义：它将各个应用的静态文件（和"
"一些你指明的目录里的文件）统一收集起来，这样一来，在生产环境中，这些文件就会"
"集中在一个便于分发的地方。"

msgid "Customize your *app's* look and feel"
msgstr "自定义 *应用* 的界面和风格"

msgid ""
"First, create a directory called ``static`` in your ``polls`` directory. "
"Django will look for static files there, similarly to how Django finds "
"templates inside ``polls/templates/``."
msgstr ""
"首先，在你的 ``polls`` 目录下创建一个名为 ``static`` 的目录。Django 将在该目"
"录下查找静态文件，这种方式和 Diango 在 ``polls/templates/`` 目录下查找 "
"template 的方式类似。"

msgid ""
"Django's :setting:`STATICFILES_FINDERS` setting contains a list of finders "
"that know how to discover static files from various sources. One of the "
"defaults is ``AppDirectoriesFinder`` which looks for a \"static\" "
"subdirectory in each of the :setting:`INSTALLED_APPS`, like the one in "
"``polls`` we just created. The admin site uses the same directory structure "
"for its static files."
msgstr ""
"Django 的 :setting:`STATICFILES_FINDERS` 设置包含了一系列的查找器，它们知道去"
"哪里找到 static 文件。``AppDirectoriesFinder`` 是默认查找器中的一个，它会在每"
"个 :setting:`INSTALLED_APPS` 中指定的应用的子文件中寻找名称为 ``static`` 的特"
"定文件夹，就像我们在 ``polls`` 中刚创建的那个一样。管理后台采用相同的目录结构"
"管理它的静态文件。"

msgid ""
"Within the ``static`` directory you have just created, create another "
"directory called ``polls`` and within that create a file called ``style."
"css``. In other words, your stylesheet should be at ``polls/static/polls/"
"style.css``. Because of how the ``AppDirectoriesFinder`` staticfile finder "
"works, you can refer to this static file in Django simply as ``polls/style."
"css``, similar to how you reference the path for templates."
msgstr ""
"在你刚创建的 ``static`` 文件夹中创建一个名为 ``polls`` 的文件夹，再在 "
"``polls`` 文件夹中创建一个名为 ``style.css`` 的文件。换句话说，你的样式表路径"
"应是 ``polls/static/polls/style.css``。因为 ``AppDirectoriesFinder`` 的存在，"
"你可以在 Django 中简单地使用以 ``polls/style.css`` 的形式引用此文件，类似你引"
"用模板路径的方式。"

msgid "Static file namespacing"
msgstr "静态文件命名空间"

msgid ""
"Just like templates, we *might* be able to get away with putting our static "
"files directly in ``polls/static`` (rather than creating another ``polls`` "
"subdirectory), but it would actually be a bad idea. Django will choose the "
"first static file it finds whose name matches, and if you had a static file "
"with the same name in a *different* application, Django would be unable to "
"distinguish between them. We need to be able to point Django at the right "
"one, and the easiest way to ensure this is by *namespacing* them. That is, "
"by putting those static files inside *another* directory named for the "
"application itself."
msgstr ""
"虽然我们 *可以* 像管理模板文件一样，把 static 文件直接放入 ``polls/static`` "
"——而不是创建另一个名为 ``polls`` 的子文件夹，不过这实际上是一个很蠢的做法。"
"Django 只会使用第一个找到的静态文件。如果你在 *其它* 应用中有一个相同名字的静"
"态文件，Django 将无法区分它们。我们需要指引 Django 选择正确的静态文件，而最简"
"单的方式就是把它们放入各自的 *命名空间* 。也就是把这些静态文件放入 *另一个* "
"与应用名相同的目录中。"

msgid ""
"Put the following code in that stylesheet (``polls/static/polls/style.css``):"
msgstr "将以下代码放入样式表(``polls/static/polls/style.css``)："

msgid ""
"Next, add the following at the top of ``polls/templates/polls/index.html``:"
msgstr "下一步，在 ``polls/templates/polls/index.html`` 的文件头添加以下内容："

msgid ""
"The ``{% static %}`` template tag generates the absolute URL of static files."
msgstr "``{% static %}`` 模板标签会生成静态文件的绝对路径。"

msgid ""
"That's all you need to do for development. Reload ``http://localhost:8000/"
"polls/`` and you should see that the question links are green (Django "
"style!) which means that your stylesheet was properly loaded."
msgstr ""
"以上就是你全部需要做的事。浏览器重载 ``http://localhost:8000/polls/``，然后你"
"可以看到投票链接是绿色的（Django 样式），这意味着你的样式表被正确加载了。"

msgid "Adding a background-image"
msgstr "添加一个背景图"

msgid ""
"Next, we'll create a subdirectory for images. Create an ``images`` "
"subdirectory in the ``polls/static/polls/`` directory. Inside this "
"directory, put an image called ``background.gif``. In other words, put your "
"image in ``polls/static/polls/images/background.gif``."
msgstr ""
"接着，我们会创建一个用于存在图像的目录。在 ``polls/static/polls`` 目录下创建"
"一个名为 ``images`` 的子目录。在这个目录中，放一张名为 ``background.gif`` 的"
"图片。换言之，在目录 ``polls/static/polls/images/background.gif`` 中放一张图"
"片。"

msgid "Then, add to your stylesheet (``polls/static/polls/style.css``):"
msgstr "随后，在你的样式表（``polls/static/polls/style.css``）中添加："

msgid ""
"Reload ``http://localhost:8000/polls/`` and you should see the background "
"loaded in the top left of the screen."
msgstr ""
"浏览器重载 ``http://localhost:8000/polls/``，你将在屏幕的左上角见到这张背景"
"图。"

msgid ""
"Of course the ``{% static %}`` template tag is not available for use in "
"static files like your stylesheet which aren't generated by Django. You "
"should always use **relative paths** to link your static files between each "
"other, because then you can change :setting:`STATIC_URL` (used by the :ttag:"
"`static` template tag to generate its URLs) without having to modify a bunch "
"of paths in your static files as well."
msgstr ""
"当然，``{% static %}`` 模板标签在静态文件（例如样式表）中是不可用的，因为它们"
"不是由 Django 生成的。你仍需要使用 *相对路径* 的方式在你的静态文件之间互相引"
"用。这样之后，你就可以任意改变 :setting:`STATIC_URL`（由 :ttag:`static` 模板"
"标签用于生成 URL），而无需修改大量的静态文件。"

msgid ""
"These are the **basics**. For more details on settings and other bits "
"included with the framework see :doc:`the static files howto </howto/static-"
"files/index>` and :doc:`the staticfiles reference </ref/contrib/"
"staticfiles>`. :doc:`Deploying static files </howto/static-files/"
"deployment>` discusses how to use static files on a real server."
msgstr ""
"这些只是 **基础** 。更多关于设置和框架的资料，参考 :doc:`静态文件解惑 </"
"howto/static-files/index>` 和 :doc:`静态文件指南 </ref/contrib/"
"staticfiles>`。:doc:`部署静态文件 </howto/static-files/deployment>` 介绍了如"
"何在真实服务器上使用静态文件。"

msgid ""
"When you're comfortable with the static files, read :doc:`part 7 of this "
"tutorial </intro/tutorial07>` to learn how to customize Django's "
"automatically-generated admin site."
msgstr ""
"当你熟悉静态文件后，阅读 :doc:`此教程的第 7 部分 </intro/tutorial07>` 来学习"
"如何自定义 Django 自动生成后台网页的过程。"

msgid "Writing your first Django app, part 7"
msgstr "编写你的第一个 Django 应用，第 7 部分"

msgid ""
"This tutorial begins where :doc:`Tutorial 6 </intro/tutorial06>` left off. "
"We're continuing the Web-poll application and will focus on customizing "
"Django's automatically-generated admin site that we first explored in :doc:"
"`Tutorial 2 </intro/tutorial02>`."
msgstr ""
"这篇教程承接 :doc:`教程第 6 部分 </intro/tutorial06>` 结束的地方。我们继续修"
"改在线投票应用，这次我们专注于自定义我们在 :doc:`教程第 2 部分 </intro/"
"tutorial02>` 初见过的 Django 自动生成后台的过程。"

msgid "Customize the admin form"
msgstr "自定义后台表单"

msgid ""
"By registering the ``Question`` model with ``admin.site."
"register(Question)``, Django was able to construct a default form "
"representation. Often, you'll want to customize how the admin form looks and "
"works. You'll do this by telling Django the options you want when you "
"register the object."
msgstr ""
"通过 ``admin.site.register(Question)`` 注册 ``Question`` 模型，Django 能够构"
"建一个默认的表单用于展示。通常来说，你期望能自定义表单的外观和工作方式。你可"
"以在注册模型时将这些设置告诉 Django。"

msgid ""
"Let's see how this works by reordering the fields on the edit form. Replace "
"the ``admin.site.register(Question)`` line with:"
msgstr ""
"让我们通过重排列表单上的字段来看看它是怎么工作的。用以下内容替换 ``admin."
"site.register(Question)``："

msgid ""
"You'll follow this pattern -- create a model admin class, then pass it as "
"the second argument to ``admin.site.register()`` -- any time you need to "
"change the admin options for a model."
msgstr ""
"你需要遵循以下流程——创建一个模型后台类，接着将其作为第二个参数传给 ``admin."
"site.register()`` ——在你需要修改模型的后台管理选项时这么做。"

msgid ""
"This particular change above makes the \"Publication date\" come before the "
"\"Question\" field:"
msgstr "以上修改使得 \"Publication date\" 字段显示在 \"Question\" 字段之前："

msgid ""
"This isn't impressive with only two fields, but for admin forms with dozens "
"of fields, choosing an intuitive order is an important usability detail."
msgstr ""
"这在只有两个字段时显得没啥卵用，但对于拥有数十个字段的表单来说，为表单选择一"
"个直观的排序方法就显得你的针很细了。"

msgid ""
"And speaking of forms with dozens of fields, you might want to split the "
"form up into fieldsets:"
msgstr "说到拥有数十个字段的表单，你可能更期望将表单分为几个字段集："

msgid ""
"The first element of each tuple in :attr:`~django.contrib.admin.ModelAdmin."
"fieldsets` is the title of the fieldset. Here's what our form looks like now:"
msgstr ""
":attr:`~django.contrib.admin.ModelAdmin.fieldsets` 元组中的第一个元素是字段集"
"的标题。以下是我们的表单现在的样子："

msgid "Adding related objects"
msgstr "添加关联的对象"

msgid ""
"OK, we have our Question admin page, but a ``Question`` has multiple "
"``Choice``\\s, and the admin page doesn't display choices."
msgstr ""
"好了，现在我们有了投票的后台页。不过，一个 ``Question`` 有多个 ``Choice``，但"
"后台页却没有显示多个选项。"

msgid "Yet."
msgstr "好了。"

msgid ""
"There are two ways to solve this problem. The first is to register "
"``Choice`` with the admin just as we did with ``Question``. That's easy:"
msgstr ""
"有两个方法可以解决这个问题。第一个就是仿照我们向后台注册 ``Question`` 一样注"
"册 ``Choice`` 。这很简单："

msgid ""
"Now \"Choices\" is an available option in the Django admin. The \"Add choice"
"\" form looks like this:"
msgstr ""
"现在 \"Choices\" 在 Django 后台页中是一个可用的选项了。“添加选项”的表单看起来"
"像这样："

msgid ""
"In that form, the \"Question\" field is a select box containing every "
"question in the database. Django knows that a :class:`~django.db.models."
"ForeignKey` should be represented in the admin as a ``<select>`` box. In our "
"case, only one question exists at this point."
msgstr ""
"在这个表单中，\"Question\" 字段是一个包含数据库中所有投票的选择框。Django 知"
"道要将 :class:`~django.db.models.ForeignKey` 在后台中以选择框 ``<select>`` 的"
"形式展示。此时，我们只有一个投票。"

msgid ""
"Also note the \"Add Another\" link next to \"Question.\" Every object with a "
"``ForeignKey`` relationship to another gets this for free. When you click "
"\"Add Another\", you'll get a popup window with the \"Add question\" form. "
"If you add a question in that window and click \"Save\", Django will save "
"the question to the database and dynamically add it as the selected choice "
"on the \"Add choice\" form you're looking at."
msgstr ""
"同时也注意下 \"Question\" 旁边的“添加”按钮。每个使用 ``ForeignKey`` 关联到另"
"一个对象的对象会自动获得这个功能。当你点击“添加”按钮时，你会见到一个包含“添加"
"投票”的表单。如果你在这个弹出框中添加了一个投票，并点击了“保存”，Django 会将"
"其保存至数据库，并动态地在你正在查看的“添加选项”表单中选中它。"

msgid ""
"But, really, this is an inefficient way of adding ``Choice`` objects to the "
"system. It'd be better if you could add a bunch of Choices directly when you "
"create the ``Question`` object. Let's make that happen."
msgstr ""
"不过，这是一种很低效地添加“选项”的方法。更好的办法是在你创建“投票”对象时直接"
"添加好几个选项。让我们实现它。"

msgid ""
"Remove the ``register()`` call for the ``Choice`` model. Then, edit the "
"``Question`` registration code to read:"
msgstr ""
"移除调用 ``register()`` 注册 ``Choice`` 模型的代码。随后，像这样修改 "
"``Question`` 的注册代码："

msgid ""
"This tells Django: \"``Choice`` objects are edited on the ``Question`` admin "
"page. By default, provide enough fields for 3 choices.\""
msgstr ""
"这会告诉 Django：“``Choice`` 对象要在 ``Question`` 后台页面编辑。默认提供 3 "
"个足够的选项字段。”"

msgid "Load the \"Add question\" page to see how that looks:"
msgstr "加载“添加投票”页面来看看它长啥样："

msgid ""
"It works like this: There are three slots for related Choices -- as "
"specified by ``extra`` -- and each time you come back to the \"Change\" page "
"for an already-created object, you get another three extra slots."
msgstr ""
"它看起来像这样：有三个关联的选项插槽——由 ``extra`` 定义，且每次你返回任意已创"
"建的对象的“修改”页面时，你会见到三个新的插槽。"

msgid ""
"At the end of the three current slots you will find an \"Add another Choice"
"\" link.  If you click on it, a new slot will be added. If you want to "
"remove the added slot, you can click on the X to the top right of the added "
"slot. Note that you can't remove the original three slots. This image shows "
"an added slot:"
msgstr ""
"在三个插槽的末端，你会看到一个“添加新选项”的按钮。如果你单击它，一个新的插槽"
"会被添加。如果你想移除已有的插槽，可以点击插槽右上角的X。注意，你不能移除原始"
"的 3 个插槽。以下图片展示了一个已添加的插槽："

msgid ""
"One small problem, though. It takes a lot of screen space to display all the "
"fields for entering related ``Choice`` objects. For that reason, Django "
"offers a tabular way of displaying inline related objects; you just need to "
"change the ``ChoiceInline`` declaration to read:"
msgstr ""
"不过，仍然有点小问题。它占据了大量的屏幕区域来显示所有关联的 ``Choice`` 对象"
"的字段。对于这个问题，Django 提供了一种表格式的单行显示关联对象的方法。你只需"
"按如下形式修改 ``ChoiceInline`` 申明："

msgid ""
"With that ``TabularInline`` (instead of ``StackedInline``), the related "
"objects are displayed in a more compact, table-based format:"
msgstr ""
"通过 ``TabularInline``（替代 ``StackedInline`` ），关联对象以一种表格式的方式"
"展示，显得更加紧凑："

msgid ""
"Note that there is an extra \"Delete?\" column that allows removing rows "
"added using the \"Add Another Choice\" button and rows that have already "
"been saved."
msgstr ""
"注意这里有一个额外的“删除？”列，这允许移除通过“添加新选项”按钮添加的，或是已"
"被保存的行。"

msgid "Customize the admin change list"
msgstr "自定义后台更改列表"

msgid ""
"Now that the Question admin page is looking good, let's make some tweaks to "
"the \"change list\" page -- the one that displays all the questions in the "
"system."
msgstr ""
"现在投票的后台页看起来很不错，让我们对“更改列表”页面进行一些调整——改成一个能"
"展示系统中所有投票的页面。"

msgid "Here's what it looks like at this point:"
msgstr "以下是它此时的外观："

msgid ""
"By default, Django displays the ``str()`` of each object. But sometimes it'd "
"be more helpful if we could display individual fields. To do that, use the :"
"attr:`~django.contrib.admin.ModelAdmin.list_display` admin option, which is "
"a tuple of field names to display, as columns, on the change list page for "
"the object:"
msgstr ""
"默认情况下，Django 显示每个对象的 ``str()`` 返回的值。但有时如果我们能够显示"
"单个字段，它会更有帮助。为此，使用 :attr:`~django.contrib.admin.ModelAdmin."
"list_display` 后台选项，它是一个包含要显示的字段名的元组，在更改列表页中以列"
"的形式展示这个对象："

msgid ""
"Just for good measure, let's also include the ``was_published_recently()`` "
"method from :doc:`Tutorial 2 </intro/tutorial02>`:"
msgstr ""
"为了更好用，让我们也包含 :doc:`教程第 2 部分 </intro/tutorial02>` 中的 "
"``was_published_recently()`` 方法："

msgid "Now the question change list page looks like this:"
msgstr "现在修改投票的列表页看起来像这样："

msgid ""
"You can click on the column headers to sort by those values -- except in the "
"case of the ``was_published_recently`` header, because sorting by the output "
"of an arbitrary method is not supported. Also note that the column header "
"for ``was_published_recently`` is, by default, the name of the method (with "
"underscores replaced with spaces), and that each line contains the string "
"representation of the output."
msgstr ""
"你可以点击列标题来对这些行进行排序——除了 ``was_published_recently`` 这个列，"
"因为没有实现排序方法。顺便看下这个列的标题 ``was_published_recently``，默认就"
"是方法名（用空格替换下划线），该列的每行都以字符串形式展示出处。"

msgid ""
"You can improve that by giving that method (in :file:`polls/models.py`) a "
"few attributes, as follows:"
msgstr ""
"你可以通过给这个方法（在 :file:`polls/models.py` 中）一些属性来达到优化的目"
"的，像这样："

msgid ""
"For more information on these method properties, see :attr:`~django.contrib."
"admin.ModelAdmin.list_display`."
msgstr ""
"更多关于这些方法属性的信息，参见 :attr:`~django.contrib.admin.ModelAdmin."
"list_display`。"

msgid ""
"Edit your :file:`polls/admin.py` file again and add an improvement to the "
"``Question`` change list page: filters using the :attr:`~django.contrib."
"admin.ModelAdmin.list_filter`. Add the following line to ``QuestionAdmin``::"
msgstr ""
"再次编辑文件 :file:`polls/admin.py`，优化 ``Question`` 变更页：过滤器，使用 :"
"attr:`~django.contrib.admin.ModelAdmin.list_filter`。将以下代码添加至 "
"``QuestionAdmin``："

msgid ""
"That adds a \"Filter\" sidebar that lets people filter the change list by "
"the ``pub_date`` field:"
msgstr ""
"这样做添加了一个“过滤器”侧边栏，允许人们以 ``pub_date`` 字段来过滤列表："

msgid ""
"The type of filter displayed depends on the type of field you're filtering "
"on. Because ``pub_date`` is a :class:`~django.db.models.DateTimeField`, "
"Django knows to give appropriate filter options: \"Any date\", \"Today\", "
"\"Past 7 days\", \"This month\", \"This year\"."
msgstr ""
"展示的过滤器类型取决你你要过滤的字段的类型。因为 ``pub_date`` 是类 :class:"
"`~django.db.models.DateTimeField`，Django 知道要提供哪个过滤器：“任意时"
"间”，“今天”，“过去7天”，“这个月”和“今年”。"

msgid "This is shaping up well. Let's add some search capability::"
msgstr "这已经弄的很好了。让我们再扩充些功能::"

msgid ""
"That adds a search box at the top of the change list. When somebody enters "
"search terms, Django will search the ``question_text`` field. You can use as "
"many fields as you'd like -- although because it uses a ``LIKE`` query "
"behind the scenes, limiting the number of search fields to a reasonable "
"number will make it easier for your database to do the search."
msgstr ""
"在列表的顶部增加一个搜索框。当输入待搜项时，Django 将搜索 ``question_text`` "
"字段。你可以使用任意多的字段——由于后台使用 ``LIKE`` 来查询数据，将待搜索的字"
"段数限制为一个不会出问题大小，会便于数据库进行查询操作。"

msgid ""
"Now's also a good time to note that change lists give you free pagination. "
"The default is to display 100 items per page. :attr:`Change list pagination "
"<django.contrib.admin.ModelAdmin.list_per_page>`, :attr:`search boxes "
"<django.contrib.admin.ModelAdmin.search_fields>`, :attr:`filters <django."
"contrib.admin.ModelAdmin.list_filter>`, :attr:`date-hierarchies <django."
"contrib.admin.ModelAdmin.date_hierarchy>`, and :attr:`column-header-ordering "
"<django.contrib.admin.ModelAdmin.list_display>` all work together like you "
"think they should."
msgstr ""
"现在是给你的修改列表页增加分页功能的好时机。默认每页显示 100 项。:attr:`变更"
"页分页 <django.contrib.admin.ModelAdmin.list_per_page>`, :attr:`搜索框 "
"<django.contrib.admin.ModelAdmin.search_fields>`, :attr:`过滤器 <django."
"contrib.admin.ModelAdmin.list_filter>`, :attr:`日期层次结构 <django.contrib."
"admin.ModelAdmin.date_hierarchy>`, 和 :attr:`列标题排序 <django.contrib."
"admin.ModelAdmin.list_display>` 均以你期望的方式合作运行。"

msgid "Customize the admin look and feel"
msgstr "自定义后台界面和风格"

msgid ""
"Clearly, having \"Django administration\" at the top of each admin page is "
"ridiculous. It's just placeholder text."
msgstr "在每个后台页顶部显示“Django 管理员”显得很滑稽。这只是一串占位文本。"

msgid ""
"That's easy to change, though, using Django's template system. The Django "
"admin is powered by Django itself, and its interfaces use Django's own "
"template system."
msgstr ""
"不过，这可以通过 Django 的模板系统很方便的修改。Django 的后台由自己驱动，且它"
"的交互接口采用 Django 自己的模板系统。"

msgid "Customizing your *project's* templates"
msgstr "自定义你的 *工程的* 模板"

msgid ""
"Create a ``templates`` directory in your project directory (the one that "
"contains ``manage.py``). Templates can live anywhere on your filesystem that "
"Django can access. (Django runs as whatever user your server runs.) However, "
"keeping your templates within the project is a good convention to follow."
msgstr ""
"在你的工程目录（指包含 ``manage.py`` 的那个文件夹）内创建一个名为 "
"``templates`` 的目录。模板可放在你系统中任何 Django 能找到的位置。（谁启动了 "
"Django，Django 就以他的用户身份运行。）不过，把你的模板放在工程内会带来很大便"
"利，推荐你这样做。"

msgid ""
"Open your settings file (:file:`mysite/settings.py`, remember) and add a :"
"setting:`DIRS <TEMPLATES-DIRS>` option in the :setting:`TEMPLATES` setting:"
msgstr ""
"打开你的设置文件（:file:`mysite/settings.py`，牢记），在 :setting:"
"`TEMPLATES` 设置中添加 :setting:`DIRS <TEMPLATES-DIRS>` 选项："

msgid ""
":setting:`DIRS <TEMPLATES-DIRS>` is a list of filesystem directories to "
"check when loading Django templates; it's a search path."
msgstr ""
":setting:`DIRS <TEMPLATES-DIRS>` 是一个包含多个系统目录的文件列表，用于在载"
"入 Django 模板时使用，是一个待搜索路径。"

msgid "Organizing templates"
msgstr "组织模板"

msgid ""
"Just like the static files, we *could* have all our templates together, in "
"one big templates directory, and it would work perfectly well. However, "
"templates that belong to a particular application should be placed in that "
"application's template directory (e.g. ``polls/templates``) rather than the "
"project's (``templates``). We'll discuss in more detail in the :doc:"
"`reusable apps tutorial </intro/reusable-apps>` *why* we do this."
msgstr ""
"就像静态文件一样，我们 *可以* 把所有的模板文件放在一个大模板目录内，这样它也"
"能工作的很好。但是，属于特定应用的模板文件最好放在应用所属的模板目录（例如 "
"``polls/templates``），而不是工程的模板目录（``templates``）。我们会在 :doc:`"
"创建可复用的应用教程 </intro/reusable-apps>` 中讨论 *为什么* 我们要这样做。"

msgid ""
"Now create a directory called ``admin`` inside ``templates``, and copy the "
"template ``admin/base_site.html`` from within the default Django admin "
"template directory in the source code of Django itself (``django/contrib/"
"admin/templates``) into that directory."
msgstr ""
"现在，在 ``templates`` 目录内创建名为 ``admin`` 的目录，随后，将存放 Django "
"默认模板的目录（``django/contrib/admin/templates``）内的模板文件 ``admin/"
"base_site.html`` 复制到这个目录内。"

msgid "Where are the Django source files?"
msgstr "Django 的源文件在哪里？"

msgid ""
"If you have difficulty finding where the Django source files are located on "
"your system, run the following command:"
msgstr "如果你不知道 Django 源码在你系统的哪个位置，运行以下命令："

msgid ""
"Then, just edit the file and replace ``{{ site_header|default:_('Django "
"administration') }}`` (including the curly braces) with your own site's name "
"as you see fit. You should end up with a section of code like:"
msgstr ""
"接着，用你站点的名字替换文件内的 ``{{ site_header|default:_('Django "
"administration') }}``（包含大括号）。完成后，你应该看到如下代码："

msgid ""
"We use this approach to teach you how to override templates. In an actual "
"project, you would probably use the :attr:`django.contrib.admin.AdminSite."
"site_header` attribute to more easily make this particular customization."
msgstr ""
"我们会用这个方法来教你复写模板。在一个实际工程中，你可能更期望使用 :attr:"
"`django.contrib.admin.AdminSite.site_header` 来进行简单的定制。"

msgid ""
"This template file contains lots of text like ``{% block branding %}`` and "
"``{{ title }}``. The ``{%`` and ``{{`` tags are part of Django's template "
"language. When Django renders ``admin/base_site.html``, this template "
"language will be evaluated to produce the final HTML page, just like we saw "
"in :doc:`Tutorial 3 </intro/tutorial03>`."
msgstr ""
"这个模板文件包含很多类似 ``{% block branding %}`` 和 ``{{ title }}`` 的文"
"本。 ``{%`` 和 ``{{`` 标签是 Django 模板语言的一部分。当 Django 渲染 ``admin/"
"base_site.html`` 时，这个模板语言会被求值，生成最终的网页，就像我们在 :doc:`"
"教程第 3 部分 </intro/tutorial03>` 所学的一样。"

msgid ""
"Note that any of Django's default admin templates can be overridden. To "
"override a template, just do the same thing you did with ``base_site.html`` "
"-- copy it from the default directory into your custom directory, and make "
"changes."
msgstr ""
"注意，所有的 Django 默认后台模板均可被复写。若要复写模板，像你修改 "
"``base_site.html`` 一样修改其它文件——先将其从默认目录中拷贝到你的自定义目录，"
"再做修改。"

msgid "Customizing your *application's* templates"
msgstr "自定义你 *应用的* 模板"

msgid ""
"Astute readers will ask: But if :setting:`DIRS <TEMPLATES-DIRS>` was empty "
"by default, how was Django finding the default admin templates? The answer "
"is that, since :setting:`APP_DIRS <TEMPLATES-APP_DIRS>` is set to ``True``, "
"Django automatically looks for a ``templates/`` subdirectory within each "
"application package, for use as a fallback (don't forget that ``django."
"contrib.admin`` is an application)."
msgstr ""
"机智的同学可能会问： :setting:`DIRS <TEMPLATES-DIRS>` 默认是空的，Django 是怎"
"么找到默认的后台模板的？因为 :setting:`APP_DIRS <TEMPLATES-APP_DIRS>` 被置为 "
"``True``，Django 会自动在每个应用包内递归查找 ``templates/`` 子目录（不要忘"
"了 ``django.contrib.admin`` 也是一个应用）。"

msgid ""
"Our poll application is not very complex and doesn't need custom admin "
"templates. But if it grew more sophisticated and required modification of "
"Django's standard admin templates for some of its functionality, it would be "
"more sensible to modify the *application's* templates, rather than those in "
"the *project*. That way, you could include the polls application in any new "
"project and be assured that it would find the custom templates it needed."
msgstr ""
"我们的投票应用不是非常复杂，所以无需自定义后台模板。不过，如果它变的更加复"
"杂，需要修改 Django 的标准后台模板功能时，修改 *应用* 的模板会比 *工程* 的更"
"加明智。这样，在其它工程包含这个投票应用时，可以确保它总是能找到需要的自定义"
"模板文件。"

msgid ""
"See the :ref:`template loading documentation <template-loading>` for more "
"information about how Django finds its templates."
msgstr ""
"更多关于 Django 如何查找模板的文档，参见 :ref:`加载模板文档 <template-"
"loading>`。"

msgid "Customize the admin index page"
msgstr "自定义后台主页"

msgid ""
"On a similar note, you might want to customize the look and feel of the "
"Django admin index page."
msgstr "在类似的说明中，你可能想要自定义 Django 后台索引页的外观。"

msgid ""
"By default, it displays all the apps in :setting:`INSTALLED_APPS` that have "
"been registered with the admin application, in alphabetical order. You may "
"want to make significant changes to the layout. After all, the index is "
"probably the most important page of the admin, and it should be easy to use."
msgstr ""
"默认情况下，它展示了所有配置在 :setting:`INSTALLED_APPS` 中，已通过后台应用注"
"册，按拼音排序的应用。你可能想对这个页面的布局做重大的修改。毕竟，索引页是后"
"台的重要页面，它应该便于使用。"

msgid ""
"The template to customize is ``admin/index.html``. (Do the same as with "
"``admin/base_site.html`` in the previous section -- copy it from the default "
"directory to your custom template directory). Edit the file, and you'll see "
"it uses a template variable called ``app_list``. That variable contains "
"every installed Django app. Instead of using that, you can hard-code links "
"to object-specific admin pages in whatever way you think is best."
msgstr ""
"需要自定义的模板是 ``admin/index.html``。（像上一节修改 ``admin/base_site."
"html`` 那样修改此文件——从默认目录中拷贝此文件至自定义模板目录）。打开此文件，"
"你将看到它使用了一个叫做 ``app_list`` 的模板变量。这个变量包含了每个安装的 "
"Django 应用。你可以用任何你期望的硬编码链接（链接至特定对象的管理页）替代使用"
"这个变量。"

msgid ""
"The beginner tutorial ends here. In the meantime, you might want to check "
"out some pointers on :doc:`where to go from here </intro/whatsnext>`."
msgstr ""
"初学者教程到这就结束了。随后，你可能想阅读 :doc:`下一步看什么 </intro/"
"whatsnext>`，看看下一步能做什么。"

msgid ""
"If you are familiar with Python packaging and interested in learning how to "
"turn polls into a \"reusable app\", check out :doc:`Advanced tutorial: How "
"to write reusable apps</intro/reusable-apps>`."
msgstr ""
"如果你很熟悉 Python 打包，且对学习如何把投票应用改成“可复用应用”感兴趣，查"
"看 :doc:`进阶教程：如何创建可复用应用 </intro/reusable-apps>`。"

msgid "What to read next"
msgstr "下一步看什么"

msgid ""
"So you've read all the :doc:`introductory material </intro/index>` and have "
"decided you'd like to keep using Django. We've only just scratched the "
"surface with this intro (in fact, if you've read every single word, you've "
"read about 5% of the overall documentation)."
msgstr ""
"如果你已经读完了 :doc:`介绍文档 </intro/index>`，且对继续使用 Django 感兴趣。"
"不过，你读的是整体文档的精简版（实际上，如果你逐字阅读了此文档，你已经阅读了"
"整体文档的 5%）。"

msgid "So what's next?"
msgstr "那么下一步做什么？"

msgid ""
"Well, we've always been big fans of learning by doing. At this point you "
"should know enough to start a project of your own and start fooling around. "
"As you need to learn new tricks, come back to the documentation."
msgstr ""
"不错，我们已经通过边学边做成为了 Django 的死忠粉了。此时，你应该已经知道如何"
"开始你自己的工程，且会到处搜索其它文档了。想知道更多技巧的话，请回到文档页。"

msgid ""
"We've put a lot of effort into making Django's documentation useful, easy to "
"read and as complete as possible. The rest of this document explains more "
"about how the documentation works so that you can get the most out of it."
msgstr ""
"为了使 Django 的文档达到更易使用，更易阅读，更加全面的目的，我们付出了巨大的"
"努力。本文档的剩余部分将更详细地介绍此文档的工作方式，以便您可以充分利用它。"

msgid ""
"(Yes, this is documentation about documentation. Rest assured we have no "
"plans to write a document about how to read the document about "
"documentation.)"
msgstr ""
"（是的，这就是传说中的说明文档的说明文档。请放心，我们不打算写一篇关于如何阅"
"读此文档的文档。）"

msgid "Finding documentation"
msgstr "查找文档"

msgid ""
"Django's got a *lot* of documentation -- almost 450,000 words and counting "
"-- so finding what you need can sometimes be tricky. A few good places to "
"start are the :ref:`search` and the :ref:`genindex`."
msgstr ""
"Django有 *许多* 的文档——差不多有 450000 字（英文单词），所以查找你需要的文档"
"可能需要点技巧。对此，有几个不错的去处，:ref:`search` 和 :ref:`genindex`。"

msgid "Or you can just browse around!"
msgstr "或者你可以只是四处看看！"

msgid "How the documentation is organized"
msgstr "文档是如何组成"

msgid ""
"Django's main documentation is broken up into \"chunks\" designed to fill "
"different needs:"
msgstr "Django的主要文档以“块”的形式划分，用于满足不同的需求："

msgid ""
"The :doc:`introductory material </intro/index>` is designed for people new "
"to Django -- or to Web development in general. It doesn't cover anything in "
"depth, but instead gives a high-level overview of how developing in Django "
"\"feels\"."
msgstr ""
"The :doc:`介绍文档 </intro/index>` 是专为 Django 初学者或 Web 初学者设计的。"
"它不会做任何的深入，只是以高度概括的方式介绍了如果以 Django “风格”开发应用的"
"方式。"

msgid ""
"The :doc:`topic guides </topics/index>`, on the other hand, dive deep into "
"individual parts of Django. There are complete guides to Django's :doc:"
"`model system </topics/db/index>`, :doc:`template engine </topics/"
"templates>`, :doc:`forms framework </topics/forms/index>`, and much more."
msgstr ""
"另一方面，The :doc:`主题指南 </topics/index>` 则深入介绍 Django 的各个部分。"
"那里有更多完整的关于 Django的 :doc:`模板系统 </topics/db/index>`,  :doc:`模板"
"引擎 </topics/templates>`, :doc:`表单框架 </topics/forms/index>` 和其它东西的"
"信息。"

msgid ""
"This is probably where you'll want to spend most of your time; if you work "
"your way through these guides you should come out knowing pretty much "
"everything there is to know about Django."
msgstr ""
"这可能是你会花费你大部分时间的地方。如果你详细阅读了这些指南，你就能了解几乎"
"所有关于 Django 的知识。"

msgid ""
"Web development is often broad, not deep -- problems span many domains. "
"We've written a set of :doc:`how-to guides </howto/index>` that answer "
"common \"How do I ...?\" questions. Here you'll find information about :doc:"
"`generating PDFs with Django </howto/outputting-pdf>`, :doc:`writing custom "
"template tags </howto/custom-template-tags>`, and more."
msgstr ""
"Web 开发通常是广而不深的——问题通常跨越多个领域。我们已经写了一系列的文档 :"
"doc:`how-to 指引 </howto/index>` 用于回答常见的“为什么我会……？”系列问题。在这"
"里，你可以找到关于 :doc:`通过 Django 生成 PDF </howto/outputting-pdf>`，:doc:"
"`定义自定义模板标签 </howto/custom-template-tags>` 的文档，当然，还有其它的文"
"档。"

msgid ""
"Answers to really common questions can also be found in the :doc:`FAQ </faq/"
"index>`."
msgstr "关于常见问题的回答可参见 :doc:`FAQ </faq/index>`。"

msgid ""
"The guides and how-to's don't cover every single class, function, and method "
"available in Django -- that would be overwhelming when you're trying to "
"learn. Instead, details about individual classes, functions, methods, and "
"modules are kept in the :doc:`reference </ref/index>`. This is where you'll "
"turn to find the details of a particular function or whatever you need."
msgstr ""
"这个引导和怎么做的文档不会覆盖 Django 中每个可用的类，函数和方法——在你想学的"
"时候，你会发现实在是太多了。作为替代，每个类，函数，方法和模块的细节在 :doc:`"
"参考 </ref/index>` 中介绍。那是你未来查找某个函数的细节或其它你需要的东西的地"
"方。"

msgid ""
"If you are interested in deploying a project for public use, our docs have :"
"doc:`several guides</howto/deployment/index>` for various deployment setups "
"as well as a :doc:`deployment checklist</howto/deployment/checklist>` for "
"some things you'll need to think about."
msgstr ""
"如果你对部署一个公用的工程感兴趣，我们有介绍各种部署设置的文档 :doc:`几个指"
"引 </howto/deployment/index>` 和介绍你几个你需要了解的东西的文档 :doc:`部署清"
"单 </howto/deployment/checklist>`。"

msgid ""
"Finally, there's some \"specialized\" documentation not usually relevant to "
"most developers. This includes the :doc:`release notes </releases/index>` "
"and :doc:`internals documentation </internals/index>` for those who want to "
"add code to Django itself, and a :doc:`few other things that simply don't "
"fit elsewhere </misc/index>`."
msgstr ""
"最后，这里有一些与大部分开发者无关的“专业”文档。包含 :doc:`发布说明 </"
"releases/index>` 和 :doc:`内部文档 </internals/index>` ，用于向那些想向 "
"Django 提交代码的专业人士。还有一份文档 :doc:`不适合放到其它地方的一点内容 </"
"misc/index>` 。"

msgid "How documentation is updated"
msgstr "这个文档是如何更新的"

msgid ""
"Just as the Django code base is developed and improved on a daily basis, our "
"documentation is consistently improving. We improve documentation for "
"several reasons:"
msgstr ""
"就像 Django 的源码每天都被更新和提升一样，我们的文档也会持续优化。我们因为以"
"下几个原因优化文档："

msgid "To make content fixes, such as grammar/typo corrections."
msgstr "更正内容，如更正语法/拼写错误。"

msgid ""
"To add information and/or examples to existing sections that need to be "
"expanded."
msgstr "向已有的需要被扩展的某个章节添加介绍信息或例子。"

msgid ""
"To document Django features that aren't yet documented. (The list of such "
"features is shrinking but exists nonetheless.)"
msgstr "记录尚未记录的 Django 功能。 （这些功能的列表正在缩小，但仍然存在。）"

msgid ""
"To add documentation for new features as new features get added, or as "
"Django APIs or behaviors change."
msgstr "在新特性被添加时，或 Django 的 API 或行为有变化时，会添加新文档。"

msgid ""
"Django's documentation is kept in the same source control system as its "
"code. It lives in the `docs`_ directory of our Git repository. Each document "
"online is a separate text file in the repository."
msgstr ""
"Django  的文档以和它的代码一样，以代码版本管理系统方式进行管理。它被保存在 "
"git 仓库的 `docs`_ 目录内。每份在线文档都是仓库内的一份独立文本文件。"

msgid "Where to get it"
msgstr "从哪里获取这个"

msgid ""
"You can read Django documentation in several ways. They are, in order of "
"preference:"
msgstr "你可以以好几种形式阅读 Django 的文档。他们按照优先顺序排列："

msgid "On the Web"
msgstr "在网络上"

msgid ""
"The most recent version of the Django documentation lives at https://docs."
"djangoproject.com/en/dev/. These HTML pages are generated automatically from "
"the text files in source control. That means they reflect the \"latest and "
"greatest\" in Django -- they include the very latest corrections and "
"additions, and they discuss the latest Django features, which may only be "
"available to users of the Django development version. (See \"Differences "
"between versions\" below.)"
msgstr ""
"Django 最新的在线版文档位于 https://docs.djangoproject.com/en/dev/。这些网页"
"由 Django 的源码控制系统中的纯文本文件自动生成。这意味着它们展示了 Django “最"
"新最好” 的修改——它们包含最新的更正和补充，并讨论了最新的Django功能，这些功能"
"只可供Django开发版的用户使用。（参见以下关于“不同版本之间的差异”的介绍。）"

msgid ""
"We encourage you to help improve the docs by submitting changes, corrections "
"and suggestions in the `ticket system`_. The Django developers actively "
"monitor the ticket system and use your feedback to improve the documentation "
"for everybody."
msgstr ""
"为提高文档质量，你可以选择在 `工单系统`_ 中提交变更，修正以及建议，为此我们将"
"十分欣喜。 Django 的开发者们会积极的监控工单系统，并使用你的反馈为大家改善文"
"档。"

msgid ""
"Note, however, that tickets should explicitly relate to the documentation, "
"rather than asking broad tech-support questions. If you need help with your "
"particular Django setup, try the |django-users| mailing list or the `#django "
"IRC channel`_ instead."
msgstr ""
"值得一提的是，工单(ticket)应该明确地关联到文档，而不是询问笼统的技术支持问"
"题。 如果你需要针对你的 Django 配置寻求帮助，尝试联系 |django-users| 邮件组 "
"或者 `#django IRC channel`_ 。"

msgid "In plain text"
msgstr "纯文本形式"

msgid ""
"For offline reading, or just for convenience, you can read the Django "
"documentation in plain text."
msgstr "离线阅读，或仅仅是为了方便，你可以阅读 Djano 文档的纯文本形式。"

msgid ""
"If you're using an official release of Django, note that the zipped package "
"(tarball) of the code includes a ``docs/`` directory, which contains all the "
"documentation for that release."
msgstr ""
"如果你正在使用的是 Django 的某个正式发布版，注意有一个代码压缩包，包含了 "
"``docs/`` 目录，内含这个版本的完整文档。"

msgid ""
"If you're using the development version of Django (aka \"trunk\"), note that "
"the ``docs/`` directory contains all of the documentation. You can update "
"your Git checkout to get the latest changes."
msgstr ""
"如果你正在使用开发版的 Django （又名“trunk”），注意目录 ``docs/`` 包含所有的"
"文档。你可以通过 git 获取最新的修改。"

msgid ""
"One low-tech way of taking advantage of the text documentation is by using "
"the Unix ``grep`` utility to search for a phrase in all of the "
"documentation. For example, this will show you each mention of the phrase "
"\"max_length\" in any Django document:"
msgstr ""
"一种没啥技术含量的利用纯文本文档的方式是使用 Unix 的 ``grep`` 工具在文档中全"
"局中搜索一个短语。举个例子，接下来会向你展示 Django 文档中所有提到这个特定短"
"语 \"max_length\" 的地方："

msgid "As HTML, locally"
msgstr "以本地网页形式阅读"

msgid ""
"You can get a local copy of the HTML documentation following a few easy "
"steps:"
msgstr "经过几步简单的操作，你可以获得一份网页文档的备份："

msgid ""
"Django's documentation uses a system called Sphinx__ to convert from plain "
"text to HTML. You'll need to install Sphinx by either downloading and "
"installing the package from the Sphinx website, or with ``pip``:"
msgstr ""
"Django 文档使用了一个叫做 Sphinx__ 的系统将纯文本转换为网页。你可以通过 "
"Sphinx 的官方网站或 ``pip`` 来下载和安装它："

msgid ""
"Then, just use the included ``Makefile`` to turn the documentation into HTML:"
msgstr "接着，仅需使用其中的 ``Makefile`` 工具将文档转换为网页："

msgid "You'll need `GNU Make`__ installed for this."
msgstr "你需要为此安装 `GNU Make`__ 工具。"

msgid "If you're on Windows you can alternatively use the included batch file:"
msgstr "如果你是 Windows 系统，你应该使用其中的批处理文件："

msgid "The HTML documentation will be placed in ``docs/_build/html``."
msgstr "这个 HTML 文档将会被放置在 ``docs/_build/html``。"

msgid "Differences between versions"
msgstr "版本之间的差异"

msgid ""
"As previously mentioned, the text documentation in our Git repository "
"contains the \"latest and greatest\" changes and additions. These changes "
"often include documentation of new features added in the Django development "
"version -- the Git (\"trunk\") version of Django. For that reason, it's "
"worth pointing out our policy on keeping straight the documentation for "
"various versions of the framework."
msgstr ""
"如前所述，我们 Git 仓库中的纯文本文档包含“最新最好”的修改和扩展。这些修改通常"
"也包含介绍 Django 开发版中的新特性的文档——Django 的 Git（“trunk”）版本。因"
"此，保存各个版本的文档是值得的。"

msgid "We follow this policy:"
msgstr "我们遵循以下原则："

msgid ""
"The primary documentation on djangoproject.com is an HTML version of the "
"latest docs in Git. These docs always correspond to the latest official "
"Django release, plus whatever features we've added/changed in the framework "
"*since* the latest release."
msgstr ""
"djangoproject.com 上的主要文档是 Git 中最新文档的 HTML 版本。 这些文档总是对"
"应于官方最新的 Django 发布版本，包含所有 *自* 最新发布版起，我们在框架中添加"
"或修改的功能。"

msgid ""
"As we add features to Django's development version, we try to update the "
"documentation in the same Git commit transaction."
msgstr ""
"当我们为 Django 的开发版本添加功能时，我们会在相同的 Git commit 事务中更新文"
"档。"

msgid ""
"To distinguish feature changes/additions in the docs, we use the phrase: "
"\"New in version X.Y\", being X.Y the next release version (hence, the one "
"being developed)."
msgstr ""
"为区分文档中功能的修改或添加，我们使用短语：“在版本 X.Y 新增”，X.Y是指下一个"
"发布版本（因此，这个这本正在开发中）。"

msgid ""
"Documentation fixes and improvements may be backported to the last release "
"branch, at the discretion of the committer, however, once a version of "
"Django is :ref:`no longer supported<supported-versions-policy>`, that "
"version of the docs won't get any further updates."
msgstr ""
"文档的修复和提升可能只会提交到最新的一个发布版本，这取决于提交者，然而，一旦"
"一个 Django 的版本处于 :ref:`不在维护列表 <supported-versions-policy>` 中，这"
"个版本对应的文档将不再更新。"

msgid ""
"The `main documentation Web page`_ includes links to documentation for all "
"previous versions. Be sure you are using the version of the docs "
"corresponding to the version of Django you are using!"
msgstr ""
"`主要文档页面`_ 包含了指向所有旧版本文档的链接。确保你正在阅读和你使用的 "
"Django 版本匹配的文档！"
