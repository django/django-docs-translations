# SOME DESCRIPTIVE TITLE.
# Copyright (C) Django Software Foundation and contributors
# This file is distributed under the same license as the Django package.
#
# Translators:
# funcy39, 2023
# Arthur Wu <dandelionstill@gmail.com>, 2018
# HuanCheng Bai白宦成（Bestony） <xiqingongzi@gmail.com>, 2018
# belitex, 2018
# HuanCheng Bai白宦成（Bestony） <xiqingongzi@gmail.com>, 2018
# CabbSir <cabbsir@gmail.com>, 2018
# Cell, 2018
# FSSlc <fsslc235@gmail.com>, 2020
# Claude Paroz <claude@2xlibre.net>, 2020
# David <huangtao0202@gmail.com>, 2018
# Dogify <595572594@qq.com>, 2018-2019
# FPlust Lu <fplustlu@gmail.com>, 2018
# Frost Ming <mianghong@gmail.com>, 2018
# Howie Zhao <zhao_h_r@163.com>, 2019
# Jason Ren, 2022
# JINGMING DAI <d664216@gmail.com>, 2018
# Json0926 <jinsong0926@hotmail.com>, 2019
# Kevin Lee <rootkitcn@live.com>, 2018
# kurtchen1988 <kurtcobain1988824@hotmail.com>, 2018
# kurtchen1988 <kurtcobain1988824@hotmail.com>, 2018
# Kwen Stephen <hyuncankun@outlook.com>, 2018
# kyle xu <tsingx@hotmail.com>, 2017
# Le Yang <youngleocn@qq.com>, 2018
# shengzhulst <lishiting1996@outlook.com>, 2018
# li xiushan <lixiushan@aliyun.com>, 2020
# MattGook <matthewpangwm@gmail.com>, 2019
# mrgaolei <gaolei@liheran.com>, 2018
# myl7 <myl.ustc@gmail.com>, 2020
# radish sx <radishxtop@gmail.com>, 2017
# raingolee <raingolee@gmail.com>, 2018
# ryan rain <holidaylover2010@gmail.com>, 2018
# Jason Ren, 2022
# tianlong zhou <tlongzou@gmail.com>, 2019
# Todd Kasaki <2524737581@qq.com>, 2020-2022
# Tylor Caesar <caesartylor@gmail.com>, 2023
# Veoco <one@nomox.cn>, 2020-2023
# Vincent Chan, 2018
# Vincent <Intelligent.vincent@gmail.com>, 2019
# Wehao Guo <kinggreenhall@gmail.com>, 2019
# Wei Liu <2407802064@qq.com>, 2020
# Wu Xiangfeng, 2022
# Xiang Yu <bupt.aswmtjdsj@gmail.com>, 2013
# xin.wang <asimplelife@live.com>, 2018
# 育霖 杨 <yylteam@hotmail.com>, 2022
# enginewang <engine74396@gmail.com>, 2018
# ykh <614457662@qq.com>, 2018
# Imken Luo, 2022
# myl7 <myl.ustc@gmail.com>, 2019
# VinCiLord <lxfyok@gmail.com>, 2018
# ZheJiao <jiaozhe1987@163.com>, 2019
# zz, 2018
# boltyu <lightingyu@gmail.com>, 2020
# 锟斤拷 <xiake21x@qq.com>, 2016
# 奇泽 吴 <wuqize5109@163.com>, 2018
# 小黑, 2023
# 尔茂 (￣︶￣)↗ 涨 <973657283@qq.com>, 2018
# 得鑫 李 <lidexin911@126.com>, 2018
# Yang Zeyu (扩散性百万甜面包) <Himself6565@gmail.com>, 2018
# 景隆 王 <Arsenal591@126.com>, 2018
# Yang Zeyu (扩散性百万甜面包) <Himself6565@gmail.com>, 2018
# 毅杰 刘 <007gzs@gmail.com>, 2021
# 空 镜 <87647703@qq.com>, 2018
# Dogify <595572594@qq.com>, 2019
msgid ""
msgstr ""
"Project-Id-Version: django-docs\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-01-04 05:55-0600\n"
"PO-Revision-Date: 2013-04-02 19:58+0000\n"
"Last-Translator: Veoco <one@nomox.cn>, 2020-2023\n"
"Language-Team: Chinese (China) (http://app.transifex.com/django/django-docs/"
"language/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

msgid "How to authenticate using ``REMOTE_USER``"
msgstr "使用 ``REMOTE_USER`` 进行身份验证"

msgid ""
"This document describes how to make use of external authentication sources "
"(where the web server sets the ``REMOTE_USER`` environment variable) in your "
"Django applications.  This type of authentication solution is typically seen "
"on intranet sites, with single sign-on solutions such as IIS and Integrated "
"Windows Authentication or Apache and `mod_authnz_ldap`_, `CAS`_, `Cosign`_, "
"`WebAuth`_, `mod_auth_sspi`_, etc."
msgstr ""
"本文档描述如何在 Django 应用中使用外部身份验证资源（在 web 服务器上设置 "
"``REMOTE_USER`` 环境变量的地方）。这种类型的身份验证方法一般用在使用了单点登"
"录方案的内部网站上，比如 IIS 和 Windows 一体化验证或者 Apache 和 "
"`mod_authnz_ldap`_, `CAS`_, `Cosign`_, `WebAuth`_, `mod_auth_sspi`_ 等等。"

msgid ""
"When the web server takes care of authentication it typically sets the "
"``REMOTE_USER`` environment variable for use in the underlying application.  "
"In Django, ``REMOTE_USER`` is made available in the :attr:`request.META "
"<django.http.HttpRequest.META>` attribute.  Django can be configured to make "
"use of the ``REMOTE_USER`` value using the ``RemoteUserMiddleware`` or "
"``PersistentRemoteUserMiddleware``, and :class:`~django.contrib.auth."
"backends.RemoteUserBackend` classes found in :mod:`django.contrib.auth`."
msgstr ""
"当 Web 服务器负责鉴权时，通常会设置 ``REMOTE_USER`` 环境变量，这是为了在底层"
"应用中使用。在 Django 中， ``REMOTE_USER`` 是作为 :attr:`request.META "
"<django.http.HttpRequest.META>` 的参数来使用的。如果想在 Django 中使用 "
"``REMOTE_USER``, 可以通过配置 ``RemoteUserMiddleware`` 中间件， "
"``PersistentRemoteUserMiddleware`` 中间件，或者继承在 :mod:`django.contrib."
"auth` 中的 :class:`~django.contrib.auth.backends.RemoteUserBackend` 来实现。"

msgid "Configuration"
msgstr "配置"

msgid ""
"First, you must add the :class:`django.contrib.auth.middleware."
"RemoteUserMiddleware` to the :setting:`MIDDLEWARE` setting **after** the :"
"class:`django.contrib.auth.middleware.AuthenticationMiddleware`::"
msgstr ""
"首先，你需要向配置文件的 :setting:`MIDDLEWARE` 键中，在 :class:`django."
"contrib.auth.middleware.AuthenticationMiddleware` 的 **后面** 添加 :class:"
"`django.contrib.auth.middleware.RemoteUserMiddleware` ::"

msgid ""
"Next, you must replace the :class:`~django.contrib.auth.backends."
"ModelBackend` with :class:`~django.contrib.auth.backends.RemoteUserBackend` "
"in the :setting:`AUTHENTICATION_BACKENDS` setting::"
msgstr ""
"然后，你需要将设置中的 :setting:`AUTHENTICATION_BACKENDS` setting:: 键值由 :"
"class:`~django.contrib.auth.backends.ModelBackend` 替换为 :class:`~django."
"contrib.auth.backends.RemoteUserBackend`::"

msgid ""
"With this setup, ``RemoteUserMiddleware`` will detect the username in "
"``request.META['REMOTE_USER']`` and will authenticate and auto-login that "
"user using the :class:`~django.contrib.auth.backends.RemoteUserBackend`."
msgstr ""
"通过此项设置， ``RemoteUserMiddleware`` 可以检测 ``request."
"META['REMOTE_USER']`` 中的用户名，而且可以认证和自动登录用户使用的 :class:"
"`~django.contrib.auth.backends.RemoteUserBackend`。"

msgid ""
"Be aware that this particular setup disables authentication with the default "
"``ModelBackend``. This means that if the ``REMOTE_USER`` value is not set "
"then the user is unable to log in, even using Django's admin interface. "
"Adding ``'django.contrib.auth.backends.ModelBackend'`` to the "
"``AUTHENTICATION_BACKENDS`` list will use ``ModelBackend`` as a fallback if "
"``REMOTE_USER`` is absent, which will solve these issues."
msgstr ""
"要注意这项设置将导致无法使用默认的 ``ModelBackend`` 验证。也就是说如果 "
"``REMOTE_USER`` 的值没有指定则该用户将无法登录，即使通过 Django 的管理后台。"
"要解决这些问题，把 ``'django.contrib.auth.backends.ModelBackend'`` 加入 "
"``AUTHENTICATION_BACKENDS`` 列表中，则当 ``REMOTE_USER`` 未指定时，就会回退使"
"用 ``ModelBackend``。"

msgid ""
"Django's user management, such as the views in ``contrib.admin`` and the :"
"djadmin:`createsuperuser` management command, doesn't integrate with remote "
"users. These interfaces work with users stored in the database regardless of "
"``AUTHENTICATION_BACKENDS``."
msgstr ""
"Django 的用户管理系统，比如 ``contrib.admin`` 中的视图函数及 :djadmin:"
"`createsuperuser` 的管理命令，都没有与远程用户集成。这些接口只工作在数据库中"
"存储的用户上，无论 ``AUTHENTICATION_BACKENDS`` 为何值。"

msgid ""
"Since the ``RemoteUserBackend`` inherits from ``ModelBackend``, you will "
"still have all of the same permissions checking that is implemented in "
"``ModelBackend``."
msgstr ""
"因为 ``RemoteUserBackend`` 继承自 ``ModelBackend``, 您仍将拥有在  "
"``ModelBackend`` 中实现的所有相同的权限检查。"

msgid ""
"Users with :attr:`is_active=False <django.contrib.auth.models.User."
"is_active>` won't be allowed to authenticate. Use :class:`~django.contrib."
"auth.backends.AllowAllUsersRemoteUserBackend` if you want to allow them to."
msgstr ""
"具有 :attr:`is_active=False <django.contrib.auth.models.User.is_active>` 的用"
"户将被禁止验证。你可以使用 :class:`~django.contrib.auth.backends."
"AllowAllUsersRemoteUserBackend` 来允许验证。"

msgid ""
"If your authentication mechanism uses a custom HTTP header and not "
"``REMOTE_USER``, you can subclass ``RemoteUserMiddleware`` and set the "
"``header`` attribute to the desired ``request.META`` key.  For example::"
msgstr ""
"如果你的验证机制使用一个自定义的 HTTP header 而不是 ``REMOTE_USER``，你可以构"
"建一个 ``RemoteUserMiddleWare`` 的子类然后把 ``header`` 属性设成你希望的 "
"``request.META`` 键值。例如::"

msgid ""
"Be very careful if using a ``RemoteUserMiddleware`` subclass with a custom "
"HTTP header. You must be sure that your front-end web server always sets or "
"strips that header based on the appropriate authentication checks, never "
"permitting an end-user to submit a fake (or \"spoofed\") header value. Since "
"the HTTP headers ``X-Auth-User`` and ``X-Auth_User`` (for example) both "
"normalize to the ``HTTP_X_AUTH_USER`` key in ``request.META``, you must also "
"check that your web server doesn't allow a spoofed header using underscores "
"in place of dashes."
msgstr ""
"使用具有自定义HTTP头部的 ``RemoteUserMiddleware`` 子类时需要特别小心。你要确"
"保你的前端服务器基于验证检查结果正确设置或去除了该头部，禁止任何终端用户提交"
"一个仿冒的头部值。因为HTTP头部 ``X-Auth-User`` 与（比方说） ``X-Auth_User`` "
"都会标准化为 ``request.META`` 的 ``HTTP_X_AUTH_USER`` 键，你必须确保你的服务"
"器不允许头部使用下划线来替代横杠。"

msgid ""
"This warning doesn't apply to ``RemoteUserMiddleware`` in its default "
"configuration with ``header = 'REMOTE_USER'``, since a key that doesn't "
"start with ``HTTP_`` in ``request.META`` can only be set by your WSGI "
"server, not directly from an HTTP request header."
msgstr ""
"这个警告不适用于 ``RemoteUserMiddlewar``，它的默认配置为 ``header "
"='REMOTE_USER'``, 因为在 ``request.META`` 中不存在以 ``HTTP_`` 开始的键可以只"
"由WSGI服务器设置, 而不能直接来自HTTP请求头部."

msgid ""
"If you need more control, you can create your own authentication backend "
"that inherits from :class:`~django.contrib.auth.backends.RemoteUserBackend` "
"and override one or more of its attributes and methods."
msgstr ""
"如果你需要更多控制, 你可以通过继承 :class:`~django.contrib.auth.backends."
"RemoteUserBackend`  并且覆盖其一个或多个属性和方法来创建你自己的验证后端."

msgid "Using ``REMOTE_USER`` on login pages only"
msgstr "仅在登录界面使用 ``REMOTE_USER``"

msgid ""
"The ``RemoteUserMiddleware`` authentication middleware assumes that the HTTP "
"request header ``REMOTE_USER`` is present with all authenticated requests. "
"That might be expected and practical when Basic HTTP Auth with ``htpasswd`` "
"or similar mechanisms are used, but with Negotiate (GSSAPI/Kerberos) or "
"other resource intensive authentication methods, the authentication in the "
"front-end HTTP server is usually only set up for one or a few login URLs, "
"and after successful authentication, the application is supposed to maintain "
"the authenticated session itself."
msgstr ""
"``RemoteUserMiddleware`` 这个认证中间件 ，它假设HTTP请求的头部 "
"``REMOTE_USER`` 在所有认证请求中都存在。这个假设在当通过 ``htpasswd`` 或者相"
"似的认证机制来做Basic HTTP的认证时才是可行的，但是使用Negotiate (GSSAPI/"
"Kerberos) 或者其它资源密集型的认证方法时就说不过去了，前端HTTP server的认证通"
"常用在仅仅一个或不太多的登录URLs，而且在认证成功后，应用还要自己去维护这个"
"session。"

msgid ""
":class:`~django.contrib.auth.middleware.PersistentRemoteUserMiddleware` "
"provides support for this use case. It will maintain the authenticated "
"session until explicit logout by the user. The class can be used as a drop-"
"in replacement of :class:`~django.contrib.auth.middleware."
"RemoteUserMiddleware` in the documentation above."
msgstr ""
":class:`~django.contrib.auth.middleware.PersistentRemoteUserMiddleware` 就针"
"对这个使用场景提供了支持。除非用户显式地退出登录，它将一直保留已认证的会话。"
"这个中间件可以代替上文中的 :class:`~django.contrib.auth.middleware."
"RemoteUserMiddleware`。"

msgid "How to use Django's CSRF protection"
msgstr "如何使用 Django 提供的 CSRF 防护功能"

msgid "To take advantage of CSRF protection in your views, follow these steps:"
msgstr "要在你的视图中利用 CSRF 保护，请遵循以下步骤："

msgid ""
"The CSRF middleware is activated by default in the :setting:`MIDDLEWARE` "
"setting. If you override that setting, remember that ``'django.middleware."
"csrf.CsrfViewMiddleware'`` should come before any view middleware that "
"assume that CSRF attacks have been dealt with."
msgstr ""
"CSRF 中间件默认在 :setting:`MIDDLEWARE` 配置中被激活。如果你覆盖了这个配置，"
"请记住 ``'django.middleware.csrf.CsrfViewMiddleware'`` 应该排在任何假设 CSRF "
"攻击已经被处理的视图中间件之前。"

msgid ""
"If you disabled it, which is not recommended, you can use :func:`~django."
"views.decorators.csrf.csrf_protect` on particular views you want to protect "
"(see below)."
msgstr ""
"如果你禁用了它，这并不推荐，你可以使用 :func:`~django.views.decorators.csrf."
"csrf_protect` 对你想要保护的特定视图进行保护（见下文）。"

msgid ""
"In any template that uses a POST form, use the :ttag:`csrf_token` tag inside "
"the ``<form>`` element if the form is for an internal URL, e.g.:"
msgstr ""
"在任何使用 POST 表单的模板中，如果表单是针对内部 URL 的，请在 ``<form>`` 元素"
"中使用 :ttag:`csrf_token` 标签，例如："

msgid ""
"This should not be done for POST forms that target external URLs, since that "
"would cause the CSRF token to be leaked, leading to a vulnerability."
msgstr ""
"对于以外部 URL 为目标的 POST 表单，不应该这样做，因为这会导致 CSRF 令牌泄露，"
"从而导致漏洞。"

msgid ""
"In the corresponding view functions, ensure that :class:`~django.template."
"RequestContext` is used to render the response so that ``{% csrf_token %}`` "
"will work properly. If you're using the :func:`~django.shortcuts.render` "
"function, generic views, or contrib apps, you are covered already since "
"these all use ``RequestContext``."
msgstr ""
"在相应的视图函数中，确保 :class:`~django.template.RequestContext` 用于渲染响"
"应，这样 ``{% csrf_token %}`` 才能正常工作。如果你使用的是 :func:`~django."
"shortcuts.render` 函数、通用视图或 contrib 应用程序，你已经被覆盖了，因为这些"
"都使用 ``RequestContext``。"

msgid "Using CSRF protection with AJAX"
msgstr "通过 AJAX 进行 CSRF 防护"

msgid ""
"While the above method can be used for AJAX POST requests, it has some "
"inconveniences: you have to remember to pass the CSRF token in as POST data "
"with every POST request. For this reason, there is an alternative method: on "
"each XMLHttpRequest, set a custom ``X-CSRFToken`` header (as specified by "
"the :setting:`CSRF_HEADER_NAME` setting) to the value of the CSRF token. "
"This is often easier because many JavaScript frameworks provide hooks that "
"allow headers to be set on every request."
msgstr ""
"虽然上述方法可以用于 AJAX POST 请求，但它有一些不便之处：你必须记住在每个 "
"POST 请求中都要把 CSRF 令牌作为 POST 数据传递进来。出于这个原因，有一种替代方"
"法：在每个 XMLHttpRequest 上，设置一个自定义的 ``X-CSRFToken`` 头（由 :"
"setting:`CSRF_HEADER_NAME` 设置指定）为 CSRF 标记的值。这通常比较容易，因为许"
"多 JavaScript 框架提供了钩子，允许在每个请求中设置头。"

msgid ""
"First, you must get the CSRF token. How to do that depends on whether or not "
"the :setting:`CSRF_USE_SESSIONS` and :setting:`CSRF_COOKIE_HTTPONLY` "
"settings are enabled."
msgstr ""
"首先，你必须获得 CSRF 令牌。如何做取决于 :setting:`CSRF_USE_SESSIONS` 和 :"
"setting:`CSRF_COOKIE_HTTPONLY` 配置是否启用。"

msgid ""
"Acquiring the token if :setting:`CSRF_USE_SESSIONS` and :setting:"
"`CSRF_COOKIE_HTTPONLY` are ``False``"
msgstr ""
"当 :setting:`CSRF_USE_SESSIONS` 和 :setting:`CSRF_COOKIE_HTTPONLY` 为 "
"``False`` 时获取令牌"

msgid ""
"The recommended source for the token is the ``csrftoken`` cookie, which will "
"be set if you've enabled CSRF protection for your views as outlined above."
msgstr ""
"推荐的令牌来源是 ``csrftoken`` cookie，如果你已经为你的视图启用了上文所述的 "
"CSRF 保护，则会设置该 cookie。"

msgid ""
"The CSRF token cookie is named ``csrftoken`` by default, but you can control "
"the cookie name via the :setting:`CSRF_COOKIE_NAME` setting."
msgstr ""
"CSRF 令牌 cookie 默认命名为 ``csrftoken``，但你可以通过 :setting:"
"`CSRF_COOKIE_NAME` 配置来控制 cookie 的名称。"

msgid "You can acquire the token like this:"
msgstr "你可以通过这样的方式获得令牌："

msgid ""
"The above code could be simplified by using the `JavaScript Cookie library "
"<https://github.com/js-cookie/js-cookie/>`_ to replace ``getCookie``:"
msgstr ""
"上述代码可以通过使用 `JavaScript Cookie 库 <https://github.com/js-cookie/js-"
"cookie/>`_ 代替 ``getCookie`` 来简化："

msgid ""
"The CSRF token is also present in the DOM in a masked form, but only if "
"explicitly included using :ttag:`csrf_token` in a template. The cookie "
"contains the canonical, unmasked token. The :class:`~django.middleware.csrf."
"CsrfViewMiddleware` will accept either. However, in order to protect against "
"`BREACH`_ attacks, it's recommended to use a masked token."
msgstr ""
"CSRF令牌也以掩码形式存在于DOM中，但仅当在模板中明确包含 :ttag:`csrf_token` 时"
"才存在。Cookie 包含规范的、未掩码的令牌。 :class:`~django.middleware.csrf."
"CsrfViewMiddleware` 将接受任一种令牌。但是，为了防止 `BREACH`_ 攻击，建议使用"
"掩码令牌。"

msgid ""
"If your view is not rendering a template containing the :ttag:`csrf_token` "
"template tag, Django might not set the CSRF token cookie. This is common in "
"cases where forms are dynamically added to the page. To address this case, "
"Django provides a view decorator which forces setting of the cookie: :func:"
"`~django.views.decorators.csrf.ensure_csrf_cookie`."
msgstr ""
"如果你的视图没有渲染包含 :ttag:`csrf_token` 模板标签的模板，Django 可能不会设"
"置 CSRF 令牌 cookie。这种情况常见于表单被动态添加到页面的情况。针对这种情况，"
"Django 提供了一个视图装饰器来强制设置 cookie： :func:`~django.views."
"dedorators.csrf.sure_csrf_cookie`。"

msgid ""
"Acquiring the token if :setting:`CSRF_USE_SESSIONS` or :setting:"
"`CSRF_COOKIE_HTTPONLY` is ``True``"
msgstr ""
"当 :setting:`CSRF_USE_SESSIONS` 或 :setting:`CSRF_COOKIE_HTTPONLY` 为 "
"``True`` 时获取令牌"

msgid ""
"If you activate :setting:`CSRF_USE_SESSIONS` or :setting:"
"`CSRF_COOKIE_HTTPONLY`, you must include the CSRF token in your HTML and "
"read the token from the DOM with JavaScript:"
msgstr ""
"如果你激活了 :setting:`CSRF_USE_SESSIONS` 或 :setting:"
"`CSRF_COOKIE_HTTPONLY`，你必须在你的 HTML 中包含 CSRF 令牌，并通过 "
"JavaScript 从 DOM 中读取该令牌："

msgid "Setting the token on the AJAX request"
msgstr "在 AJAX 请求中设置令牌"

msgid ""
"Finally, you'll need to set the header on your AJAX request. Using the "
"`fetch()`_ API:"
msgstr "最后，你需要在 AJAX 请求中设置头。使用 `fetch()`_ API："

msgid "Using CSRF protection in Jinja2 templates"
msgstr "在 Jinja2 模板中使用 CSRF 防护"

msgid ""
"Django's :class:`~django.template.backends.jinja2.Jinja2` template backend "
"adds ``{{ csrf_input }}`` to the context of all templates which is "
"equivalent to ``{% csrf_token %}`` in the Django template language. For "
"example:"
msgstr ""
"Django 的 :class:`~django.template.backends.jinja2.Jinja2` 模板后端在所有模板"
"的上下文中添加了 ``{{ csrf_input }}``，相当于 Django 模板语言中的 ``{% "
"csrf_token %}``。例如："

msgid "Using the decorator method"
msgstr "在装饰器方法中使用"

msgid ""
"Rather than adding ``CsrfViewMiddleware`` as a blanket protection, you can "
"use the :func:`~django.views.decorators.csrf.csrf_protect` decorator, which "
"has exactly the same functionality, on particular views that need the "
"protection. It must be used **both** on views that insert the CSRF token in "
"the output, and on those that accept the POST form data. (These are often "
"the same view function, but not always)."
msgstr ""
"不要将 ``CsrfViewMiddleware`` 作为全局保护添加，而是可以在需要保护的特定视图"
"上使用具有完全相同功能的 :func:`~django.views.decorators.csrf.csrf_protect` "
"装饰器。它必须 **同时** 用于在输出中插入 CSRF 令牌的视图和接受 POST 表单数据"
"的视图。 (这些通常是相同的视图函数，但不总是)。"

msgid ""
"Use of the decorator by itself is **not recommended**, since if you forget "
"to use it, you will have a security hole. The 'belt and braces' strategy of "
"using both is fine, and will incur minimal overhead."
msgstr ""
"**不建议** 单独使用装饰器，因为如果忘记使用，就会出现安全漏洞。“腰带和支架”的"
"策略，两者同时使用也可以，而且会产生最小的开销。"

msgid "Handling rejected requests"
msgstr "处理被拒绝的请求"

msgid ""
"By default, a '403 Forbidden' response is sent to the user if an incoming "
"request fails the checks performed by ``CsrfViewMiddleware``. This should "
"usually only be seen when there is a genuine Cross Site Request Forgery, or "
"when, due to a programming error, the CSRF token has not been included with "
"a POST form."
msgstr ""
"默认情况下，如果传入的请求未能通过由中间件 ``CsrfViewMiddleware`` 执行的检"
"查，用户会收到“403 Forbidden”响应。 这通常只应该出现在真正的跨站点请求伪造"
"时，或者由于编程错误，CSRF 令牌没有被包含在 POST 表单中。"

msgid ""
"The error page, however, is not very friendly, so you may want to provide "
"your own view for handling this condition. To do this, set the :setting:"
"`CSRF_FAILURE_VIEW` setting."
msgstr ""
"然而，错误页面不是很友好，所以你可能想提供自己的视图来处理这种情况。 要做到这"
"一点，请在`settings.py`中的配置`CSRF_FAILURE_VIEW` 来指定视图。"

msgid ""
"CSRF failures are logged as warnings to the :ref:`django.security.csrf "
"<django-security-logger>` logger."
msgstr ""
"CSRF 失败会被记录为警告到 :ref:`django.security.csrf <django-security-"
"logger>` 记录器。"

msgid "Using CSRF protection with caching"
msgstr "通过缓存进行 CSRF 防护"

msgid ""
"If the :ttag:`csrf_token` template tag is used by a template (or the "
"``get_token`` function is called some other way), ``CsrfViewMiddleware`` "
"will add a cookie and a ``Vary: Cookie`` header to the response. This means "
"that the middleware will play well with the cache middleware if it is used "
"as instructed (``UpdateCacheMiddleware`` goes before all other middleware)."
msgstr ""
"如果 :ttag:`csrf_token` 模板标签被模板使用（或 ``get_token`` 函数被其他方式调"
"用），``CsrfViewMiddleware`` 将添加一个 cookie 和一个 ``Vary: Cookie`` 头到响"
"应中。这意味着，如果按照指示使用，中间件将与缓存中间件很好地配合"
"（``UpdateCacheMiddleware`` 先于所有其他中间件）。"

msgid ""
"However, if you use cache decorators on individual views, the CSRF "
"middleware will not yet have been able to set the Vary header or the CSRF "
"cookie, and the response will be cached without either one. In this case, on "
"any views that will require a CSRF token to be inserted you should use the :"
"func:`django.views.decorators.csrf.csrf_protect` decorator first::"
msgstr ""
"但是，如果你在单个视图上使用缓存装饰器，CSRF 中间件还不能设置 Vary 头或 CSRF "
"cookie，响应将在没有任何一个的情况下被缓存。在这种情况下，在任何需要插入 "
"CSRF 令牌的视图上，你应该先使用 :func:`django.views.decorators.csrf."
"csrf_protect` 装饰器："

msgid ""
"If you are using class-based views, you can refer to :ref:`Decorating class-"
"based views<decorating-class-based-views>`."
msgstr ""
"如果你使用的是基于类的视图，你可以参考 :ref:`装饰基于类的视图 <decorating-"
"class-based-views>`。"

msgid "Testing and CSRF protection"
msgstr "CSRF 防护与测试"

msgid ""
"The ``CsrfViewMiddleware`` will usually be a big hindrance to testing view "
"functions, due to the need for the CSRF token which must be sent with every "
"POST request. For this reason, Django's HTTP client for tests has been "
"modified to set a flag on requests which relaxes the middleware and the "
"``csrf_protect`` decorator so that they no longer rejects requests. In every "
"other respect (e.g. sending cookies etc.), they behave the same."
msgstr ""
"``CsrfViewMiddleware``通常会对测试视图函数造成很大的阻碍，因为每个POST请求都"
"需要发送CSRF令牌。因此，Django用于测试的HTTP客户端已经修改了，为请求设置了一"
"个标志，放松了中间件和` ' csrf_protect ' `装饰器，使它们不再拒绝请求。在其他"
"方面(例如发送cookie等)，它们的行为是相同的。"

msgid ""
"If, for some reason, you *want* the test client to perform CSRF checks, you "
"can create an instance of the test client that enforces CSRF checks:"
msgstr ""
"如果出于某种原因，你* *希望* *测试客户端执行CSRF检查，你可以创建一个强制执行"
"CSRF检查的测试客户端实例:"

msgid "Edge cases"
msgstr "边缘案例"

msgid ""
"Certain views can have unusual requirements that mean they don't fit the "
"normal pattern envisaged here. A number of utilities can be useful in these "
"situations. The scenarios they might be needed in are described in the "
"following section."
msgstr ""
"某些视图可能有不寻常的要求，这意味着它们不符合这里所设想的正常模式。在这些情"
"况下，一些实用程序可能很有用。下一节将介绍可能需要它们的情况。"

msgid "Disabling CSRF protection for just a few views"
msgstr "在较少视图中禁用 CSRF 防护"

msgid "Most views requires CSRF protection, but a few do not."
msgstr "大多数视图需要 CSRF 保护，但也有少数视图不需要。"

msgid ""
"Solution: rather than disabling the middleware and applying ``csrf_protect`` "
"to all the views that need it, enable the middleware and use :func:`~django."
"views.decorators.csrf.csrf_exempt`."
msgstr ""
"解决办法：与其禁用中间件并对所有需要的视图应用 ``csrf_protect``，不如启用中间"
"件并使用 :func:`~django.views.decrators.csrf.csrf_exempt`。"

msgid ""
"Setting the token when ``CsrfViewMiddleware.process_view()`` is not used"
msgstr "当`CsrfViewMiddleware.process_view()``不被使用时设置令牌"

msgid ""
"There are cases when ``CsrfViewMiddleware.process_view`` may not have run "
"before your view is run - 404 and 500 handlers, for example - but you still "
"need the CSRF token in a form."
msgstr ""
"有些情况下，``CsrfViewMiddleware.process_view`` 可能在你的视图运行之前没有运"
"行——例如 404 和 500 处理程序——但你仍然需要表单中的 CSRF 令牌。"

msgid "Solution: use :func:`~django.views.decorators.csrf.requires_csrf_token`"
msgstr ""
"解决方法：使用 :func:`~django.views.decorators.csrf.requests_csrf_token`。"

msgid "Including the CSRF token in an unprotected view"
msgstr "在未保护的视图中包含 CSRF 令牌。"

msgid ""
"There may be some views that are unprotected and have been exempted by "
"``csrf_exempt``, but still need to include the CSRF token."
msgstr ""
"可能有一些视图是不受保护的，已经被 ``csrf_exempt`` 豁免，但仍然需要包括 CSRF "
"令牌。"

msgid ""
"Solution: use :func:`~django.views.decorators.csrf.csrf_exempt` followed by :"
"func:`~django.views.decorators.csrf.requires_csrf_token`. (i.e. "
"``requires_csrf_token`` should be the innermost decorator)."
msgstr ""
"解决方法：使用 :func:`~django.views.decorators.csrf.csrf_exempt` 后面跟着 :"
"func:`~django.views.decorators.csrf.requires_csrf_token`。（即 "
"``requires_csrf_token`` 应该是最里面的装饰器)。"

msgid "Protecting a view for only one path"
msgstr "仅为一个路径保护视图"

msgid ""
"A view needs CSRF protection under one set of conditions only, and mustn't "
"have it for the rest of the time."
msgstr "一个视图只在一组条件下需要 CSRF 保护，其余时间一定不能有。"

msgid ""
"Solution: use :func:`~django.views.decorators.csrf.csrf_exempt` for the "
"whole view function, and :func:`~django.views.decorators.csrf.csrf_protect` "
"for the path within it that needs protection. Example::"
msgstr ""
"解决方法：用 :func:`~django.views.decrators.csrf.csrf_exempt` 表示整个视图函"
"数，用 :func:`~django.views.decrators.csrf.csrf_protect` 表示其中需要保护的路"
"径。例如："

msgid "Protecting a page that uses AJAX without an HTML form"
msgstr "保护没有 HTML 表单，使用 AJAX 的页面。"

msgid ""
"A page makes a POST request via AJAX, and the page does not have an HTML "
"form with a :ttag:`csrf_token` that would cause the required CSRF cookie to "
"be sent."
msgstr ""
"一个页面通过 AJAX 进行 POST 请求，而该页面并没有一个带有 :ttag:`csrf_token` "
"的 HTML 表单，这将导致所需的 CSRF cookie 被发送。"

msgid ""
"Solution: use :func:`~django.views.decorators.csrf.ensure_csrf_cookie` on "
"the view that sends the page."
msgstr ""
"解决方法：在发送页面的视图上使用 :func:`~django.views.decorators.csrf."
"sure_csrf_cookie`。"

msgid "CSRF protection in reusable applications"
msgstr "在可复用应用中使用 CSRF 保护。"

msgid ""
"Because it is possible for the developer to turn off the "
"``CsrfViewMiddleware``, all relevant views in contrib apps use the "
"``csrf_protect`` decorator to ensure the security of these applications "
"against CSRF. It is recommended that the developers of other reusable apps "
"that want the same guarantees also use the ``csrf_protect`` decorator on "
"their views."
msgstr ""
"因为开发人员可以关闭 ``CsrfViewMiddleware``，所以 contrib 应用程序中的所有相"
"关视图都使用 ``csrf_protect`` 装饰器来确保这些应用程序针对 CSRF 的安全性。 建"
"议需要相同保证的其他可重用应用程序的开发人员也在其视图上使用 "
"``csrf_protect`` 装饰器。"

msgid "How to write a custom storage class"
msgstr "如何编写一个自定义的文件存储类"

msgid ""
"If you need to provide custom file storage -- a common example is storing "
"files on some remote system -- you can do so by defining a custom storage "
"class. You'll need to follow these steps:"
msgstr ""
"如果你需要提供自定义文件储存功能——一个普通的例子是，把文件储存在远程系统中——"
"自定义一个存储类可以完成这一任务来完成。下面是需要完成的具体步骤："

msgid ""
"Your custom storage system must be a subclass of ``django.core.files.storage."
"Storage``::"
msgstr ""
"你自定义的存储系统必须为 ``Django.core.files.storage.Storage`` 的一个子类::"

msgid ""
"Django must be able to instantiate your storage system without any "
"arguments. This means that any settings should be taken from ``django.conf."
"settings``::"
msgstr ""
"Django 必须能以无参数实例化你的存储系统。意味着所有配置都应从 ``django.conf."
"settings`` 配置中获取::"

msgid ""
"Your storage class must implement the :meth:`_open()` and :meth:`_save()` "
"methods, along with any other methods appropriate to your storage class. See "
"below for more on these methods."
msgstr ""
"在你的存储类中，除了其他自定义的方法外，还必须实现  :meth:`_open()` 以及 :"
"meth:`_save()` 等其他适合你的存储类的方法。关于这些方法，详情请查看下面的信"
"息。"

msgid ""
"In addition, if your class provides local file storage, it must override the "
"``path()`` method."
msgstr "另外，如果你的类提供了本地文件存储，它必须重写  ``path()`` 方法。"

msgid ""
"Your storage class must be :ref:`deconstructible <custom-deconstruct-"
"method>` so it can be serialized when it's used on a field in a migration. "
"As long as your field has arguments that are themselves :ref:`serializable "
"<migration-serializing>`, you can use the ``django.utils.deconstruct."
"deconstructible`` class decorator for this (that's what Django uses on "
"FileSystemStorage)."
msgstr ""
"您的存储类必须是 :ref:`deconstructible <custom-deconstruct-method>`，以便在迁"
"移中的字段上使用它时可以序列化。 只要你的字段有自己的参数 :ref:`serializable "
"<migration-serializing>`，你可以使用 ``django.utils.deconstruct."
"deconstructible`` 类装饰器（这是 Django 在 FileSystemStorage 上使用的）。"

msgid ""
"By default, the following methods raise ``NotImplementedError`` and will "
"typically have to be overridden:"
msgstr ""
"默认情况下，下面的方法将引发一个 `NotImplementedError` 的错误，并且通常它们必"
"须被重写。"

msgid ":meth:`Storage.delete`"
msgstr ":meth:`Storage.delete`"

msgid ":meth:`Storage.exists`"
msgstr ":meth:`Storage.exists`"

msgid ":meth:`Storage.listdir`"
msgstr ":meth:`Storage.listdir`"

msgid ":meth:`Storage.size`"
msgstr ":meth:`Storage.size`"

msgid ":meth:`Storage.url`"
msgstr ":meth:`Storage.url`"

msgid ""
"Note however that not all these methods are required and may be deliberately "
"omitted. As it happens, it is possible to leave each method unimplemented "
"and still have a working Storage."
msgstr ""
"可是，记住并非所有这些方法都是需要的，并且可能故意被省略。正因为如此，让每个"
"方法未实现并仍然拥有一个可用储存是可能的。"

msgid ""
"By way of example, if listing the contents of certain storage backends turns "
"out to be expensive, you might decide not to implement ``Storage.listdir()``."
msgstr ""
"举例来说，如果列出某些存储后端的内容被证明代价会很昂贵，那么您可以决定不实现 "
"`Storage.listdir()` 方法。 "

msgid ""
"Another example would be a backend that only handles writing to files. In "
"this case, you would not need to implement any of the above methods."
msgstr ""
"另一个例子是只处理写入文件的后端。在这种情况下，你不需要实现上述任何方法。"

msgid ""
"Ultimately, which of these methods are implemented is up to you. Leaving "
"some methods unimplemented will result in a partial (possibly broken) "
"interface."
msgstr ""
"最终，你决定实现这些方法中的哪一个。一些方法未实现结果会生成部分（可能会损坏"
"的）接口。"

msgid ""
"You'll also usually want to use hooks specifically designed for custom "
"storage objects. These are:"
msgstr "你可能也经常会用到专为自定义存储对象设计的钩子函数。他们是："

msgid "**Required**."
msgstr "**要求**。"

msgid ""
"Called by ``Storage.open()``, this is the actual mechanism the storage class "
"uses to open the file. This must return a ``File`` object, though in most "
"cases, you'll want to return some subclass here that implements logic "
"specific to the backend storage system. The :exc:`FileNotFoundError` "
"exception should be raised when a file doesn't exist."
msgstr ""
"由 ``Storage.open()`` 调用，这是存储类用于打开文件的实际机制。这必须返回一个 "
"``File`` 对象，尽管在大多数情况下，你会想在这里返回一些实现特定于后端存储系统"
"的逻辑的子类。当文件不存在时，应该引发 :exc:`FileNotFoundError` 异常。"

msgid ""
"Called by ``Storage.save()``. The ``name`` will already have gone through "
"``get_valid_name()`` and ``get_available_name()``, and the ``content`` will "
"be a ``File`` object itself."
msgstr ""
"被称为 ``Storage.save()``。这个 ``name`` 会早已经历 ``get_valid_name()`` 和 "
"``get_available_name()``，并且 ``content`` 将会成为 ``File`` 对象自身。"

msgid ""
"Should return the actual name of the file saved (usually the ``name`` passed "
"in, but if the storage needs to change the file name return the new name "
"instead)."
msgstr ""
"应该返回实际保存的文件的名称（通常是传递的 ``name``，但如果存储需要更改文件"
"名，则返回新名称）。"

msgid ""
"Returns a filename suitable for use with the underlying storage system. The "
"``name`` argument passed to this method is either the original filename sent "
"to the server or, if ``upload_to`` is a callable, the filename returned by "
"that method after any path information is removed. Override this to "
"customize how non-standard characters are converted to safe filenames."
msgstr ""
"返回适用于底层存储系统的文件名。 传递给此方法的 ``name`` 参数既不是发送给服务"
"器的原始文件名，如果 ``upload_to`` 是可调用的，则在删除任何路径信息后由该方法"
"返回的文件名。 重写此操作可以自定义如何将非标准字符转换为安全文件名。"

msgid ""
"The code provided on ``Storage`` retains only alpha-numeric characters, "
"periods and underscores from the original filename, removing everything else."
msgstr ""
"“Storage”上提供的代码仅保留原始文件名中的字母数字字符，句点和下划线，并删除其"
"他所有内容。"

msgid ""
"Returns an alternative filename based on the ``file_root`` and ``file_ext`` "
"parameters. By default, an underscore plus a random 7 character alphanumeric "
"string is appended to the filename before the extension."
msgstr ""
"将会在 ``file_root`` 和 ``file_ext`` 这两个参数的基础上返回另一个文件名。默认"
"情况下，在执行前一个下划线再加上 7 个由字母和数字组成的字符串将将会追加到原来"
"的文件名后。"

msgid ""
"Returns a filename that is available in the storage mechanism, possibly "
"taking the provided filename into account. The ``name`` argument passed to "
"this method will have already cleaned to a filename valid for the storage "
"system, according to the ``get_valid_name()`` method described above."
msgstr ""
"返回存储机制中可用的文件名，可能会考虑提供的文件名。 根据上述 "
"``get_valid_name()`` 方法，传递给此方法的 ``name`` 参数已经被清除为一个对存储"
"系统有效的文件名。"

msgid ""
"The length of the filename will not exceed ``max_length``, if provided. If a "
"free unique filename cannot be found, a :exc:`SuspiciousFileOperation "
"<django.core.exceptions.SuspiciousOperation>` exception is raised."
msgstr ""
"返回的文件名的长度不会超过 ``max_length``，如果该参数被提供的话。若找不到一个"
"可用的独一无二的文件名，则抛出一个 :exc:`SuspiciousFileOperation <django."
"core.exceptions.SuspiciousOperation>` 异常。"

msgid ""
"If a file with ``name`` already exists, ``get_alternative_name()`` is called "
"to obtain an alternative name."
msgstr ""
"假如已经存在名为 ``name`` 的文件，那么 ``get_alternative_name()`` 将会被调用"
"来得到另一个替代的名称。"

msgid "Use your custom storage engine"
msgstr "使用你的自定义存储引擎"

msgid ""
"The first step to using your custom storage with Django is to tell Django "
"about the file storage backend you'll be using. This is done using the :"
"setting:`STORAGES` setting. This setting maps storage aliases, which are a "
"way to refer to a specific storage throughout Django, to a dictionary of "
"settings for that specific storage backend. The settings in the inner "
"dictionaries are described fully in the :setting:`STORAGES` documentation."
msgstr ""
"使用自定义存储与 Django 的第一步是告诉 Django 你将要使用的文件存储后端。这可"
"以通过 :setting:`STORAGES` 设置来完成。该设置将存储别名（这是在整个 Django 中"
"引用特定存储的一种方式）映射到该特定存储后端的设置字典。内部字典中的设置在 :"
"setting:`STORAGES` 文档中有详细描述。"

msgid ""
"Storages are then accessed by alias from from the :data:`django.core.files."
"storage.storages` dictionary::"
msgstr ""
"然后通过别名从 :data:`django.core.files.storage.storages` 字典中访问存储："

msgid "How to write custom lookups"
msgstr "如何编写自定义的查询器"

msgid ""
"Django offers a wide variety of :ref:`built-in lookups <field-lookups>` for "
"filtering (for example, ``exact`` and ``icontains``). This documentation "
"explains how to write custom lookups and how to alter the working of "
"existing lookups. For the API references of lookups, see the :doc:`/ref/"
"models/lookups`."
msgstr ""
"Django 提供了各种各样的 :ref:`内置查询器 <field-lookups>` （例如， ``exact`` "
"和 ``icontains`` ）。本文档解释了如何编写自定义查询器以及如何更改已有查询器的"
"工作方式。 有关 lookup 的 API 参考，请参阅 :doc:`/ref/models/lookups`。"

msgid "A lookup example"
msgstr "一个查询器示例。"

msgid ""
"Let's start with a small custom lookup. We will write a custom lookup ``ne`` "
"which works opposite to ``exact``. ``Author.objects."
"filter(name__ne='Jack')`` will translate to the SQL:"
msgstr ""
"让我们以一个小巧的自定义查询器为例。我们将书写一个名为 ``ne`` 的自定义查询"
"器，它的效果与 ``exact`` 相反。语句 ``Author.objects."
"filter(name__ne='Jack')``  将会翻译为下面的 SQL 语句："

msgid ""
"This SQL is backend independent, so we don't need to worry about different "
"databases."
msgstr "SQL 会自动适配不同的后端，所以我们不需要为使用不同的数据库而担心。"

msgid ""
"There are two steps to making this work. Firstly we need to implement the "
"lookup, then we need to tell Django about it::"
msgstr ""
"要让它生效需要两个步骤，首先我们需要实现该查询器，然后我们需要告诉 Django 有"
"关它的信息。"

msgid ""
"To register the ``NotEqual`` lookup we will need to call ``register_lookup`` "
"on the field class we want the lookup to be available for. In this case, the "
"lookup makes sense on all ``Field`` subclasses, so we register it with "
"``Field`` directly::"
msgstr ""
"为了注册  ``NotEqual`` 查询器，我们需要在对应需要该查询器的字段类中调用  "
"``register_lookup`` 方法。在该情形下，该查询器作用在所有的 ``Field`` 子类，所"
"以我们直接将它注册在 ``Field`` 中::"

msgid "Lookup registration can also be done using a decorator pattern::"
msgstr "查询器注册也可以用修饰模式来完成::"

msgid ""
"We can now use ``foo__ne`` for any field ``foo``. You will need to ensure "
"that this registration happens before you try to create any querysets using "
"it. You could place the implementation in a ``models.py`` file, or register "
"the lookup in the ``ready()`` method of an ``AppConfig``."
msgstr ""
"现在我们可以用 ``foo__ne`` 来代表 ``foo`` 的任意字段。你需要确保注册行为发生"
"在创建任意的 queryset 之前。你可以在 ``models.py`` 文件内设置它，或者在 "
"``AppConfig`` 的 ``ready()`` 方法中注册它。"

msgid ""
"Taking a closer look at the implementation, the first required attribute is "
"``lookup_name``. This allows the ORM to understand how to interpret "
"``name__ne`` and use ``NotEqual`` to generate the SQL. By convention, these "
"names are always lowercase strings containing only letters, but the only "
"hard requirement is that it must not contain the string ``__``."
msgstr ""
"仔细观察实现过程，第一个要求的属性是 ``lookup_name``。它能让 ORM 理解如何编"
"译 ``name_ne`` 并使用 ``NotEqual`` 来建立 SQL 语句。按照惯例，这些名字应该总"
"是仅包含小写字母的字符串，但是绝对不能包含双下划线 ``__``。"

msgid ""
"We then need to define the ``as_sql`` method. This takes a ``SQLCompiler`` "
"object, called ``compiler``,  and the active database connection. "
"``SQLCompiler`` objects are not documented, but the only thing we need to "
"know about them is that they have a ``compile()`` method which returns a "
"tuple containing an SQL string, and the parameters to be interpolated into "
"that string. In most cases, you don't need to use it directly and can pass "
"it on to ``process_lhs()`` and ``process_rhs()``."
msgstr ""
"之后我们需要定义 ``as_sql`` 方法。此方法需要一个 ``SQLCompiler`` 对象, 被叫"
"做 ``compiler``，和一个有效的数据库连接。``SQLCompller`` 对象没有文档，我们只"
"需要知道它有一个 ``compile()`` 方法可以返回一个包括 SQL 字符串的元组，和插入"
"这个字符串的参数。大部分情况下，你不需要直接使用这个对象你可以把它传送给 "
"``process_lhs()`` 和 ``process_rhs()``。"

msgid ""
"A ``Lookup`` works against two values, ``lhs`` and ``rhs``, standing for "
"left-hand side and right-hand side. The left-hand side is usually a field "
"reference, but it can be anything implementing the :ref:`query expression "
"API <query-expression>`. The right-hand is the value given by the user. In "
"the example ``Author.objects.filter(name__ne='Jack')``, the left-hand side "
"is a reference to the ``name`` field of the ``Author`` model, and ``'Jack'`` "
"is the right-hand side."
msgstr ""
"``Lookup`` 工作依靠两个值，``lhs`` 和 ``rhs``，代表左右两边，左边是一个字段参"
"考，它可以是任何实现了 :ref:`查询表达式 API <query-expression>` 的实例。右边"
"是一个用户给定的数值。举个例子： ``Author.objects.filter(name__ne='Jack')``，"
"左边是 ``Author`` 模型的 ``name`` 字段，右边是 ``'Jack'``。"

msgid ""
"We call ``process_lhs`` and ``process_rhs`` to convert them into the values "
"we need for SQL using the ``compiler`` object described before. These "
"methods return tuples containing some SQL and the parameters to be "
"interpolated into that SQL, just as we need to return from our ``as_sql`` "
"method. In the above example, ``process_lhs`` returns ``('\"author\"."
"\"name\"', [])`` and ``process_rhs`` returns ``('\"%s\"', ['Jack'])``. In "
"this example there were no parameters for the left hand side, but this would "
"depend on the object we have, so we still need to include them in the "
"parameters we return."
msgstr ""
"我们利用 ``process_lhs`` 和 ``process_rhs`` 将他们转换为我们期望值，用于之前"
"介绍的 ``compiler`` 对象执行 SQL。这俩方法返回一个元组，包含一些 SQL 语句和插"
"入 SQL 语句一些参数，就像是 ``as_sql`` 方法需要返回的。前文所述的例子中，"
"``process_lhs`` 返回 ``('\"author\".\"name\"', [])``，``process_lhs`` 返回 "
"``('\"%s\"', ['Jack'])``。在这个例子里面没有手边的参数，这需要看情况而定，所"
"以我们仍需要在返回结果时包括这些参数。"

msgid ""
"Finally we combine the parts into an SQL expression with ``<>``, and supply "
"all the parameters for the query. We then return a tuple containing the "
"generated SQL string and the parameters."
msgstr ""
"最后，我们将这些部分组合成一个带有 ``<>`` 的 SQL 表达式，并提供查询的所有参"
"数。 然后我们返回一个包含生成的 SQL 字符串和参数的元组。"

msgid "A transformer example"
msgstr "一个转换器示例。"

msgid ""
"The custom lookup above is great, but in some cases you may want to be able "
"to chain lookups together. For example, let's suppose we are building an "
"application where we want to make use of the ``abs()`` operator. We have an "
"``Experiment`` model which records a start value, end value, and the change "
"(start - end). We would like to find all experiments where the change was "
"equal to a certain amount (``Experiment.objects.filter(change__abs=27)``), "
"or where it did not exceed a certain amount (``Experiment.objects."
"filter(change__abs__lt=27)``)."
msgstr ""
"上面的自定义查询器没问题，但在某些情况下，您可能希望能够将一些查询器链接在一"
"起。 例如，假设我们正在构建一个使用 ``abs()`` 运算的应用程序。我们有一个 "
"``Experiment`` 模型，它记录起始值，结束值和差值（起始 - 结束）。 我们想找到 "
"change 属性等于某个数值的所有 Experiment 对象(``Experiment.objects."
"filter(change__abs = 27)``)，change属性没有超过一定数量的 Experiment 对象"
"(``Experiment.objects.filter(change__abs__lt= 27)``)。"

msgid ""
"This example is somewhat contrived, but it nicely demonstrates the range of "
"functionality which is possible in a database backend independent manner, "
"and without duplicating functionality already in Django."
msgstr ""
"这个例子有点刻意，但它很好地演示了以数据库后端独立方式可能实现的功能范围，并"
"且没有重复 Django 中的功能。"

msgid ""
"We will start by writing an ``AbsoluteValue`` transformer. This will use the "
"SQL function ``ABS()`` to transform the value before comparison::"
msgstr ""
"我们将从编写一个 ``AbsoluteValue`` 变换器开始。 这将使用 SQL 中的 ``ABS()`` "
"函数在比较进行之前转换值::"

msgid "Next, let's register it for ``IntegerField``::"
msgstr "下一步，让我们为其注册 ``IntrgerField``::"

msgid ""
"We can now run the queries we had before. ``Experiment.objects."
"filter(change__abs=27)`` will generate the following SQL:"
msgstr ""
"现在可以运行我们先前已有的查询了。``Experiment.objects."
"filter(change__abs=27)`` 将生成下面的 SQL 语句::"

msgid ""
"By using ``Transform`` instead of ``Lookup`` it means we are able to chain "
"further lookups afterward. So ``Experiment.objects."
"filter(change__abs__lt=27)`` will generate the following SQL:"
msgstr ""
"使用 ``Transform`` 代替 ``Lookup`` 意味着我们可以在后面联锁更多的查询，所以 "
"``Experiment.objects.filter(change__abs__lt=27)`` 将会生成下面的 SQL："

msgid ""
"Note that in case there is no other lookup specified, Django interprets "
"``change__abs=27`` as ``change__abs__exact=27``."
msgstr ""
"请注意，如果没有指定其他查找定义，Django则会将 ``change__abs=27`` 解析为 "
"``change__abs__exact=27``。"

msgid ""
"This also allows the result to be used in ``ORDER BY`` and ``DISTINCT ON`` "
"clauses. For example ``Experiment.objects.order_by('change__abs')`` "
"generates:"
msgstr ""
"这也允许把结果用在 ``ORDER BY`` 和 ``DISTINCT ON`` 子句中。例如 ``Experiment."
"objects.order_by('change__abs')`` 生成:"

msgid ""
"And on databases that support distinct on fields (such as PostgreSQL), "
"``Experiment.objects.distinct('change__abs')`` generates:"
msgstr ""
"并且在支持对字段使用 distinct 的数据库中（比如 PostgreSQL），``Experiment."
"objects.distinct('change__abs')`` 会产生："

msgid ""
"When looking for which lookups are allowable after the ``Transform`` has "
"been applied, Django uses the ``output_field`` attribute. We didn't need to "
"specify this here as it didn't change, but supposing we were applying "
"``AbsoluteValue`` to some field which represents a more complex type (for "
"example a point relative to an origin, or a complex number) then we may have "
"wanted to specify that the transform returns a ``FloatField`` type for "
"further lookups. This can be done by adding an ``output_field`` attribute to "
"the transform::"
msgstr ""
"当我们在应用 ``Transform`` 之后查找允许执行哪些查找时，Django 使用 "
"``output_field`` 属性。 我们不需要在这里指定它，因为它没有改变，但假设我们将 "
"``AbsoluteValue`` 应用于某个字段，该字段表示更复杂的类型（例如，相对于原点的"
"点或复数） 那么我们可能想要指定转换返回一个 ``FloatField`` 类型以进行进一步的"
"查找。 这可以通过在变换中添加 ``output_field`` 属性来完成::"

msgid ""
"This ensures that further lookups like ``abs__lte`` behave as they would for "
"a ``FloatField``."
msgstr "这确保了像 ``abs__lte`` 这样的进一步查找与对 ``FloatField`` 一致。"

msgid "Writing an efficient ``abs__lt`` lookup"
msgstr "编写一个高效的 ``abs__lt`` 查找"

msgid ""
"When using the above written ``abs`` lookup, the SQL produced will not use "
"indexes efficiently in some cases. In particular, when we use "
"``change__abs__lt=27``, this is equivalent to ``change__gt=-27`` AND "
"``change__lt=27``. (For the ``lte`` case we could use the SQL ``BETWEEN``)."
msgstr ""
"当使用上面写的 ``abs`` 查找时，生成的 SQL 在某些情况下不会有效地使用索引。 特"
"别是，当我们使用 ``change__abs__lt=27`` 时，这相当于 ``change__gt=-27`` 和 "
"``change__lt=27``。（对于 ``lte`` 情况，我们可以使用 SQL ``BETWEEN``）。"

msgid ""
"So we would like ``Experiment.objects.filter(change__abs__lt=27)`` to "
"generate the following SQL:"
msgstr ""
"所以我们期望 ``Experiment.objects.filter(change__abs__lt=27)``  会生成下列 "
"SQL 语句 ::"

msgid "The implementation is::"
msgstr "实现方式是::"

msgid ""
"There are a couple of notable things going on. First, "
"``AbsoluteValueLessThan`` isn't calling ``process_lhs()``. Instead it skips "
"the transformation of the ``lhs`` done by ``AbsoluteValue`` and uses the "
"original ``lhs``. That is, we want to get ``\"experiments\".\"change\"`` not "
"``ABS(\"experiments\".\"change\")``. Referring directly to ``self.lhs.lhs`` "
"is safe as ``AbsoluteValueLessThan`` can be accessed only from the "
"``AbsoluteValue`` lookup, that is the ``lhs`` is always an instance of "
"``AbsoluteValue``."
msgstr ""
"这里有几件值得注意的事情。首先，``AbsoluteValueLessThan`` 没有调用 "
"``process_lhs()``。 相反，它会跳过由 ``AbsoluteValue`` 完成的 ``lhs`` 的转"
"换，并使用原始的 ``lhs``。也就是说，我们希望得到 ``\"experiments\"."
"\"change\"``，而不是 ``ABS(\"experiments\".\"change\")`` 。直接引用 ``self."
"lhs.lhs`` 是安全的，因为 ``AbsoluteValueLessThan`` 只能从 ``AbsoluteValue`` "
"lookup 访问，即 ``lhs`` 总是 ``AbsoluteValue`` 的实例。"

msgid ""
"Notice also that  as both sides are used multiple times in the query the "
"params need to contain ``lhs_params`` and ``rhs_params`` multiple times."
msgstr ""
"另请注意，由于在查询中多次使用两边，所以需要多次包含 ``lhs_params`` 和 "
"``rhs_params`` 参数。"

msgid ""
"The final query does the inversion (``27`` to ``-27``) directly in the "
"database. The reason for doing this is that if the ``self.rhs`` is something "
"else than a plain integer value (for example an ``F()`` reference) we can't "
"do the transformations in Python."
msgstr ""
"最后的查询直接在数据库中进行反转（ `27` 到 `-27` ）。 这样做的原因是，如果 "
"``self.rhs`` 不是普通的整数值（例如 `F()` 引用），我们就不能在 Python 中进行"
"转换。"

msgid ""
"In fact, most lookups with ``__abs`` could be implemented as range queries "
"like this, and on most database backends it is likely to be more sensible to "
"do so as you can make use of the indexes. However with PostgreSQL you may "
"want to add an index on ``abs(change)`` which would allow these queries to "
"be very efficient."
msgstr ""
"实际上，大多数的利用 ``__abs`` 的查找都可以被转换为类似此的范围查找，且在大多"
"数数据库后端来说，这样做能更好的利用索引。不过，对于 PostgreSQL，你可能会为 "
"``abs(change)`` 添加索引，这会使查找更加高效。"

msgid "A bilateral transformer example"
msgstr "一个双向转换器示例"

msgid ""
"The ``AbsoluteValue`` example we discussed previously is a transformation "
"which applies to the left-hand side of the lookup. There may be some cases "
"where you want the transformation to be applied to both the left-hand side "
"and the right-hand side. For instance, if you want to filter a queryset "
"based on the equality of the left and right-hand side insensitively to some "
"SQL function."
msgstr ""
"前文所述的 ``AbsoluteValue`` 例子实现了左侧查询。在某些场景下，你期望转换器同"
"时作用于左侧和右侧。例如，如果你想在左侧基于等式进行过滤，而右侧对于某些 SQL "
"函数不敏感。"

msgid ""
"Let's examine case-insensitive transformations here. This transformation "
"isn't very useful in practice as Django already comes with a bunch of built-"
"in case-insensitive lookups, but it will be a nice demonstration of "
"bilateral transformations in a database-agnostic way."
msgstr ""
"让我们在此测试这个大小写转换器。实际上这个转换器不是非常实用，因为 Django 已"
"经内置了一系列大小写敏感相关的查询器，但它将是双向转换的一个很好的演示，且通"
"过与数据库无关的方式来演示。"

msgid ""
"We define an ``UpperCase`` transformer which uses the SQL function "
"``UPPER()`` to transform the values before comparison. We define :attr:"
"`bilateral = True <django.db.models.Transform.bilateral>` to indicate that "
"this transformation should apply to both ``lhs`` and ``rhs``::"
msgstr ""
"我们定义了一个 ``UpperCase`` 转换器，使用了 SQL 函数 ``UPPER()``，在比较之前"
"转换值。我们定义了:attr:`bilateral = True <django.db.models.Transform."
"bilateral>` 指明此转换应同时用于 ``lhs`` 和 ``rhs``::"

msgid "Next, let's register it::"
msgstr "下一步, 让我们注册它::"

msgid ""
"Now, the queryset ``Author.objects.filter(name__upper=\"doe\")`` will "
"generate a case insensitive query like this:"
msgstr ""
"现在， ``Author.objects.filter(name__upper=\"doe\")`` 将会产生一个不区分大小"
"写的查询如下："

msgid "Writing alternative implementations for existing lookups"
msgstr "为现有的查找编写代替实现"

msgid ""
"Sometimes different database vendors require different SQL for the same "
"operation. For this example we will rewrite a custom implementation for "
"MySQL for the NotEqual operator. Instead of ``<>`` we will be using ``!=`` "
"operator. (Note that in reality almost all databases support both, including "
"all the official databases supported by Django)."
msgstr ""
"有时候，不同的数据库提供商对相同的操作要求不同的 SQL 语句。针对此例子，我们会"
"为 MySQL 重写 NotEqual 操作符。使用 ``!=`` 操作符替代 ``<>``。（注意，实际上"
"几乎所有的数据两者都支持，包括 Django 支持的所有正式数据库）。"

msgid ""
"We can change the behavior on a specific backend by creating a subclass of "
"``NotEqual`` with an ``as_mysql`` method::"
msgstr ""
"我们可以通过使用 ``as_mysql`` 方法创建 ``NotEqual`` 的子类来更改特定后端的行"
"为::"

msgid ""
"We can then register it with ``Field``. It takes the place of the original "
"``NotEqual`` class as it has the same ``lookup_name``."
msgstr ""
"接着，我们可以里利用 ``Field`` 注册它。它会替换之前的 ``NotEqual`` 类，因为拥"
"有相同的 ``lookup_name``。"

msgid ""
"When compiling a query, Django first looks for ``as_%s % connection.vendor`` "
"methods, and then falls back to ``as_sql``. The vendor names for the in-"
"built backends are ``sqlite``, ``postgresql``, ``oracle`` and ``mysql``."
msgstr ""
"编译查询指令是，Django 先查找 ``as_%s % connection.vendor`` 方法，其次 "
"``as_sql``。内置后端的提供商名为 ``sqlite``，``postgresql``，``oracle`` 和 "
"``mysql``。"

msgid "How Django determines the lookups and transforms which are used"
msgstr "Django 是如何取舍查询器和转换器的"

msgid ""
"In some cases you may wish to dynamically change which ``Transform`` or "
"``Lookup`` is returned based on the name passed in, rather than fixing it. "
"As an example, you could have a field which stores coordinates or an "
"arbitrary dimension, and wish to allow a syntax like ``."
"filter(coords__x7=4)`` to return the objects where the 7th coordinate has "
"value 4. In order to do this, you would override ``get_lookup`` with "
"something like::"
msgstr ""
"某些场景下，你可能期望基于传入的名字动态地返回 ``Transform`` 或 ``Lookup``，"
"而不是指定。例如，有一个字段，存储了一些坐标或尺寸，期望使用以下语法 ``."
"filter(coords__x7=4)`` 返回第七个值为 4 的坐标。为此，你需要用以下内容重写 "
"``get_lookup``::"

msgid ""
"You would then define ``get_coordinate_lookup`` appropriately to return a "
"``Lookup`` subclass which handles the relevant value of ``dimension``."
msgstr ""
"随后你需要定义 ``get_coordinate_lookup`` 正确地返回一个 ``Lookup`` 子类，用于"
"处理 ``dimension`` 的相关值。"

msgid ""
"There is a similarly named method called ``get_transform()``. "
"``get_lookup()`` should always return a ``Lookup`` subclass, and "
"``get_transform()`` a ``Transform`` subclass. It is important to remember "
"that ``Transform`` objects can be further filtered on, and ``Lookup`` "
"objects cannot."
msgstr ""
"有个类似的名字叫做 ``get_transform()``。``get_lookup()`` 总是要返回 "
"``Lookup`` 子类，而 ``get_transform`` 要返回 ``Transform`` 子类。千万牢记，"
"``Transform`` 对象能被进一步过滤，而 ``Lookup`` 对象不能。"

msgid ""
"When filtering, if there is only one lookup name remaining to be resolved, "
"we will look for a ``Lookup``. If there are multiple names, it will look for "
"a ``Transform``. In the situation where there is only one name and a "
"``Lookup`` is not found, we look for a ``Transform`` and then the ``exact`` "
"lookup on that ``Transform``. All call sequences always end with a "
"``Lookup``. To clarify:"
msgstr ""
"过滤时，若只能找到一个名字，我们会查找 ``Lookup``。如果有多个名字，将会寻找 "
"``Transform``。在某种情况下，仅有一个名字，且未找到 ``Lookup``，我们将查找 "
"``Transform``，并附加 ``exact`` 查询器。所以的系列调用都以一个 ``Lookup`` 结"
"束。简单说明："

msgid ""
"``.filter(myfield__mylookup)`` will call ``myfield.get_lookup('mylookup')``."
msgstr ""
"``.filter(myfield__mylookup)`` 将会调用 ``myfield.get_lookup('mylookup')``。"

msgid ""
"``.filter(myfield__mytransform__mylookup)`` will call ``myfield."
"get_transform('mytransform')``, and then ``mytransform."
"get_lookup('mylookup')``."
msgstr ""
"``.filter(myfield__mytransform__mylookup)`` 将会调用 ``myfield."
"get_transform('mytransform')``, 接着调用 ``mytransform."
"get_lookup('mylookup')``。"

msgid ""
"``.filter(myfield__mytransform)`` will first call ``myfield."
"get_lookup('mytransform')``, which will fail, so it will fall back to "
"calling ``myfield.get_transform('mytransform')`` and then ``mytransform."
"get_lookup('exact')``."
msgstr ""
"``.filter(myfield__mytransform)`` 会先调用 ``myfield."
"get_lookup('mytransform')``，失败，然后回滚调用 ``myfield."
"get_transform('mytransform')``，随后返回 ``mytransform."
"get_lookup('exact')``。"

msgid "How to create custom ``django-admin`` commands"
msgstr "编写自定义 ``django-admin`` 命令"

msgid ""
"Applications can register their own actions with ``manage.py``. For example, "
"you might want to add a ``manage.py`` action for a Django app that you're "
"distributing. In this document, we will be building a custom ``closepoll`` "
"command for the ``polls`` application from the :doc:`tutorial</intro/"
"tutorial01>`."
msgstr ""
"应用程序可以用 ``manage.py`` 注册自己的动作。例如，你可能想为你正在分发的 "
"Django 应用添加一个 ``manage.py`` 动作。在本文档中，我们将为 :doc:`教程 </"
"intro/tutorial01>` 中的 ``polls`` 应用程序构建一个自定义的 ``closepoll`` 命"
"令。"

msgid ""
"To do this, add a ``management/commands`` directory to the application. "
"Django will register a ``manage.py`` command for each Python module in that "
"directory whose name doesn't begin with an underscore. For example:"
msgstr ""
"要做到这一点，将一个 ``management/commands`` 目录添加到应用程序中。Django 将"
"为该目录中名称不以下划线开头的每个 Python 模块注册一个 ``manage.py`` 命令。例"
"如："

msgid ""
"In this example, the ``closepoll`` command will be made available to any "
"project that includes the ``polls`` application in :setting:`INSTALLED_APPS`."
msgstr ""
"在这个例子中，``closepoll`` 命令将提供给任何在 :setting:`INSTALLED_APPS` 中包"
"含 ``polls`` 应用程序的项目。"

msgid ""
"The ``_private.py`` module will not be available as a management command."
msgstr "``_private.py`` 模块将不会作为管理命令使用。"

msgid ""
"The ``closepoll.py`` module has only one requirement -- it must define a "
"class ``Command`` that extends :class:`BaseCommand` or one of its :ref:"
"`subclasses<ref-basecommand-subclasses>`."
msgstr ""
"``closepoll.py`` 模块只有一个要求——必须定义 ``Command`` 类，该类继承自 :"
"class:`BaseCommand` 或其 :ref:`子类 <ref-basecommand-subclasses>`。"

msgid "Standalone scripts"
msgstr "独立的脚本"

msgid ""
"Custom management commands are especially useful for running standalone "
"scripts or for scripts that are periodically executed from the UNIX crontab "
"or from Windows scheduled tasks control panel."
msgstr ""
"自定义管理命令在运行独立脚本命令方面十分有用，也可用于 UNIX 的周期性 crontab "
"任务，或是 Windows 的定时任务。"

msgid ""
"To implement the command, edit ``polls/management/commands/closepoll.py`` to "
"look like this::"
msgstr "要实现该命令，请编辑 ``polls/management/commands/closepoll.py`` 如下："

msgid ""
"When you are using management commands and wish to provide console output, "
"you should write to ``self.stdout`` and ``self.stderr``, instead of printing "
"to ``stdout`` and ``stderr`` directly. By using these proxies, it becomes "
"much easier to test your custom command. Note also that you don't need to "
"end messages with a newline character, it will be added automatically, "
"unless you specify the ``ending`` parameter::"
msgstr ""
"当你使用管理命令并希望提供控制台输出时，你需要 write 至 ``self.stdout`` 和 "
"``self.stderr``，而不是直接 print 至 ``stdout`` 和 ``stderr``。利用这些代理，"
"测试自定义命令会更方便。还需要注意的是，你不需要用换行符来结束消息，它会自动"
"添加，除非你指定了 ``ending`` 参数："

msgid ""
"The new custom command can be called using ``python manage.py closepoll "
"<poll_ids>``."
msgstr ""
"这个新的自定义命令能用 ``python manage.py closepoll <poll_ids>`` 调用。"

msgid ""
"The ``handle()`` method takes one or more ``poll_ids`` and sets ``poll."
"opened`` to ``False`` for each one. If the user referenced any nonexistent "
"polls, a :exc:`CommandError` is raised. The ``poll.opened`` attribute does "
"not exist in the :doc:`tutorial</intro/tutorial02>` and was added to ``polls."
"models.Question`` for this example."
msgstr ""
"``handle()`` 方法接受一个或多个 ``poll_ids``，并将每个 ``poll.opened`` 设置"
"为 ``False``。若用户传入了不存在的 polls，将会抛出 :exc:`CommandError`。:doc:"
"`教程 </intro/tutorial02>` 中不存在 ``poll.opened`` 属性，只是这里为了本例添"
"加至 ``polls.models.Question`` 的。"

msgid "Accepting optional arguments"
msgstr "接受可选参数"

msgid ""
"The same ``closepoll`` could be easily modified to delete a given poll "
"instead of closing it by accepting additional command line options. These "
"custom options can be added in the :meth:`~BaseCommand.add_arguments` method "
"like this::"
msgstr ""
"同样的 ``closepoll`` 可以很容易地修改，通过接受额外的命令行选项来删除一个给定"
"的投票，而不是关闭它。这些自定义选项可以在 :meth:`~BaseCommand."
"add_arguments` 方法中添加，比如："

msgid ""
"The option (``delete`` in our example) is available in the options dict "
"parameter of the handle method. See the :py:mod:`argparse` Python "
"documentation for more about ``add_argument`` usage."
msgstr ""
"选项（本例中 ``delete``）是由 handle 方法的 options 字典参数传入的。参见 "
"Python 文档查询 :py:mod:`argparse`，获取更多 ``add_argument`` 的用法。"

msgid ""
"In addition to being able to add custom command line options, all :doc:"
"`management commands</ref/django-admin>` can accept some default options "
"such as :option:`--verbosity` and :option:`--traceback`."
msgstr ""
"为了能添加自定义命令选项，所以的 :doc:`管理命令 </ref/django-admin>` 都能接受"
"一些默认选项，例如 :option:`--verbosity` 和 :option:`--traceback`。"

msgid "Management commands and locales"
msgstr "管理命令和本地化"

msgid ""
"By default, management commands are executed with the current active locale."
msgstr "默认情况下，管理命令以当前活动的 locale 执行。"

msgid ""
"If, for some reason, your custom management command must run without an "
"active locale (for example, to prevent translated content from being "
"inserted into the database), deactivate translations using the "
"``@no_translations`` decorator on your :meth:`~BaseCommand.handle` method::"
msgstr ""
"如果由于某些原因，你的自定义管理命令必须在没有活动的 locale 的情况下运行（例"
"如，为了防止翻译的内容被插入数据库），请在你的 :meth:`~BaseCommand.handle` 方"
"法上使用 ``@no_translations`` 装饰器停用翻译："

msgid ""
"Since translation deactivation requires access to configured settings, the "
"decorator can't be used for commands that work without configured settings."
msgstr ""
"由于禁用翻译需要使用配置文件，故装饰器不能用于那些不加载配置文件的命令。"

msgid "Testing"
msgstr "测试"

msgid ""
"Information on how to test custom management commands can be found in the :"
"ref:`testing docs <topics-testing-management-commands>`."
msgstr ""
"关于如何测试自定义管理命令的内容可在 :ref:`测试文档 <topics-testing-"
"management-commands>` 中找到。"

msgid "Overriding commands"
msgstr "覆盖命令"

msgid ""
"Django registers the built-in commands and then searches for commands in :"
"setting:`INSTALLED_APPS` in reverse. During the search, if a command name "
"duplicates an already registered command, the newly discovered command "
"overrides the first."
msgstr ""
"Django 先注册内置命令，然后按相反的顺序在 :setting:`INSTALLED_APPS` 查找命"
"令。在查找时，如果一个命令和已注册的命令重名，这个新发现的命令会覆盖第一个命"
"令。"

msgid ""
"In other words, to override a command, the new command must have the same "
"name and its app must be before the overridden command's app in :setting:"
"`INSTALLED_APPS`."
msgstr ""
"换句话说，为了覆盖一个命令，新命令必须有同样的名字并且它的 app 在 :setting:"
"`INSTALLED_APPS` 中必须排在被覆盖命令 app 的前面。"

msgid ""
"Management commands from third-party apps that have been unintentionally "
"overridden can be made available under a new name by creating a new command "
"in one of your project's apps (ordered before the third-party app in :"
"setting:`INSTALLED_APPS`) which imports the ``Command`` of the overridden "
"command."
msgstr ""
"第三方应用提供的管理命令若被不小心重写，能通过在你项目中的某个应用（在 :"
"setting:`INSTALLED_APPS` 配置在第三方应用之前）创建新命令的方式为其取个别名，"
"另其能被调用。这个应用需要导入被重写的 ``Command``。"

msgid "Command objects"
msgstr "命令对象"

msgid "The base class from which all management commands ultimately derive."
msgstr "所有管理命令最终派生的基类。"

msgid ""
"Use this class if you want access to all of the mechanisms which parse the "
"command-line arguments and work out what code to call in response; if you "
"don't need to change any of that behavior, consider using one of its :ref:"
"`subclasses<ref-basecommand-subclasses>`."
msgstr ""
"如果你想处理解析命令行参数，决定调用什么代码的过程，使用这个类。如果你不需要"
"改变任何行为，考虑直接使用它的某个 :ref:`子类 <ref-basecommand-subclasses>`。"

msgid ""
"Subclassing the :class:`BaseCommand` class requires that you implement the :"
"meth:`~BaseCommand.handle` method."
msgstr ""
"继承 :class:`BaseCommand` 要求你重写 :meth:`~BaseCommand.handle` 方法。"

msgid "Attributes"
msgstr "属性"

msgid ""
"All attributes can be set in your derived class and can be used in :class:"
"`BaseCommand`’s :ref:`subclasses<ref-basecommand-subclasses>`."
msgstr ""
"能被你派生的子类设置的，且能被 :class:`BaseCommand` 的 :ref:`子类 <ref-"
"basecommand-subclasses>` 使用的属性。"

msgid ""
"A short description of the command, which will be printed in the help "
"message when the user runs the command ``python manage.py help <command>``."
msgstr ""
"命令简介，当用户运行命令 ``python manage.py help <command>`` 时包含在打印的帮"
"助信息内。"

msgid ""
"If your command defines mandatory positional arguments, you can customize "
"the message error returned in the case of missing arguments. The default is "
"output by :py:mod:`argparse` (\"too few arguments\")."
msgstr ""
"如果你的命令定义了必须的位置参数，你可以在缺失参数时返回自定义错误消息。默认"
"输出由 :py:mod:`argparse` 打印(\"too few arguments\")。"

msgid ""
"A boolean indicating whether the command outputs SQL statements; if "
"``True``, the output will automatically be wrapped with ``BEGIN;`` and "
"``COMMIT;``. Default value is ``False``."
msgstr ""
"一个布尔值，决定命令是否暑输出 SQL 语句；若为 ``True``，输出内容会自动以 "
"``BEGIN;`` 和 ``COMMIT;`` 包裹。默认值为 ``False``。"

msgid ""
"A boolean; if ``True``, the command prints a warning if the set of "
"migrations on disk don't match the migrations in the database. A warning "
"doesn't prevent the command from executing. Default value is ``False``."
msgstr ""
"一个布尔值；若为 ``True``，命令会在硬盘上存储的 migrations 与 数据库中的不一"
"致时打印警告。警告不会阻止命令执行。默认值为 ``False``。"

msgid ""
"A list or tuple of tags, e.g. ``[Tags.staticfiles, Tags.models]``. System "
"checks :ref:`registered in the chosen tags <registering-labeling-checks>` "
"will be checked for errors prior to executing the command. The value "
"``'__all__'`` can be used to specify that all system checks should be "
"performed. Default value is ``'__all__'``."
msgstr ""
"一个标签的列表或元组，例如 ``[Tags.staticfiles, Tags.models]`` 。系统会在执行"
"命令 :ref:`registered in the chosen tags <registering-labeling-checks>` 之前"
"检查是否有错误。值 ``'__all__'`` 可用于指定应执行所有系统检查。  默认值为 "
"``'__all__'`` 。"

msgid ""
"An instance attribute that helps create colored output when writing to "
"``stdout`` or ``stderr``. For example::"
msgstr "一个实例属性，用于向 ``stdout`` 或 ``stderr`` 输出彩色内容。例如::"

msgid ""
"See :ref:`syntax-coloring` to learn how to modify the color palette and to "
"see the available styles (use uppercased versions of the \"roles\" described "
"in that section)."
msgstr ""
"参考 :ref:`syntax-coloring` 了解如何修改调色板与现成的样式（使用本节介绍的大"
"写字母版本的 \"roles\"）。"

msgid ""
"If you pass the :option:`--no-color` option when running your command, all "
"``self.style()`` calls will return the original string uncolored."
msgstr ""
"如果运行命令时传递了 :option:`--no-color` 选项，所有的 ``self.style()`` 调用"
"会返回未染色的原始字符串。"

msgid ""
"The default command options to suppress in the help output. This should be a "
"set of option names (e.g. ``'--verbosity'``). The default values for the "
"suppressed options are still passed."
msgstr ""
"要在帮助输出中取消显示的默认命令选项。这应该是一个选项名称的集合（例如，``'--"
"verbosity'``）。取消显示的选项仍然传递其默认值。"

msgid "Methods"
msgstr "方法"

msgid ""
":class:`BaseCommand` has a few methods that can be overridden but only the :"
"meth:`~BaseCommand.handle` method must be implemented."
msgstr ""
":class:`BaseCommand` 有很多方法可供重写，不过仅有 :meth:`~BaseCommand."
"handle` 是必须实现的。"

msgid "Implementing a constructor in a subclass"
msgstr "子类中实现构造器"

msgid ""
"If you implement ``__init__`` in your subclass of :class:`BaseCommand`, you "
"must call :class:`BaseCommand`’s ``__init__``::"
msgstr ""
"若 :class:`BaseCommand` 的子类实现了 ``__init__`` 方法，那么就必须调用 :"
"class:`BaseCommand` 的 ``__init__``::"

msgid ""
"Returns a ``CommandParser`` instance, which is an :class:`~argparse."
"ArgumentParser` subclass with a few customizations for Django."
msgstr ""
"返回一个 ``CommandParser`` 实例，它是 :class:`~argparse.ArgumentParser` 的子"
"类，包含一些针对 Django 的个性化设计。"

msgid ""
"You can customize the instance by overriding this method and calling "
"``super()`` with ``kwargs`` of :class:`~argparse.ArgumentParser` parameters."
msgstr ""
"你可以自定义这个实例，通过重写此方法，并为  ``super()`` 方法传入值为 :class:"
"`~argparse.ArgumentParser` 的 ``kwargs`` 参数。"

msgid ""
"Entry point to add parser arguments to handle command line arguments passed "
"to the command. Custom commands should override this method to add both "
"positional and optional arguments accepted by the command. Calling "
"``super()`` is not needed when directly subclassing ``BaseCommand``."
msgstr ""
"添加命令行转换参数的入口，用于处理传给命令行的参数。自定义命令需要重写此方"
"法，并同时添加命令接受的位置参数和可选参数。直接使用 ``BaseCommand`` 的子类时"
"无需调用 ``super()``。"

msgid ""
"Returns the Django version, which should be correct for all built-in Django "
"commands. User-supplied commands can override this method to return their "
"own version."
msgstr ""
"返回 Django 版本，内置 Django 命令必须正确返回。用户实现的命令可以重写此方法"
"返回自己的版本。"

msgid ""
"Tries to execute this command, performing system checks if needed (as "
"controlled by the :attr:`requires_system_checks` attribute). If the command "
"raises a :exc:`CommandError`, it's intercepted and printed to ``stderr``."
msgstr ""
"尝试执行此命令，根据 :attr:`requires_system_checks` 属性控制是否需要执行系统"
"检查。如果命令引发 :exc:`CommandError`，它将被拦截并打印到 ``stderr``。"

msgid "Calling a management command in your code"
msgstr "在你的代码中调用管理命令"

msgid ""
"``execute()`` should not be called directly from your code to execute a "
"command. Use :func:`~django.core.management.call_command` instead."
msgstr ""
"执行命令时，不要从代码直接调用 ``execute()`` 方法。而是使用 :func:`~django."
"core.management.call_command`。"

msgid "The actual logic of the command. Subclasses must implement this method."
msgstr "命令的实际逻辑处理。子类必须实现此方法。"

msgid ""
"It may return a string which will be printed to ``stdout`` (wrapped by "
"``BEGIN;`` and ``COMMIT;`` if :attr:`output_transaction` is ``True``)."
msgstr ""
"此方法可能会返回一个字符串，输出至 ``stdout`` （若 :attr:"
"`output_transaction` 为 ``True``，则由 ``BEGIN;`` 和 ``COMMIT`` 包裹）。"

msgid ""
"Uses the system check framework to inspect the entire Django project for "
"potential problems. Serious problems are raised as a :exc:`CommandError`; "
"warnings are output to ``stderr``; minor notifications are output to "
"``stdout``."
msgstr ""
"使用系统检查框架来检查整个 Django 项目中的潜在问题。严重的问题将作为 :exc:"
"`CommandError` 引发；警告将输出到 ``stderr``；较小的通知将输出到 ``stdout``。"

msgid ""
"If ``app_configs`` and ``tags`` are both ``None``, all system checks are "
"performed. ``tags`` can be a list of check tags, like ``compatibility`` or "
"``models``."
msgstr ""
"若 ``app_configs`` 和 ``tags`` 均为 ``None``，所以的系统检查项都会被运行。"
"``tags`` 能是一个检查标签的列表，例如 ``compatibility`` 或 ``models``。"

msgid "``BaseCommand`` subclasses"
msgstr "``BaseCommand`` 的子类"

msgid ""
"A management command which takes one or more installed application labels as "
"arguments, and does something with each of them."
msgstr "管理命令接受一个或多个应用标签参数，并对每项应用做某些事。"

msgid ""
"Rather than implementing :meth:`~BaseCommand.handle`, subclasses must "
"implement :meth:`~AppCommand.handle_app_config`, which will be called once "
"for each application."
msgstr ""
"子类必须实现 :meth:`~AppCommand.handle_app_config`，而不是 :meth:"
"`~BaseCommand.handle`。此方法会为每个应用调用一次。"

msgid ""
"Perform the command's actions for ``app_config``, which will be an :class:"
"`~django.apps.AppConfig` instance corresponding to an application label "
"given on the command line."
msgstr ""
"为 ``app_config`` 运行命令，这会是 :class:`~django.apps.AppConfig` 的实例，并"
"指向命令行给定的应用标签。"

msgid ""
"A management command which takes one or more arbitrary arguments (labels) on "
"the command line, and does something with each of them."
msgstr ""
"一个管理命令，从命令行接受一个或任意多个参数(labels)，并针对每项做些事情。"

msgid ""
"Rather than implementing :meth:`~BaseCommand.handle`, subclasses must "
"implement :meth:`~LabelCommand.handle_label`, which will be called once for "
"each label."
msgstr ""
"子类必须实现 :meth:`~LabelCommand.handle_label`，而不是 :meth:`~BaseCommand."
"handle`。此方法会为每个应用调用一次。"

msgid ""
"A string describing the arbitrary arguments passed to the command. The "
"string is used in the usage text and error messages of the command. Defaults "
"to ``'label'``."
msgstr ""
"一个字符串，介绍了传递给命令的任意多个参数。此字符串用于命令的用法文本和错误"
"消息。默认为 ``'label'``。"

msgid ""
"Perform the command's actions for ``label``, which will be the string as "
"given on the command line."
msgstr "运行 ``label`` 指定的命令动作，由命令行传入的字符串指定。"

msgid "Command exceptions"
msgstr "命令异常"

msgid ""
"Exception class indicating a problem while executing a management command."
msgstr "异常类说明在运行管理命令时出错了。"

msgid ""
"If this exception is raised during the execution of a management command "
"from a command line console, it will be caught and turned into a nicely-"
"printed error message to the appropriate output stream (i.e., ``stderr``); "
"as a result, raising this exception (with a sensible description of the "
"error) is the preferred way to indicate that something has gone wrong in the "
"execution of a command. It accepts the optional ``returncode`` argument to "
"customize the exit status for the management command to exit with, using :"
"func:`sys.exit`."
msgstr ""
"如果在从命令行控制台执行管理命令期间引发此异常，它将被捕获并转换为适当输出流"
"（即 ``stderr``）上的精美打印的错误消息；因此，引发此异常（附带一个合理的错误"
"描述）是指示命令执行出现问题的首选方式。它接受可选的 ``returncode`` 参数，以"
"自定义管理命令退出时使用的退出状态，使用 :func:`sys.exit`。"

msgid ""
"If a management command is called from code through :func:`~django.core."
"management.call_command`, it's up to you to catch the exception when needed."
msgstr ""
"如果管理命令是由 :func:`~django.core.management.call_command` 调用的，是否捕"
"获异常取决于你。"

msgid "How to create custom model fields"
msgstr "编写自定义模型字段"

msgid "Introduction"
msgstr "介绍"

msgid ""
"The :doc:`model reference </topics/db/models>` documentation explains how to "
"use Django's standard field classes -- :class:`~django.db.models."
"CharField`, :class:`~django.db.models.DateField`, etc. For many purposes, "
"those classes are all you'll need. Sometimes, though, the Django version "
"won't meet your precise requirements, or you'll want to use a field that is "
"entirely different from those shipped with Django."
msgstr ""
":doc:`字段参考 </topics/db/models>` 文档介绍了如何使用 Django 的标准字段类"
"—— :class:`~django.db.models.CharField`， :class:`~django.db.models."
"DateField`，等等。大多数情况下，这些类就是你需要的。虽然有时候，Django 的版本"
"不能精确地匹配你的需求，或者你想使用的字段与 Django 内置的完全不同。"

msgid ""
"Django's built-in field types don't cover every possible database column "
"type -- only the common types, such as ``VARCHAR`` and ``INTEGER``. For more "
"obscure column types, such as geographic polygons or even user-created types "
"such as `PostgreSQL custom types`_, you can define your own Django ``Field`` "
"subclasses."
msgstr ""
"Django 内置的字段类型并未覆盖所有可能的数据库字段类型——只有常见的类型，例如 "
"``VARCHAR`` 和 ``INTEGER``。对于更多模糊的列类型，例如地理多边形（geographic "
"polygons），甚至是用户创建的类型，例如 `PostgreSQL custom types`_，你可以自定"
"义 Django 的 ``Field`` 子类。"

msgid ""
"Alternatively, you may have a complex Python object that can somehow be "
"serialized to fit into a standard database column type. This is another case "
"where a ``Field`` subclass will help you use your object with your models."
msgstr ""
"或者，你有一个复杂的 Python 对象，它可以以某种形式序列化，适应标准的数据库列"
"类型。这是另一个 ``Field`` 子类能帮助你配合模型使用你的对象的示例。"

msgid "Our example object"
msgstr "我们的示例对象"

msgid ""
"Creating custom fields requires a bit of attention to detail. To make things "
"easier to follow, we'll use a consistent example throughout this document: "
"wrapping a Python object representing the deal of cards in a hand of "
"Bridge_. Don't worry, you don't have to know how to play Bridge to follow "
"this example. You only need to know that 52 cards are dealt out equally to "
"four players, who are traditionally called *north*, *east*, *south* and "
"*west*.  Our class looks something like this::"
msgstr ""
"创建自定义字段要求注意一些细节。为了简化问题，我们在本文档中全程使用同一实"
"例：封装一个 Python 对象，代表手上 桥牌_ 的细节。不要担心，你不需要知道如何玩"
"桥牌就能学习此例子。你只需知道 52 张牌被均分给 4 个玩家，一般称他们 *北*，*东"
"*，*南* 和 *西*。我们的类长这样::"

msgid ""
"This is an ordinary Python class, with nothing Django-specific about it. "
"We'd like to be able to do things like this in our models (we assume the "
"``hand`` attribute on the model is an instance of ``Hand``)::"
msgstr ""
"这是一个一般的 Python 类，其中没有特殊的 Django 内容。我们期望在我们的模块中"
"做如下操作 (我们假设模型中的 ``hand`` 属性是 ``Hand`` 的一个实例)::"

msgid ""
"We assign to and retrieve from the ``hand`` attribute in our model just like "
"any other Python class. The trick is to tell Django how to handle saving and "
"loading such an object."
msgstr ""
"对模型中的 ``hand`` 属性的赋值与取值操作与其它 Python 类一直。技巧是告诉 "
"Django 如何保存和加载对象。"

msgid ""
"In order to use the ``Hand`` class in our models, we **do not** have to "
"change this class at all. This is ideal, because it means you can easily "
"write model support for existing classes where you cannot change the source "
"code."
msgstr ""
"为了在模型中使用 ``Hand`` 类，我们 **不** 需要修改这个类。这很不错，因为这以"
"为着你仅需为已存在的类编写模型支持，即便你不能修改源码。"

msgid ""
"You might only be wanting to take advantage of custom database column types "
"and deal with the data as standard Python types in your models; strings, or "
"floats, for example. This case is similar to our ``Hand`` example and we'll "
"note any differences as we go along."
msgstr ""
"你可能只想要自定义数据库列的优点，并在模型中像使用标准 Python 那样；字符串，"
"或浮点数，等等。这种情况与 ``Hand`` 例子类似，在进行过程中，我们将注意到差"
"异。"

msgid "Background theory"
msgstr "背后的理论"

msgid "Database storage"
msgstr "数据库存储"

msgid ""
"Let's start with model fields. If you break it down, a model field provides "
"a way to take a normal Python object -- string, boolean, ``datetime``, or "
"something more complex like ``Hand`` -- and convert it to and from a format "
"that is useful when dealing with the database. (Such a format is also useful "
"for serialization, but as we'll see later, that is easier once you have the "
"database side under control)."
msgstr ""
"让我们从模型字段开始吧。把它们分开来看，一个模型字段可以在处理数据库时，提供"
"处理一般 Python 对象的方法（字符串，布尔值， ``datetime`` ，或像 ``Hand`` 这"
"样更复杂的类型），并将其转换成有用的格式。（对序列化而言这种格式是很有用的，"
"但接下来我们会看到，如果数据库端处于控制之下，序列化会更简单）"

msgid ""
"Fields in a model must somehow be converted to fit into an existing database "
"column type. Different databases provide different sets of valid column "
"types, but the rule is still the same: those are the only types you have to "
"work with. Anything you want to store in the database must fit into one of "
"those types."
msgstr ""
"模型中的字段必须能以某种方式转换为已存在的数据库列类型。不能的数据库提供不同"
"的可用列类型集，但规则仍相同：你只需要处理这些类型。你想存在数据库中的任何数"
"据都必须能适配这些类型中的某一个。"

msgid ""
"Normally, you're either writing a Django field to match a particular "
"database column type, or you will need a way to convert your data to, say, a "
"string."
msgstr ""
"一般地讲，您要么编写一个 Django 字段来匹配特定的数据库列类型，要么需要一种方"
"法将数据转换为字符串。"

msgid ""
"For our ``Hand`` example, we could convert the card data to a string of 104 "
"characters by concatenating all the cards together in a predetermined order "
"-- say, all the *north* cards first, then the *east*, *south* and *west* "
"cards. So ``Hand`` objects can be saved to text or character columns in the "
"database."
msgstr ""
"对于我们的 ``Hand`` 示例，我们可以通过将所有卡片按预定的顺序连接在一起来将卡"
"片数据转换为一个包含 104 个字符的字符串，例如，首先是所有 *北方* 的卡片，然后"
"是 *东方*、*南方* 和 *西方* 的卡片。因此，``Hand`` 对象可以保存到数据库中的文"
"本或字符列中。"

msgid "What does a field class do?"
msgstr "一个字段(Field)类做了什么？"

msgid ""
"All of Django's fields (and when we say *fields* in this document, we always "
"mean model fields and not :doc:`form fields </ref/forms/fields>`) are "
"subclasses of :class:`django.db.models.Field`. Most of the information that "
"Django records about a field is common to all fields -- name, help text, "
"uniqueness and so forth. Storing all that information is handled by "
"``Field``. We'll get into the precise details of what ``Field`` can do later "
"on; for now, suffice it to say that everything descends from ``Field`` and "
"then customizes key pieces of the class behavior."
msgstr ""
"所有的 Django 字段（本页提到的 *字段* 均指模型字段，而不是 :doc:`表单字段 </"
"ref/forms/fields>`）都是 :class:`django.db.models.Field` 的子类。对于所有字"
"段，Django 记录的大部分信息是一样的——名字，帮助文本，是否唯一，等等。存储行为"
"由 ``Field`` 处理。稍后，我们会深入了解 ``Field`` 能做什么；现在， 可以说万物"
"源于 ``Field``，并在其基础上自定义了类的关键行为。"

msgid ""
"It's important to realize that a Django field class is not what is stored in "
"your model attributes. The model attributes contain normal Python objects. "
"The field classes you define in a model are actually stored in the ``Meta`` "
"class when the model class is created (the precise details of how this is "
"done are unimportant here). This is because the field classes aren't "
"necessary when you're just creating and modifying attributes. Instead, they "
"provide the machinery for converting between the attribute value and what is "
"stored in the database or sent to the :doc:`serializer </topics/"
"serialization>`."
msgstr ""
"了解 Django 字段类不保存在模型属性中很重要。模型属性包含普通的 Python 对象。"
"你所以定义的字段类实际上在模型类创建时在 ``Meta`` 类中（这是如何实现的在这里"
"不重要）。这是因为在仅创建和修改属性时，字段类不是必须的。相反，他们提供了属"
"性值间转换的机制，并决定了什么被存入数据库或发送给 :doc:`序列化器 </topics/"
"serialization>`。"

msgid ""
"Keep this in mind when creating your own custom fields. The Django ``Field`` "
"subclass you write provides the machinery for converting between your Python "
"instances and the database/serializer values in various ways (there are "
"differences between storing a value and using a value for lookups, for "
"example). If this sounds a bit tricky, don't worry -- it will become clearer "
"in the examples below. Just remember that you will often end up creating two "
"classes when you want a custom field:"
msgstr ""
"在你创建自定义字段时牢记这点。你所写的 Django 的 ``Field`` 子类提供了多种在 "
"Python 实例和数据库/序列化器之间的转换机制（比如，保存值和使用值进行查询之间"
"是不同的）。听起来有点迷糊，但别担心——通过以下的例子会清晰起来。只要记住，在"
"你需要一个自定义字段时，只需创建两个类："

msgid ""
"The first class is the Python object that your users will manipulate. They "
"will assign it to the model attribute, they will read from it for displaying "
"purposes, things like that. This is the ``Hand`` class in our example."
msgstr ""
"第一个类是用户需要操作的 Python 对象。它们会复制给模型属性，它们会为了显示而"
"读取属性，就想这样。这里本例中的 ``Hand`` 类。"

msgid ""
"The second class is the ``Field`` subclass. This is the class that knows how "
"to convert your first class back and forth between its permanent storage "
"form and the Python form."
msgstr ""
"第二类是 ``Field`` 的子类。这个类知道如何在永久存储格式和 Python 格式之间来回"
"转换。"

msgid "Writing a field subclass"
msgstr "编写一个 field 子类"

msgid ""
"When planning your :class:`~django.db.models.Field` subclass, first give "
"some thought to which existing :class:`~django.db.models.Field` class your "
"new field is most similar to. Can you subclass an existing Django field and "
"save yourself some work? If not, you should subclass the :class:`~django.db."
"models.Field` class, from which everything is descended."
msgstr ""
"计划编写第一个 :class:`~django.db.models.Field` 子类时，需要先想想新字段和哪"
"个已有的 :class:`~django.db.models.Field` 最相似。你会继承 Django 字段节约你"
"的时间吗？如果不会，你需要继承 :class:`~django.db.models.Field` 类，从它继承"
"了一切。"

msgid ""
"Initializing your new field is a matter of separating out any arguments that "
"are specific to your case from the common arguments and passing the latter "
"to the ``__init__()`` method of :class:`~django.db.models.Field` (or your "
"parent class)."
msgstr ""
"初始化新字段有点麻烦，因为要从公共参数中分离你需要的参数，并将剩下的传给父"
"类 :class:`~django.db.models.Field` 的 ``__init__()`` 方法（或你的父类）。"

msgid ""
"In our example, we'll call our field ``HandField``. (It's a good idea to "
"call your :class:`~django.db.models.Field` subclass ``<Something>Field``, so "
"it's easily identifiable as a :class:`~django.db.models.Field` subclass.) It "
"doesn't behave like any existing field, so we'll subclass directly from :"
"class:`~django.db.models.Field`::"
msgstr ""
"在本例中，我们会调用 ``HandField``。（调用你的 :class:`~django.db.models."
"Field` 子类这个主意也很不错，所以认证为一个 :class:`~django.db.models.Field` "
"很简单。）它并不表现的像任何已存在的字段，所以我们将直接继承自 :class:"
"`~django.db.models.Field`::"

msgid ""
"Our ``HandField`` accepts most of the standard field options (see the list "
"below), but we ensure it has a fixed length, since it only needs to hold 52 "
"card values plus their suits; 104 characters in total."
msgstr ""
"我们的 ``HandField`` 接收大多数标准字段选项（参考下面的列表），但是我们确定参"
"数是定长的，因为它只需要保存 52 个卡片和它们的值；总计 104 个字符。"

msgid ""
"Many of Django's model fields accept options that they don't do anything "
"with. For example, you can pass both :attr:`~django.db.models.Field."
"editable` and :attr:`~django.db.models.DateField.auto_now` to a :class:"
"`django.db.models.DateField` and it will ignore the :attr:`~django.db.models."
"Field.editable` parameter (:attr:`~django.db.models.DateField.auto_now` "
"being set implies ``editable=False``). No error is raised in this case."
msgstr ""
"许多 Django 模型字段可以接受并没有什么用的可选参数。比如，你可以同时将 :attr:"
"`~django.db.models.DateField.auto_now` 和:attr:`~django.db.models.DateField."
"auto_now` 传递给  :class:`django.db.models.DateField` ，它将无视参数 :attr:"
"`~django.db.models.Field.editable` （:attr:`~django.db.models.DateField."
"auto_now` 被设置了就意味着 ``editable=False``）。这种情况下不会抛出错误。"

msgid ""
"This behavior simplifies the field classes, because they don't need to check "
"for options that aren't necessary. They pass all the options to the parent "
"class and then don't use them later on. It's up to you whether you want your "
"fields to be more strict about the options they select, or to use the more "
"permissive behavior of the current fields."
msgstr ""
"这种行为简化了字段类，因为它不需要检查那些没必要出现的可选参数。它们传递所有"
"可选参数到父类，之后就不再使用它们了。您可以更严格地设置字段可选参数，或者对"
"当前字段设置更放任的行为，一切都有您来决定。"

msgid "The ``Field.__init__()`` method takes the following parameters:"
msgstr "``Field.__init__()`` 方法接收以下参数:"

msgid ":attr:`~django.db.models.Field.verbose_name`"
msgstr ":attr:`~django.db.models.Field.verbose_name`"

msgid "``name``"
msgstr "``name``"

msgid ":attr:`~django.db.models.Field.primary_key`"
msgstr ":attr:`~django.db.models.Field.primary_key`"

msgid ":attr:`~django.db.models.CharField.max_length`"
msgstr ":attr:`~django.db.models.CharField.max_length`"

msgid ":attr:`~django.db.models.Field.unique`"
msgstr ":attr:`~django.db.models.Field.unique`"

msgid ":attr:`~django.db.models.Field.blank`"
msgstr ":attr:`~django.db.models.Field.blank`"

msgid ":attr:`~django.db.models.Field.null`"
msgstr ":attr:`~django.db.models.Field.null`"

msgid ":attr:`~django.db.models.Field.db_index`"
msgstr ":attr:`~django.db.models.Field.db_index`"

msgid ""
"``rel``: Used for related fields (like :class:`ForeignKey`). For advanced "
"use only."
msgstr "``rel``: 用于关联字段（像是： :class:`ForeignKey`）。仅用于进阶用途。"

msgid ":attr:`~django.db.models.Field.default`"
msgstr ":attr:`~django.db.models.Field.default`"

msgid ":attr:`~django.db.models.Field.editable`"
msgstr ":attr:`~django.db.models.Field.editable`"

msgid ""
"``serialize``: If ``False``, the field will not be serialized when the model "
"is passed to Django's :doc:`serializers </topics/serialization>`. Defaults "
"to ``True``."
msgstr ""
"``serialize``: 若为 ``False``，字段传给 Django 的 :doc:`序列化器 </topics/"
"serialization>` 时不会被序列化。默认为 ``True``。"

msgid ":attr:`~django.db.models.Field.unique_for_date`"
msgstr ":attr:`~django.db.models.Field.unique_for_date`"

msgid ":attr:`~django.db.models.Field.unique_for_month`"
msgstr ":attr:`~django.db.models.Field.unique_for_month`"

msgid ":attr:`~django.db.models.Field.unique_for_year`"
msgstr ":attr:`~django.db.models.Field.unique_for_year`"

msgid ":attr:`~django.db.models.Field.choices`"
msgstr ":attr:`~django.db.models.Field.choices`"

msgid ":attr:`~django.db.models.Field.help_text`"
msgstr ":attr:`~django.db.models.Field.help_text`"

msgid ":attr:`~django.db.models.Field.db_column`"
msgstr ":attr:`~django.db.models.Field.db_column`"

msgid ""
":attr:`~django.db.models.Field.db_tablespace`: Only for index creation, if "
"the backend supports :doc:`tablespaces </topics/db/tablespaces>`. You can "
"usually ignore this option."
msgstr ""
":attr:`~django.db.models.Field.db_tablespace`: 仅为创建索引，如果后端支持 :"
"doc:`tablespaces </topics/db/tablespaces>`。一般情况下你可以忽略此选项。"

msgid ""
":attr:`~django.db.models.Field.auto_created`: ``True`` if the field was "
"automatically created, as for the :class:`~django.db.models.OneToOneField` "
"used by model inheritance. For advanced use only."
msgstr ""
":attr:`~django.db.models.Field.auto_created`:若字段是自动创建的，则为 "
"``True``，用于 :class:`~django.db.models.OneToOneField` 的模型继承。仅用于进"
"阶用途。"

msgid ""
"All of the options without an explanation in the above list have the same "
"meaning they do for normal Django fields. See the :doc:`field documentation "
"</ref/models/fields>` for examples and details."
msgstr ""
"上述列表中所有无解释的选项与在普通 Django 字段中的作用一样。参见 :doc:`字段文"
"档 </ref/models/fields>` 获取例子和细节信息。"

msgid "Field deconstruction"
msgstr "字段解析"

msgid ""
"The counterpoint to writing your ``__init__()`` method is writing the :meth:"
"`~.Field.deconstruct` method. It's used during :doc:`model migrations </"
"topics/migrations>` to tell Django how to take an instance of your new field "
"and reduce it to a serialized form - in particular, what arguments to pass "
"to ``__init__()`` to recreate it."
msgstr ""
"编写 ``__init__()`` 方法的对应部分是编写 :meth:`~.Field.deconstruct` 方法。"
"在 :doc:`模型迁移 </topics/migrations>` 过程中，它用于告诉 Django 如何将新字"
"段的实例减少为序列化形式 - 特别是传递给 ``__init__()`` 以重新创建它的哪些参"
"数。"

msgid ""
"If you haven't added any extra options on top of the field you inherited "
"from, then there's no need to write a new ``deconstruct()`` method. If, "
"however, you're changing the arguments passed in ``__init__()`` (like we are "
"in ``HandField``), you'll need to supplement the values being passed."
msgstr ""
"如果你未在继承的字段之前添加任何选项，就不需要编写新的 ``deconstruct()`` 方"
"法。然而，如果你正在修改传递给 ``__init__()`` 的参数（像 ``HandField`` 中的一"
"样），你需要增补被传递的值。"

msgid ""
"``deconstruct()`` returns a tuple of four items: the field's attribute name, "
"the full import path of the field class, the positional arguments (as a "
"list), and the keyword arguments (as a dict). Note this is different from "
"the ``deconstruct()`` method :ref:`for custom classes <custom-deconstruct-"
"method>` which returns a tuple of three things."
msgstr ""
"``deconstruct()`` 返回包含 4 个项目的元组：字段的属性名，字段类的完整导入路"
"径，位置参数（以列表的形式），和关键字参数（以字典的形式）。注意，这与 :ref:`"
"为自定义类 <custom-deconstruct-method>` 的 ``deconstruct()`` 方法不同，它返回"
"包含 3个项目的元组。"

msgid ""
"As a custom field author, you don't need to care about the first two values; "
"the base ``Field`` class has all the code to work out the field's attribute "
"name and import path. You do, however, have to care about the positional and "
"keyword arguments, as these are likely the things you are changing."
msgstr ""
"作为自定义字段的作者，你不需要担心前两个值；基类 ``Field`` 已包含处理字段属性"
"名和导入路径的代码。然后，你仍必须关注位置参数和关键字参数，这些是你最有可能"
"改的东西。"

msgid ""
"For example, in our ``HandField`` class we're always forcibly setting "
"max_length in ``__init__()``. The ``deconstruct()`` method on the base "
"``Field`` class will see this and try to return it in the keyword arguments; "
"thus, we can drop it from the keyword arguments for readability::"
msgstr ""
"例如，在 ``HandField`` 类中，我们总是强制设置 ``__init__()`` 的长度。基类 "
"``Field`` 中的 ``deconstruct()`` 方法会看到这个值，并尝试在关键字参数中返回"
"它；因此，我们能为了可读性从关键字参数中剔除它::"

msgid ""
"If you add a new keyword argument, you need to write code in "
"``deconstruct()`` that puts its value into ``kwargs`` yourself. You should "
"also omit the value from ``kwargs`` when it isn't necessary to reconstruct "
"the state of the field, such as when the default value is being used::"
msgstr ""
"若你添加了一个新的关键字参数，你需要在 ``deconstruct`` 中新增代码，将其值传"
"入 ``kwargs``。如果不需要字段的重构状态，比如使用默认值的情况，还应该忽略 "
"``kwargs`` 中的值。"

msgid ""
"More complex examples are beyond the scope of this document, but remember - "
"for any configuration of your Field instance, ``deconstruct()`` must return "
"arguments that you can pass to ``__init__`` to reconstruct that state."
msgstr ""
"更多的复杂例子超出本文的范围，但是请牢记——对于你的字段实例的任意配置，"
"``deconstruct()`` 必须返回能传递给 ``__init__`` 的参数重构状态。"

msgid ""
"Pay extra attention if you set new default values for arguments in the "
"``Field`` superclass; you want to make sure they're always included, rather "
"than disappearing if they take on the old default value."
msgstr ""
"如果你在父类 ``Field`` 中设置了新的默认值需要额外注意；说明你希望总是包含它"
"们，而不是在它们采用旧有值时消失。"

msgid ""
"In addition, try to avoid returning values as positional arguments; where "
"possible, return values as keyword arguments for maximum future "
"compatibility. If you change the names of things more often than their "
"position in the constructor's argument list, you might prefer positional, "
"but bear in mind that people will be reconstructing your field from the "
"serialized version for quite a while (possibly years), depending how long "
"your migrations live for."
msgstr ""
"另外，应当避免用位置参数来返回值，尽可能用关键字参数来返回值以保证在未来能拥"
"有最大的兼容性。如果您在构造方法参数列表中修改参数名称比修改其位置更频繁，您"
"可能会更喜欢位置参数，但请记住，在相当长的一段时间内（也许几年），人们将从序"
"列化版本中重新构建您的字段，这取决于您迁移持续的时间。"

msgid ""
"You can see the results of deconstruction by looking in migrations that "
"include the field, and you can test deconstruction in unit tests by "
"deconstructing and reconstructing the field::"
msgstr ""
"您可以在包含字段的迁移文件里查看解析的结果，此外您可以在单元测试中通过解构和"
"重构字段来测试。"

msgid "Field attributes not affecting database column definition"
msgstr "字段属性不影响数据库列定义"

msgid ""
"You can override ``Field.non_db_attrs`` to customize attributes of a field "
"that don't affect a column definition. It's used during model migrations to "
"detect no-op ``AlterField`` operations."
msgstr ""
"你可以重写 ``Field.non_db_attrs`` 来自定义不影响列定义的字段属性。它在模型迁"
"移过程中用于检测无操作的 ``AlterField`` 操作。"

msgid "For example::"
msgstr "例子::"

msgid "Changing a custom field's base class"
msgstr "修改自定义字段的基类"

msgid ""
"You can't change the base class of a custom field because Django won't "
"detect the change and make a migration for it. For example, if you start "
"with::"
msgstr ""
"你可能修改自定义字段的基类，因为 Django 无法检测到修改，并为其实施迁移。例"
"如，如果你先这样::"

msgid ""
"and then decide that you want to use ``TextField`` instead, you can't change "
"the subclass like this::"
msgstr "随后决定继承自 ``TextField``，你不能像这样修改子类::"

msgid ""
"Instead, you must create a new custom field class and update your models to "
"reference it::"
msgstr "替代方法是，你必须新建一个自定义字段类，并将你的模型指向此类::"

msgid ""
"As discussed in :ref:`removing fields <migrations-removing-model-fields>`, "
"you must retain the original ``CustomCharField`` class as long as you have "
"migrations that reference it."
msgstr ""
"就像文档 :ref:`移除字段 <migrations-removing-model-fields>` 中讨论的一样，你"
"必须保留原 ``CustomCharField`` 类只要你还有迁移指向它。"

msgid "Documenting your custom field"
msgstr "为自定义字段编写文档"

msgid ""
"As always, you should document your field type, so users will know what it "
"is. In addition to providing a docstring for it, which is useful for "
"developers, you can also allow users of the admin app to see a short "
"description of the field type via the :doc:`django.contrib.admindocs </ref/"
"contrib/admin/admindocs>` application. To do this provide descriptive text "
"in a :attr:`~Field.description` class attribute of your custom field. In the "
"above example, the description displayed by the ``admindocs`` application "
"for a ``HandField`` will be 'A hand of cards (bridge style)'."
msgstr ""
"像之前一样，你需要为自定义字段类型编写文档，这样用户就会知道这他喵到底是啥。"
"除了为其提供对开发者很有用的 docstring 外，你也需要让后台管理员应用程序的用户"
"通过应用程序 :doc:`django.contrib.admindocs 1` 看到一个关于字段类型的简单介"
"绍。只需在自定义字段的 :attr:`~Field.description` 属性提供描述性文本。在上述"
"例子中，由 ``admindocs`` 应用为 ``HandField`` 字段提供的描述是 'A hand of "
"cards (bridge style)'。"

msgid ""
"In the :mod:`django.contrib.admindocs` display, the field description is "
"interpolated with ``field.__dict__`` which allows the description to "
"incorporate arguments of the field. For example, the description for :class:"
"`~django.db.models.CharField` is::"
msgstr ""
"在 :mod:`django.contrib.admindocs` 展示的内容中，字段描述在 ``field."
"__dict__`` 中差值，它允许描述包含字段参数。例如， :class:`~django.db.models."
"CharField` 的说明是::"

msgid "Useful methods"
msgstr "实用方法"

msgid ""
"Once you've created your :class:`~django.db.models.Field` subclass, you "
"might consider overriding a few standard methods, depending on your field's "
"behavior. The list of methods below is in approximately decreasing order of "
"importance, so start from the top."
msgstr ""
"一旦你已创建了 :class:`~django.db.models.Field` 的子类，你可能会考虑重写一些"
"标准方法，这取决于你的字段行为。以下列表中的方法大致按重要性降序排列，即从上"
"至下。"

msgid "Custom database types"
msgstr "自定义数据库类型"

msgid ""
"Say you've created a PostgreSQL custom type called ``mytype``. You can "
"subclass ``Field`` and implement the :meth:`~Field.db_type` method, like so::"
msgstr ""
"假设你已创建了一个 PostgreSQL 自定义字段，名叫 ``mytype``。你可以继承 "
"``Field`` 并实现 :meth:`~Field.db_type` 方法，像这样::"

msgid ""
"Once you have ``MytypeField``, you can use it in any model, just like any "
"other ``Field`` type::"
msgstr ""
"只要已建立 ``MytypeField``，你就能像使用其它 ``Field`` 类型一样在模型中使用"
"它::"

msgid ""
"If you aim to build a database-agnostic application, you should account for "
"differences in database column types. For example, the date/time column type "
"in PostgreSQL is called ``timestamp``, while the same column in MySQL is "
"called ``datetime``. You can handle this in a :meth:`~Field.db_type` method "
"by checking the ``connection.vendor`` attribute. Current built-in vendor "
"names are: ``sqlite``, ``postgresql``, ``mysql``, and ``oracle``."
msgstr ""
"如果您的目标是构建一个与数据库无关的应用程序，您应该考虑数据库账户列类型的差"
"异。 例如，PostgreSQL 中的日期/时间列类型称为 ``timestamp`` ，而 MySQL 中的同"
"一列称为 ``datetime`` 。您可以通过 :meth:`~Field.db_type` 方法中处理此问题检"
"查连接 ``connection.vendor`` 属性。 当前的内置供应商名称是：``sqlite``, "
"``postgresql``, ``mysql``, 和 ``oracle``。"

msgid ""
"The :meth:`~Field.db_type` and :meth:`~Field.rel_db_type` methods are called "
"by Django when the framework constructs the ``CREATE TABLE`` statements for "
"your application -- that is, when you first create your tables. The methods "
"are also called when constructing a ``WHERE`` clause that includes the model "
"field -- that is, when you retrieve data using QuerySet methods like "
"``get()``, ``filter()``, and ``exclude()`` and have the model field as an "
"argument."
msgstr ""
":meth:`~Field.db_type` 和 :meth:`~Field.rel_db_type` 方法在 Django 构建应用程"
"序的 ``CREATE TABLE`` 语句时被调用，也就是当你首次创建表时。这些方法还在构建"
"包含模型字段的 ``WHERE`` 子句时被调用，也就是当你使用 QuerySet 方法如 "
"``get()``, ``filter()`` 和 ``exclude()`` 来检索数据，并将模型字段作为参数时。"

msgid ""
"Some database column types accept parameters, such as ``CHAR(25)``, where "
"the parameter ``25`` represents the maximum column length. In cases like "
"these, it's more flexible if the parameter is specified in the model rather "
"than being hard-coded in the ``db_type()`` method. For example, it wouldn't "
"make much sense to have a ``CharMaxlength25Field``, shown here::"
msgstr ""
"某些数据库列类型接受参数，例如 ``CHAR(25)``，参数 ``25`` 表示列的最大长度。类"
"似用例中，该参数若在模型中指定比硬编码在 ``db_type()`` 方法中更灵活。举个例"
"子，构建 ``CharMaxlength25Field`` 没多大意义，如下所示::"

msgid ""
"The better way of doing this would be to make the parameter specifiable at "
"run time -- i.e., when the class is instantiated. To do that, implement "
"``Field.__init__()``, like so::"
msgstr ""
"更好的方式是在运行时指定参数值——即类实例化的时候。需要像这样实现 ``Field."
"__init__()`` 即可::"

msgid ""
"Finally, if your column requires truly complex SQL setup, return ``None`` "
"from :meth:`.db_type`. This will cause Django's SQL creation code to skip "
"over this field. You are then responsible for creating the column in the "
"right table in some other way, but this gives you a way to tell Django to "
"get out of the way."
msgstr ""
"最后，如果你的列真的要求配置复杂的 SQL，从 :meth:`.db_type` 返回 ``None``。这"
"会让 Django 创建 SQL 的代码跳过该字段。随后你需要负责为该字段在正确的表中以某"
"种方式创建列，这种方式允许你告诉 Django 不处理此事。"

msgid ""
"The :meth:`~Field.rel_db_type` method is called by fields such as "
"``ForeignKey`` and ``OneToOneField`` that point to another field to "
"determine their database column data types. For example, if you have an "
"``UnsignedAutoField``, you also need the foreign keys that point to that "
"field to use the same data type::"
msgstr ""
":meth:`~Field.rel_db_type` 方法由字段调用，例如 ``ForeignKey`` 和 "
"``OneToOneField`` ，这些通过指向另一个字段来决定数据库列类型的字段。举个例"
"子，如果你有个 ``UnsignedAutoField``，你也需要指向该字段的外键使用相同的数据"
"类型::"

msgid "Converting values to Python objects"
msgstr "将值转为 Python 对象"

msgid ""
"If your custom :class:`~Field` class deals with data structures that are "
"more complex than strings, dates, integers, or floats, then you may need to "
"override :meth:`~Field.from_db_value` and :meth:`~Field.to_python`."
msgstr ""
"若自定义 :class:`~Field` 处理的数据结构比字符串，日期，整型，或浮点型更复杂，"
"你可能需要重写 :meth:`~Field.from_db_value` 和 :meth:`~Field.to_python`。"

msgid ""
"If present for the field subclass, ``from_db_value()`` will be called in all "
"circumstances when the data is loaded from the database, including in "
"aggregates and :meth:`~django.db.models.query.QuerySet.values` calls."
msgstr ""
"若要展示字段的子类， ``from_db_value()`` 将会在从数据库中载入的生命周期中调"
"用，包括聚集和 :meth:`~django.db.models.query.QuerySet.values` 调用。"

msgid ""
"``to_python()`` is called by deserialization and during the :meth:`~django."
"db.models.Model.clean` method used from forms."
msgstr ""
"``to_python()`` 在反序列化时和为表单应用 :meth:`~django.db.models.Model."
"clean` 时调用。"

msgid ""
"As a general rule, ``to_python()`` should deal gracefully with any of the "
"following arguments:"
msgstr "作为通用规则， ``to_python`` 应该平滑地处理以下参数："

msgid ""
"An instance of the correct type (e.g., ``Hand`` in our ongoing example)."
msgstr "一个正确的类型（本业持续介绍的例子 ``Hand`` ）。"

msgid "A string"
msgstr "一个字符串"

msgid "``None`` (if the field allows ``null=True``)"
msgstr "``None`` （若字段允许 ``null=True``）"

msgid ""
"In our ``HandField`` class, we're storing the data as a ``VARCHAR`` field in "
"the database, so we need to be able to process strings and ``None`` in the "
"``from_db_value()``. In ``to_python()``, we need to also handle ``Hand`` "
"instances::"
msgstr ""
"在我们的 ``HandField`` 类中，我们将数据存储为数据库中的 ``VARCHAR`` 字段，因"
"此需要能够处理字符串和 ``None`` 在 ``from_db_value()`` 中。在 "
"``to_python()`` 中，我们还需要处理 ``Hand`` 实例："

msgid ""
"Notice that we always return a ``Hand`` instance from these methods. That's "
"the Python object type we want to store in the model's attribute."
msgstr ""
"注意，我们总是为这些方法返回一个 ``Hand`` 实例。这就是我们要保存在模型属性中"
"的 Python 对象类型。"

msgid ""
"For ``to_python()``, if anything goes wrong during value conversion, you "
"should raise a :exc:`~django.core.exceptions.ValidationError` exception."
msgstr ""
"对于 ``to_python()`` 来说，如果在值转换过程中出现任何问题，你应该抛出一个 :"
"exc:`~django.core.exceptions.ValidationError` 异常。"

msgid "Converting Python objects to query values"
msgstr "将 Python 转为查询值"

msgid ""
"Since using a database requires conversion in both ways, if you override :"
"meth:`~Field.from_db_value` you also have to override :meth:`~Field."
"get_prep_value` to convert Python objects back to query values."
msgstr ""
"使用数据库需要双向转换，如果你重写了 :meth:`~Field.from_db_value` 方法，你也"
"必须重写 :meth:`~Field.get_prep_value` 将 Python 对象转回查询值。"

msgid ""
"If your custom field uses the ``CHAR``, ``VARCHAR`` or ``TEXT`` types for "
"MySQL, you must make sure that :meth:`.get_prep_value` always returns a "
"string type. MySQL performs flexible and unexpected matching when a query is "
"performed on these types and the provided value is an integer, which can "
"cause queries to include unexpected objects in their results. This problem "
"cannot occur if you always return a string type from :meth:`.get_prep_value`."
msgstr ""
"如果你使用了 MySQL 的 ``CHAR``，``VARCHAR`` 或 ``TEXT`` 类型，你必须确保 :"
"meth:`.get_prep_value` 总是返回一个字符串。在 MySQL 中对这些类型操作时非常灵"
"活，甚至有时超出预期，在传入值为正数时，检出结果可能包含非期望的结果。这个问"
"题不会在你总为 :meth:`.get_prep_value` 返回字符串类型的时候出现。"

msgid "Converting query values to database values"
msgstr "将查询值转为数据库值"

msgid ""
"Some data types (for example, dates) need to be in a specific format before "
"they can be used by a database backend. :meth:`~Field.get_db_prep_value` is "
"the method where those conversions should be made. The specific connection "
"that will be used for the query is passed as the ``connection`` parameter. "
"This allows you to use backend-specific conversion logic if it is required."
msgstr ""
"某些数据类型（比如 dates）在数据库后端处理前要转为某种特定格式。 :meth:"
"`~Field.get_db_prep_value` 实现了这种转换。查询所以使用的连接由 "
"``connection`` 参数指定。这允许你在需要时指定后台要求的转换逻辑。"

msgid ""
"For example, Django uses the following method for its :class:`BinaryField`::"
msgstr "例如，Django 为其 :class:`BinaryField` 利用以下方法::"

msgid ""
"In case your custom field needs a special conversion when being saved that "
"is not the same as the conversion used for normal query parameters, you can "
"override :meth:`~Field.get_db_prep_save`."
msgstr ""
"万一自定义字段需要与普通查询参数使用的转换不同的转换规则，你可以重写 :meth:"
"`~Field.get_db_prep_save`。"

msgid "Preprocessing values before saving"
msgstr "在保存前预处理数值"

msgid ""
"If you want to preprocess the value just before saving, you can use :meth:"
"`~Field.pre_save`. For example, Django's :class:`~django.db.models."
"DateTimeField` uses this method to set the attribute correctly in the case "
"of :attr:`~django.db.models.DateField.auto_now` or :attr:`~django.db.models."
"DateField.auto_now_add`."
msgstr ""
"如果你要在保存前预处理值，你可以调用 :meth:`~Field.pre_save`。举个例子，"
"Django 的 :class:`~django.db.models.DateTimeField` 在 :attr:`~django.db."
"models.DateField.auto_now` 或 :attr:`~django.db.models.DateField."
"auto_now_add` 中利用此方法正确设置属性。"

msgid ""
"If you do override this method, you must return the value of the attribute "
"at the end. You should also update the model's attribute if you make any "
"changes to the value so that code holding references to the model will "
"always see the correct value."
msgstr ""
"如果你重写了此方法，你必须在最后返回该属性的值。如果修改了值，那么你也需要更"
"新模型属性，这样持有该引用的模型总会看到正确的值。"

msgid "Specifying the form field for a model field"
msgstr "为模型字段指定表单字段"

msgid ""
"To customize the form field used by :class:`~django.forms.ModelForm`, you "
"can override :meth:`~Field.formfield`."
msgstr ""
"为了自定义 :class:`~django.forms.ModelForm` 使用的表单属性，你必须重写 :meth:"
"`~Field.formfield`。"

msgid ""
"The form field class can be specified via the ``form_class`` and "
"``choices_form_class`` arguments; the latter is used if the field has "
"choices specified, the former otherwise. If these arguments are not "
"provided, :class:`~django.forms.CharField` or :class:`~django.forms."
"TypedChoiceField` will be used."
msgstr ""
"表单字段类能通过 ``form_class`` 和 ``choices_form_class`` 参数指定；如果字段"
"指定了选项，则使用后者，反之前者。若未提供这些参数，将会使用 :class:`~django."
"forms.CharField` 或 :class:`~django.forms.TypedChoiceField`。"

msgid ""
"All of the ``kwargs`` dictionary is passed directly to the form field's "
"``__init__()`` method. Normally, all you need to do is set up a good default "
"for the ``form_class`` (and maybe ``choices_form_class``) argument and then "
"delegate further handling to the parent class. This might require you to "
"write a custom form field (and even a form widget). See the :doc:`forms "
"documentation </topics/forms/index>` for information about this."
msgstr ""
"完整的 ``kwargs`` 被直接传递给表单字段的 ``__init__()`` 方法。一般的，你要做"
"的全部工作就是为 ``form_class`` 参数配置一个合适的默认值，并在随后委托父类处"
"理。这可能要求你编写一个自定义表单字段（甚至表单视图）。查看 :doc:`表单文件材"
"料 </topics/forms/index>` 获取相关信息。"

msgid ""
"Continuing our ongoing example, we can write the :meth:`~Field.formfield` "
"method as::"
msgstr "承接上面的例子，我们能这样编写 :meth:`~Field.formfield` 方法::"

msgid ""
"This assumes we've imported a ``MyFormField`` field class (which has its own "
"default widget). This document doesn't cover the details of writing custom "
"form fields."
msgstr ""
"这假定我们已导入 ``MyFormField`` 字段类（它有默认视图）。本页文档未覆盖编写自"
"定义表单字段的细节。"

msgid "Emulating built-in field types"
msgstr "仿造内置字段类型"

msgid ""
"If you have created a :meth:`.db_type` method, you don't need to worry "
"about :meth:`.get_internal_type` -- it won't be used much. Sometimes, "
"though, your database storage is similar in type to some other field, so you "
"can use that other field's logic to create the right column."
msgstr ""
"若你已创建了 :meth:`.db_type` 方法，你无需担心 :meth:`.get_internal_type` 方"
"法——它并不常用。虽然很多时候，数据库存储行为和其他字段类似，所以你能直接用其"
"它字段的逻辑创建正确的列。"

msgid ""
"No matter which database backend we are using, this will mean that :djadmin:"
"`migrate` and other SQL commands create the right column type for storing a "
"string."
msgstr ""
"无论我们使用了哪个数据库后端， :djadmin:`migrate` 或其它 SQL 命令总会在保存字"
"符串时为其创建正确的列类型。"

msgid ""
"If :meth:`.get_internal_type` returns a string that is not known to Django "
"for the database backend you are using -- that is, it doesn't appear in "
"``django.db.backends.<db_name>.base.DatabaseWrapper.data_types`` -- the "
"string will still be used by the serializer, but the default :meth:`~Field."
"db_type` method will return ``None``. See the documentation of :meth:`~Field."
"db_type` for reasons why this might be useful. Putting a descriptive string "
"in as the type of the field for the serializer is a useful idea if you're "
"ever going to be using the serializer output in some other place, outside of "
"Django."
msgstr ""
"若 :meth:`.get_internal_type` 返回了当前数据库后端（即 ``django.db.backends."
"<db_name>.base.DatabaseWrapper.data_types`` 中未出现的后端）无法理解的字符串"
"——该字符串仍会被序列化器使用的，但是默认的 :meth:`~Field.db_type` 方法会返回 "
"``None``。查阅文档 :meth:`~Field.db_type` 了解为啥有用。如果您打算在 Django "
"之外的其他地方使用序列化器输出，那么将描述性字符串作为序列化器的字段类型是一"
"个有用的想法。"

msgid "Converting field data for serialization"
msgstr "为序列化转换字段数据"

msgid ""
"To customize how the values are serialized by a serializer, you can "
"override :meth:`~Field.value_to_string`. Using :meth:`~Field."
"value_from_object` is the best way to get the field's value prior to "
"serialization. For example, since ``HandField`` uses strings for its data "
"storage anyway, we can reuse some existing conversion code::"
msgstr ""
"自定义序列化器序列化值的流程，你要重写 :meth:`~Field.value_to_string`。使用 :"
"meth:`~Field.value_to_string` 是在序列化之前获取字段值的最佳方法。举个例子，"
"由于 ``HandField`` 使用字符串存储数据，我们能复用一些已有代码::"

msgid "Some general advice"
msgstr "一些通用建议"

msgid ""
"Writing a custom field can be a tricky process, particularly if you're doing "
"complex conversions between your Python types and your database and "
"serialization formats. Here are a couple of tips to make things go more "
"smoothly:"
msgstr ""
"编写自定义字段是个棘手的，尤其是在 Python 类，数据库，序列化格式之间进行复杂"
"转换的时候。下面有几个让事情更顺利的建议："

msgid ""
"Look at the existing Django fields (in :source:`django/db/models/fields/"
"__init__.py`) for inspiration. Try to find a field that's similar to what "
"you want and extend it a little bit, instead of creating an entirely new "
"field from scratch."
msgstr ""
"查看现有的 Django 字段（在 :source:`django/db/models/fields/__init__.py` 中）"
"以获取灵感。尝试找到与你想要的类似的字段，并稍微扩展它，而不是从头开始创建一"
"个全新的字段。"

msgid ""
"Put a ``__str__()`` method on the class you're wrapping up as a field. There "
"are a lot of places where the default behavior of the field code is to call "
"``str()`` on the value. (In our examples in this document, ``value`` would "
"be a ``Hand`` instance, not a ``HandField``). So if your ``__str__()`` "
"method automatically converts to the string form of your Python object, you "
"can save yourself a lot of work."
msgstr ""
"为字段类添加一个 ``__str__()`` 方法。在很多地方，字段代码的默认行为是对值调"
"用 ``str()``。（本页文档中， ``value`` 会是一个 ``Hand`` 实例，而不是 "
"``HandField``）。所以 ``__str()__`` 方法会自动将 Python 对象转为字符串格式，"
"帮你剩下不少时间。 "

msgid "Writing a ``FileField`` subclass"
msgstr "编写一个 ``FileField`` 子类"

msgid ""
"In addition to the above methods, fields that deal with files have a few "
"other special requirements which must be taken into account. The majority of "
"the mechanics provided by ``FileField``, such as controlling database "
"storage and retrieval, can remain unchanged, leaving subclasses to deal with "
"the challenge of supporting a particular type of file."
msgstr ""
"除了上述方法外，处理文件的字段还有一些必须考虑到的特殊要求。 ``FileField`` 提"
"供的大部分机制（像是操作数据库存储和检索）能保持不变，让子类面对支持特殊文件"
"的挑战。"

msgid ""
"Django provides a ``File`` class, which is used as a proxy to the file's "
"contents and operations. This can be subclassed to customize how the file is "
"accessed, and what methods are available. It lives at ``django.db.models."
"fields.files``, and its default behavior is explained in the :doc:`file "
"documentation </ref/files/file>`."
msgstr ""
"Django 提供一个 ``File`` 类，作为文件内容和文件操作的代理。可以继承该类自定义"
"访问文件的方式，哪些方法是可用的。它位于 ``django.db.models.fields.files``，"
"它的默认行为在 :doc:`file 文档 </ref/files/file>` 中介绍。"

msgid ""
"Once a subclass of ``File`` is created, the new ``FileField`` subclass must "
"be told to use it. To do so, assign the new ``File`` subclass to the special "
"``attr_class`` attribute of the ``FileField`` subclass."
msgstr ""
"一旦创建了文件 ``File`` 子类，必须说明要使用新子类 ``FileField``。为此，需要"
"为 ``FileField`` 的子类的 ``attr_class`` 属性指定新的文件 ``File`` 子类。"

msgid "A few suggestions"
msgstr "一些建议"

msgid ""
"In addition to the above details, there are a few guidelines which can "
"greatly improve the efficiency and readability of the field's code."
msgstr ""
"除了上述细节，下面还有一些准则，有助于极大地提高字段代码的效率和可读性。"

msgid ""
"The source for Django's own ``ImageField`` (in :source:`django/db/models/"
"fields/files.py`) is a great example of how to subclass ``FileField`` to "
"support a particular type of file, as it incorporates all of the techniques "
"described above."
msgstr ""
"Django 自带的 ``ImageField`` 的源代码（在 :source:`django/db/models/fields/"
"files.py` 中）是一个很好的示例，展示了如何通过子类化 ``FileField`` 来支持特定"
"类型的文件，因为它包含了上面描述的所有技术。"

msgid ""
"Cache file attributes wherever possible. Since files may be stored in remote "
"storage systems, retrieving them may cost extra time, or even money, that "
"isn't always necessary. Once a file is retrieved to obtain some data about "
"its content, cache as much of that data as possible to reduce the number of "
"times the file must be retrieved on subsequent calls for that information."
msgstr ""
"尽可能的缓存文件属性。因为文件可能保存在远端存储系统中，检出它们会消耗额外的"
"时间，甚至是钱，且不总是必要的。一旦检出某个文件，获取其内容，尽可能缓存所有"
"数据，以减少后续调用再次检索文件的次数。"

msgid "How to implement a custom template backend"
msgstr "如何编写一个自定义的模板后端"

msgid "Custom backends"
msgstr "自定义后端"

msgid ""
"Here's how to implement a custom template backend in order to use another "
"template system. A template backend is a class that inherits ``django."
"template.backends.base.BaseEngine``. It must implement ``get_template()`` "
"and optionally ``from_string()``. Here's an example for a fictional "
"``foobar`` template library::"
msgstr ""
"以下是如何实现一个在另一个模板系统中使用的自定义后端。一个模板后端是继承自后"
"端基本类 ``django.template.backends.base.BaseEngine`` 。它必须实现 "
"``get_template()`` 和可选实现 ``from_string()`` 。以下是一个模拟 ``foobar`` "
"模板库的例子。"

msgid "See `DEP 182`_ for more information."
msgstr "请参阅 `DEP 182`_ 以获取更多信息。"

msgid "Debug integration for custom engines"
msgstr "为自定义引擎集成调试功能"

msgid ""
"The Django debug page has hooks to provide detailed information when a "
"template error arises. Custom template engines can use these hooks to "
"enhance the traceback information that appears to users. The following hooks "
"are available:"
msgstr ""
"当模板有错误时Django调试页面会提供相应的钩子信息。自定义后端引擎能使用这些钩"
"子来细化显示给用户的回溯信息。以下是可用的钩子："

msgid "Template postmortem"
msgstr "模板剖析"

msgid ""
"The postmortem appears when :exc:`~django.template.TemplateDoesNotExist` is "
"raised. It lists the template engines and loaders that were used when trying "
"to find a given template. For example, if two Django engines are configured, "
"the postmortem will appear like:"
msgstr ""
"当错误 :exc:`~django.template.TemplateDoesNotExist` 发生时显示剖析。它会列举"
"出尝试查找指定模板时使用的模板引擎和加载器。举个例子，如果配置了两个Django引"
"擎，剖析显示如下："

msgid ""
"Custom engines can populate the postmortem by passing the ``backend`` and "
"``tried`` arguments when raising :exc:`~django.template."
"TemplateDoesNotExist`. Backends that use the postmortem :ref:`should specify "
"an origin <template-origin-api>` on the template object."
msgstr ""
"当 :exc:`~django.template.TemplateDoesNotExist` 错误触发时自定义引擎会填写 ``"
"后端`` 和 ``尝试`` 参数。使用剖析 :ref:` 的后端必须要指定模板对象上的一个来"
"源 1` 。"

msgid "Contextual line information"
msgstr "上下文信息"

msgid ""
"If an error happens during template parsing or rendering, Django can display "
"the line the error happened on. For example:"
msgstr "当模板解析或渲染时发生错误，Django会显示错误所在的行。举个例子："

msgid ""
"Custom engines can populate this information by setting a ``template_debug`` "
"attribute on exceptions raised during parsing and rendering. This attribute "
"is a :class:`dict` with the following values:"
msgstr ""
"在解析或渲染异常中配置了 ``template_debug`` 属性的自定义引擎会显示这条信息。"
"这个属性是一个有以下值的类 :class:`dict`："

msgid "``'name'``: The name of the template in which the exception occurred."
msgstr "``'name'`` ：发生异常的模板名称"

msgid "``'message'``: The exception message."
msgstr "``'message'``: 异常信息。"

msgid ""
"``'source_lines'``: The lines before, after, and including the line the "
"exception occurred on. This is for context, so it shouldn't contain more "
"than 20 lines or so."
msgstr ""
"``'source_lines'``: 异常发生的行及其前后内容。这是为了上下文，所以它不应该超"
"过二十行。"

msgid "``'line'``: The line number on which the exception occurred."
msgstr "``'line'``: 异常发生的行数。"

msgid ""
"``'before'``: The content on the error line before the token that raised the "
"error."
msgstr "``'before'``: 发生错误的标识符的错误行前面的内容。"

msgid "``'during'``: The token that raised the error."
msgstr "``'during'``: 发生错误的标识符。"

msgid ""
"``'after'``: The content on the error line after the token that raised the "
"error."
msgstr "``'after'``: 发生错误的标识符的错误行后面的内容。"

msgid "``'total'``: The number of lines in ``source_lines``."
msgstr "``'total'``: ``source_lines`` 总行数。"

msgid "``'top'``: The line number where ``source_lines`` starts."
msgstr "``'top'``: ``source_lines`` 起始行数。"

msgid "``'bottom'``: The line number where ``source_lines`` ends."
msgstr "``'bottom'``: ``source_lines`` 结束的行数。"

msgid "Given the above template error, ``template_debug`` would look like::"
msgstr "根据上述模板错误， ``template_debug`` 会像这样："

msgid "Origin API and 3rd-party integration"
msgstr "原始API和第3方集成"

msgid ""
"Django templates have an :class:`~django.template.base.Origin` object "
"available through the ``template.origin`` attribute. This enables debug "
"information to be displayed in the :ref:`template postmortem <template-"
"postmortem>`, as well as in 3rd-party libraries, like the `Django Debug "
"Toolbar`_."
msgstr ""
"Django有一个可用  ``template.origin`` 属性的 :class:`~django.template.base."
"Origin` 基本对象类。这可以让调试信息显示在 :ref:`template 模板剖析上，同时支"
"持第3方库，例如 `Django Debug Toolbar`_。"

msgid ""
"Custom engines can provide their own ``template.origin`` information by "
"creating an object that specifies the following attributes:"
msgstr ""
"自定义引擎可以通过创建有以下特定属性的对象来提供自身的 ``template.origin`` 信"
"息。"

msgid "``'name'``: The full path to the template."
msgstr "``'name'``: 模板的完整路径。"

msgid ""
"``'template_name'``: The relative path to the template as passed into the "
"template loading methods."
msgstr "``'template_name'``: 通过模板加载方法打开的模板的相对路径。"

msgid ""
"``'loader_name'``: An optional string identifying the function or class used "
"to load the template, e.g. ``django.template.loaders.filesystem.Loader``."
msgstr ""
"``'loader_name'``: 一个可选的以字符串形式指定用来加载模板的文件系统类或函数, "
"e.g. ``django.template.loaders.filesystem.Loader``."

msgid "How to create custom template tags and filters"
msgstr "如何编写自定义的模板标签和过滤器"

msgid ""
"Django's template language comes with a wide variety of :doc:`built-in tags "
"and filters </ref/templates/builtins>` designed to address the presentation "
"logic needs of your application. Nevertheless, you may find yourself needing "
"functionality that is not covered by the core set of template primitives. "
"You can extend the template engine by defining custom tags and filters using "
"Python, and then make them available to your templates using the :ttag:`{% "
"load %}<load>` tag."
msgstr ""
"Django  模板语言包含了很多 :doc:`内置 tags 和 filters </ref/templates/"
"builtins>`，设计目的是满足应用需要占位逻辑需求。极少情况下，你可能发现需要的"
"功能未被核心模板集覆盖。你能通过 Python 代码自定义 tags 和 filters 扩展集成模"
"板引擎，通过 :ttag:`{% load %} <load>` 标签使其可用。"

msgid "Code layout"
msgstr "代码布局"

msgid ""
"The most common place to specify custom template tags and filters is inside "
"a Django app. If they relate to an existing app, it makes sense to bundle "
"them there; otherwise, they can be added to a new app. When a Django app is "
"added to :setting:`INSTALLED_APPS`, any tags it defines in the conventional "
"location described below are automatically made available to load within "
"templates."
msgstr ""
"定制自定义模板 tags 和 filters 的位置就是 Django 应用内。如果它们关联至某个已"
"存在的应用，在那里将它们打包就很有用；否则，它们能被添加至新应用。当一个 "
"Django 应用被添加至 :setting:`INSTALLED_APPS`，所以其在常规位置（下面介绍）定"
"义的标签都可以在模板中自动加载。"

msgid ""
"The app should contain a ``templatetags`` directory, at the same level as "
"``models.py``, ``views.py``, etc. If this doesn't already exist, create it - "
"don't forget the ``__init__.py`` file to ensure the directory is treated as "
"a Python package."
msgstr ""
"该应用应包含一个 ``templatetags`` 目录，与 ``models.py``， ``views.py`` 等同"
"级。若该目录不存在，创建它——不要忘了用 ``__init__.py`` 文件确保目录被视作一"
"个 Python 包。"

msgid "Development server won't automatically restart"
msgstr "开发服务器并不会自动重启"

msgid ""
"After adding the ``templatetags``  module, you will need to restart your "
"server before you can use the tags or filters in templates."
msgstr ""
"添加 ``templatetags`` 模块后，你需要重启服务器，这样才能在模板中使用 tags 和 "
"filters。"

msgid ""
"Your custom tags and filters will live in a module inside the "
"``templatetags`` directory. The name of the module file is the name you'll "
"use to load the tags later, so be careful to pick a name that won't clash "
"with custom tags and filters in another app."
msgstr ""
"自定义的 tags 和 filters 会保存在模块名为 ``templatetags`` 的目录内。模块文件"
"的名字即稍候你用来加载 tags 的名字，所以小心不要采用一个可能与其它应用自定义"
"的 tags 和 filters 冲突的名字。"

msgid ""
"For example, if your custom tags/filters are in a file called ``poll_extras."
"py``, your app layout might look like this:"
msgstr ""
"例如，如果你的自定义标签/过滤器位于一个名为 ``poll_extras.py`` 的文件中，你的"
"应用程序布局可能如下所示："

msgid "And in your template you would use the following:"
msgstr "在模板中你会使用以下代码："

msgid ""
"The app that contains the custom tags must be in :setting:`INSTALLED_APPS` "
"in order for the :ttag:`{% load %}<load>` tag to work. This is a security "
"feature: It allows you to host Python code for many template libraries on a "
"single host machine without enabling access to all of them for every Django "
"installation."
msgstr ""
"为了使 :ttag:`{% load %}<load>` 标签生效，包含自定义标签的应用必须包含在 :"
"setting:`INSTALLED_APPS` 中。这是个安全特性：它允许你在一个主机上持有多个模板"
"库，而不是让每个 Django 安装都能访问所有的库。"

msgid ""
"There's no limit on how many modules you put in the ``templatetags`` "
"package. Just keep in mind that a :ttag:`{% load %}<load>` statement will "
"load tags/filters for the given Python module name, not the name of the app."
msgstr ""
"我们并未限制放入 ``templatetags`` 包中的模块数量。只需牢记 :ttag:`{% load %}"
"<load>` 语句会加载名字指定 Python 模块的 tags/filters，而不是应用。"

msgid ""
"To be a valid tag library, the module must contain a module-level variable "
"named ``register`` that is a ``template.Library`` instance, in which all the "
"tags and filters are registered. So, near the top of your module, put the "
"following::"
msgstr ""
"要成为一个可用的 tag 库，模块必须包含一个名为 ``register`` 的模块级变量，它是"
"一个 ``template.Library`` 实例。所有的 tags 和 filters 均在其中注册。所以，在"
"模块的开始，输入以下内容::"

msgid ""
"Alternatively, template tag modules can be registered through the "
"``'libraries'`` argument to :class:`~django.template.backends.django."
"DjangoTemplates`. This is useful if you want to use a different label from "
"the template tag module name when loading template tags. It also enables you "
"to register tags without installing an application."
msgstr ""
"或者，模板标签模块能通过 :class:`~django.template.backends.django."
"DjangoTemplates` 的 ``'libraries'`` 参数注册。这在加载模板名字时，想为模板标"
"签起个别名时很有用。这也让你能在未安装应用的情况下注册标签。"

msgid "Behind the scenes"
msgstr "幕后"

msgid ""
"For a ton of examples, read the source code for Django's default filters and "
"tags. They're in :source:`django/template/defaultfilters.py` and :source:"
"`django/template/defaulttags.py`, respectively."
msgstr ""
"要获取大量示例，请阅读 Django 默认过滤器和标签的源代码。它们分别位于 :source:"
"`django/template/defaultfilters.py` 和 :source:`django/template/defaulttags."
"py` 中。"

msgid "For more information on the :ttag:`load` tag, read its documentation."
msgstr "更多关于 :ttag:`load` 标签的信息，阅读本文档。"

msgid "Writing custom template filters"
msgstr "编写自定义的模板过滤器"

msgid "Custom filters are Python functions that take one or two arguments:"
msgstr "自定义的过滤器就是一些有一到两个参数的 Python 函数："

msgid "The value of the variable (input) -- not necessarily a string."
msgstr "（输入的）变量的值，不一定得是字符串类型"

msgid ""
"The value of the argument -- this can have a default value, or be left out "
"altogether."
msgstr "而参数的值，它们可以有一个默认值，或者被排除在外"

msgid ""
"For example, in the filter ``{{ var|foo:\"bar\" }}``, the filter ``foo`` "
"would be passed the variable ``var`` and the argument ``\"bar\"``."
msgstr ""
"举个例子，在过滤器 ``{{ var|foo:\"bar\" }}`` 中，变量 ``var`` 和参数 ``bar`` "
"会传递给过滤器 ``foo``。"

msgid ""
"Since the template language doesn't provide exception handling, any "
"exception raised from a template filter will be exposed as a server error. "
"Thus, filter functions should avoid raising exceptions if there is a "
"reasonable fallback value to return. In case of input that represents a "
"clear bug in a template, raising an exception may still be better than "
"silent failure which hides the bug."
msgstr ""
"因为模板语言不提供异常处理机制，所以任何从模板过滤器中抛出的异常都将被视为服"
"务器异常。因此，如果有一个合理的返回值将要被返回的话，过滤器函数应当避免产生"
"异常。万一模板中出现有明显错误的输入，产生异常也仍然比隐藏这个 bug 要好。"

msgid "Here's an example filter definition::"
msgstr "这是一个过滤器定义的例子::"

msgid "And here's an example of how that filter would be used:"
msgstr "这个例子展示了如何使用这个过滤器："

msgid ""
"Most filters don't take arguments. In this case, leave the argument out of "
"your function::"
msgstr ""
"大部分的过滤器并没有参数。这样的话，只需要把这些参数从你的函数中去掉就好。"

msgid "Registering custom filters"
msgstr "注册自定义过滤器"

msgid ""
"Once you've written your filter definition, you need to register it with "
"your ``Library`` instance, to make it available to Django's template "
"language::"
msgstr ""
"每当你写好你的过滤器定义的时候，你需要用你的 ``Library`` 实例去注册它，从而让"
"它对于 Django 模板语言而言是可用的"

msgid "The ``Library.filter()`` method takes two arguments:"
msgstr "``Library.filter()`` 方法有两个参数："

msgid "The name of the filter -- a string."
msgstr "过滤器的名称——字符串。"

msgid ""
"The compilation function -- a Python function (not the name of the function "
"as a string)."
msgstr "编辑函数——一个 Python 函数（不是函数名的字符串）。"

msgid "You can use ``register.filter()`` as a decorator instead::"
msgstr "你也能以装饰器的模式使用 ``register.filter()``::"

msgid ""
"If you leave off the ``name`` argument, as in the second example above, "
"Django will use the function's name as the filter name."
msgstr ""
"若你不填 ``name`` 参数，像第二个例子展示的一样，Django 会将函数名当做过滤器"
"名。"

msgid ""
"Finally, ``register.filter()`` also accepts three keyword arguments, "
"``is_safe``, ``needs_autoescape``, and ``expects_localtime``. These "
"arguments are described in :ref:`filters and auto-escaping <filters-auto-"
"escaping>` and :ref:`filters and time zones <filters-timezones>` below."
msgstr ""
"最后， ``register.filter()`` 也接受 3 个关键字参数， ``is_sage``， "
"``needs_autoescape``，和 ``expects_localtime``。这些参数在下面的 :ref:`过滤器"
"和自动转义 <filters-auto-escaping>` 和 :ref:`过滤器和时区 <filters-"
"timezones>` 介绍。"

msgid "Template filters that expect strings"
msgstr "模板过滤器期望字符串"

msgid ""
"If you're writing a template filter that only expects a string as the first "
"argument, you should use the decorator ``stringfilter``. This will convert "
"an object to its string value before being passed to your function::"
msgstr ""
"如果编写只接收一个字符串作为第一个参数的模板过滤器，你需要使用 "
"``stringfilter`` 的装饰器。它会将参数前转为字符串后传递给函数::"

msgid ""
"This way, you'll be able to pass, say, an integer to this filter, and it "
"won't cause an ``AttributeError`` (because integers don't have ``lower()`` "
"methods)."
msgstr ""
"这样，您就可以将一个整数传递给这个过滤器，而不会导致 ``AttributeError`` (因为"
"整数没有 ``lower()`` 方法)。"

msgid "Filters and auto-escaping"
msgstr "过滤器和自动转义"

msgid ""
"When writing a custom filter, give some thought to how the filter will "
"interact with Django's auto-escaping behavior. Note that two types of "
"strings can be passed around inside the template code:"
msgstr "编写自定义过滤器时，考虑一下过滤器将如何与 Django 的自动转义行为交互。"

msgid ""
"**Raw strings** are the native Python strings. On output, they're escaped if "
"auto-escaping is in effect and presented unchanged, otherwise."
msgstr ""
"**原始字符串** 指原生 Python 字符串。在输出时，如果自动转义生效，则对它们进行"
"转义，否则将保持不变。"

msgid ""
"**Safe strings** are strings that have been marked safe from further "
"escaping at output time. Any necessary escaping has already been done. "
"They're commonly used for output that contains raw HTML that is intended to "
"be interpreted as-is on the client side."
msgstr ""
"**安全字符串** 是在输出时被标记为安全的字符串，不会进一步转义。必要的转义已在"
"之前完成。它们通常用于原样输出 HTML，HTML 会在客户端被解释。"

msgid ""
"Internally, these strings are of type :class:`~django.utils.safestring."
"SafeString`. You can test for them using code like::"
msgstr ""
"实质上，这些字符串是 :class:`~django.utils.safestring.SafeString` 类的实例。"
"你能用以下代码测试它们::"

msgid "Template filter code falls into one of two situations:"
msgstr "模板过滤器代码有两种情况："

msgid ""
"Your filter does not introduce any HTML-unsafe characters (``<``, ``>``, "
"``'``, ``\"`` or ``&``) into the result that were not already present. In "
"this case, you can let Django take care of all the auto-escaping handling "
"for you. All you need to do is set the ``is_safe`` flag to ``True`` when you "
"register your filter function, like so::"
msgstr ""
"你的过滤器不会将任何 HTML 不安全的字符(``<``, ``>``, ``'``, ``\"`` or ``&``)"
"引入尚未出现的结果中。这种情况下，可以让 Django 自动为您处理所有的转义操作。"
"你只需在注册自己的过滤器函数时，将 ``is_safe`` 标志置为 ``True``，像这样::"

msgid ""
"This flag tells Django that if a \"safe\" string is passed into your filter, "
"the result will still be \"safe\" and if a non-safe string is passed in, "
"Django will automatically escape it, if necessary."
msgstr ""
"该标志告诉 Django，若一个“安全”字符串传给您的过滤器，结果仍会是安全的。若传入"
"了不安全的字符串，Django 会在需要时自动转义。"

msgid ""
"You can think of this as meaning \"this filter is safe -- it doesn't "
"introduce any possibility of unsafe HTML.\""
msgstr "你可以这么认为，“过滤器是安全的——它不会产生任何不安全的 HTML。”"

msgid ""
"The reason ``is_safe`` is necessary is because there are plenty of normal "
"string operations that will turn a ``SafeData`` object back into a normal "
"``str`` object and, rather than try to catch them all, which would be very "
"difficult, Django repairs the damage after the filter has completed."
msgstr ""
"一定要 ``is_safe`` 的原因是大量的字符串操作会将 ``SafeData`` 对象返回为普通 "
"``str`` 对象，而不是尝试全部捕获（挺难的），Django 在过滤完成后尝试修复这些损"
"伤。"

msgid ""
"For example, suppose you have a filter that adds the string ``xx`` to the "
"end of any input. Since this introduces no dangerous HTML characters to the "
"result (aside from any that were already present), you should mark your "
"filter with ``is_safe``::"
msgstr ""
"举例来说，假定有个过滤器，会在任何输入后追加 ``xx``。由于此操作不会在结果产生"
"任何 HTML 危险的字符（除了那些已存在的），你需要用 ``is_safe`` 标记你的过滤"
"器::"

msgid ""
"When this filter is used in a template where auto-escaping is enabled, "
"Django will escape the output whenever the input is not already marked as "
"\"safe\"."
msgstr ""
"当该过滤器对某个启用了自动转义的模板生效时，Django 会对输出自动转义，不管输入"
"是否被标记为“安全的”。"

msgid ""
"By default, ``is_safe`` is ``False``, and you can omit it from any filters "
"where it isn't required."
msgstr ""
"默认情况下， ``is_sate`` 为 ``False``，你可以为不要求此项的过滤器忽略它。"

msgid ""
"Be careful when deciding if your filter really does leave safe strings as "
"safe. If you're *removing* characters, you might inadvertently leave "
"unbalanced HTML tags or entities in the result. For example, removing a "
"``>`` from the input might turn ``<a>`` into ``<a``, which would need to be "
"escaped on output to avoid causing problems. Similarly, removing a semicolon "
"(``;``) can turn ``&amp;`` into ``&amp``, which is no longer a valid entity "
"and thus needs further escaping. Most cases won't be nearly this tricky, but "
"keep an eye out for any problems like that when reviewing your code."
msgstr ""
"在确定过滤器是否确实将安全字符串保留为安全字符串时要千万小心。如果你正在 **删"
"除** 字符，你可能不经意的在结果中留下不成对的 HTML 标记或实体。例如，从输入中"
"删除一个 ``>`` 可能将 ``<a>`` 转为 ``<a``，后者可能需要转移，避免导致输出错"
"误。类似的，删除一个分号(``;``)会将 ``&amp;`` 转为 ``&amp``，后者不再是一个有"
"效的实体，因此需要转义。大多数情况下都没这么复杂，但是检查代码时要注意类似的"
"问题。"

msgid ""
"Marking a filter ``is_safe`` will coerce the filter's return value to a "
"string.  If your filter should return a boolean or other non-string value, "
"marking it ``is_safe`` will probably have unintended consequences (such as "
"converting a boolean False to the string 'False')."
msgstr ""
"标记过滤器的 ``is_safe`` 会强制该过滤器的返回值为字符串。如果你的过滤器要返回"
"一个布尔值或非字符串值，将其标记为 ``is_safe`` 可能会导致出乎意料的结果（类似"
"将一个布尔值 False 转为字符串 'False'）。"

msgid ""
"Alternatively, your filter code can manually take care of any necessary "
"escaping. This is necessary when you're introducing new HTML markup into the "
"result. You want to mark the output as safe from further escaping so that "
"your HTML markup isn't escaped further, so you'll need to handle the input "
"yourself."
msgstr ""
"或者，你的过滤器代码要手动关注必须的转义操作。这在输出新 HTML 标记时是必须"
"的。想要避免你的 HTML 标记不被后续操作转义，你要将输出标记为安全的，且需要自"
"己处理输入。"

msgid ""
"To mark the output as a safe string, use :func:`django.utils.safestring."
"mark_safe`."
msgstr ""
"要将输出标记为安全字符串，使用 :func:`django.utils.safestring.mark_safe`。"

msgid ""
"Be careful, though. You need to do more than just mark the output as safe. "
"You need to ensure it really *is* safe, and what you do depends on whether "
"auto-escaping is in effect. The idea is to write filters that can operate in "
"templates where auto-escaping is either on or off in order to make things "
"easier for your template authors."
msgstr ""
"不过还是要小心，你要做的不只是将输出标记为安全的。你需要确保它 *真的是* 安全"
"的，你所做的取决于自动转义是否生效。理想状态下，编写的过滤器在自动转义开启与"
"关闭的情况下均能正确的操作模板，这样模板作者用起来就更简单了。 "

msgid ""
"In order for your filter to know the current auto-escaping state, set the "
"``needs_autoescape`` flag to ``True`` when you register your filter "
"function. (If you don't specify this flag, it defaults to ``False``). This "
"flag tells Django that your filter function wants to be passed an extra "
"keyword argument, called ``autoescape``, that is ``True`` if auto-escaping "
"is in effect and ``False`` otherwise. It is recommended to set the default "
"of the ``autoescape`` parameter to ``True``, so that if you call the "
"function from Python code it will have escaping enabled by default."
msgstr ""
"为了让你的过滤器知道自动转移开关的状态，在你注册过滤器函数时将 "
"``needs_autoescape`` 标志（默认 ``False``）设置为 ``True``。该标志告诉 "
"Django 过滤器函数额外接受一个名为 ``autoescape`` 关键字参数，值为 ``True`` 时"
"说明自动转义生效中， ``False`` 说明关闭。推荐将 ``autoescape`` 参数的默认值设"
"为 ``True``，这样，从 Python 代码调用此函数时，默认开启自动转义功能。"

msgid ""
"For example, let's write a filter that emphasizes the first character of a "
"string::"
msgstr "例子，让我们编写一个强制大写字符串的首字母的过滤器::"

msgid ""
"The ``needs_autoescape`` flag and the ``autoescape`` keyword argument mean "
"that our function will know whether automatic escaping is in effect when the "
"filter is called. We use ``autoescape`` to decide whether the input data "
"needs to be passed through ``django.utils.html.conditional_escape`` or not. "
"(In the latter case, we use the identity function as the \"escape\" "
"function.) The ``conditional_escape()`` function is like ``escape()`` except "
"it only escapes input that is **not** a ``SafeData`` instance. If a "
"``SafeData`` instance is passed to ``conditional_escape()``, the data is "
"returned unchanged."
msgstr ""
"``needs_autoescape`` 标志和 ``autoescape`` 自动转义关键字参数意味着函数会在过"
"滤器被调用时知道自动转义是否生效。我们利用 ``autoescape`` 来决定是否要将输入"
"数据传递给 ``django.utils.html.conditional_escape``。（后续实例中，我们使用同"
"一函数作为“转义”函数。） ``conditional_escape()`` 函数除了它只转义 **不是** "
"一个 ``SafeData`` 的实例的输入之外其他等同于 ``escape()`` 。如果一个 "
"``SafeData`` 实例经过 ``conditional_escape()`` ，数据将会不经过修改返回。"

msgid ""
"Finally, in the above example, we remember to mark the result as safe so "
"that our HTML is inserted directly into the template without further "
"escaping."
msgstr ""
"最后，在上述例子中，我们牢记将结果标为安全的，所以 HMTL 未经转义就直接插入模"
"板中。"

msgid ""
"There's no need to worry about the ``is_safe`` flag in this case (although "
"including it wouldn't hurt anything). Whenever you manually handle the auto-"
"escaping issues and return a safe string, the ``is_safe`` flag won't change "
"anything either way."
msgstr ""
"这种场景下无需担心 ``is_safe`` 标志（虽然包含它不会有什么问题）。无论你何时决"
"定手动处理自动转义，并返回安全字符串， ``is_safe`` 标志不会有任何影响。"

msgid "Avoiding XSS vulnerabilities when reusing built-in filters"
msgstr "在重用内置过滤器时避免 XSS 漏洞"

msgid ""
"Django's built-in filters have ``autoescape=True`` by default in order to "
"get the proper autoescaping behavior and avoid a cross-site script "
"vulnerability."
msgstr ""
"Django 内置的过滤器默认配置 ``autoescape=True``，获取合适的自动转义行为，并避"
"免跨站脚本漏洞。"

msgid ""
"In older versions of Django, be careful when reusing Django's built-in "
"filters as ``autoescape`` defaults to ``None``. You'll need to pass "
"``autoescape=True`` to get autoescaping."
msgstr ""
"在旧版本的 Django 中，复用 Django 内置过滤器时要小心，因为 ``自动转义`` 默认"
"为 ``None``。你需要传入 ``autoescape=True`` 启用自动转义。"

msgid ""
"For example, if you wanted to write a custom filter called "
"``urlize_and_linebreaks`` that combined the :tfilter:`urlize` and :tfilter:"
"`linebreaksbr` filters, the filter would look like::"
msgstr ""
"举个例子，如果你想编写一个联合 :tfilter:`urlize` 和 :tfilter:`linebreaksbr` "
"过滤器的，名为 ``urlize_and_linebreaks`` 的自定义过滤器，可通过以下代码::"

msgid "Then:"
msgstr "接下来："

msgid "would be equivalent to:"
msgstr "等价于："

msgid "Filters and time zones"
msgstr "过滤器和时区"

msgid ""
"If you write a custom filter that operates on :class:`~datetime.datetime` "
"objects, you'll usually register it with the ``expects_localtime`` flag set "
"to ``True``::"
msgstr ""
"如果你编写了一个自定义过滤器，处理 :class:`~datetime.datetime` 对象，注册过滤"
"器时通常将 ``expects_localtime`` 标志置为 ``True``::"

msgid ""
"When this flag is set, if the first argument to your filter is a time zone "
"aware datetime, Django will convert it to the current time zone before "
"passing it to your filter when appropriate, according to :ref:`rules for "
"time zones conversions in templates <time-zones-in-templates>`."
msgstr ""
"设置该标志后，如果过滤器接收的第一个参数是一个时区敏感的 datetime，Django 在"
"将其传递给过滤器前的某个合适时间将其转换为当前时区的时间，依据 :ref:`模板中的"
"时区转换规则 <time-zones-in-templates>`。"

msgid "Writing custom template tags"
msgstr "编写自定义模板标签"

msgid ""
"Tags are more complex than filters, because tags can do anything. Django "
"provides a number of shortcuts that make writing most types of tags easier. "
"First we'll explore those shortcuts, then explain how to write a tag from "
"scratch for those cases when the shortcuts aren't powerful enough."
msgstr ""
"标签比过滤器更复杂，因为标签啥都能做。Django 提供了很多快捷方式，简化了编写绝"
"大多数类型的标签过程。我们先探索这些快捷方式，然后解释如何在快捷方式不够强大"
"的情况下从零编写标签。"

msgid "Simple tags"
msgstr "简单标签"

msgid ""
"Many template tags take a number of arguments -- strings or template "
"variables -- and return a result after doing some processing based solely on "
"the input arguments and some external information. For example, a "
"``current_time`` tag might accept a format string and return the time as a "
"string formatted accordingly."
msgstr ""
"许多模板标签接受多个参数——字符串或模板变量——并仅根据输入参数和一些额外信息进"
"行某种处理，并返回结果。例如， ``current_time`` 标签可能接受一个格式字符串，"
"并将时间按照字符串要求的格式返回。"

msgid ""
"To ease the creation of these types of tags, Django provides a helper "
"function, ``simple_tag``. This function, which is a method of ``django."
"template.Library``, takes a function that accepts any number of arguments, "
"wraps it in a ``render`` function and the other necessary bits mentioned "
"above and registers it with the template system."
msgstr ""
"为了简化创建标签类型的流程，Django 提供了一个助手函数， ``simple_tag``。该函"
"数实际是 ``django.template.Library`` 的一个方法，该函数接受任意个数的参数，将"
"其封装在一个 ``render`` 函数以及上述其它必要的位置，并用模板系统注册它。"

msgid "Our ``current_time`` function could thus be written like this::"
msgstr "我们的 ``current_time`` 函数因此能这样写::"

msgid "A few things to note about the ``simple_tag`` helper function:"
msgstr "关于 ``simple_tag`` 助手函数，有几点要注意："

msgid ""
"Checking for the required number of arguments, etc., has already been done "
"by the time our function is called, so we don't need to do that."
msgstr "检测要求参数的个数等在调用函数时就已完成，所以我们无需再做。"

msgid ""
"The quotes around the argument (if any) have already been stripped away, so "
"we receive a plain string."
msgstr "包裹参数（如果有的话）的引号已被删除，所以我们收到一个普通字符串。"

msgid ""
"If the argument was a template variable, our function is passed the current "
"value of the variable, not the variable itself."
msgstr "如果参数是一个模板变量，函数将传递变量值，而不是变量本身。"

msgid ""
"Unlike other tag utilities, ``simple_tag`` passes its output through :func:"
"`~django.utils.html.conditional_escape` if the template context is in "
"autoescape mode, to ensure correct HTML and protect you from XSS "
"vulnerabilities."
msgstr ""
"若模板上下文处于自动转义模式，不像其它标签实体， ``simple_tag`` 通过 :func:"
"`~django.utils.html.conditional_escape` 传递输出，为了确保输出正确的 HTML，避"
"免 XSS 漏洞的威胁。"

msgid ""
"If additional escaping is not desired, you will need to use :func:`~django."
"utils.safestring.mark_safe` if you are absolutely sure that your code does "
"not contain XSS vulnerabilities. For building small HTML snippets, use of :"
"func:`~django.utils.html.format_html` instead of ``mark_safe()`` is strongly "
"recommended."
msgstr ""
"如果不需要额外转义，你可能需要在万分确定您的代码不会引入任何 XSS 漏洞的情况下"
"使用 :func:`~django.utils.safestring.mark_safe`。如果只是构建小的 HTML 片段，"
"强烈建议使用 :func:`~django.utils.html.format_html`，而不是 ``mark_safe()``。"

msgid ""
"If your template tag needs to access the current context, you can use the "
"``takes_context`` argument when registering your tag::"
msgstr ""
"若您的模板标签需要访问当前上下文，你可以在注册标签时传入 ``takes_context`` 参"
"数::"

msgid "Note that the first argument *must* be called ``context``."
msgstr "注意，第一个参数必须是 ``context``。"

msgid ""
"For more information on how the ``takes_context`` option works, see the "
"section on :ref:`inclusion tags<howto-custom-template-tags-inclusion-tags>`."
msgstr ""
"更多关于 ``takes_context`` 选项如何工作的信息，参见章节 :ref:`包含标签 "
"<howto-custom-template-tags-inclusion-tags>`。"

msgid "If you need to rename your tag, you can provide a custom name for it::"
msgstr "若你需要重命名标签，你可以为其提供一个自定义名称::"

msgid ""
"``simple_tag`` functions may accept any number of positional or keyword "
"arguments. For example::"
msgstr "``simple_tag`` 函数可以接受任意数量的位置或关键字参数。例如::"

msgid ""
"Then in the template any number of arguments, separated by spaces, may be "
"passed to the template tag. Like in Python, the values for keyword arguments "
"are set using the equal sign (\"``=``\") and must be provided after the "
"positional arguments. For example:"
msgstr ""
"随后在模板中，任意数量的，以空格分隔的参数会被传递给模板标签。与 Python 中类"
"似，关键字参数的赋值使用等号（\"``=``\"），且必须在位置参数后提供。例子："

msgid ""
"It's possible to store the tag results in a template variable rather than "
"directly outputting it. This is done by using the ``as`` argument followed "
"by the variable name. Doing so enables you to output the content yourself "
"where you see fit:"
msgstr ""
"将标签结果存入一个模板变量而不是直接将其输出是可能的。这能通过使用 ``as`` 参"
"数，后跟变量名实现。这样做能让你在期望的位置输出内容："

msgid "Inclusion tags"
msgstr "包含标签"

msgid ""
"Another common type of template tag is the type that displays some data by "
"rendering *another* template. For example, Django's admin interface uses "
"custom template tags to display the buttons along the bottom of the \"add/"
"change\" form pages. Those buttons always look the same, but the link "
"targets change depending on the object being edited -- so they're a perfect "
"case for using a small template that is filled with details from the current "
"object. (In the admin's case, this is the ``submit_row`` tag.)"
msgstr ""
"另一种常见的模板标签会为 *另一个* 模板渲染数据。例如， Django 的后台利用自定"
"义模板标签在表单页的底部展示按钮。这些按钮看起来一样，但是连接目标根据被编辑"
"的对象不同而不同——所以，这是一个极好的例子，展示如何用当前对象的细节填充小模"
"板。（在后台例子中，即 ``submit_row`` 标签。）"

msgid "These sorts of tags are called \"inclusion tags\"."
msgstr "这种标签被称为“包含标签”。"

msgid ""
"Writing inclusion tags is probably best demonstrated by example. Let's write "
"a tag that outputs a list of choices for a given ``Poll`` object, such as "
"was created in the :ref:`tutorials <creating-models>`. We'll use the tag "
"like this:"
msgstr ""
"编写包含标签可能最好通过实例来展示。让我们编写一个标签，它会将指定 ``Poll`` "
"对象（就像 :ref:`教程 <creating-models>` 中创建的那样）的选项以列表输出。我们"
"像这样使用标签："

msgid "...and the output will be something like this:"
msgstr "输出看起来像这样："

msgid ""
"First, define the function that takes the argument and produces a dictionary "
"of data for the result. The important point here is we only need to return a "
"dictionary, not anything more complex. This will be used as a template "
"context for the template fragment. Example::"
msgstr ""
"首先，定义一个函数，接受参数，并返回一个字典。此处的要点是我们只需返回一个字"
"典，不是任何其它复杂的东西。这将作为一个模板上下文被模板碎片使用。例子::"

msgid ""
"Next, create the template used to render the tag's output. This template is "
"a fixed feature of the tag: the tag writer specifies it, not the template "
"designer. Following our example, the template is very short:"
msgstr ""
"随后，创建用于渲染标签输出的模板。该模板是标签的一个固有特性：标签作者指定"
"它，而不是模板设计者。跟随我们的例子，模板非常简短："

msgid ""
"Now, create and register the inclusion tag by calling the "
"``inclusion_tag()`` method on a ``Library`` object. Following our example, "
"if the above template is in a file called ``results.html`` in a directory "
"that's searched by the template loader, we'd register the tag like this::"
msgstr ""
"现在，在 ``Library`` 对象上调用 ``inclusion_tag()`` 创建并注册该包含标签。如"
"果上述模板位于一个名为 ``results.html`` 的文件中，在模板加载器搜索的目录中，"
"我们像这样注册该标签::"

msgid ""
"Alternatively it is possible to register the inclusion tag using a :class:"
"`django.template.Template` instance::"
msgstr "或者，也能用 :class:`django.template.Template` 实例注册包含标签::"

msgid "...when first creating the function."
msgstr "在第一次创建该函数时。"

msgid ""
"Sometimes, your inclusion tags might require a large number of arguments, "
"making it a pain for template authors to pass in all the arguments and "
"remember their order. To solve this, Django provides a ``takes_context`` "
"option for inclusion tags. If you specify ``takes_context`` in creating a "
"template tag, the tag will have no required arguments, and the underlying "
"Python function will have one argument -- the template context as of when "
"the tag was called."
msgstr ""
"有时候，你的包含标签可能要求超多参数，模板作者不得不传入所有参数，并牢记它们"
"的顺序，非常痛苦。为了解决此问题， Django 为包含标签提供了一个 "
"``take_context`` 选项。如果在创建模板标签时指定了 ``takes_context``，该标签将"
"没有必要的参数，底层 Python 函数将只有一个参数——标签创建时的模板上下文。"

msgid ""
"For example, say you're writing an inclusion tag that will always be used in "
"a context that contains ``home_link`` and ``home_title`` variables that "
"point back to the main page. Here's what the Python function would look "
"like::"
msgstr ""
"举个例子，假设你编写了一个包含标签，总会在一个包含指向首页的 ``home_link`` "
"和 ``home_title`` 的上下文环境下使用。Python 函数看起来会像这样::"

msgid ""
"Note that the first parameter to the function *must* be called ``context``."
msgstr "注意，该函数的第一个参数 *必须* 是 ``context``。"

msgid ""
"In that ``register.inclusion_tag()`` line, we specified "
"``takes_context=True`` and the name of the template. Here's what the "
"template ``link.html`` might look like:"
msgstr ""
"在 ``register.inclusion_tag()`` 行，我们制定了模板名并设置 "
"``takes_context=True``。以下是模板 ``link.html`` 的样子："

msgid ""
"Then, any time you want to use that custom tag, load its library and call it "
"without any arguments, like so:"
msgstr ""
"后面，当你想用该自定义标签时，加载它的库，并不带任何参数的调用它，像这样："

msgid ""
"Note that when you're using ``takes_context=True``, there's no need to pass "
"arguments to the template tag. It automatically gets access to the context."
msgstr ""
"注意，只要使用了 ``takes_context=True``，就无需为模板标签传递参数。它自动从上"
"下文获取。"

msgid ""
"The ``takes_context`` parameter defaults to ``False``. When it's set to "
"``True``, the tag is passed the context object, as in this example. That's "
"the only difference between this case and the previous ``inclusion_tag`` "
"example."
msgstr ""
"``takes_context`` 参数默认为 ``False``。当其为 ``True``，标签会被传入上下文对"
"象，像本例展示的那样。这是本例和之前的 ``包含标签`` 实例的唯一不同之处。"

msgid ""
"``inclusion_tag`` functions may accept any number of positional or keyword "
"arguments. For example::"
msgstr "``包含标签`` 函数能接受任意个数的位置或关键字参数。例子::"

msgid "Advanced custom template tags"
msgstr "进阶自定义模板标签"

msgid ""
"Sometimes the basic features for custom template tag creation aren't enough. "
"Don't worry, Django gives you complete access to the internals required to "
"build a template tag from the ground up."
msgstr ""
"有时候，用于自定义模板标签的基础特性不够用。不要担心，Django 开放了从零开始构"
"建模板标签所需的所有内置机制。"

msgid "A quick overview"
msgstr "简介"

msgid ""
"The template system works in a two-step process: compiling and rendering. To "
"define a custom template tag, you specify how the compilation works and how "
"the rendering works."
msgstr ""
"模板系统工作只需两步：编译和渲染。为了定义自定义模板标签，你需指定如何编译和"
"渲染。"

msgid ""
"When Django compiles a template, it splits the raw template text into "
"''nodes''. Each node is an instance of ``django.template.Node`` and has a "
"``render()`` method. A compiled template is a list of ``Node`` objects. When "
"you call ``render()`` on a compiled template object, the template calls "
"``render()`` on each ``Node`` in its node list, with the given context.  The "
"results are all concatenated together to form the output of the template."
msgstr ""
"Django 编译模板时，会将原始模板文本划为“节点”。每个节点都是一个 ``django."
"template.Node`` 实例，拥有一个 ``render()`` 方法。编译完的模板就是一个包含 ``"
"节点`` 对象的列表。当你在已编译的模板上调用 ``render()``，该模板会为节点列表"
"中的每个 ``节点`` 携带指定上下文调用 ``render()`` 方法。结果会自动连接，形成"
"模板的输出。"

msgid ""
"Thus, to define a custom template tag, you specify how the raw template tag "
"is converted into a ``Node`` (the compilation function), and what the node's "
"``render()`` method does."
msgstr ""
"因此，要定义一个自定义模板标签，你要指定如何将原始模板标签转换为 ``节点`` "
"（编译函数），还要指定 ``render()`` 方法的操作。"

msgid "Writing the compilation function"
msgstr "编写编译函数"

msgid ""
"For each template tag the template parser encounters, it calls a Python "
"function with the tag contents and the parser object itself. This function "
"is responsible for returning a ``Node`` instance based on the contents of "
"the tag."
msgstr ""
"模板解析器遇到的每个模板标签，解析器都会调用一个 Python 函数，参数是标签内容"
"和解析器对象本身。该函数需要基于标签的内容返回一个 ``节点`` 实例。"

msgid ""
"For example, let's write a full implementation of our template tag, ``{% "
"current_time %}``, that displays the current date/time, formatted according "
"to a parameter given in the tag, in :func:`~time.strftime` syntax. It's a "
"good idea to decide the tag syntax before anything else. In our case, let's "
"say the tag should be used like this:"
msgstr ""
"举个例子，让我们完整地实现模板标签 ``{% current_time %}``，该标签根据标签中指"
"定的参数，以 :func:`~time.strftime` 语法格式化当前时间或日期。先决定标签语法"
"是个不错的主意。在本例中，我们要这样使用标签："

msgid ""
"The parser for this function should grab the parameter and create a ``Node`` "
"object::"
msgstr "这个函数的解析器应用获取参数，并创建一个 ``节点`` 对象::"

msgid "Notes:"
msgstr "注意："

msgid ""
"``parser`` is the template parser object. We don't need it in this example."
msgstr "``parser`` 是模板解析器对象。本例中不需要。"

msgid ""
"``token.contents`` is a string of the raw contents of the tag. In our "
"example, it's ``'current_time \"%Y-%m-%d %I:%M %p\"'``."
msgstr ""
"``token.contents`` 是包含标签原始内容的字符串。本例中是 ``'current_time \"%Y-"
"%m-%d %I:%M %p\"'``。"

msgid ""
"The ``token.split_contents()`` method separates the arguments on spaces "
"while keeping quoted strings together. The more straightforward ``token."
"contents.split()`` wouldn't be as robust, as it would naively split on *all* "
"spaces, including those within quoted strings. It's a good idea to always "
"use ``token.split_contents()``."
msgstr ""
"``token.split_contents()`` 方法按空格分隔字符串，但不会分隔引号包裹的部分。二"
"愣子 ``token.contents.split()`` 就没那么健壮了，它直接在空格处分割字符串，不"
"论它们是否被引号包裹。推荐总是使用 ``token.split_contents()``。"

msgid ""
"This function is responsible for raising ``django.template."
"TemplateSyntaxError``, with helpful messages, for any syntax error."
msgstr ""
"该方法要在语法错误发生时抛出包含有用信息的 ``django.template."
"TemplateSyntaxError``。"

msgid ""
"The ``TemplateSyntaxError`` exceptions use the ``tag_name`` variable. Don't "
"hard-code the tag's name in your error messages, because that couples the "
"tag's name to your function. ``token.contents.split()[0]`` will ''always'' "
"be the name of your tag -- even when the tag has no arguments."
msgstr ""
"``TemplateSyntaxError`` 异常使用了 ``tag_name`` 变量。不要在错误消息中硬编码"
"标签名，因为这会使的标签名与函数耦合。 ``token.contents.split()[0]`` 总会返回"
"标签名——即便标签没有参数。"

msgid ""
"The function returns a ``CurrentTimeNode`` with everything the node needs to "
"know about this tag. In this case, it passes the argument -- ``\"%Y-%m-%d %I:"
"%M %p\"``. The leading and trailing quotes from the template tag are removed "
"in ``format_string[1:-1]``."
msgstr ""
"该函数返回一个 ``CurrentTimeNode``，内含节点需要了解的标签的一切信息。在本例"
"中，传递了参数—— ``\"%Y-%m-%d %I:%M %p\"``。开头和结尾的引号由 "
"``format_string[1:-1]`` 删除。"

msgid ""
"The parsing is very low-level. The Django developers have experimented with "
"writing small frameworks on top of this parsing system, using techniques "
"such as EBNF grammars, but those experiments made the template engine too "
"slow. It's low-level because that's fastest."
msgstr ""
"这种解析是很低级的。Django 开发者已试着在该解析系统之上编写小型解析框架，使用"
"类似 EBNF 语法，但这些尝试使得模板引擎运行的很慢。低级意味着快。"

msgid "Writing the renderer"
msgstr "编写渲染器"

msgid ""
"The second step in writing custom tags is to define a ``Node`` subclass that "
"has a ``render()`` method."
msgstr ""
"编写自定义标签的第二步是定义一个 ``Node`` 子类，带有一个 ``render()`` 方法。"

msgid "Continuing the above example, we need to define ``CurrentTimeNode``::"
msgstr "承接上述例子，我们需要定义 ``CurrentTimeNode``::"

msgid ""
"``__init__()`` gets the ``format_string`` from ``do_current_time()``. Always "
"pass any options/parameters/arguments to a ``Node`` via its ``__init__()``."
msgstr ""
"``__init__()`` 从 ``do_current_time()`` 获取 ``format_string``。总是通过 ``节"
"点`` 的 ``__init__()`` 方法为其传入  options/parameters/arguments。"

msgid "The ``render()`` method is where the work actually happens."
msgstr "``render()`` 方法是实际干活的地方。"

msgid ""
"``render()`` should generally fail silently, particularly in a production "
"environment. In some cases however, particularly if ``context.template."
"engine.debug`` is ``True``, this method may raise an exception to make "
"debugging easier. For example, several core tags raise ``django.template."
"TemplateSyntaxError`` if they receive the wrong number or type of arguments."
msgstr ""
"``render()`` 应该无声失败，尤其是在生产环境。不过，某些场景下，尤其是 "
"``context.template.engine.debug`` 为 ``True`` 时，该方法可能抛出一个异常，简"
"化调式流程。例如，某些核心标签在接受个数不对的参数时抛出 ``django.template."
"TemplateSyntaxError``。"

msgid ""
"Ultimately, this decoupling of compilation and rendering results in an "
"efficient template system, because a template can render multiple contexts "
"without having to be parsed multiple times."
msgstr ""
"最终，这种对编译和渲染的解耦会产生一个高效的模板系统，因为一个模板无需多次解"
"析就能渲染多个上下文。"

msgid "Auto-escaping considerations"
msgstr "自动转义的注意事项"

msgid ""
"The output from template tags is **not** automatically run through the auto-"
"escaping filters (with the exception of :meth:`~django.template.Library."
"simple_tag` as described above). However, there are still a couple of things "
"you should keep in mind when writing a template tag."
msgstr ""
"模板标签的输出 **不会** 自动通过自动转义过滤器（除了上述的 :meth:`~django."
"template.Library.simple_tag` 之外）。不过，在编写模板标签时，你仍需牢记几点。"

msgid ""
"If the ``render()`` method of your template tag stores the result in a "
"context variable (rather than returning the result in a string), it should "
"take care to call ``mark_safe()`` if appropriate. When the variable is "
"ultimately rendered, it will be affected by the auto-escape setting in "
"effect at the time, so content that should be safe from further escaping "
"needs to be marked as such."
msgstr ""
"若模板标签的 ``render()`` 方法在上下文变量中存储结果（而不是以字符串返回结"
"果），它要小心地在合适的时机调用 ``mark_safe()``。当变量最后一次被渲染时，它"
"会在这个时候受到自动转义配置的影响，所以为了避免变量被进一步转义，需要如此配"
"置。"

msgid ""
"Also, if your template tag creates a new context for performing some sub-"
"rendering, set the auto-escape attribute to the current context's value. The "
"``__init__`` method for the ``Context`` class takes a parameter called "
"``autoescape`` that you can use for this purpose. For example::"
msgstr ""
"同理，如果你的模板标签为某些子渲染进程创建了新的上下文，那么就需要将当前上下"
"文对应的自动转义属性传入。 ``Context`` 类的方法 ``__init__`` 的参数 "
"``autoescape`` 就是为此目的设计的。例如::"

msgid ""
"This is not a very common situation, but it's useful if you're rendering a "
"template yourself. For example::"
msgstr "该场景不常见，但在自助渲染模板时很有用。例如::"

msgid ""
"If we had neglected to pass in the current ``context.autoescape`` value to "
"our new ``Context`` in this example, the results would have *always* been "
"automatically escaped, which may not be the desired behavior if the template "
"tag is used inside a :ttag:`{% autoescape off %}<autoescape>` block."
msgstr ""
"在本例中，如果我们忽略了将当前的 ``context.autoescape`` 值传递给新 "
"``Context``，结果 *总会* 被自动转义，这可能与期望不同，尤其是模板标签被用于 :"
"ttag:`{% autoescape off %} <autoescape>` 块之内的时候。"

msgid "Thread-safety considerations"
msgstr "线程安全的注意事项"

msgid ""
"Once a node is parsed, its ``render`` method may be called any number of "
"times. Since Django is sometimes run in multi-threaded environments, a "
"single node may be simultaneously rendering with different contexts in "
"response to two separate requests. Therefore, it's important to make sure "
"your template tags are thread safe."
msgstr ""
"节点被解析后，其 ``render`` 方法可能被任意次地调用。由于 Django 有可能运行于"
"多线程环境，一个节点可能同时以不同的上下文进行渲染，以相应不同的请求。因此，"
"确保你的模板标签是线程安全就非常重要了。"

msgid ""
"To make sure your template tags are thread safe, you should never store "
"state information on the node itself. For example, Django provides a "
"builtin :ttag:`cycle` template tag that cycles among a list of given strings "
"each time it's rendered:"
msgstr ""
"为了确保你的模板标签是线程安全的，你应该永远不要在节点中存储状态信息。例如，"
"Django 提供了一个内置的 :ttag:`cycle` 模板标签，每次渲染时它都在一个给定字符"
"串列表间循环："

msgid ""
"A naive implementation of ``CycleNode`` might look something like this::"
msgstr "``CycleNode`` 的原生实现看起来可能像这样::"

msgid ""
"But, suppose we have two templates rendering the template snippet from above "
"at the same time:"
msgstr "但是，假设有两个模板渲染器同时渲染上述模板片段："

msgid ""
"Thread 1 performs its first loop iteration, ``CycleNode.render()`` returns "
"'row1'"
msgstr "线程 1 执行其第一次迭代， ``CycleNode.render()`` 返回 'row1'"

msgid ""
"Thread 2 performs its first loop iteration, ``CycleNode.render()`` returns "
"'row2'"
msgstr "线程 2 执行其第一次迭代， ``CycleNode.render()`` 返回 'row2'"

msgid ""
"Thread 1 performs its second loop iteration, ``CycleNode.render()`` returns "
"'row1'"
msgstr "线程 1 执行其第二次迭代， ``CycleNode.render()`` 返回 'row1'"

msgid ""
"Thread 2 performs its second loop iteration, ``CycleNode.render()`` returns "
"'row2'"
msgstr "线程 2 执行其第二次迭代， ``CycleNode.render()`` 返回 'row2'"

msgid ""
"The CycleNode is iterating, but it's iterating globally. As far as Thread 1 "
"and Thread 2 are concerned, it's always returning the same value. This is "
"not what we want!"
msgstr ""
"CycleNode 正在被迭代，却是全局范围的。就像线程 1 和线程 2 担心的那样，它们总"
"是返回同样的值。这不是我们想要的。"

msgid ""
"To address this problem, Django provides a ``render_context`` that's "
"associated with the ``context`` of the template that is currently being "
"rendered. The ``render_context`` behaves like a Python dictionary, and "
"should be used to store ``Node`` state between invocations of the ``render`` "
"method."
msgstr ""
"为了定位此问题，Django 提供了一个 ``render_context``，关联至当前正在渲染的模"
"板的 ``context``。 ``render_context`` 表现的像一个 Python 字典，应该在其中保"
"存多次同时调用 ``render`` 方法时的 ``Node`` 状态。"

msgid ""
"Let's refactor our ``CycleNode`` implementation to use the "
"``render_context``::"
msgstr "让我们用 ``render_context`` 重构我们的 ``CycleNode`` 实现::"

msgid ""
"Note that it's perfectly safe to store global information that will not "
"change throughout the life of the ``Node`` as an attribute. In the case of "
"``CycleNode``, the ``cyclevars`` argument doesn't change after the ``Node`` "
"is instantiated, so we don't need to put it in the ``render_context``. But "
"state information that is specific to the template that is currently being "
"rendered, like the current iteration of the ``CycleNode``, should be stored "
"in the ``render_context``."
msgstr ""
"注意，将 ``Node`` 生命周期中都不会发生变化的全局信息保存为属性是非常安全的。"
"在 ``CycleNode`` 例中， ``cyclevars`` 参数在 ``Node`` 初始化后就不会变了，所"
"以无需将其放入 ``render_context``。但是当前正在渲染的模板的状态信息，类似 "
"``CycleNode`` 的当前迭代信息，就应该被保存在 ``render_context``。"

msgid ""
"Notice how we used ``self`` to scope the ``CycleNode`` specific information "
"within the ``render_context``. There may be multiple ``CycleNodes`` in a "
"given template, so we need to be careful not to clobber another node's state "
"information. The easiest way to do this is to always use ``self`` as the key "
"into ``render_context``. If you're keeping track of several state variables, "
"make ``render_context[self]`` a dictionary."
msgstr ""
"注意我们是如何利用 ``self`` 将 ``CycleNode`` 的特定参数装入 "
"``render_context`` 的。一个模板中可能有多个 ``CycleNodes``，所以我们要十分小"
"心，不要破坏其它节点的状态信息。最简单的方式就是一直将 ``self`` 作为键存入 "
"``render_context``。如果你同时追踪好几个状态变量，将 "
"``render_context[self]`` 做成一个字典。"

msgid "Registering the tag"
msgstr "注册该标签"

msgid ""
"Finally, register the tag with your module's ``Library`` instance, as "
"explained in :ref:`writing custom template tags<howto-writing-custom-"
"template-tags>` above. Example::"
msgstr ""
"最后，用你的模块的 ``Library`` 实例注册该标签，像上文 :ref:`编写自定义模板标"
"签 1` 介绍的那样。举个例子："

msgid "The ``tag()`` method takes two arguments:"
msgstr "``tag`` 方法接收两个参数："

msgid ""
"The name of the template tag -- a string. If this is left out, the name of "
"the compilation function will be used."
msgstr "模板标签的名字——一个字符串。若为空，将会使用编译函数的名字。"

msgid ""
"As with filter registration, it is also possible to use this as a decorator::"
msgstr "就像过滤器注册一样，这里也能用装饰器::"

msgid ""
"If you leave off the ``name`` argument, as in the second example above, "
"Django will use the function's name as the tag name."
msgstr ""
"若未输入 ``name`` 参数，像上述第二个例子一样，Django 会将函数名作为标签名。"

msgid "Passing template variables to the tag"
msgstr "传递模板变量给标签"

msgid ""
"Although you can pass any number of arguments to a template tag using "
"``token.split_contents()``, the arguments are all unpacked as string "
"literals. A little more work is required in order to pass dynamic content (a "
"template variable) to a template tag as an argument."
msgstr ""
"虽然你能利用 ``token.split_contents()`` 将任意数量的变量传递给一个模板标签，"
"但是解包出来的参数均是字符串文本。要将一个动态内容（一个模板变量）作为参数传"
"递给模板标签需要额外工作。"

msgid ""
"While the previous examples have formatted the current time into a string "
"and returned the string, suppose you wanted to pass in a :class:`~django.db."
"models.DateTimeField` from an object and have the template tag format that "
"date-time:"
msgstr ""
"前文的例子已经成功将当前时间转为字符串并将之返回，假设你想传入一个 :class:"
"`~django.db.models.DateTimeField` 对象，并想用该模板标签格式化这个对象："

msgid "Initially, ``token.split_contents()`` will return three values:"
msgstr "首先，``token.split_contents()`` 会返回 3 个值："

msgid "The tag name ``format_time``."
msgstr "标签名 ``format_time``。"

msgid ""
"The string ``'blog_entry.date_updated'`` (without the surrounding quotes)."
msgstr "字符串 ``'blog_entry.date_updated'`` （不包含引号）。"

msgid ""
"The formatting string ``'\"%Y-%m-%d %I:%M %p\"'``. The return value from "
"``split_contents()`` will include the leading and trailing quotes for string "
"literals like this."
msgstr ""
"格式化字符串 ``'\"%Y-%m-%d %I:%M %p\"'``。 ``split_contents()`` 的返回值会为"
"类似这样的字符串保留引号。"

msgid "Now your tag should begin to look like this::"
msgstr "现在，你的标签应该看起来像这样::"

msgid ""
"You also have to change the renderer to retrieve the actual contents of the "
"``date_updated`` property of the ``blog_entry`` object.  This can be "
"accomplished by using the ``Variable()`` class in ``django.template``."
msgstr ""
"你也需要修改 renderer，让其获取 ``blog_entry`` 对象的 ``date_updated`` 属性的"
"真实内容。这能通过在 ``django.template`` 中使用 ``Variable()`` 完成。"

msgid ""
"To use the ``Variable`` class, instantiate it with the name of the variable "
"to be resolved, and then call ``variable.resolve(context)``. So, for "
"example::"
msgstr ""
"要使用 ``Variable`` 类，用变量名实例化它，并调用 ``variable."
"resolve(context)`` 上下文。举个例子："

msgid ""
"Variable resolution will throw a ``VariableDoesNotExist`` exception if it "
"cannot resolve the string passed to it in the current context of the page."
msgstr ""
"变量解决方案会在无法在当前页的上下文中找到指定字符串时抛出 "
"``VariableDoesNotExist`` 异常。"

msgid "Setting a variable in the context"
msgstr "在上下文中设置变量"

msgid ""
"The above examples output a value. Generally, it's more flexible if your "
"template tags set template variables instead of outputting values. That way, "
"template authors can reuse the values that your template tags create."
msgstr ""
"上述例子输出了一个值。一般来说，如果你的模板标签设置模板变量，会比直接输出更"
"加灵活。这样，模板作者在你的模板标签创建时能复用这些值。"

msgid ""
"To set a variable in the context, use dictionary assignment on the context "
"object in the ``render()`` method. Here's an updated version of "
"``CurrentTimeNode`` that sets a template variable ``current_time`` instead "
"of outputting it::"
msgstr ""
"要在上下文中设置变量，需要在 ``render()`` 方法中对其上下文使用字典赋值。新版"
"的 ``CurrentTimeNode`` 设置了一个模板变量 ``current_time``，而不是直接输出::"

msgid ""
"Note that ``render()`` returns the empty string. ``render()`` should always "
"return string output. If all the template tag does is set a variable, "
"``render()`` should return the empty string."
msgstr ""
"注意， ``render()`` 返回了空字符串。 ``render()`` 应该总是返回字符串。如果所"
"有的模板标签都设置了变量， ``render()`` 应该返回空字符串。"

msgid "Here's how you'd use this new version of the tag:"
msgstr "下面是如何使用新版标签的实例："

msgid "Variable scope in context"
msgstr "上下文中的变量作用域"

msgid ""
"Any variable set in the context will only be available in the same ``block`` "
"of the template in which it was assigned. This behavior is intentional; it "
"provides a scope for variables so that they don't conflict with context in "
"other blocks."
msgstr ""
"上下文内变量仅在模板中相同 ``block`` 内生效。这是故意的；提供有作用域的变量不"
"会与其它区块中的上下文发生冲突。"

msgid ""
"But, there's a problem with ``CurrentTimeNode2``: The variable name "
"``current_time`` is hard-coded. This means you'll need to make sure your "
"template doesn't use ``{{ current_time }}`` anywhere else, because the ``{% "
"current_time %}`` will blindly overwrite that variable's value. A cleaner "
"solution is to make the template tag specify the name of the output "
"variable, like so:"
msgstr ""
"但是， ``CurrentTimeNode2`` 有个问题：变量名 ``current_time`` 是硬编码的。这"
"意味着你需要确认模板未在其它地方使用 ``{{ current_time }}``，因为 ``{% "
"current_time %}`` 会绑定兵重写该变量的值。一个简洁的方法是让模板标签指定输出"
"变量的值，像这样："

msgid ""
"To do that, you'll need to refactor both the compilation function and "
"``Node`` class, like so::"
msgstr "为此，你需要重构编译函数和 ``Node`` 类，像这样::"

msgid ""
"The difference here is that ``do_current_time()`` grabs the format string "
"and the variable name, passing both to ``CurrentTimeNode3``."
msgstr ""
"此处的不同点是 ``do_current_time()`` 处理了格式化字符串和变量名，并将它们传递"
"给 ``CurrentTimeNode3``。"

msgid ""
"Finally, if you only need to have a simple syntax for your custom context-"
"updating template tag, consider using the :meth:`~django.template.Library."
"simple_tag` shortcut, which supports assigning the tag results to a template "
"variable."
msgstr ""
"最后，如果你的自定义上下文更新模板标签只需要简单的语法，考虑使用 :meth:"
"`~django.template.Library.simple_tag` 快捷方式，它支持将标签结果分配给模板变"
"量。"

msgid "Parsing until another block tag"
msgstr "解析直到碰到另一区块的标签"

msgid ""
"Template tags can work in tandem. For instance, the standard :ttag:`{% "
"comment %}<comment>` tag hides everything until ``{% endcomment %}``. To "
"create a template tag such as this, use ``parser.parse()`` in your "
"compilation function."
msgstr ""
"模板标签能串联工作。例如，标准标签 ttag:`{% comment %} <comment>` 隐藏任何东"
"西，直到碰到 ``{% endcomment %}``。要创建一个类似的标签，在编译函数中使用 "
"``parser.parse()``。"

msgid "Here's how a simplified ``{% comment %}`` tag might be implemented::"
msgstr "以下是如何实现一个简单的 ``{% comment %}`` 标签的介绍::"

msgid ""
"The actual implementation of :ttag:`{% comment %}<comment>` is slightly "
"different in that it allows broken template tags to appear between ``{% "
"comment %}`` and ``{% endcomment %}``. It does so by calling ``parser."
"skip_past('endcomment')`` instead of ``parser.parse(('endcomment',))`` "
"followed by ``parser.delete_first_token()``, thus avoiding the generation of "
"a node list."
msgstr ""
":ttag:`{% comment %} <comment>` 的实现略有不同，它允许 ``{% comment %}`` 和 "
"``{% endcomment %}`` 出现破损的标记。它通过调用 ``parser."
"skip_past('endcomment')`` （而不是 ``parser.parse(('endcomment',))``），后跟 "
"``parser.delete_first_token()``，从而避免生成节点列表。"

msgid ""
"``parser.parse()`` takes a tuple of names of block tags ''to parse until''. "
"It returns an instance of ``django.template.NodeList``, which is a list of "
"all ``Node`` objects that the parser encountered ''before'' it encountered "
"any of the tags named in the tuple."
msgstr ""
"``parser.parse()`` 接受一个包含 “解析直到” 区块标签的元组。它返回一个 "
"``django.template.NodeList`` 实例，它解析器遇到元组中的标签前解析的 ``Node`` "
"对象。"

msgid ""
"In ``\"nodelist = parser.parse(('endcomment',))\"`` in the above example, "
"``nodelist`` is a list of all nodes between the ``{% comment %}`` and ``{% "
"endcomment %}``, not counting ``{% comment %}`` and ``{% endcomment %}`` "
"themselves."
msgstr ""
"上文例子 ``\"nodelist = parser.parse(('endcomment',))\"`` 中， ``nodelist`` "
"是一个包含了 ``{% comment %}`` 和 ``{% endcomment %}`` 之间所有节点的列表，但"
"不包含 ``{% comment %}`` 和 ``{% endcomment %}`` 本身。"

msgid ""
"After ``parser.parse()`` is called, the parser hasn't yet \"consumed\" the "
"``{% endcomment %}`` tag, so the code needs to explicitly call ``parser."
"delete_first_token()``."
msgstr ""
"在调用 ``parser.parse()`` 后，解析还未 “消费掉” ``{% endcomment %}`` 标签，所"
"以代码需要显示地调用 ``parser.delete_first_token()``。"

msgid ""
"``CommentNode.render()`` returns an empty string. Anything between ``{% "
"comment %}`` and ``{% endcomment %}`` is ignored."
msgstr ""
"``CommentNode.render()`` 返回了一个空字符串。 ``{% comment %}`` 和 ``{% "
"endcomment %}``  注释之间的全部内容均被忽略。"

msgid "Parsing until another block tag, and saving contents"
msgstr "解析直到碰到另一区块标签，并保存内容。"

msgid ""
"In the previous example, ``do_comment()`` discarded everything between ``{% "
"comment %}`` and ``{% endcomment %}``. Instead of doing that, it's possible "
"to do something with the code between block tags."
msgstr ""
"在前文的例子中， ``do_comment`` 抛弃了 ``{% comment %}`` 和 ``{% endcomment "
"%}`` 之间的所有内容。现在我们不这么做，我们要对区块标签之间的东西做点什么。"

msgid ""
"For example, here's a custom template tag, ``{% upper %}``, that capitalizes "
"everything between itself and ``{% endupper %}``."
msgstr ""
"举个例子，这里有个模板标签， ``{% upper %}``，它将自己与 ``{% endupper %}`` "
"之间的内容全部大写。"

msgid "Usage:"
msgstr "用法："

msgid ""
"As in the previous example, we'll use ``parser.parse()``. But this time, we "
"pass the resulting ``nodelist`` to the ``Node``::"
msgstr ""
"与之前的例子一样，我们将使用 ``parser.parse()``。但这次，我们将生成的 "
"``nodelist`` 传递给 ``Node``::"

msgid ""
"The only new concept here is the ``self.nodelist.render(context)`` in "
"``UpperNode.render()``."
msgstr ""
"唯一的新概念是 ``UpperNode.render()`` 中的 ``self.nodelist."
"render(context)``。"

msgid ""
"For more examples of complex rendering, see the source code of :ttag:`{% for "
"%}<for>` in :source:`django/template/defaulttags.py` and :ttag:`{% if %}"
"<if>` in :source:`django/template/smartif.py`."
msgstr ""
"要获取更多复杂渲染的示例，请查看 :source:`django/template/defaulttags.py` 中"
"的 :ttag:`{% for %}<for>` 和 :source:`django/template/smartif.py` 中的 :ttag:"
"`{% if %}<if>` 的源代码。"

msgid "How to delete a Django application"
msgstr "如何删除一个 Django 应用"

msgid ""
"Django provides the ability to group sets of features into Python packages "
"called :doc:`applications</ref/applications/>`. When requirements change, "
"apps may become obsolete or unnecessary. The following steps will help you "
"delete an application safely."
msgstr ""
"Django 提供了将一组功能组织成名为 :doc:`应用程序</ref/applications/>` 的 "
"Python 包的能力。当需求发生变化时，应用程序可能会变得过时或不再需要。以下步骤"
"将帮助你安全地删除一个应用程序。"

msgid "Remove all references to the app (imports, foreign keys etc.)."
msgstr "删除所有与该应用程序相关的引用（导入、外键等）。"

msgid "Remove all models from the corresponding ``models.py`` file."
msgstr "从相应的 ``models.py`` 文件中删除所有模型。"

msgid ""
"Create relevant migrations by running :djadmin:`makemigrations`. This step "
"generates a migration that deletes tables for the removed models, and any "
"other required migration for updating relationships connected to those "
"models."
msgstr ""
"通过运行 :djadmin:`makemigrations` 来创建相关的迁移。这一步会生成一个迁移，用"
"于删除已删除模型的表，以及与这些模型相关的更新关系所需的任何其他迁移。"

msgid ""
":ref:`Squash <migration-squashing>` out references to the app in other apps' "
"migrations."
msgstr ""
":ref:`压缩 <migration-squashing>` 其他应用程序的迁移中与该应用程序相关的引"
"用。"

msgid ""
"Apply migrations locally, runs tests, and verify the correctness of your "
"project."
msgstr "在本地应用迁移，运行测试，并验证项目的正确性。"

msgid "Deploy/release your updated Django project."
msgstr "部署/发布您更新后的 Django 项目。"

msgid "Remove the app from :setting:`INSTALLED_APPS`."
msgstr "从 :setting:`INSTALLED_APPS` 中删除该应用程序。"

msgid "Finally, remove the app's directory."
msgstr "最后，删除应用程序的目录。"

msgid "How to use Django with Daphne"
msgstr "如何使用 Daphne 托管 Django"

msgid ""
":pypi:`Daphne <daphne>` is a pure-Python ASGI server for UNIX, maintained by "
"members of the Django project. It acts as the reference server for ASGI."
msgstr ""
":pypi:`Daphne <daphne>` 是一个纯 Python 的 ASGI 服务器，由 Django 项目的成员"
"维护。它充当了 ASGI 的参考服务器。"

msgid "Installing Daphne"
msgstr "安装 Daphne"

msgid "You can install Daphne with ``pip``:"
msgstr "你可以使用 ``pip`` 安装 Daphne："

msgid "Running Django in Daphne"
msgstr "在 Daphne 中运行 Django"

msgid ""
"When Daphne is installed, a ``daphne`` command is available which starts the "
"Daphne server process. At its simplest, Daphne needs to be called with the "
"location of a module containing an ASGI application object, followed by what "
"the application is called (separated by a colon)."
msgstr ""
"一旦 Daphne 安装完毕，你就可以使用 ``daphne`` 命令了，它将用来启动 Daphne 服"
"务进程。在最简单的情形下，Daphne 加上包含一个 ASGI 应用模块的位置和应用的名称"
"（以冒号分隔）。"

msgid "For a typical Django project, invoking Daphne would look like:"
msgstr "对于一个典型的 Django 项目，调用 Daphne 的方式如下："

msgid ""
"This will start one process listening on ``127.0.0.1:8000``. It requires "
"that your project be on the Python path; to ensure that run this command "
"from the same directory as your ``manage.py`` file."
msgstr ""
"它将开启一个进程，监听 ``127.0.0.1:8000``。这需要你的项目位于 Python path "
"上。为了确保这点，你应该在与 ``manage.py`` 文件相同的路径中运行这个命令。"

msgid "Integration with ``runserver``"
msgstr "与 ``runserver`` 集成"

msgid ""
"Daphne provides a :djadmin:`runserver` command to serve your site under ASGI "
"during development."
msgstr ""
"Daphne 提供了一个 :djadmin:`runserver` 命令，用于在开发过程中使用 ASGI 来提供"
"站点服务。"

msgid ""
"This can be enabled by adding ``daphne`` to the start of your :setting:"
"`INSTALLED_APPS` and adding an ``ASGI_APPLICATION`` setting pointing to your "
"ASGI application object::"
msgstr ""
"这可以通过将 ``daphne`` 添加到你的 :setting:`INSTALLED_APPS` 的开头，并添加一"
"个指向你的 ASGI 应用程序对象的 ``ASGI_APPLICATION`` 设置来启用："

msgid "How to use Django with Hypercorn"
msgstr "如何使用 Hypercorn 托管 Django。"

msgid ""
"Hypercorn_ is an ASGI server that supports HTTP/1, HTTP/2, and HTTP/3 with "
"an emphasis on protocol support."
msgstr "Hypercorn_ 是一个加强支持HTTP/1，HTTP/2和HTTP/3的ASGI服务器。"

msgid "Installing Hypercorn"
msgstr "安装Hypercorn"

msgid "You can install Hypercorn with ``pip``:"
msgstr "你可以使用 ``pip`` 安装 Hypercorn："

msgid "Running Django in Hypercorn"
msgstr "在Hypercorn中运行Django"

msgid ""
"When Hypercorn is installed, a ``hypercorn`` command is available which runs "
"ASGI applications. Hypercorn needs to be called with the location of a "
"module containing an ASGI application object, followed by what the "
"application is called (separated by a colon)."
msgstr ""
"一旦 Hypercorn 安装完毕，你就可用 ``hypercorn`` 命令来运行ASGI应用了。"
"Hypercorn 运行需要包含一个 ASGI 应用程序模块的位置和应用程序的名称（以冒号分"
"隔）。"

msgid "For a typical Django project, invoking Hypercorn would look like:"
msgstr "对于一个典型的 Django 项目，调用 Hypercorn 的方式如下："

msgid ""
"For more advanced usage, please read the `Hypercorn documentation "
"<Hypercorn_>`_."
msgstr "有关更多的高级用法，请参阅 `Hypercorn documentation 1`_."

msgid "How to deploy with ASGI"
msgstr "如何使用 ASGI 来部署"

msgid ""
"As well as WSGI, Django also supports deploying on ASGI_, the emerging "
"Python standard for asynchronous web servers and applications."
msgstr ""
"同 WSGI 一样，Django 也支持使用 ASGI_ 来部署，它是为了支持异步网络服务器和应"
"用而新出现的 Python 标准。"

msgid ""
"Django's :djadmin:`startproject` management command sets up a default ASGI "
"configuration for you, which you can tweak as needed for your project, and "
"direct any ASGI-compliant application server to use."
msgstr ""
"Django 的管理命令 :djadmin:`startproject` 生成了一个默认的 ASGI 配置，你可以"
"按照自己项目的需要去调整这个配置，任何兼容 ASGI 的应用程序服务器都可以直接使"
"用。"

msgid ""
"Django includes getting-started documentation for the following ASGI servers:"
msgstr "Django 提供了下面这些 ASGI 服务的入门文档："

msgid "The ``application`` object"
msgstr "``application`` 对象"

msgid ""
"Like WSGI, ASGI has you supply an ``application`` callable which the "
"application server uses to communicate with your code. It's commonly "
"provided as an object named ``application`` in a Python module accessible to "
"the server."
msgstr ""
"与WSGI类似，ASGI需要你提供 ``application`` 可以让应用程序服务器用它与你的代码"
"交互。可调用的应用程序 ``application`` 一般以一个位于 Python 模块中，名为应用"
"程序 ``application`` 的对象的形式提供，且对服务器可见。"

msgid ""
"The :djadmin:`startproject` command creates a file :file:`<project_name>/"
"asgi.py` that contains such an ``application`` callable."
msgstr ""
":djadmin:`startproject` 命令创建了文件 :file:`<project_name>/asgi.py`，其中包"
"含了 ``application`` callable应用程序。"

msgid ""
"It's not used by the development server (``runserver``), but can be used by "
"any ASGI server either in development or in production."
msgstr ""
"它不会被开发服务器使用 (``runserver``) ，但是可以在开发环境或生产环境中用任意"
"一种ASGI服务器来使用。"

msgid ""
"ASGI servers usually take the path to the application callable as a string; "
"for most Django projects, this will look like ``myproject.asgi:application``."
msgstr ""
"ASGI服务器通常会以字符串形式获取可调用应用程序的路径；对于大多数Django项目来"
"说，应用程序形如 ``myproject.asgi:application`` 。"

msgid ""
"While Django's default ASGI handler will run all your code in a synchronous "
"thread, if you choose to run your own async handler you must be aware of "
"async-safety."
msgstr ""
"Django默认的ASGI处理器会将你所有的代码放在一个同步的线程内运行，但你如果选择"
"运行自己的异步处理器，你必须确保它是异步安全的。"

msgid ""
"Do not call blocking synchronous functions or libraries in any async code. "
"Django prevents you from doing this with the parts of Django that are not "
"async-safe, but the same may not be true of third-party apps or Python "
"libraries."
msgstr ""
"不要在异步代码中调用阻塞的同步函数或库。Django会阻止你这样异步不安全地使用"
"Django的内容，但是对第三方应用程序或者Python库不一定会这样。"

msgid "Configuring the settings module"
msgstr "配置 settings 模块"

msgid ""
"When the ASGI server loads your application, Django needs to import the "
"settings module — that's where your entire application is defined."
msgstr ""
"当 ASGI 服务器加载应用程序时，Django 需要导入配置模块——完整定义应用程序的地"
"方。"

msgid ""
"Django uses the :envvar:`DJANGO_SETTINGS_MODULE` environment variable to "
"locate the appropriate settings module. It must contain the dotted path to "
"the settings module. You can use a different value for development and "
"production; it all depends on how you organize your settings."
msgstr ""
"Django 利用 :envvar:`DJANGO_SETTINGS_MODULE` 环境变量来定位合适的配置模块。它"
"必须包含到配置模块的点式路径。开发环境和生产环境可以配置不同值；这都取决于你"
"是如何组织配置的。"

msgid ""
"If this variable isn't set, the default :file:`asgi.py` sets it to ``mysite."
"settings``, where ``mysite`` is the name of your project."
msgstr ""
"若未设置该变量，文件 :file:`asgi.py` 默认将其配置为 ``mysite.settings``， "
"``mysite`` 即工程名字。"

msgid "Applying ASGI middleware"
msgstr "应用 ASGI 中间件"

msgid ""
"To apply ASGI middleware, or to embed Django in another ASGI application, "
"you can wrap Django's ``application`` object in the ``asgi.py`` file. For "
"example::"
msgstr ""
"为了应用ASGI中间件，或者将Django嵌入到其他的ASGI应用程序中，你可以将Django的 "
"``application`` 应用程序对象包装到  ``asgi.py`` 文件中。举个例子："

msgid "How to use Django with Uvicorn"
msgstr "如何使用 Uvicorn 托管 Django"

msgid ""
"Uvicorn_ is an ASGI server based on ``uvloop`` and ``httptools``, with an "
"emphasis on speed."
msgstr ""
"Uvicorn_ 是一个基于 ``uvloop`` 和 ``httptools`` 的加强运行速度的ASGI服务器。"

msgid "Installing Uvicorn"
msgstr "安装Uvicorn"

msgid "You can install Uvicorn with ``pip``:"
msgstr "你可以使用 ``pip`` 安装 Uvicorn："

msgid "Running Django in Uvicorn"
msgstr "在 Uvicorn 中运行 Django"

msgid ""
"When Uvicorn is installed, a ``uvicorn`` command is available which runs "
"ASGI applications. Uvicorn needs to be called with the location of a module "
"containing an ASGI application object, followed by what the application is "
"called (separated by a colon)."
msgstr ""
"一旦 Uvicorn 安装完毕，你就可用 ``uvicorn`` 命令来运行ASGI应用了。Uvicorn 运"
"行需要包含一个 ASGI 应用程序模块的位置和应用程序的名称（以冒号分隔）。"

msgid "For a typical Django project, invoking Uvicorn would look like:"
msgstr "对于一个典型的 Django 项目，调用 Uvicorn 的方式如下："

msgid ""
"In development mode, you can add ``--reload`` to cause the server to reload "
"any time a file is changed on disk."
msgstr ""
"在开发模式下，你可以添加 ``--reload`` 选项，以便在磁盘上的文件发生更改时重新"
"加载服务器。"

msgid ""
"For more advanced usage, please read the `Uvicorn documentation <Uvicorn_>`_."
msgstr "有关更多的高级用法，请参阅 `Uvicorn documentation 1`_."

msgid "Deploying Django using Uvicorn and Gunicorn"
msgstr "使用 Uvicorn 和 Gunicorn 部署 Django 应用"

msgid ""
"Gunicorn_ is a robust web server that implements process monitoring and "
"automatic restarts. This can be useful when running Uvicorn in a production "
"environment."
msgstr ""
"Gunicorn 是一个强大的 Web 服务器，实现了进程监控和自动重启。在生产环境中运行 "
"Uvicorn 时，这非常有用。"

msgid "To install Uvicorn and Gunicorn, use the following:"
msgstr "要安装 Uvicorn 和 Gunicorn，请使用以下命令："

msgid "Then start Gunicorn using the Uvicorn worker class like this:"
msgstr "然后像这样使用 Uvicorn worker 类启动 Gunicorn ："

msgid "Deployment checklist"
msgstr "部署清单"

msgid ""
"The internet is a hostile environment. Before deploying your Django project, "
"you should take some time to review your settings, with security, "
"performance, and operations in mind."
msgstr ""
"互联网是一个恶劣的环境。在部署你的 Django 项目之前，你应该花一些时间来审查你"
"的配置，要考虑到安全、性能和操作。"

msgid ""
"Django includes many :doc:`security features </topics/security>`. Some are "
"built-in and always enabled. Others are optional because they aren't always "
"appropriate, or because they're inconvenient for development. For example, "
"forcing HTTPS may not be suitable for all websites, and it's impractical for "
"local development."
msgstr ""
"Django 包含了许多 :doc:`安全特性 </topics/security>`。一些是内置的并且总保持"
"激活状态，其他的则是可选的因为它们不总是恰当的，或者因为它们不便于之后的开"
"发。举个例子，强制的 HTTPS 并不一定适合所有网站，它对于本地开发就是不切实际"
"的。"

msgid ""
"Performance optimizations are another category of trade-offs with "
"convenience. For instance, caching is useful in production, less so for "
"local development. Error reporting needs are also widely different."
msgstr ""
"性能优化是另一项便利性权衡的主题。例如，缓存在生成环境很有用，但是对本地开发"
"就作用不大。错误报告的需求也大不相同。"

msgid "The following checklist includes settings that:"
msgstr "以下清单包括以下配置："

msgid ""
"must be set properly for Django to provide the expected level of security;"
msgstr "必须正确地设置 Django 以提供预期的安全级别；"

msgid "are expected to be different in each environment;"
msgstr "期望在每个环境中都是不同的；"

msgid "enable optional security features;"
msgstr "启用可选的安全功能；"

msgid "enable performance optimizations;"
msgstr "启用性能优化；"

msgid "provide error reporting."
msgstr "提供错误报告功能。"

msgid ""
"Many of these settings are sensitive and should be treated as confidential. "
"If you're releasing the source code for your project, a common practice is "
"to publish suitable settings for development, and to use a private settings "
"module for production."
msgstr ""
"许多配置项是敏感的，需要被当做机密对待。如果要发布项目源码，常见操作是为开发"
"开放合适的配置项，为生产环境配置私密设置模块。"

msgid "Run ``manage.py check --deploy``"
msgstr "运行 ``manage.py check --deploy``"

msgid ""
"Some of the checks described below can be automated using the :option:`check "
"--deploy` option. Be sure to run it against your production settings file as "
"described in the option's documentation."
msgstr ""
"下面介绍的某些检查项会自动使用 :option:`check --deploy` 选项。请确保根据选项"
"文档中描述的生产设置文件运行它。"

msgid "Critical settings"
msgstr "关键配置"

msgid ":setting:`SECRET_KEY`"
msgstr ":setting:`SECRET_KEY`"

msgid ""
"**The secret key must be a large random value and it must be kept secret.**"
msgstr "**密码必须是一个较长的随机值，且被妥善保存。**"

msgid ""
"Make sure that the key used in production isn't used anywhere else and avoid "
"committing it to source control. This reduces the number of vectors from "
"which an attacker may acquire the key."
msgstr ""
"确保生产环境使用的密码并未用于其它环境，且未被提交至版本控制系统。这将减少攻"
"击者获取密码的概率。"

msgid ""
"Instead of hardcoding the secret key in your settings module, consider "
"loading it from an environment variable::"
msgstr "逾期将安全密码硬编码在配置模块中，不然考虑从环境变量加载它::"

msgid "or from a file::"
msgstr "或者从一个文件::"

msgid "If rotating secret keys, you may use :setting:`SECRET_KEY_FALLBACKS`::"
msgstr "如果要轮换密钥，你可以使用 :setting:`SECRET_KEY_FALLBACKS`："

msgid ""
"Ensure that old secret keys are removed from ``SECRET_KEY_FALLBACKS`` in a "
"timely manner."
msgstr "确保及时从 ``SECRET_KEY_FALLBACKS`` 中删除旧的密钥。"

msgid ":setting:`DEBUG`"
msgstr ":setting:`DEBUG`"

msgid "**You must never enable debug in production.**"
msgstr "**永远不要在生产环境打开 debug 开关。**"

msgid ""
"You're certainly developing your project with :setting:`DEBUG = True "
"<DEBUG>`, since this enables handy features like full tracebacks in your "
"browser."
msgstr ""
"开发时，你当然要配置 :setting:`DEBUG = True <DEBUG>`，这将方便你在浏览器启用"
"完全回溯功能。"

msgid ""
"For a production environment, though, this is a really bad idea, because it "
"leaks lots of information about your project: excerpts of your source code, "
"local variables, settings, libraries used, etc."
msgstr ""
"不过，对于生产环境来说，这真是一个坏主意，因为这会泄露很多超出预期的信息：代"
"码摘要，本地变量，配置项，使用的库，等等。"

msgid "Environment-specific settings"
msgstr "特定于环境的配置"

msgid ":setting:`ALLOWED_HOSTS`"
msgstr ":setting:`ALLOWED_HOSTS`"

msgid ""
"When :setting:`DEBUG = False <DEBUG>`, Django doesn't work at all without a "
"suitable value for :setting:`ALLOWED_HOSTS`."
msgstr ""
":setting:`DEBUG = False <DEBUG>` 时，Django 在未正确配置 :setting:"
"`ALLOWED_HOSTS` 时无法工作。"

msgid ""
"This setting is required to protect your site against some CSRF attacks. If "
"you use a wildcard, you must perform your own validation of the ``Host`` "
"HTTP header, or otherwise ensure that you aren't vulnerable to this category "
"of attacks."
msgstr ""
"该配置避免你的站点遭受某些 CSRF 攻击。如果使用了通配符，你必须实现自定义的 "
"``Host`` HTTP 头，或者确保你不会很容易地遭受此种攻击。"

msgid ""
"You should also configure the web server that sits in front of Django to "
"validate the host. It should respond with a static error page or ignore "
"requests for incorrect hosts instead of forwarding the request to Django. "
"This way you'll avoid spurious errors in your Django logs (or emails if you "
"have error reporting configured that way). For example, on nginx you might "
"set up a default server to return \"444 No Response\" on an unrecognized "
"host:"
msgstr ""
"你还应该配置位于 Django 前面的网络服务器来验证主机。它应该用一个静态错误页面"
"来回应，或者忽略不正确主机的请求，而不是将请求转发给 Django。这样你就可以避免"
"在你的 Django 日志中出现虚假的错误（如果你有配置错误报告的话，也可以用电子邮"
"件）。例如，在 nginx 上，你可以设置一个默认的服务器，在一个未识别的主机上返"
"回“444 No Response”。"

msgid ":setting:`CACHES`"
msgstr ":setting:`CACHES`"

msgid ""
"If you're using a cache, connection parameters may be different in "
"development and in production. Django defaults to per-process :ref:`local-"
"memory caching <local-memory-caching>` which may not be desirable."
msgstr ""
"若使用了缓存，开发环境的连接参数和生产环境可能不同。Djano 默认为每个进程提"
"供 :ref:`本地内存缓存 <local-memory-caching>`，这可能与期望不同。"

msgid ""
"Cache servers often have weak authentication. Make sure they only accept "
"connections from your application servers."
msgstr "缓存服务器一般采用弱验证。确保它们只接受来自你的应用服务器的连接。"

msgid ":setting:`DATABASES`"
msgstr ":setting:`DATABASES`"

msgid ""
"Database connection parameters are probably different in development and in "
"production."
msgstr "生产环境与开发环境的数据库连接参数可能是不同的。"

msgid ""
"Database passwords are very sensitive. You should protect them exactly like :"
"setting:`SECRET_KEY`."
msgstr "数据库密码是机密的。你应该像保护 :setting:`SECRET_KEY` 那样保护它们。"

msgid ""
"For maximum security, make sure database servers only accept connections "
"from your application servers."
msgstr "为了最大限度的安全，确保数据库只为来自你应用的连接提供服务。"

msgid "If you haven't set up backups for your database, do it right now!"
msgstr "如果你还未为数据库设置备份，现在就做！"

msgid ":setting:`EMAIL_BACKEND` and related settings"
msgstr ":setting:`EMAIL_BACKEND` 和关联配置"

msgid "If your site sends emails, these values need to be set correctly."
msgstr "如果你的站点发送邮件，以下值需要被正确地配置。"

msgid ""
"By default, Django sends email from webmaster@localhost and root@localhost. "
"However, some mail providers reject email from these addresses. To use "
"different sender addresses, modify the :setting:`DEFAULT_FROM_EMAIL` and :"
"setting:`SERVER_EMAIL` settings."
msgstr ""
"默认情况下，Django 从 webmaster@localhost 和 root@localhost 发送邮件。然而，"
"某些邮件服务商拒绝来自这些地址的邮件。为了使用不同的发件人地址，修改 :"
"setting:`DEFAULT_FROM_EMAIL` 和 :setting:`SERVER_EMAIL` 配置。"

msgid ":setting:`STATIC_ROOT` and :setting:`STATIC_URL`"
msgstr ":setting:`STATIC_ROOT` 和 :setting:`STATIC_URL`"

msgid ""
"Static files are automatically served by the development server. In "
"production, you must define a :setting:`STATIC_ROOT` directory where :"
"djadmin:`collectstatic` will copy them."
msgstr ""
"静态文件由开发服务器自动托管。但在生产环境，你必须定义配置 :setting:"
"`STATIC_ROOT` ， :djadmin:`collectstatic` 将会拷贝它们。"

msgid "See :doc:`/howto/static-files/index` for more information."
msgstr "查看 :doc:`/howto/static-files/index` 获得更多信息。"

msgid ":setting:`MEDIA_ROOT` and :setting:`MEDIA_URL`"
msgstr ":setting:`MEDIA_ROOT` 和 :setting:`MEDIA_URL`"

msgid ""
"Media files are uploaded by your users. They're untrusted! Make sure your "
"web server never attempts to interpret them. For instance, if a user uploads "
"a ``.php`` file, the web server shouldn't execute it."
msgstr ""
"媒体文件由用户上传。他们是不可信任的！确保 web 服务器从未尝试解析这些文件。例"
"如，若用户上传了一个 ``.php`` 文件，web 服务器应该永远不要运行它。"

msgid "Now is a good time to check your backup strategy for these files."
msgstr "现在是检查这些文件的备份策略的好时机。"

msgid "HTTPS"
msgstr "HTTPS"

msgid ""
"Any website which allows users to log in should enforce site-wide HTTPS to "
"avoid transmitting access tokens in clear. In Django, access tokens include "
"the login/password, the session cookie, and password reset tokens. (You "
"can't do much to protect password reset tokens if you're sending them by "
"email.)"
msgstr ""
"允许用户登录的网站应该强制站点范围的 HTTPS，避免明文传输令牌。在 Django 中，"
"令牌包括账号/密码，会话 cookie 和重置密码的令牌。（如果你用邮件发送重置密码的"
"令牌，那就没什么办法能保护它们。）"

msgid ""
"Protecting sensitive areas such as the user account or the admin isn't "
"sufficient, because the same session cookie is used for HTTP and HTTPS. Your "
"web server must redirect all HTTP traffic to HTTPS, and only transmit HTTPS "
"requests to Django."
msgstr ""
"仅保护用户账号或后台等敏感区域是不够的，因为 HTTP 和 HTTPS 使用相同的会话 "
"cookie。Web 服务器必须将所有的 HTTP 重定向至 HTTPS，且只将 HTTPS 的请求转发"
"给 Django。"

msgid "Once you've set up HTTPS, enable the following settings."
msgstr "若你已经配置了 HTTPS，启用下列配置。"

msgid ":setting:`CSRF_COOKIE_SECURE`"
msgstr ":setting:`CSRF_COOKIE_SECURE`"

msgid ""
"Set this to ``True`` to avoid transmitting the CSRF cookie over HTTP "
"accidentally."
msgstr "将此设置为 ``True``，避免不甚用 HTTP 传输 CSRF cookie。"

msgid ":setting:`SESSION_COOKIE_SECURE`"
msgstr ":setting:`SESSION_COOKIE_SECURE`"

msgid ""
"Set this to ``True`` to avoid transmitting the session cookie over HTTP "
"accidentally."
msgstr "将此设置未 ``True``，避免不甚用 HTTP 传输会话 cookie。"

msgid "Performance optimizations"
msgstr "性能优化"

msgid ""
"Setting :setting:`DEBUG = False <DEBUG>` disables several features that are "
"only useful in development. In addition, you can tune the following settings."
msgstr ""
"配置 :setting:`DEBUG = False <DEBUG>` 会禁用几个仅在开发时有用的功能。另外，"
"你要调整下列配置。"

msgid "Sessions"
msgstr "会话"

msgid ""
"Consider using :ref:`cached sessions <cached-sessions-backend>` to improve "
"performance."
msgstr "建议参考 :ref:`cached sessions 1` 以提升性能。"

msgid ""
"If using database-backed sessions, regularly :ref:`clear old sessions "
"<clearing-the-session-store>` to avoid storing unnecessary data."
msgstr ""
"如果使用数据库来备份会话，参考  :ref:`clear old sessions 1` 以避免存储不必要"
"的数据。"

msgid ":setting:`CONN_MAX_AGE`"
msgstr ":setting:`CONN_MAX_AGE`"

msgid ""
"Enabling :ref:`persistent database connections <persistent-database-"
"connections>` can result in a nice speed-up when connecting to the database "
"accounts for a significant part of the request processing time."
msgstr ""
"开启 :ref:`持久数据库连接 <persistent-database-connections>` 会在连接数据库账"
"号耗费了请求处理时间的很大一部分的时候，大大提升速度。"

msgid "This helps a lot on virtualized hosts with limited network performance."
msgstr "这对带宽有限的虚拟主机帮助极大。"

msgid ":setting:`TEMPLATES`"
msgstr ":setting:`TEMPLATES`"

msgid ""
"Enabling the cached template loader often improves performance drastically, "
"as it avoids compiling each template every time it needs to be rendered. "
"When :setting:`DEBUG = False <DEBUG>`, the cached template loader is enabled "
"automatically. See :class:`django.template.loaders.cached.Loader` for more "
"information."
msgstr ""
"启用缓存模板加载器通常可以显著提高性能，因为它避免了每次需要呈现模板时都要编"
"译模板。当 :setting:`DEBUG = False <DEBUG>` 时，缓存模板加载器会自动启用。有"
"关更多信息，请参阅 :class:`django.template.loaders.cached.Loader`。"

msgid "Error reporting"
msgstr "发送错误"

msgid ""
"By the time you push your code to production, it's hopefully robust, but you "
"can't rule out unexpected errors. Thankfully, Django can capture errors and "
"notify you accordingly."
msgstr ""
"在你将代码推送至生产环境后，你总是期望代码是健壮的，但你并不能控制意料之外的"
"错误。还好，Django 能捕获错误并通知你。"

msgid ":setting:`LOGGING`"
msgstr ":setting:`LOGGING`"

msgid ""
"Review your logging configuration before putting your website in production, "
"and check that it works as expected as soon as you have received some "
"traffic."
msgstr ""
"在将网站放入生产环境前，检查 logging 配置项。在你收到某些信息后，查看其是否按"
"预期运行。"

msgid "See :doc:`/topics/logging` for details on logging."
msgstr "查看 :doc:`/topics/logging` 了解 logging 的细节。"

msgid ":setting:`ADMINS` and :setting:`MANAGERS`"
msgstr ":setting:`ADMINS` 和 :setting:`MANAGERS`"

msgid ":setting:`ADMINS` will be notified of 500 errors by email."
msgstr "发生 500 错误时，会邮件通知 :setting:`ADMINS`。"

msgid ""
":setting:`MANAGERS` will be notified of 404 errors. :setting:"
"`IGNORABLE_404_URLS` can help filter out spurious reports."
msgstr ""
"404 错误会通知 :setting:`MANAGERS`。:setting:`IGNORABLE_404_URLS` 有助于过滤"
"误报。"

msgid ""
"See :doc:`/howto/error-reporting` for details on error reporting by email."
msgstr ""
"参考  :doc:`/howto/error-reporting` 了解邮件如何在发生错误时发送报告的细节。"

msgid "Error reporting by email doesn't scale very well"
msgstr "利用邮件报告错误的弹性并不好"

msgid ""
"Consider using an error monitoring system such as Sentry_ before your inbox "
"is flooded by reports. Sentry can also aggregate logs."
msgstr ""
"在收件箱被报告塞满前，考虑下使用错误监控系统，类似 Sentry_。Sentry 还可以聚合"
"日志。"

msgid "Customize the default error views"
msgstr "自定义默认错误视图"

msgid ""
"Django includes default views and templates for several HTTP error codes. "
"You may want to override the default templates by creating the following "
"templates in your root template directory: ``404.html``, ``500.html``, ``403."
"html``, and ``400.html``. The :ref:`default error views <error-views>` that "
"use these templates should suffice for 99% of web applications, but you can :"
"ref:`customize them <customizing-error-views>` as well."
msgstr ""
"Django 包括几个 HTTP 错误代码的默认视图和模板。你可能想覆盖默认模板，在你的根"
"模板目录下创建以下模板：``404.html``、``500.html``、``403.html`` 和 ``400."
"html``。使用这些模板的 :ref:`默认错误视图 <error-views>` 应该足以满足 99% 的"
"网络应用，但你也可以 :ref:`自定义它们 <customizing-error-views>`。"

msgid "How to deploy Django"
msgstr "如何部署 Django"

msgid ""
"Django is full of shortcuts to make web developers' lives easier, but all "
"those tools are of no use if you can't easily deploy your sites. Since "
"Django's inception, ease of deployment has been a major goal."
msgstr ""
"Django 充满了让网站开发者生活更轻松的快捷工具，但如果你不能轻松部署你的网站，"
"那么所有这些工具都没有用。自 Django 诞生以来，部署的便利性一直是其主要目标。"

msgid ""
"There are many options for deploying your Django application, based on your "
"architecture or your particular business needs, but that discussion is "
"outside the scope of what Django can give you as guidance."
msgstr ""
"部署你的Django应用程序有很多选择，可以基于你的架构或者特定的业务需要，但是这"
"不在Django可以给出指导建议的范围内。"

msgid ""
"Django, being a web framework, needs a web server in order to operate. And "
"since most web servers don't natively speak Python, we need an interface to "
"make that communication happen."
msgstr ""
"Django是一个需要Web服务器来运行的Web框架。然而由于大多数Web服务器不是用Python"
"编写，我们需要一个接口来实现沟通。"

msgid "Django currently supports two interfaces: WSGI and ASGI."
msgstr "Django现在支持两种接口：WSGI和ASGI。"

msgid ""
"`WSGI`_ is the main Python standard for communicating between web servers "
"and applications, but it only supports synchronous code."
msgstr ""
"`WSGI`_ 是 Python 的主要标准，用于网络服务器和应用程序之间的通信，但它只支持"
"同步代码。"

msgid ""
"`ASGI`_ is the new, asynchronous-friendly standard that will allow your "
"Django site to use asynchronous Python features, and asynchronous Django "
"features as they are developed."
msgstr ""
"`ASGI`_ 是新兴的，对异步友好的让你的Django网页使用Python异步特性和已经开发的"
"Django异步特性的标准。"

msgid ""
"You should also consider how you will handle :doc:`static files </howto/"
"static-files/deployment>` for your application, and how to handle :doc:"
"`error reporting</howto/error-reporting>`."
msgstr ""
"你还应该考虑如何为你的应用程序处理 :doc:`静态文件 </howto/static-files/"
"deployment>`，以及如何处理 :doc:`错误报告 </howto/error-reporting>`。"

msgid ""
"Finally, before you deploy your application to production, you should run "
"through our :doc:`deployment checklist<checklist>` to ensure that your "
"configurations are suitable."
msgstr ""
"最后，在将你的应用程序部署到生产环境中之前，你应该执行一遍 :doc:`deployment "
"checklist 1` 以确保你的配置是合适的。"

msgid "How to authenticate against Django's user database from Apache"
msgstr "如何从 Apache 对 Django 的用户数据库进行认证"

msgid ""
"Since keeping multiple authentication databases in sync is a common problem "
"when dealing with Apache, you can configure Apache to authenticate against "
"Django's :doc:`authentication system </topics/auth/index>` directly. This "
"requires Apache version >= 2.2 and mod_wsgi >= 2.0. For example, you could:"
msgstr ""
"使用 Apache 时，保持多个身份认证数据同步是一个常见的问题，你可以让 Apache 直"
"接使用 Django 的 :doc:`验证系统 </topics/auth/index>`。这要求 Apache 版本 >= "
"2.2，且 mod_wsgi >= 2.0。例如这样："

msgid ""
"Serve static/media files directly from Apache only to authenticated users."
msgstr "仅为已授权的用户直接从 Apache 提供 static/media 文件。"

msgid ""
"Authenticate access to a Subversion_ repository against Django users with a "
"certain permission."
msgstr "仅为有特定权限的 Django 用户提供 Subversion 仓库访问。"

msgid "Allow certain users to connect to a WebDAV share created with mod_dav_."
msgstr "允许某些用户连接到 mod_dav_ 创建的 WebDAV 共享。"

msgid ""
"If you have installed a :ref:`custom user model <auth-custom-user>` and want "
"to use this default auth handler, it must support an ``is_active`` "
"attribute. If you want to use group based authorization, your custom user "
"must have a relation named 'groups', referring to a related object that has "
"a 'name' field. You can also specify your own custom mod_wsgi auth handler "
"if your custom cannot conform to these requirements."
msgstr ""
"若你已安装了一个 :ref:`自定义用户模型 <auth-custom-user>`，且想使用其默认认证"
"处理器，它必须要支持 ``is_active`` 属性。若你想使用用户组授权，自定义用户必须"
"有个关联名 'groups`，指向一个拥有 'name' 字段的关联对象。若自定义的无法满足上"
"述要求，你也可以指定自定义 mod_wsgi 认证处理器。"

msgid "Authentication with ``mod_wsgi``"
msgstr "用 ``mod_wsgi`` 进行授权认证"

msgid ""
"The use of ``WSGIApplicationGroup %{GLOBAL}`` in the configurations below "
"presumes that your Apache instance is running only one Django application. "
"If you are running more than one Django application, please refer to the "
"`Defining Application Groups`_ section of the mod_wsgi docs for more "
"information about this setting."
msgstr ""
"以下配置文件中的 ``WSGIApplicationGroup %{GLOBAL}`` 假定 Apache 实例仅运行了"
"一个 Django 应用。若你运行了不止一个 Django 应用，请参考 mod_wigi 文档的 `定"
"义应用集群`_ 章节获取更多配置信息。"

msgid ""
"Make sure that mod_wsgi is installed and activated and that you have "
"followed the steps to set up :doc:`Apache with mod_wsgi </howto/deployment/"
"wsgi/modwsgi>`."
msgstr ""
"确保 mod_wsgi 已经安装并激活，并且你已经按照步骤设置了:doc:`Apache 的 "
"mod_wsgi </howto/deployment/wsgi/modwsgi>`。"

msgid ""
"Next, edit your Apache configuration to add a location that you want only "
"authenticated users to be able to view:"
msgstr "然后，编辑 Apache 配置，添加只允许授权用户查看的位置："

msgid ""
"The ``WSGIAuthUserScript`` directive tells mod_wsgi to execute the "
"``check_password`` function in specified wsgi script, passing the user name "
"and password that it receives from the prompt. In this example, the "
"``WSGIAuthUserScript`` is the same as the ``WSGIScriptAlias`` that defines "
"your application :doc:`that is created by django-admin startproject </howto/"
"deployment/wsgi/index>`."
msgstr ""
"``WSGIAuthUserScript`` 指令告诉 mod_wsgi 在指定 wsgi 脚本中执行 "
"``check_password`` 函数，并传递从提示符获取的用户名和密码。在本例中， "
"``WSGIAuthUserScript`` 与 ``WSGIScriptAlias`` 一样，后者 :doc:`由 django-"
"admin startproject 创建 </howto/deployment/wsgi/index>`，定义了应用。"

msgid "Using Apache 2.2 with authentication"
msgstr "使用带身份验证的 Apache 2.2 "

msgid "Make sure that ``mod_auth_basic`` and ``mod_authz_user`` are loaded."
msgstr "确认 ``mod_auth_basic`` 和 ``mod_authz_user`` 被加载了。"

msgid ""
"These might be compiled statically into Apache, or you might need to use "
"LoadModule to load them dynamically in your ``httpd.conf``:"
msgstr ""
"这些可能被静态编译进 Apache，或者用 LoadModule 在 ``httpd.conf`` 动态加载它"
"们："

msgid ""
"Finally, edit your WSGI script ``mysite.wsgi`` to tie Apache's "
"authentication to your site's authentication mechanisms by importing the "
"``check_password`` function::"
msgstr ""
"最后，编辑 WSGI 脚本 ``mysite.wsgi``，通过导入 ``check_password`` 函数，将 "
"Apache 的认证授权机制接续在你站点的授权机制之后::"

msgid ""
"Requests beginning with ``/secret/`` will now require a user to authenticate."
msgstr "以 ``/secret/`` 开头的请求现在会要求用户认证。"

msgid ""
"The mod_wsgi `access control mechanisms documentation`_ provides additional "
"details and information about alternative methods of authentication."
msgstr ""
"mod_wsgi `可达性控制机制文档`_ 提供了其它授权机制和方法的更多细节和信息。"

msgid "Authorization with ``mod_wsgi`` and Django groups"
msgstr "利用 ``mod_wsgi`` 和 Django 用户组(groups)进行授权"

msgid ""
"mod_wsgi also provides functionality to restrict a particular location to "
"members of a group."
msgstr "mod_wsgi 也提供了将组成员限制至特定路径的功能。"

msgid "In this case, the Apache configuration should look like this:"
msgstr "在本例中，Apache 配置应该看起来像这样："

msgid ""
"To support the ``WSGIAuthGroupScript`` directive, the same WSGI script "
"``mysite.wsgi`` must also import the ``groups_for_user`` function which "
"returns a list groups the given user belongs to."
msgstr ""
"要支持 ``WSGIAuthGroupScript`` 指令，同样的 WSGI 脚本 ``mysite.wsgi`` 必须也"
"导入 ``groups_for_user`` 函数，函数会返回用户所属用户组的列表。"

msgid ""
"Requests for ``/secret/`` will now also require user to be a member of the "
"\"secret-agents\" group."
msgstr ""
"对 ``/secret`` 的请求现在也会要求用户是 \"secret-agents\" 用户组的成员。"

msgid "How to use Django with Gunicorn"
msgstr "如何使用 Gunicorn 托管 Django"

msgid ""
"Gunicorn_ ('Green Unicorn') is a pure-Python WSGI server for UNIX. It has no "
"dependencies and can be installed using ``pip``."
msgstr ""
"Gunicorn_ ('Green Unicorn') 是一个 UNIX 下的纯 Python WSGI 服务器。它没有其它"
"依赖，可以使用 ``pip``安装。"

msgid "Installing Gunicorn"
msgstr "安装 Gunicorn"

msgid ""
"Install gunicorn by running ``python -m pip install gunicorn``. For more "
"details, see the `gunicorn documentation`_."
msgstr ""
"安装 gunicorn  执行 ``python -m pip install gunicorn`` 即可。更多细节请参考 "
"`gunicorn documentation`_。"

msgid "Running Django in Gunicorn as a generic WSGI application"
msgstr "把 Django 当作普通 WSGI 应用在 Gunicorn 中运行"

msgid ""
"When Gunicorn is installed, a ``gunicorn`` command is available which starts "
"the Gunicorn server process. The simplest invocation of gunicorn is to pass "
"the location of a module containing a WSGI application object named "
"``application``, which for a typical Django project would look like:"
msgstr ""
"安装了 Gunicorn 后，将提供一个 ``gunicorn`` 命令，该命令用于启动 Gunicorn 服"
"务器进程。最简单的使用方式是传递包含名为 ``application`` 的 WSGI 应用程序对象"
"的模块的位置，对于典型的 Django 项目，如下所示："

msgid ""
"This will start one process running one thread listening on "
"``127.0.0.1:8000``. It requires that your project be on the Python path; the "
"simplest way to ensure that is to run this command from the same directory "
"as your ``manage.py`` file."
msgstr ""
"这样会创建一个进程，包含了一个监听在 ``127.0.0.1:8000`` 的线程。前提是你的项"
"目在 Python path 中，要满足这个条件，最简单的方法是在 ``manage.py`` 文件所在"
"的目录中运行这条命令。"

msgid "See Gunicorn's `deployment documentation`_ for additional tips."
msgstr "更多技巧请参考 Gunicorn 的 `部署文档`_ 。"

msgid "How to deploy with WSGI"
msgstr "如何使用 WSGI 进行部署"

msgid ""
"Django's primary deployment platform is WSGI_, the Python standard for web "
"servers and applications."
msgstr ""
"Django 的主要部署平台是 WSGI_，它是 Web 服务器和 Web 应用的 Python 标准。"

msgid ""
"Django's :djadmin:`startproject` management command sets up a minimal "
"default WSGI configuration for you, which you can tweak as needed for your "
"project, and direct any WSGI-compliant application server to use."
msgstr ""
"Django 的管理命令 :djadmin:`startproject` 生成了一个最小化的默认 WSGI 配置，"
"你可以按照自己项目的需要去调整这个配置，任何兼容 WSGI 的应用程序服务器都可以"
"直接使用。"

msgid ""
"Django includes getting-started documentation for the following WSGI servers:"
msgstr "Django 提供了下面这些 WSGI 服务的入门文档："

msgid ""
"The key concept of deploying with WSGI is the ``application`` callable which "
"the application server uses to communicate with your code. It's commonly "
"provided as an object named ``application`` in a Python module accessible to "
"the server."
msgstr ""
"用 WSGI 部署的关键是 ``application`` callable，应用服务器用它与你的代码交"
"互。 ``application`` callable 一般以一个位于 Python 模块中，名为 "
"``application`` 的对象的形式提供，且对服务器可见。"

msgid ""
"The :djadmin:`startproject` command creates a file :file:`<project_name>/"
"wsgi.py` that contains such an ``application`` callable."
msgstr ""
":djadmin:`startproject` 命令创建了文件 :file:`<project_name>/wsgi.py`，其中包"
"含了 ``application`` callable。"

msgid ""
"It's used both by Django's development server and in production WSGI "
"deployments."
msgstr "Django 开发服务器和生产环境的 WSGI 部署都用到了它。"

msgid ""
"WSGI servers obtain the path to the ``application`` callable from their "
"configuration. Django's built-in server, namely the :djadmin:`runserver` "
"command, reads it from the :setting:`WSGI_APPLICATION` setting. By default, "
"it's set to ``<project_name>.wsgi.application``, which points to the "
"``application`` callable in :file:`<project_name>/wsgi.py`."
msgstr ""
"WSGI 服务器从其配置中获取 ``application`` callable 的路径。Django 的默认服务"
"器（ :djadmin:`runserver` 命令），从配置项 :setting:`WSGI_APPLICATION` 中获"
"取。默认值是 ``<project_name>.wsgi.application``，指向 :file:`<project_name>/"
"wsgi.py` 中的 ``application`` callable。"

msgid ""
"When the WSGI server loads your application, Django needs to import the "
"settings module — that's where your entire application is defined."
msgstr ""
"当 WSGI 服务器加载应用时，Django 需要导入配置模块——完整定义应用的地方。"

msgid ""
"If this variable isn't set, the default :file:`wsgi.py` sets it to ``mysite."
"settings``, where ``mysite`` is the name of your project. That's how :"
"djadmin:`runserver` discovers the default settings file by default."
msgstr ""
"若未设置该变量， :file:`wsgi.py` 默认将其设置为 ``mysite.settings``， "
"``mysite`` 即工程名字。这就是 :djadmin:`runserver` 默认的发现默认配置行为。"

msgid ""
"Since environment variables are process-wide, this doesn't work when you run "
"multiple Django sites in the same process. This happens with mod_wsgi."
msgstr ""
"由于环境变量是进程级的，所以如果在同一进程运行多个 Django 站点将出错。这在使"
"用 mod_wsgi 时会出现。"

msgid ""
"To avoid this problem, use mod_wsgi's daemon mode with each site in its own "
"daemon process, or override the value from the environment by enforcing ``os."
"environ[\"DJANGO_SETTINGS_MODULE\"] = \"mysite.settings\"`` in your :file:"
"`wsgi.py`."
msgstr ""
"要避免此问题，为每个站点在后台进程使用 mod_wsgi 的后台模式，或者在 :file:"
"`wsgi.py` 中通过 ``os.environ[\"DJANGO_SETTINGS_MODULE\"] = \"mysite."
"settings\"`` 重写来自环境变量的值。"

msgid "Applying WSGI middleware"
msgstr "应用 WSGI 中间件"

msgid ""
"To apply :pep:`WSGI middleware <3333#middleware-components-that-play-both-"
"sides>` you can wrap the application object. For instance you could add "
"these lines at the bottom of :file:`wsgi.py`::"
msgstr ""
"要应用 `WSGI 中间件 <3333#middleware-components-that-play-both-sides> ` 中间"
"件组件，你只需简单包裹应用程序对象。举个例子，你可以在文件 :file:`wsgi.py` 末"
"尾添加以下代码::"

msgid ""
"You could also replace the Django WSGI application with a custom WSGI "
"application that later delegates to the Django WSGI application, if you want "
"to combine a Django application with a WSGI application of another framework."
msgstr ""
"如果你想将 Django 应用于一个 WSGI 应用或其它框架联合起来，可以用自定义 WSGI "
"应用替换 Django 的 WSGI 应用，前者会在稍晚时候将任务委托给 WSGI 应用。"

msgid "How to use Django with Apache and ``mod_wsgi``"
msgstr "如何使用 Apache 和 ``mod_wsgi`` 托管 Django"

msgid ""
"Deploying Django with Apache_ and `mod_wsgi`_ is a tried and tested way to "
"get Django into production."
msgstr "利用 Apache_ 和 `mod_wsgi`_ 在生产环境部署已经过充分测试。"

msgid ""
"mod_wsgi is an Apache module which can host any Python WSGI_ application, "
"including Django. Django will work with any version of Apache which supports "
"mod_wsgi."
msgstr ""
"mod_wsgi 是一个 Apache 模块，它可以管理任何 Python WSGI_ 应用，包括 Django。"
"Django 支持所有支持 mod_wsgi 的 Apache 版本。"

msgid ""
"The `official mod_wsgi documentation`_ is your source for all the details "
"about how to use mod_wsgi. You'll probably want to start with the "
"`installation and configuration documentation`_."
msgstr ""
"`官方 mod_wsgi 文档`_ 介绍了如何使用 mod_wsgi 的全部细节。你可能更喜欢从 `安"
"装和配置文档`_ 开始。"

msgid "Basic configuration"
msgstr "基础配置"

msgid ""
"Once you've got mod_wsgi installed and activated, edit your Apache server's "
"`httpd.conf`_ file and add the following."
msgstr ""
"一旦你安装了 mod_wsgi 并且启用了它，请在你的Apache服务器的 `httpd.conf`_ 文件"
"中添加如下内容。"

msgid ""
"The first bit in the ``WSGIScriptAlias`` line is the base URL path you want "
"to serve your application at (``/`` indicates the root url), and the second "
"is the location of a \"WSGI file\" -- see below -- on your system, usually "
"inside of your project package (``mysite`` in this example). This tells "
"Apache to serve any request below the given URL using the WSGI application "
"defined in that file."
msgstr ""
"``WSGIScriptAlias`` 行的第一项是你所期望的应用所在的基础 URL 路径（ ``/`` 根 "
"url），第二项是 \"WSGI 文件\" 的位置——一般位于项目包之内（本例中是 "
"``mysite``）。这告诉 Apache 用该文件中定义的 WSGI 应用响应指定 URL 下的请求。"

msgid ""
"If you install your project's Python dependencies inside a :mod:`virtual "
"environment <venv>`, add the path using ``WSGIPythonHome``. See the "
"`mod_wsgi virtual environment guide`_ for more details."
msgstr ""
"如果你在某个 :mod:`virtual environment 1` 内为应用安装项目的 Python 依赖，将"
"该 virtualenv 的路径添加至 ``WSGIPythonHome`` 。参考 `mod_wsgi virtualenv "
"guide`_ 指南获取更多细节。"

msgid ""
"The ``WSGIPythonPath`` line ensures that your project package is available "
"for import on the Python path; in other words, that ``import mysite`` works."
msgstr ""
"``WSGIPythonPath`` 行确保你的项目包能从 Python path 导入；换句话说， "
"``import mysite`` 能正常工作。 "

msgid ""
"The ``<Directory>`` piece ensures that Apache can access your :file:`wsgi."
"py` file."
msgstr "``1`` 片段确保 Apache 能访问文件 :file:`wsgi.py` 文件。"

msgid ""
"Next we'll need to ensure this :file:`wsgi.py` with a WSGI application "
"object exists. As of Django version 1.4, :djadmin:`startproject` will have "
"created one for you; otherwise, you'll need to create it. See the :doc:`WSGI "
"overview documentation</howto/deployment/wsgi/index>` for the default "
"contents you should put in this file, and what else you can add to it."
msgstr ""
"下一步，我们需要确认 :file:`wsgi.py` 文件包含一个 WSGI 应用对象。从 Django "
"1.4 起， :djadmin:`startproject` 会自动创建；换而言之，你无需手动创建。查阅 :"
"doc:`WSGI 概述文档 </howto/deployment/wsgi/index>` 获取你需要配置的默认内容，"
"以及其它可配置项。"

msgid ""
"If multiple Django sites are run in a single mod_wsgi process, all of them "
"will use the settings of whichever one happens to run first. This can be "
"solved by changing::"
msgstr ""
"如果多个 Django 站点运行在同一 mod_wsgi 进程，它们会共用最先启动的站点配置。"
"能通过以下修改改变行为::"

msgid "in ``wsgi.py``, to::"
msgstr "``wsgi.py`` 中也这么改::"

msgid ""
"or by :ref:`using mod_wsgi daemon mode<daemon-mode>` and ensuring that each "
"site runs in its own daemon process."
msgstr ""
"或通过 :ref:`使用 mod_wsgi 的后台模式 <daemon-mode>` 确保每个站点都运行于独立"
"的后台进程。"

msgid "Fixing ``UnicodeEncodeError`` for file uploads"
msgstr "为文件上传修复 ``UnicodeEncodeError``"

msgid ""
"If you get a ``UnicodeEncodeError`` when uploading or writing files with "
"file names or content that contains non-ASCII characters, make sure Apache "
"is configured to support UTF-8 encoding:"
msgstr ""
"如果在上传或写入文件时遇到包含非 ASCII 字符的文件名或内容导致的 "
"``UnicodeEncodeError``，请确保 Apache 配置支持UTF-8编码："

msgid ""
"A common location to put this configuration is ``/etc/apache2/envvars``."
msgstr "常见的配置文件路径是 ``/etc/apache2/envvars``。"

msgid ""
"Alternatively, if you are :ref:`using mod_wsgi daemon mode<daemon-mode>` you "
"can add ``lang`` and ``locale`` options to the ``WSGIDaemonProcess`` "
"directive:"
msgstr ""
"或者，如果你正在 :ref:`使用 mod_wsgi 守护进程模式<daemon-mode>`，你可以在 "
"``WSGIDaemonProcess`` 指令中添加 ``lang`` 和 ``locale`` 选项："

msgid ""
"See the :ref:`unicode-files` section of the Unicode reference guide for "
"details."
msgstr "参考 Unicode 参考指引的 :ref:`unicode-files` 章节获取细节信息。"

msgid "Using ``mod_wsgi`` daemon mode"
msgstr "使用 ``mod_wsgi`` 后台模式"

msgid ""
"\"Daemon mode\" is the recommended mode for running mod_wsgi (on non-Windows "
"platforms). To create the required daemon process group and delegate the "
"Django instance to run in it, you will need to add appropriate "
"``WSGIDaemonProcess`` and ``WSGIProcessGroup`` directives. A further change "
"required to the above configuration if you use daemon mode is that you can't "
"use ``WSGIPythonPath``; instead you should use the ``python-path`` option to "
"``WSGIDaemonProcess``, for example:"
msgstr ""
"\"Daemon mode\" 是运行 mod_wsgi 的推荐模式（在非 Windows 平台上）。为了创建必"
"要的后台进程组并在其中运行 Django 实例，你需要添加合适的 "
"``WSGIDaemonProcess`` 和 ``WSGIProcessGroup`` 指令。上述配置在你使用后台模式"
"时需要点小修改，即你不能使用 ``WSGIPythonPath``；作为替换，你要在 "
"``WSGIDaemonProcess`` 中添加 ``python-path`` 选项，例如："

msgid ""
"If you want to serve your project in a subdirectory (``https://example.com/"
"mysite`` in this example), you can add ``WSGIScriptAlias`` to the "
"configuration above:"
msgstr ""
"如果你想在子目录中开放你的项目（本例中 ``https://example.com/mysite``），你可"
"在上述配置中添加 ``WSGIScriptAlias``："

msgid ""
"See the official mod_wsgi documentation for `details on setting up daemon "
"mode`_."
msgstr "参考官方 mod_wsgi 文档获取 `配置后台模式的细节`_。"

msgid "Serving files"
msgstr "提供文件服务"

msgid ""
"Django doesn't serve files itself; it leaves that job to whichever web "
"server you choose."
msgstr "Django 本身并不提供文件，它把这项工作留给你选择的任何一个网络服务器。"

msgid ""
"We recommend using a separate web server -- i.e., one that's not also "
"running Django -- for serving media. Here are some good choices:"
msgstr ""
"我们建议使用一个单独的 Web 服务器——即一个不同时运行 Django 的服务器——来提供媒"
"体服务。这里有一些不错的选择。"

msgid "Nginx_"
msgstr "Nginx_"

msgid "A stripped-down version of Apache_"
msgstr "一个 Apache_ 的朴素版本"

msgid ""
"If, however, you have no option but to serve media files on the same Apache "
"``VirtualHost`` as Django, you can set up Apache to serve some URLs as "
"static media, and others using the mod_wsgi interface to Django."
msgstr ""
"然而，若你别无选择，只能在与 Django 相同的 Apache ``VirtualHost`` 上提供媒体"
"文件，你可以让 Apache 为一些 URL 提供静态媒体服务，其它的用 mod_wsgi 接口传递"
"给 Django。"

msgid ""
"This example sets up Django at the site root, but serves ``robots.txt``, "
"``favicon.ico``, and anything in the ``/static/`` and ``/media/`` URL space "
"as a static file. All other URLs will be served using mod_wsgi:"
msgstr ""
"本例在站点根目录配置 Django，但以静态文件的形式提供 ``robots.txt``， "
"``favicon.ico`` 以及 ``/static/`` 和 ``/media/`` 中的内容。其它所有 URL 以 "
"mod_wsgi 提供服务："

msgid "Serving the admin files"
msgstr "服务后台文件"

msgid ""
"When :mod:`django.contrib.staticfiles` is in :setting:`INSTALLED_APPS`, the "
"Django development server automatically serves the static files of the admin "
"app (and any other installed apps). This is however not the case when you "
"use any other server arrangement. You're responsible for setting up Apache, "
"or whichever web server you're using, to serve the admin files."
msgstr ""
"当 :mod:`django.contrib.staticfiles` 在 :setting:`INSTALLED_APPS` 中时，"
"Django 开发服务器会自动提供管理应用程序（以及其他任何已安装的应用程序）的静态"
"文件。然而，当你使用任何其他服务器安排时，情况就不是这样了。你要负责设置 "
"Apache 或你所使用的任何网络服务器，以提供管理文件。"

msgid ""
"The admin files live in (:source:`django/contrib/admin/static/admin`) of the "
"Django distribution."
msgstr ""
"管理文件位于 Django 分发版的 (:source:`django/contrib/admin/static/admin`) 目"
"录中。"

msgid ""
"We **strongly** recommend using :mod:`django.contrib.staticfiles` to handle "
"the admin files (along with a web server as outlined in the previous "
"section; this means using the :djadmin:`collectstatic` management command to "
"collect the static files in :setting:`STATIC_ROOT`, and then configuring "
"your web server to serve :setting:`STATIC_ROOT` at :setting:`STATIC_URL`), "
"but here are three other approaches:"
msgstr ""
"我们* *强烈** 建议使用 :mod:`django.contrib.staticfiles` 来处理管理文件（同时"
"使用上一节所述的网络服务器；这意味着使用 :djadmin:`collectstatic` 管理命令来"
"收集 :setup:`STATIC_ROOT` 中的静态文件，然后配置你的网络服务器在 :setup:"
"`STATIC_URL` 中提供 :setup:`STATIC_ROOT` 服务），但这里有三种其他方法："

msgid ""
"Create a symbolic link to the admin static files from within your document "
"root (this may require ``+FollowSymLinks`` in your Apache configuration)."
msgstr ""
"在文档根目录中创建一个指向后台静态文件的符号链接（Apache 配置中可能要添加 "
"``+FollowSymLinks``）。"

msgid ""
"Use an ``Alias`` directive, as demonstrated above, to alias the appropriate "
"URL (probably :setting:`STATIC_URL` + ``admin/``) to the actual location of "
"the admin files."
msgstr ""
"使用前文介绍的 ``Alias`` 指令，为合适的 URL (可能是 :setting:`STATIC_URL` + "
"``admin/``) 取个别名，指向后台文件的实际位置。"

msgid ""
"Copy the admin static files so that they live within your Apache document "
"root."
msgstr "直接将后台静态文件拷贝至 Apache 的文档根目录。"

msgid "Authenticating against Django's user database from Apache"
msgstr "Apache 利用 Django 的用户数据库进行验证"

msgid ""
"Django provides a handler to allow Apache to authenticate users directly "
"against Django's authentication backends. See the :doc:`mod_wsgi "
"authentication documentation </howto/deployment/wsgi/apache-auth>`."
msgstr ""
"Django 提供了一个处理器，允许 Apache 直接用 Django 的认证授权后端认证用户。参"
"考文档 :doc:`mod_wsgi 认证授权文档 </howto/deployment/wsgi/apache-auth>`。"

msgid "How to use Django with uWSGI"
msgstr "如何用 uWSGI 托管 Django"

msgid ""
"uWSGI_ is a fast, self-healing and developer/sysadmin-friendly application "
"container server coded in pure C."
msgstr ""
"uWSGI_ 是一个快速的，自我驱动的，对开发者和系统管理员友好的应用容器服务器，完"
"全由 C 编写。"

msgid ""
"The uWSGI docs offer a `tutorial`_ covering Django, nginx, and uWSGI (one "
"possible deployment setup of many). The docs below are focused on how to "
"integrate Django with uWSGI."
msgstr ""
"uWSGI 文档提供了一个覆盖 Django，nginx，和 uWSGI（一个配置，多种适配）。以下"
"文档专注于如何用 uWSGI 集成 Django。"

msgid "Prerequisite: uWSGI"
msgstr "前置条件：uWSGI"

msgid ""
"The uWSGI wiki describes several `installation procedures`_. Using pip, the "
"Python package manager, you can install any uWSGI version with a single "
"command. For example:"
msgstr ""
"uWSGI 百科介绍了几种 `安装流程`_。Pip （Python 包管理器）能让你仅用一行代码就"
"安装任意版本的 uWSGI。例子："

msgid "uWSGI model"
msgstr "uWSGI 模块"

msgid ""
"uWSGI operates on a client-server model. Your web server (e.g., nginx, "
"Apache) communicates with a ``django-uwsgi`` \"worker\" process to serve "
"dynamic content."
msgstr ""
"uWSGI以 客户-服务器模式运行。你的网站服务器（如 nginx、Apache）与 ``django-"
"uwsgi`` “worker” 进程进行通信，以提供动态内容。"

msgid "Configuring and starting the uWSGI server for Django"
msgstr "配置并启动用于 Django 的 uWSGI 服务器"

msgid ""
"uWSGI supports multiple ways to configure the process. See uWSGI's "
"`configuration documentation`_."
msgstr "uWSGI 支持多种配置进程的方式。参考 uWSGI 的 `配置文档`_。"

msgid "Here's an example command to start a uWSGI server:"
msgstr "以下是启动 uWSGI 服务器的示例命令："

msgid ""
"This assumes you have a top-level project package named ``mysite``, and "
"within it a module :file:`mysite/wsgi.py` that contains a WSGI "
"``application`` object. This is the layout you'll have if you ran ``django-"
"admin startproject mysite`` (using your own project name in place of "
"``mysite``) with a recent version of Django. If this file doesn't exist, "
"you'll need to create it. See the :doc:`/howto/deployment/wsgi/index` "
"documentation for the default contents you should put in this file and what "
"else you can add to it."
msgstr ""
"假设你有个叫做 ``mysite`` 的顶级项目包，其中包含一个模板 :file:`mysite/wsgi."
"py`，模块包含一个 WSGI ``application`` 对象。如果你使用的是较新的 Django，这"
"就是你运行 ``django-admin startproject mysite`` （使用你的项目名替换 "
"``mysite``）后得到的目录结构。若该文件不存在，你需要创建它。参考文档 :doc:`/"
"howto/deployment/wsgi/index` 看看你需要配置的默认内容，以及你还能添加什么。"

msgid "The Django-specific options here are:"
msgstr "Django 指定的参数如下："

msgid ""
"``chdir``: The path to the directory that needs to be on Python's import "
"path -- i.e., the directory containing the ``mysite`` package."
msgstr ""
"``chdir``：需要包含于 Python 的导入路径的目录的路径——例如，包含 ``mysite`` 包"
"的目录。"

msgid ""
"``module``: The WSGI module to use -- probably the ``mysite.wsgi`` module "
"that :djadmin:`startproject` creates."
msgstr ""
"``module``：要使用的 WSGI 模块——可能是 :djadmin:`startproject` 创建的 "
"``mysite.wsgi`` 的模块。"

msgid ""
"``env``: Should probably contain at least :envvar:`DJANGO_SETTINGS_MODULE`."
msgstr "``env``：至少要包括 :envvar:`DJANGO_SETTINGS_MODULE`。"

msgid "``home``: Optional path to your project virtual environment."
msgstr "``home``: 可选的路径，指向你工程的虚拟环境。"

msgid "Example ini configuration file:"
msgstr "示例 INI 配置文件："

msgid "Example ini configuration file usage:"
msgstr "示例 INI 配置文件的使用方法："

msgid ""
"If you get a ``UnicodeEncodeError`` when uploading files with file names "
"that contain non-ASCII characters, make sure uWSGI is configured to accept "
"non-ASCII file names by adding this to your ``uwsgi.ini``:"
msgstr ""
"如果在上传包含非 ASCII 字符的文件名的文件时出现 ``UnicodeEncodeError``，请确"
"保 uWSGI 配置允许接受非 ASCII 文件名，方法是将以下内容添加到你的 ``uwsgi."
"ini`` 文件中："

msgid ""
"See the uWSGI docs on `managing the uWSGI process`_ for information on "
"starting, stopping and reloading the uWSGI workers."
msgstr ""
"参考 uWSGI 文档 `管理 uWSGI 进程`_ 获取更多关于开启，关闭和重载 uWSGI "
"workers 的信息。"

msgid "How to manage error reporting"
msgstr "如何管理错误报告"

msgid ""
"When you're running a public site you should always turn off the :setting:"
"`DEBUG` setting. That will make your server run much faster, and will also "
"prevent malicious users from seeing details of your application that can be "
"revealed by the error pages."
msgstr ""
"当您运行着公开的网页时，你应该把设置中的 :setting:`DEBUG` 选项设为关闭。 这将"
"使您的服务器运行得更快，并且还可以防止恶意用户在错误页面中看到应用的详细信"
"息。"

msgid ""
"However, running with :setting:`DEBUG` set to ``False`` means you'll never "
"see errors generated by your site -- everyone will instead see your public "
"error pages. You need to keep track of errors that occur in deployed sites, "
"so Django can be configured to create reports with details about those "
"errors."
msgstr ""
"然而，把配置 :setting:`DEBUG` 设置为 `False`， 这意味着你永远不会在你的网站上"
"看到错误的细节，所有的人相应会看到你公开的错误页面。当你需要在部署的网页上追"
"踪出现的错误，Django 可以通过设置去报告错误的细节。"

msgid "Email reports"
msgstr "通过邮件方式报告"

msgid "Server errors"
msgstr "服务器错误"

msgid ""
"When :setting:`DEBUG` is ``False``, Django will email the users listed in "
"the :setting:`ADMINS` setting whenever your code raises an unhandled "
"exception and results in an internal server error (strictly speaking, for "
"any response with an HTTP status code of 500 or greater). This gives the "
"administrators immediate notification of any errors. The :setting:`ADMINS` "
"will get a description of the error, a complete Python traceback, and "
"details about the HTTP request that caused the error."
msgstr ""
"当 :setting:`DEBUG` 为 ``False`` 时，Django 会在代码抛出的异常未被捕获且导致"
"一个内部的服务器错误（HTTP 状态码 500）时向 :setting:`ADMINS` 配置中列出的用"
"户发送邮件。这让管理员立刻收到错误通知。 :setting:`ADMINS` 列表中的用户，会收"
"到详细的错误描述，完整的 Python 调用栈，和引发此错误的 HTTP 请求的细节。"

msgid ""
"In order to send email, Django requires a few settings telling it how to "
"connect to your mail server. At the very least, you'll need to specify :"
"setting:`EMAIL_HOST` and possibly :setting:`EMAIL_HOST_USER` and :setting:"
"`EMAIL_HOST_PASSWORD`, though other settings may be also required depending "
"on your mail server's configuration. Consult :doc:`the Django settings "
"documentation </ref/settings>` for a full list of email-related settings."
msgstr ""
"要发送邮件，Django 要求一些配置项，告诉它如何连接至邮件服务器。最小配置下，你"
"需要指定 :setting:`EMAIL_HOST` 和 :setting:`EMAIL_HOST_USER` 和 :setting:"
"`EMAIL_HOST_PASSWORD`，可能还有其它配置，这取决于邮件服务器的配置。查阅 :doc:"
"`Django 配置文档 </ref/settings>` 获取邮件相关配置的完整列表。"

msgid ""
"By default, Django will send email from root@localhost. However, some mail "
"providers reject all email from this address. To use a different sender "
"address, modify the :setting:`SERVER_EMAIL` setting."
msgstr ""
"默认情况下，Django 会从 root@localhost 发送邮件。然而，某些邮件服务商拒绝来自"
"该地址的所有邮件。要使用不同的发件人地址，修改 :setting:`SERVER_EMAIL` 配置。"

msgid ""
"To activate this behavior, put the email addresses of the recipients in the :"
"setting:`ADMINS` setting."
msgstr "要启动该行为，将收件人的邮箱地址放入 :setting:`ADMINS`。"

msgid ""
"Server error emails are sent using the logging framework, so you can "
"customize this behavior by :doc:`customizing your logging configuration </"
"topics/logging>`."
msgstr ""
"服务器错误邮件由 logging 框架发出，所以你能通过 :doc:`自定义 logging 配置 </"
"topics/logging>` 自定义该行为。"

msgid "404 errors"
msgstr "404 错误"

msgid ""
"Django can also be configured to email errors about broken links (404 \"page "
"not found\" errors). Django sends emails about 404 errors when:"
msgstr ""
"Django 也能配置成为已失效的连接发送错误邮件（404 \"page not found\" 错误）。"
"Django 发送 404 错误邮件的条件："

msgid ":setting:`DEBUG` is ``False``;"
msgstr ":setting:`DEBUG` 为 ``False``；"

msgid ""
"Your :setting:`MIDDLEWARE` setting includes :class:`django.middleware.common."
"BrokenLinkEmailsMiddleware`."
msgstr ""
":setting:`MIDDLEWARE` 配置包括 :class:`django.middleware.common."
"BrokenLinkEmailsMiddleware`。"

msgid ""
"If those conditions are met, Django will email the users listed in the :"
"setting:`MANAGERS` setting whenever your code raises a 404 and the request "
"has a referer. It doesn't bother to email for 404s that don't have a referer "
"-- those are usually people typing in broken URLs or broken web bots. It "
"also ignores 404s when the referer is equal to the requested URL, since this "
"behavior is from broken web bots too."
msgstr ""
"如果满足这些条件，Django 会在你的代码出现 404 并且请求有引用来源时，给 :"
"setting:`MANAGERS` 配置中列出的用户发送电子邮件。对于没有引用来源的 404，"
"Django 懒得发邮件——那些通常是人们输入了错误的 URL 或错误的网络机器人。当引用"
"来源等于被请求的 URL 时，它也会忽略 404，因为这种行为也是来自坏掉的网络机器"
"人。"

msgid ""
":class:`~django.middleware.common.BrokenLinkEmailsMiddleware` must appear "
"before other middleware that intercepts 404 errors, such as :class:`~django."
"middleware.locale.LocaleMiddleware` or :class:`~django.contrib.flatpages."
"middleware.FlatpageFallbackMiddleware`. Put it toward the top of your :"
"setting:`MIDDLEWARE` setting."
msgstr ""
":class:`~django.middleware.common.BrokenLinkEmailsMiddleware` 必须出现在其他"
"拦截 404 错误的中间件之前，例如 :class:`~django.middleware.locale."
"LocaleMiddleware` 或者 :class:`~django.contrib.flatpages.middleware."
"FlatpageFallbackMiddleware`。把它放在你的 :setting:`MIDDLEWARE` 配置的顶部。"

msgid ""
"You can tell Django to stop reporting particular 404s by tweaking the :"
"setting:`IGNORABLE_404_URLS` setting. It should be a list of compiled "
"regular expression objects. For example::"
msgstr ""
"你可以通过调整配置项 :setting:`IGNORABLE_404_URLS` 让 Django 忽略某些 404s。"
"内容应该是已编译的正则表达式的列表。例子::"

msgid ""
"In this example, a 404 to any URL ending with ``.php`` or ``.cgi`` will "
"*not* be reported. Neither will any URL starting with ``/phpmyadmin/``."
msgstr ""
"在本例中，对以 ``.php`` 或 ``.cgi`` 结尾的 URL 的 404 错误将 *不会* 被报告。"
"以 ``phpmyadmin`` 开头的也不会被报告。"

msgid ""
"The following example shows how to exclude some conventional URLs that "
"browsers and crawlers often request::"
msgstr "下面的例子展示了如何排除一些浏览器和爬虫经常访问的传统 URL::"

msgid ""
"(Note that these are regular expressions, so we put a backslash in front of "
"periods to escape them.)"
msgstr "（注意，这些都是正则表达式，所以我们用反斜杠转义了点号。）"

msgid ""
"If you'd like to customize the behavior of :class:`django.middleware.common."
"BrokenLinkEmailsMiddleware` further (for example to ignore requests coming "
"from web crawlers), you should subclass it and override its methods."
msgstr ""
"若后续你想自定义 :class:`django.middleware.common."
"BrokenLinkEmailsMiddleware` 的行为（例如忽略来自网络爬虫的请求），你需要继承"
"该类，并重写方法。"

msgid ""
"404 errors are logged using the logging framework. By default, these log "
"records are ignored, but you can use them for error reporting by writing a "
"handler and :doc:`configuring logging </topics/logging>` appropriately."
msgstr ""
"404 错误由 logging 框架报告。默认情况下，这些日志记录被忽略了，但你能通过编写"
"一个处理器和 :doc:`配置 logging </topics/logging>` 让它们报告错误。"

msgid "Filtering error reports"
msgstr "过滤错误报告"

msgid ""
"Filtering sensitive data is a hard problem, and it's nearly impossible to "
"guarantee that sensitive data won't leak into an error report. Therefore, "
"error reports should only be available to trusted team members and you "
"should avoid transmitting error reports unencrypted over the internet (such "
"as through email)."
msgstr ""
"过滤敏感数据是一个很难的问题，几乎不可能保证敏感数据不会泄漏到错误报告中。因"
"此，错误报告应该只提供给受信任的团队成员，你应该避免在互联网上传输未加密的错"
"误报告（如通过电子邮件）。"

msgid "Filtering sensitive information"
msgstr "过滤敏感数据"

msgid ""
"Error reports are really helpful for debugging errors, so it is generally "
"useful to record as much relevant information about those errors as "
"possible. For example, by default Django records the `full traceback`_ for "
"the exception raised, each `traceback frame`_’s local variables, and the :"
"class:`~django.http.HttpRequest`’s :ref:`attributes<httprequest-attributes>`."
msgstr ""
"错误报告对于调试错误来说超级有用，所以通常尽可能多的记录关键信息。例如，"
"Django 默认记录了抛出异常的 `完整调用栈`_，每个 `调用栈层`_ 的局部变量，以"
"及 :class:`~django.http.HttpRequest` 的 :ref:`属性 <httprequest-"
"attributes>`。"

msgid ""
"However, sometimes certain types of information may be too sensitive and "
"thus may not be appropriate to be kept track of, for example a user's "
"password or credit card number. So in addition to filtering out settings "
"that appear to be sensitive as described in the :setting:`DEBUG` "
"documentation, Django offers a set of function decorators to help you "
"control which information should be filtered out of error reports in a "
"production environment (that is, where :setting:`DEBUG` is set to "
"``False``): :func:`sensitive_variables` and :func:"
"`sensitive_post_parameters`."
msgstr ""
"然而，有时候某些信息会涉及敏感内容，因此不适合写入调用栈。例如，用户的密码或"
"信用卡号。故此，为了过滤 :setting:`DEBUG` 文档中描述的敏感内容，Django 提供了"
"一系列的函数装饰器，帮你控制在生产环境（即 :setting:`DEBUG` 为 ``False``）下"
"应该从错误报告中过滤掉哪些信息：:func:`sensitive_variables` 和 :func:"
"`sensitive_post_parameters`。"

msgid ""
"If a function (either a view or any regular callback) in your code uses "
"local variables susceptible to contain sensitive information, you may "
"prevent the values of those variables from being included in error reports "
"using the ``sensitive_variables`` decorator::"
msgstr ""
"若代码中的一个函数（也可能是视图或定期回调）使用容易包含敏感信息的本地变量，"
"你可以用 ``sensitive_variables`` 装饰器阻止错误报告包含这些变量的值::"

msgid ""
"In the above example, the values for the ``user``, ``pw`` and ``cc`` "
"variables will be hidden and replaced with stars (``**********``) in the "
"error reports, whereas the value of the ``name`` variable will be disclosed."
msgstr ""
"上述例子中，错误报告中变量 ``user``， ``pw`` 和 ``cc`` 的值会被以星开头的字符"
"串(``**********``)替换 ，不过 ``name`` 变量的值不会被屏蔽。"

msgid ""
"To systematically hide all local variables of a function from error logs, do "
"not provide any argument to the ``sensitive_variables`` decorator::"
msgstr ""
"要在错误日志中系统的隐藏所有的局部变量，不要向 ``sensitive_variables`` 装饰器"
"传入任何参数::"

msgid "When using multiple decorators"
msgstr "同时使用多个装饰器时"

msgid ""
"If the variable you want to hide is also a function argument (e.g. "
"'``user``’ in the following example), and if the decorated function has "
"multiple decorators, then make sure to place ``@sensitive_variables`` at the "
"top of the decorator chain. This way it will also hide the function argument "
"as it gets passed through the other decorators::"
msgstr ""
"若你想隐藏的变量还是一个函数参数（下例中 '``user``’），且被装饰的函数已拥有好"
"几个装饰器，确保将 ``@sensitive_variables`` 置于最上面。这样，它就也能隐藏函"
"数参数了，因为它穿过其它装饰器::"

msgid "Support for wrapping ``async`` functions was added."
msgstr "已添加对包装 ``async`` 函数的支持。"

msgid ""
"If one of your views receives an :class:`~django.http.HttpRequest` object "
"with :attr:`POST parameters<django.http.HttpRequest.POST>` susceptible to "
"contain sensitive information, you may prevent the values of those "
"parameters from being included in the error reports using the "
"``sensitive_post_parameters`` decorator::"
msgstr ""
"若视图收到一个包含 :attr:`POST 参数 <django.http.HttpRequest.POST>` 的 :"
"class:`~django.http.HttpRequest` 对象，参数中极有可能内含敏感信息。你可以通"
"过 ``sensitive_post_parameters`` 装饰器避免这些参数的值被包括在错误报告中::"

msgid ""
"In the above example, the values for the ``pass_word`` and "
"``credit_card_number`` POST parameters will be hidden and replaced with "
"stars (``**********``) in the request's representation inside the error "
"reports, whereas the value of the ``name`` parameter will be disclosed."
msgstr ""
"上文例子中，POST 参数 ``pass_word`` 和 ``credit_card_number`` 的值会被隐藏，"
"通过在错误报告中展示请求信息的地方用星号开头的字符串 (``**********``)替换，而"
"参数 ``name`` 的值不会被屏蔽。"

msgid ""
"To systematically hide all POST parameters of a request in error reports, do "
"not provide any argument to the ``sensitive_post_parameters`` decorator::"
msgstr ""
"要在错误报告中系统的屏蔽所有 POST 参数，不要给 ``sensitive_post_parameters`` "
"装饰器提供任何参数::"

msgid ""
"All POST parameters are systematically filtered out of error reports for "
"certain :mod:`django.contrib.auth.views` views (``login``, "
"``password_reset_confirm``, ``password_change``, and ``add_view`` and "
"``user_change_password`` in the ``auth`` admin) to prevent the leaking of "
"sensitive information such as user passwords."
msgstr ""
"为了避免敏感信息的泄露（例如账号密码）， 所有传入认证视图 :mod:`django."
"contrib.auth.views` （``login``， ``password_reset_confirm``， "
"``password_change``， and ``add_view`` 和 ``auth`` 后台中的 "
"``user_change_password``）的 POST 参数都在错误报告中经过系统过滤。"

msgid "Custom error reports"
msgstr "自定义错误报告"

msgid ""
"All :func:`sensitive_variables` and :func:`sensitive_post_parameters` do is, "
"respectively, annotate the decorated function with the names of sensitive "
"variables and annotate the ``HttpRequest`` object with the names of "
"sensitive POST parameters, so that this sensitive information can later be "
"filtered out of reports when an error occurs. The actual filtering is done "
"by Django's default error reporter filter: :class:`django.views.debug."
"SafeExceptionReporterFilter`. This filter uses the decorators' annotations "
"to replace the corresponding values with stars (``**********``) when the "
"error reports are produced. If you wish to override or customize this "
"default behavior for your entire site, you need to define your own filter "
"class and tell Django to use it via the :setting:"
"`DEFAULT_EXCEPTION_REPORTER_FILTER` setting::"
msgstr ""
":func:`sensitive_variables` 和 :func:`sensitive_post_parameters` 所做的全部工"
"作是，前者用敏感变量名注解被装饰的函数，后者用 POST 参数中的敏感变量名注解 "
"``HttpRequest`` 对象，所以敏感信息能在后续错误发生时从报告中过滤出去。这项过"
"滤操作者实际上是由 Django 的默认错误报告处理器类： :class:`django.views."
"debug.SafeExceptionReporterFilter`。该过滤器在错误报告生成时，利用装饰器注解"
"以星号 (``**********``) 替换指定值。若你想在全网页范围重写或自定义该默认行"
"为，你需要定义你的过滤器类，并通过配置项 :setting:"
"`DEFAULT_EXCEPTION_REPORTER_FILTER` 配置告诉 Django 启用它::"

msgid ""
"You may also control in a more granular way which filter to use within any "
"given view by setting the ``HttpRequest``’s ``exception_reporter_filter`` "
"attribute::"
msgstr ""
"你也能在任意视图内以一种更细碎的方式控制过滤器，通过设置 ``HttpRequest`` 的 "
"``exception_reporter_filter`` 属性::"

msgid ""
"Your custom filter class needs to inherit from :class:`django.views.debug."
"SafeExceptionReporterFilter` and may override the following attributes and "
"methods:"
msgstr ""
"自定义过滤器类需要继承自类 :class:`django.views.debug."
"SafeExceptionReporterFilter` 并重写以下属性和方法："

msgid ""
"The string value to replace sensitive value with. By default it replaces the "
"values of sensitive variables with stars (``**********``)."
msgstr ""
"用于替换敏感值的字符串。默认情况下，它将敏感参数的值替换成星号 "
"(`**********`)。"

msgid ""
"A compiled regular expression object used to match settings and ``request."
"META`` values considered as sensitive. By default equivalent to::"
msgstr ""
"一个编译了的用于匹配配置和 ``request.META`` 值的不忽略大写的正则表达式对象。"
"默认相当于 ::"

msgid "``HTTP_COOKIE`` was added."
msgstr "添加了 ``HTTP_COOKIE``。"

msgid ""
"Returns ``True`` to activate the filtering in :meth:`get_post_parameters` "
"and :meth:`get_traceback_frame_variables`. By default the filter is active "
"if :setting:`DEBUG` is ``False``. Note that sensitive ``request.META`` "
"values are always filtered along with sensitive setting values, as described "
"in the :setting:`DEBUG` documentation."
msgstr ""
"返回 ``True`` 以在 :meth:`get_post_parameters` 和 :meth:"
"`get_traceback_frame_variables` 中激活过滤。默认情况下如果配置 :setting:"
"`DEBUG` 为 ``False`` 则过滤器会启动。请注意，就像文档中配置 :setting:`DEBUG` "
"描述的一样，敏感的 ``request.META`` 请求值总是会以配置好的值过滤掉。"

msgid ""
"Returns the filtered dictionary of POST parameters. Sensitive values are "
"replaced with :attr:`cleansed_substitute`."
msgstr ""
"返回POST参数过滤后的字典。敏感参数的值会被替换成 :attr:"
"`cleansed_substitute`。"

msgid ""
"Returns the filtered dictionary of local variables for the given traceback "
"frame. Sensitive values are replaced with :attr:`cleansed_substitute`."
msgstr ""
"返回给定的调用栈层中的局部变量经过过滤后的字段。敏感值会被替换成 :attr:"
"`cleansed_substitute`。"

msgid ""
"If you need to customize error reports beyond filtering you may specify a "
"custom error reporter class by defining the :setting:"
"`DEFAULT_EXCEPTION_REPORTER` setting::"
msgstr ""
"如果你需要在过滤器之外自定义错误报告，你可以指定一个自定义写在配置 :setting:"
"`DEFAULT_EXCEPTION_REPORTER` setting:: 配置的错误报告类"

msgid ""
"The exception reporter is responsible for compiling the exception report "
"data, and formatting it as text or HTML appropriately. (The exception "
"reporter uses :setting:`DEFAULT_EXCEPTION_REPORTER_FILTER` when preparing "
"the exception report data.)"
msgstr ""
"异常报告工具负责编译异常报告并将其整理成文本或HTML文件的形式。（当准备要报告"
"的异常数据的时候异常报告工具使用配置 :setting:"
"`DEFAULT_EXCEPTION_REPORTER_FILTER` ）"

msgid ""
"Your custom reporter class needs to inherit from :class:`django.views.debug."
"ExceptionReporter`."
msgstr ""
"你的自定义的报告类需要继承自类 :class: `django.views.debug."
"ExceptionReporter` 。"

msgid ""
"Property that returns a :class:`pathlib.Path` representing the absolute "
"filesystem path to a template for rendering the HTML representation of the "
"exception. Defaults to the Django provided template."
msgstr ""
"返回一个 :class:`pathlib.Path` 的类，该路径表示模板的绝对文件系统路径，用于呈"
"现异常的 HTML 表示。 默认为 Django 提供的模板。 "

msgid ""
"Property that returns a :class:`pathlib.Path` representing the absolute "
"filesystem path to a template for rendering the plain-text representation of "
"the exception. Defaults to the Django provided template."
msgstr ""
"返回一个 :class:`pathlib.Path` 的类，该路径表示模板的绝对文件系统路径，用于呈"
"现异常的纯文本表示。 默认为 Django 提供的模板。 "

msgid "Return a dictionary containing traceback information."
msgstr "返回一个包含回溯信息的字典。"

msgid ""
"This is the main extension point for customizing exception reports, for "
"example::"
msgstr "这是自定义异常报告工具的主要扩展点，如下::"

msgid "Return HTML version of exception report."
msgstr "返回异常报告的HTML版本。"

msgid "Used for HTML version of debug 500 HTTP error page."
msgstr "用于返回HTTP 500错误页面的HTML版本。"

msgid "Return plain text version of exception report."
msgstr "返回异常报告的纯文本版本。"

msgid ""
"Used for plain text version of debug 500 HTTP error page and email reports."
msgstr "用于调试HTTP 500错误页面和相应邮件报告的纯文本版本。"

msgid ""
"As with the filter class, you may control which exception reporter class to "
"use within any given view by setting the ``HttpRequest``’s "
"``exception_reporter_class`` attribute::"
msgstr ""
"和过滤类一样，你也能在任意视图内通过配置 ``HttpRequest`` 的 "
"``exception_reporter_filter`` 属性来控制具体使用哪个错误报告类::"

msgid ""
"You can also set up custom error reporting by writing a custom piece of :ref:"
"`exception middleware <exception-middleware>`. If you do write custom error "
"handling, it's a good idea to emulate Django's built-in error handling and "
"only report/log errors if :setting:`DEBUG` is ``False``."
msgstr ""
"你也能够通过自定义一系列的 :ref:`异常中间层 <exception-middleware>` 定制错误"
"报告行为。若你已经编写了自定义错误处理器，模仿 Django 内置的错误处理器，并只"
"在 :setting:`DEBUG` 为 ``False`` 时报告或记录错误是个不错的主意。"

msgid "\"How-to\" guides"
msgstr "操作指南"

msgid ""
"Here you'll find short answers to \"How do I....?\" types of questions. "
"These how-to guides don't cover topics in depth -- you'll find that material "
"in the :doc:`/topics/index` and the :doc:`/ref/index`. However, these guides "
"will help you quickly accomplish common tasks."
msgstr ""
"你将在此找到大量回答形如“我该如何……”问题的简答。这些怎么做指南不会深入各个主"
"题——你可以在 :doc:`/topics/index` 和 :doc:`/ref/index` 找到深入的讲解。不过，"
"这些指引可以帮你快速完成常见的任务。"

msgid ""
"The `Django community aggregator`_, where we aggregate content from the "
"global Django community. Many writers in the aggregator write this sort of "
"how-to material."
msgstr ""
"`Django 聚合社区`_，我们将全球 Django 社区的内容聚合至此。聚合社区中的很多作"
"者编写了本快速指南文档。"

msgid "How to provide initial data for models"
msgstr "如何为模型提供初始数据"

msgid ""
"It's sometimes useful to prepopulate your database with hard-coded data when "
"you're first setting up an app. You can provide initial data with migrations "
"or fixtures."
msgstr ""
"在初次设置应用程序时，使用硬编码数据预填充数据库有时是很有用的。您可以使用迁"
"移或固定数据来提供初始数据。"

msgid "Provide initial data with migrations"
msgstr "使用迁移提供初始数据"

msgid ""
"To automatically load initial data for an app, create a :ref:`data migration "
"<data-migrations>`. Migrations are run when setting up the test database, so "
"the data will be available there, subject to :ref:`some limitations <test-"
"case-serialized-rollback>`."
msgstr ""
"要自动加载应用程序的初始数据，请创建一个 :ref:`数据迁移 <data-migrations>`。"
"迁移会在设置测试数据库时运行，因此数据将在那里可用，但受到 :ref:`一些限制 "
"<test-case-serialized-rollback>` 的影响。"

msgid "Provide data with fixtures"
msgstr "使用固定数据提供数据"

msgid ""
"You can also provide data using :ref:`fixtures <fixtures-explanation>`, "
"however, this data isn't loaded automatically, except if you use :attr:`."
"TransactionTestCase.fixtures`."
msgstr ""
"你还可以使用 :ref:`fixtures <fixtures-explanation>` 提供数据，但这些数据不会"
"自动加载，除非你使用 :attr:`.TransactionTestCase.fixtures`。"

msgid ""
"A fixture is a collection of data that Django knows how to import into a "
"database. The most straightforward way of creating a fixture if you've "
"already got some data is to use the :djadmin:`manage.py dumpdata <dumpdata>` "
"command. Or, you can write fixtures by hand; fixtures can be written as "
"JSON, XML or YAML (with PyYAML_ installed) documents. The :doc:"
"`serialization documentation </topics/serialization>` has more details about "
"each of these supported :ref:`serialization formats <serialization-formats>`."
msgstr ""
"固定内容是一个 Django 知道如何导入数据库的集合。若你已有一些可用数据，最直接"
"的创建固定内容的方式是使用  :djadmin:`manage.py dumpdata <dumpdata>` 命令。或"
"者，你可以手写固定内容；固定数据能被写作 JSON，XML 或 YAML （要求已安装 "
"PyYAML_）文档。 :doc:`序列化文档 </topics/serialization>` 拥有更多这些支持"
"的 :ref:`序列化格式 <serialization-formats>` 的细节信息。"

msgid ""
"As an example, though, here's what a fixture for a ``Person`` model might "
"look like in JSON:"
msgstr ""
"举个例子，这有一个固定内容，描述了一个 ``Person`` 模型写成 JSON 后的样子："

msgid "And here's that same fixture as YAML:"
msgstr "以下是一样的固定内容，YAML 格式："

msgid "You'll store this data in a ``fixtures`` directory inside your app."
msgstr "你会将该数据存入应用中的 ``fixtures`` 字典。"

msgid ""
"You can load data by calling :djadmin:`manage.py loaddata <loaddata>` "
"``<fixturename>``, where ``<fixturename>`` is the name of the fixture file "
"you've created. Each time you run :djadmin:`loaddata`, the data will be read "
"from the fixture and reloaded into the database. Note this means that if you "
"change one of the rows created by a fixture and then run :djadmin:`loaddata` "
"again, you'll wipe out any changes you've made."
msgstr ""
"你可以通过调用 :djadmin:`manage.py loaddata <loaddata>` ``<fixturename>`` 来"
"加载数据，其中 ``<fixturename>`` 是你创建的 fixture 文件的名称。每次运行 :"
"djadmin:`loaddata` 时，数据将从 fixture 中读取并重新加载到数据库中。请注意，"
"这意味着如果你更改了 fixture 创建的行之一，然后再次运行 :djadmin:`loaddata`，"
"你将覆盖你所做的任何更改。"

msgid "Tell Django where to look for fixture files"
msgstr "告诉 Django 在哪里查找固定数据文件"

msgid ""
"By default, Django looks for fixtures in the ``fixtures`` directory inside "
"each app for, so the command ``loaddata sample`` will find the file ``my_app/"
"fixtures/sample.json``. This works with relative paths as well, so "
"``loaddata my_app/sample`` will find the file ``my_app/fixtures/my_app/"
"sample.json``."
msgstr ""
"默认情况下，Django 在每个应用程序内部查找 fixtures，因此命令 ``loaddata "
"sample`` 将找到文件 ``my_app/fixtures/sample.json``。这也适用于相对路径，因"
"此 ``loaddata my_app/sample`` 将找到文件 ``my_app/fixtures/my_app/sample."
"json``。"

msgid ""
"Django also looks for fixtures in the list of directories provided in the :"
"setting:`FIXTURE_DIRS` setting."
msgstr ""
"Django 还会在 :setting:`FIXTURE_DIRS` 设置提供的目录列表中查找 fixtures。"

msgid ""
"To completely prevent default search form happening, use an absolute path to "
"specify the location of your fixture file, e.g. ``loaddata /path/to/sample``."
msgstr ""
"要完全阻止默认搜索发生，使用绝对路径来指定 fixture 文件的位置，例如 "
"``loaddata /path/to/sample``。"

msgid "Namespace your fixture files"
msgstr "为你的固定数据文件设置命名空间"

msgid ""
"Django will use the first fixture file it finds whose name matches, so if "
"you have fixture files with the same name in different applications, you "
"will be unable to distinguish between them in your ``loaddata`` commands. "
"The easiest way to avoid this problem is by *namespacing* your fixture "
"files. That is, by putting them inside a directory named for their "
"application, as in the relative path example above."
msgstr ""
"Django 将使用它找到的第一个与名称匹配的 fixture 文件，因此如果在不同应用程序"
"中有具有相同名称的 fixture 文件，你将无法在你的 ``loaddata`` 命令中区分它们。"
"避免这个问题的最简单方法是通过为 fixture 文件添加 *命名空间*。也就是说，将它"
"们放在以其应用程序命名的目录中，就像上面的相对路径示例中一样。"

msgid ""
"Fixtures are also used by the :ref:`testing framework <topics-testing-"
"fixtures>` to help set up a consistent test environment."
msgstr ""
"固定内容通常备 :ref:`测试框架 <topics-testing-fixtures>` 用于创建永久的测试环"
"境。"

msgid "How to integrate Django with a legacy database"
msgstr "如何将 Django 与旧有的数据库集成"

msgid ""
"While Django is best suited for developing new applications, it's quite "
"possible to integrate it into legacy databases. Django includes a couple of "
"utilities to automate as much of this process as possible."
msgstr ""
"虽然 Django 很适合开发新应用，但也能用它集成旧数据库。Django 包含了一整套套件"
"来尽可能自动处理类似的任务。"

msgid ""
"This document assumes you know the Django basics, as covered in the :doc:"
"`tutorial </intro/tutorial01>`."
msgstr ""
"本文假设你有 Django 基础，基础内容由 :doc:`教程 </intro/tutorial01>` 介绍。"

msgid ""
"Once you've got Django set up, you'll follow this general process to "
"integrate with an existing database."
msgstr "你配置完 Django 后，你就能跟着此常规操作去集成旧数据库了。"

msgid "Give Django your database parameters"
msgstr "将数据库参数告诉 Django"

msgid ""
"You'll need to tell Django what your database connection parameters are, and "
"what the name of the database is. Do that by editing the :setting:"
"`DATABASES` setting and assigning values to the following keys for the "
"``'default'`` connection:"
msgstr ""
"你需要告诉 Django 数据库连接参数和数据库名称。通过编写 :setting:`DATABASES` "
"配置项并为 ``'default'`` 连接指定下列值："

msgid ":setting:`NAME`"
msgstr ":setting:`NAME`"

msgid ":setting:`ENGINE <DATABASE-ENGINE>`"
msgstr ":setting:`ENGINE <DATABASE-ENGINE>`"

msgid ":setting:`USER`"
msgstr ":setting:`USER`"

msgid ":setting:`PASSWORD`"
msgstr ":setting:`PASSWORD`"

msgid ":setting:`HOST`"
msgstr ":setting:`HOST`"

msgid ":setting:`PORT`"
msgstr ":setting:`PORT`"

msgid "Auto-generate the models"
msgstr "自动生成这些模型"

msgid ""
"Django comes with a utility called :djadmin:`inspectdb` that can create "
"models by introspecting an existing database. You can view the output by "
"running this command:"
msgstr ""
"Django 自带一个名为 :djadmin:`inspectdb` 的实用程序，可以通过审查现有数据库来"
"创建模型。你可以通过运行以下命令来查看输出："

msgid "Save this as a file by using standard Unix output redirection:"
msgstr "通过使用标准的 Unix 输出重定向，将此保存为文件："

msgid ""
"This feature is meant as a shortcut, not as definitive model generation. See "
"the :djadmin:`documentation of inspectdb <inspectdb>` for more information."
msgstr ""
"该功能仅是一个快捷方式，不是最佳的创建模型的方法。参考 :djadmin:`inspectdb 文"
"档 <inspectdb>` 获取更多信息。"

msgid ""
"Once you've cleaned up your models, name the file ``models.py`` and put it "
"in the Python package that holds your app. Then add the app to your :setting:"
"`INSTALLED_APPS` setting."
msgstr ""
"只要你整理完这些模型，就可以将文件重命名为 ``models.py`` 并将其放入持有应用"
"的 Python 包中。随后，将应用添加至 :setting:`INSTALLED_APPS` 配置。"

msgid ""
"By default, :djadmin:`inspectdb` creates unmanaged models. That is, "
"``managed = False`` in the model's ``Meta`` class tells Django not to manage "
"each table's creation, modification, and deletion::"
msgstr ""
"默认情况下， :djadmin:`inspectdb` 创建未托管的模型。也就是说，模型的 "
"``Meta`` 类中的 ``managed = False`` 告诉 Django 不要管理这些表的创建，修改和"
"删除::"

msgid ""
"If you do want to allow Django to manage the table's lifecycle, you'll need "
"to change the :attr:`~django.db.models.Options.managed` option above to "
"``True`` (or remove it because ``True`` is its default value)."
msgstr ""
"若你的确想要允许 Django 管理这些表格的生命周期，你需要将上面的 :attr:"
"`~django.db.models.Options.managed` 选项的值改为 ``True`` （或者删掉它，因为 "
"``True`` 是默认值）。"

msgid "Install the core Django tables"
msgstr "安装核心 Django 表"

msgid ""
"Next, run the :djadmin:`migrate` command to install any extra needed "
"database records such as admin permissions and content types:"
msgstr ""
"接下来，运行 :djadmin:`migrate` 命令来安装任何额外所需的数据库记录，如管理员"
"权限和内容类型："

msgid "Test and tweak"
msgstr "测试和调整"

msgid ""
"Those are the basic steps -- from here you'll want to tweak the models "
"Django generated until they work the way you'd like. Try accessing your data "
"via the Django database API, and try editing objects via Django's admin "
"site, and edit the models file accordingly."
msgstr ""
"这些是基本步骤——这样，你就能调整 Django 生成的模型，直到他们达到你的要求。试"
"着通过 Django 数据库 API 访问数据，试着通过 Django 后台站点编辑数据，也可以直"
"接编辑模型文件。"

msgid "How to configure and use logging"
msgstr "如何配置和使用日志"

msgid ":ref:`Django logging reference <logging-ref>`"
msgstr ":ref:`Django 日志参考 <logging-ref>`"

msgid ":ref:`Django logging overview <logging-explanation>`"
msgstr ":ref:`Django 日志概览 <logging-explanation>`"

msgid ""
"Django provides a working :ref:`default logging configuration <default-"
"logging-configuration>` that is readily extended."
msgstr ""
"Django 提供了一个可扩展的 :ref:`默认日志配置 <default-logging-"
"configuration>`。"

msgid "Make a basic logging call"
msgstr "发起基本的 logging 调用"

msgid ""
"To send a log message from within your code, you place a logging call into "
"it."
msgstr "要从代码中发送日志消息，你需要在代码中添加日志调用。"

msgid "Don't be tempted to use logging calls in ``settings.py``."
msgstr "不要在 ``settings.py`` 中使用日志调用。"

msgid ""
"The way that Django logging is configured as part of the ``setup()`` "
"function means that logging calls placed in ``settings.py`` may not work as "
"expected, because *logging will not be set up at that point*. To explore "
"logging, use a view function as suggested in the example below."
msgstr ""
"Django 日志配置作为 ``setup()`` 函数的一部分配置的方式意味着在 ``settings."
"py`` 中放置的日志调用可能不会按预期工作，因为在那个时候 *日志还没有设置好*。"
"要探索日志，请使用下面示例中建议的视图函数。"

msgid ""
"First, import the Python logging library, and then obtain a logger instance "
"with :py:func:`logging.getLogger`. Provide the ``getLogger()`` method with a "
"name to identify it and the records it emits. A good option is to use "
"``__name__`` (see :ref:`naming-loggers` below for more on this) which will "
"provide the name of the current Python module as a dotted path::"
msgstr ""
"首先，导入Python的日志库，然后使用 :py:func:`logging.getLogger` 获取一个日志"
"记录器实例。为 ``getLogger()`` 方法提供一个用于识别它和它发出的记录的名称。一"
"个好的选择是使用 ``__name__`` （参见下面的 :ref:`命名日志记录器` 了解更多信"
"息），它将提供当前Python模块的名称作为一个点分路径："

msgid "It's a good convention to perform this declaration at module level."
msgstr "在模块级别执行此声明是一个好的约定。"

msgid ""
"And then in a function, for example in a view, send a record to the logger::"
msgstr "然后在函数中，例如在视图中，向日志记录器发送一条记录："

msgid ""
"When this code is executed, a :py:class:`~logging.LogRecord` containing that "
"message will be sent to the logger. If you're using Django's default logging "
"configuration, the message will appear in the console."
msgstr ""
"当执行此代码时，将发送一个包含该消息的 :py:class:`~logging.LogRecord` 到日志"
"记录器。如果你正在使用 Django 的默认日志配置，该消息将出现在控制台中。"

msgid ""
"The ``WARNING`` level used in the example above is one of several :ref:"
"`logging severity levels <topic-logging-parts-loggers>`: ``DEBUG``, "
"``INFO``, ``WARNING``, ``ERROR``, ``CRITICAL``. So, another example might "
"be::"
msgstr ""
"上面示例中使用的 ``WARNING`` 级别是多个 :ref:`日志严重级别 <topic-logging-"
"parts-loggers>` 中的一个：``DEBUG``, ``INFO``, ``WARNING``, ``ERROR``, "
"``CRITICAL``。因此，另一个示例可能如下所示："

msgid ""
"Records with a level lower than ``WARNING`` will not appear in the console "
"by default. Changing this behavior requires additional configuration."
msgstr ""
"级别低于 ``WARNING`` 的记录默认情况下不会出现在控制台中。要更改此行为，需要额"
"外的配置。"

msgid "Customize logging configuration"
msgstr "自定义日志配置"

msgid ""
"Although Django's logging configuration works out of the box, you can "
"control exactly how your logs are sent to various destinations - to log "
"files, external services, email and so on - with some additional "
"configuration."
msgstr ""
"虽然 Django 的日志配置可以直接使用，但您可以通过一些额外的配置来精确控制日志"
"发送到各种目标的方式，如日志文件、外部服务、电子邮件等。"

msgid "You can configure:"
msgstr "你可以配置："

msgid "logger mappings, to determine which records are sent to which handlers"
msgstr "使用日志记录器映射来确定将哪些记录发送到哪些处理程序。"

msgid "handlers, to determine what they do with the records they receive"
msgstr "使用处理程序来确定它们接收到的记录的处理方式"

msgid ""
"filters, to provide additional control over the transfer of records, and "
"even modify records in-place"
msgstr "使用过滤器来对记录的传递进行额外控制，甚至可以对记录进行原地修改"

msgid ""
"formatters, to convert :class:`~logging.LogRecord` objects to a string or "
"other form for consumption by human beings or another system"
msgstr ""
"格式化器，用于将 :class:`~logging.LogRecord` 对象转换为字符串或其他形式，以供"
"人类或其他系统使用。"

msgid ""
"There are various ways of configuring logging. In Django, the :setting:"
"`LOGGING` setting is most commonly used. The setting uses the :ref:"
"`dictConfig format <logging-config-dictschema>`, and extends the :ref:"
"`default logging configuration <default-logging-definition>`."
msgstr ""
"有各种配置日志的方式。在Django中，最常用的是 :setting:`LOGGING` 设置。该设置"
"使用 :ref:`dictConfig 格式 <logging-config-dictschema>`，并扩展了 :ref:`默认"
"的日志配置 <default-logging-definition>`。"

msgid ""
"See :ref:`configuring-logging` for an explanation of how your custom "
"settings are merged with Django's defaults."
msgstr ""
"请参阅 :ref:`configuring-logging` 以了解如何将你的自定义设置与 Django 的默认"
"设置合并的解释。"

msgid ""
"See the :mod:`Python logging documentation <python:logging.config>` for "
"details of other ways of configuring logging. For the sake of simplicity, "
"this documentation will only consider configuration via the ``LOGGING`` "
"setting."
msgstr ""
"有关其他配置日志的方式的详细信息，请参阅 :mod:`Python 日志文档 <python:"
"logging.config>`。为了简单起见，本文档将仅考虑通过 ``LOGGING`` 设置进行配置。"

msgid "Basic logging configuration"
msgstr "基础日志配置"

msgid "When configuring logging, it makes sense to"
msgstr "在配置日志时，以下操作是有意义的"

msgid "Create a ``LOGGING`` dictionary"
msgstr "创建一个 ``LOGGING`` 目录"

msgid "In your ``settings.py``::"
msgstr "在你的 ``settings.py``:: 中"

msgid ""
"It nearly always makes sense to retain and extend the default logging "
"configuration by setting ``disable_existing_loggers`` to ``False``."
msgstr ""
"通常情况下，将 ``disable_existing_loggers`` 设置为 ``False``，保留并扩展默认"
"的日志配置是有意义的。"

msgid "Configure a handler"
msgstr "配置一个处理程序"

msgid ""
"This example configures a single handler named ``file``, that uses Python's :"
"class:`~logging.FileHandler` to save logs of level ``DEBUG`` and higher to "
"the file ``general.log`` (at the project root):"
msgstr ""
"这个示例配置了一个名为 ``file`` 的处理程序，使用Python的 :class:`~logging."
"FileHandler` 将级别为 ``DEBUG`` 及更高的日志保存到文件 ``general.log`` （位于"
"项目根目录）中："

msgid ""
"Different handler classes take different configuration options. For more "
"information on available handler classes, see the :class:`~django.utils.log."
"AdminEmailHandler` provided by Django and the various :py:mod:`handler "
"classes <logging.handlers>` provided by Python."
msgstr ""
"不同的处理程序类接受不同的配置选项。有关可用处理程序类的更多信息，请参阅 "
"Django 提供的 :class:`~django.utils.log.AdminEmailHandler` 以及 Python 提供的"
"各种 :py:mod:`处理程序类 <logging.handlers>`。"

msgid ""
"Logging levels can also be set on the handlers (by default, they accept log "
"messages of all levels). Using the example above, adding:"
msgstr ""
"日志级别也可以在处理程序上进行设置（默认情况下，它们接受所有级别的日志消"
"息）。使用上面的示例，添加以下内容："

msgid ""
"would define a handler configuration that only accepts records of level "
"``DEBUG`` and higher."
msgstr ""
"可以定义一个处理程序配置，该配置只接受级别为 ``DEBUG`` 及更高级别的记录。"

msgid "Configure a logger mapping"
msgstr "配置一个日志记录器映射"

msgid ""
"To send records to this handler, configure a logger mapping to use it for "
"example:"
msgstr "要将记录发送到该处理程序，请配置一个日志记录器映射，例如："

msgid ""
"The mapping's name determines which log records it will process. This "
"configuration (``''``) is *unnamed*. That means that it will process records "
"from *all* loggers (see :ref:`naming-loggers` below on how to use the "
"mapping name to determine the loggers for which it will process records)."
msgstr ""
"映射的名称决定了它将处理哪些日志记录。此配置（``''``）是 *无名称* 的。这意味"
"着它将处理 *所有* 记录器的记录（请参阅下面的 :ref:`命名记录器` 以了解如何使用"
"映射名称来确定它将处理哪些记录器的记录）。"

msgid ""
"It will forward messages of levels ``DEBUG`` and higher to the handler named "
"``file``."
msgstr "它将级别为 ``DEBUG`` 及更高的消息发送给名为 ``file`` 的处理程序。"

msgid ""
"Note that a logger can forward messages to multiple handlers, so the "
"relation between loggers and handlers is many-to-many."
msgstr ""
"请注意，一个日志记录器可以将消息转发给多个处理程序，因此日志记录器和处理程序"
"之间的关系是多对多的。"

msgid "If you execute::"
msgstr "如果您执行以下操作："

msgid ""
"in your code, you will find that message in the file ``general.log`` in the "
"root of the project."
msgstr "在你的代码中，你将在项目根目录中的文件 ``general.log`` 中找到该消息。"

msgid "Configure a formatter"
msgstr "配置格式化器"

msgid ""
"By default, the final log output contains the message part of each :class:"
"`log record <logging.LogRecord>`. Use a formatter if you want to include "
"additional data. First name and define your formatters - this example "
"defines formatters named ``verbose`` and ``simple``:"
msgstr ""
"默认情况下，最终的日志输出包含每个 :class:`日志记录 <logging.LogRecord>` 的消"
"息部分。如果想要包含附加数据，可以使用格式化器。首先命名并定义你的格式化器 - "
"以下示例定义了名为 ``verbose`` 和 ``simple`` 的格式化器："

msgid ""
"The ``style`` keyword allows you to specify ``{`` for :meth:`str.format` or "
"``$`` for :class:`string.Template` formatting; the default is ``$``."
msgstr ""
"``style`` 关键字允许你指定 ``{`` 用于 :meth:`str.format` 或 ``$`` 用于 :"
"class:`string.Template` 格式化；默认值是 ``$``。"

msgid ""
"See :ref:`logrecord-attributes` for the :class:`~logging.LogRecord` "
"attributes you can include."
msgstr ""
"查看 :ref:`logrecord-attributes` 以了解可以包含的 :class:`~logging."
"LogRecord` 属性。"

msgid ""
"To apply a formatter to a handler, add a ``formatter`` entry to the "
"handler's dictionary referring to the formatter by name, for example:"
msgstr ""
"要将格式化器应用到处理程序，可以在处理程序的字典中添加一个指向格式化器的名称"
"的 ``formatter`` 条目，例如："

msgid "Use logger namespacing"
msgstr "使用命名空间日志记录器"

msgid ""
"The unnamed logging configuration ``''`` captures logs from any Python "
"application. A named logging configuration will capture logs only from "
"loggers with matching names."
msgstr ""
"未命名的日志配置 ``''`` 捕获来自任何 Python 应用程序的日志。命名的日志配置将"
"仅捕获名称匹配的记录器的日志。"

msgid ""
"The namespace of a logger instance is defined using :py:func:`~logging."
"getLogger`. For example in ``views.py`` of ``my_app``::"
msgstr ""
"日志记录器实例的命名空间是使用 :py:func:`~logging.getLogger` 定义的。例如，"
"在 ``my_app`` 的 ``views.py`` 中："

msgid ""
"will create a logger in the ``my_app.views`` namespace. ``__name__`` allows "
"you to organize log messages according to their provenance within your "
"project's applications automatically. It also ensures that you will not "
"experience name collisions."
msgstr ""
"将在 ``my_app.views`` 命名空间中创建一个日志记录器。``__name__`` 允许你自动根"
"据项目中应用程序的来源组织日志消息。它还确保你不会遇到名称冲突。"

msgid ""
"A logger mapping named ``my_app.views`` will capture records from this "
"logger:"
msgstr "一个名为 ``my_app.views`` 的日志记录器映射将捕获来自这个记录器的记录："

msgid ""
"A logger mapping named ``my_app`` will be more permissive, capturing records "
"from loggers anywhere within the ``my_app`` namespace (including ``my_app."
"views``, ``my_app.utils``, and so on):"
msgstr ""
"一个名为 ``my_app`` 的日志记录器映射将更加宽松，捕获来自 ``my_app`` 命名空间"
"中任何地方的记录器（包括 ``my_app.views``、``my_app.utils`` 等等）："

msgid "You can also define logger namespacing explicitly::"
msgstr "您还可以明确定义日志记录器的命名空间："

msgid "and set up logger mappings accordingly."
msgstr "并相应地设置日志记录器映射。"

msgid "Using logger hierarchies and propagation"
msgstr "使用日志记录器层次结构和传播"

msgid ""
"Logger naming is *hierarchical*. ``my_app`` is the parent of ``my_app."
"views``, which is the parent of ``my_app.views.private``. Unless specified "
"otherwise, logger mappings will propagate the records they process to their "
"parents - a record from a logger in the ``my_app.views.private`` namespace "
"will be handled by a mapping for both ``my_app`` and ``my_app.views``."
msgstr ""
"日志记录器的命名是 *分层* 的。``my_app`` 是 ``my_app.views`` 的父级，"
"``my_app.views`` 是 ``my_app.views.private`` 的父级。除非另有说明，否则日志记"
"录器映射将将它们处理的记录传播给它们的父级 - 来自 ``my_app.views.private`` 命"
"名空间中的记录器的记录将由 ``my_app`` 和 ``my_app.views`` 的映射处理。"

msgid ""
"To manage this behavior, set the propagation key on the mappings you define::"
msgstr "为了管理这种行为，请在您定义的映射中设置传播键："

msgid ""
"``propagate`` defaults to ``True``. In this example, the logs from ``my_app."
"views.private`` will not be handled by the parent, but logs from ``my_app."
"views`` will."
msgstr ""
"``propagate`` 默认为 ``True``。在这个示例中，来自 ``my_app.views.private`` 的"
"日志不会被父级处理，但来自 ``my_app.views`` 的日志会被处理。"

msgid "Configure responsive logging"
msgstr "配置响应式日志记录"

msgid ""
"Logging is most useful when it contains as much information as possible, but "
"not information that you don't need - and how much you need depends upon "
"what you're doing. When you're debugging, you need a level of information "
"that would be excessive and unhelpful if you had to deal with it in "
"production."
msgstr ""
"当日志包含尽可能多的信息，而不是您不需要的信息时，日志是最有用的——需要多少取"
"决于您正在做的事情。在调试时，您需要一定程度的信息，如果您不得不在生产环境中"
"处理这些信息，那么这些信息将是多余的，而且毫无用处。"

msgid ""
"You can configure logging to provide you with the level of detail you need, "
"when you need it. Rather than manually change configuration to achieve this, "
"a better way is to apply configuration automatically according to the "
"environment."
msgstr ""
"您可以配置日志记录，以在需要时为您提供所需的详细程度。与手动更改配置以实现此"
"目的不同，更好的方式是根据环境自动应用配置。"

msgid ""
"For example, you could set an environment variable ``DJANGO_LOG_LEVEL`` "
"appropriately in your development and staging environments, and make use of "
"it in a logger mapping thus::"
msgstr ""
"例如，你可以在开发和测试环境中适当设置一个环境变量 ``DJANGO_LOG_LEVEL``，然后"
"在日志记录器映射中使用它，如下所示："

msgid ""
"\\- so that unless the environment specifies a lower log level, this "
"configuration will only forward records of severity ``WARNING`` and above to "
"its handler."
msgstr ""
"因此，除非环境指定较低的日志级别，否则此配置将仅将严重性为 ``WARNING`` 及以上"
"的记录转发到其处理程序。"

msgid ""
"Other options in the configuration (such as the ``level`` or ``formatter`` "
"option of handlers) can be similarly managed."
msgstr ""
"配置中的其他选项（例如处理程序的 ``level`` 或 ``formatter`` 选项）可以以类似"
"的方式进行管理。"

msgid "How to create CSV output"
msgstr "如何输出 CSV"

msgid ""
"This document explains how to output CSV (Comma Separated Values) "
"dynamically using Django views. To do this, you can either use the Python "
"CSV library or the Django template system."
msgstr ""
"本文介绍如何用 Django 的视图动态输出 CSV (Comma Separated Values)。要达到目"
"的，你可以使用 Python 的 CSV 库或 Django 的模板系统。"

msgid "Using the Python CSV library"
msgstr "使用 Python 的 CSV 库"

msgid ""
"Python comes with a CSV library, :mod:`csv`. The key to using it with Django "
"is that the :mod:`csv` module's CSV-creation capability acts on file-like "
"objects, and Django's :class:`~django.http.HttpResponse` objects are file-"
"like objects."
msgstr ""
"Python 有用一个 CSV 库 :mod:`csv`。它配合 Django 使用的关键是 :mod:`csv` 模块"
"的 CSV 创建行为作用于类文件对象，而 Django 的 :class:`~django.http."
"HttpResponse` 对象也是类文件对象。"

msgid "Here's an example::"
msgstr "这有个例子::"

msgid ""
"The code and comments should be self-explanatory, but a few things deserve a "
"mention:"
msgstr "代码和注释应该是不言自明的，但是有几件事值得提一下："

msgid ""
"The response gets a special MIME type, :mimetype:`text/csv`. This tells "
"browsers that the document is a CSV file, rather than an HTML file. If you "
"leave this off, browsers will probably interpret the output as HTML, which "
"will result in ugly, scary gobbledygook in the browser window."
msgstr ""
"响应指定了特殊的 MIME 类型 :mimetype:`text/csv`。这告诉浏览器该文档是一个 "
"CSV 文件，而不是一个 HTML 文件。如果你没这么干，浏览器可能会将输出视作 HTML，"
"这会在浏览器窗口展示丑陋的，恐怖的官样文章。"

msgid ""
"The response gets an additional ``Content-Disposition`` header, which "
"contains the name of the CSV file. This filename is arbitrary; call it "
"whatever you want. It'll be used by browsers in the \"Save as...\" dialog, "
"etc."
msgstr ""
"相应还包括一个额外的 ``Content-Disposition`` 头，其中包含了 CSV 文件的名称。"
"文件名是任意的；随便你怎么叫。它会被浏览器在 \"保存为……\" 对话框中用到。"

msgid ""
"You can hook into the CSV-generation API by passing ``response`` as the "
"first argument to ``csv.writer``. The ``csv.writer`` function expects a file-"
"like object, and :class:`~django.http.HttpResponse` objects fit the bill."
msgstr ""
"你需将 ``response`` 作为第一个参数传给 ``csv.writer`` 来接入生成 CSV API 。 "
"``csv.writer`` 函数期望一个类文件对象，而 :class:`~django.http.HttpResponse` "
"对象满足该要求。"

msgid ""
"For each row in your CSV file, call ``writer.writerow``, passing it an :term:"
"`iterable`."
msgstr ""
"要按行输出 CSV 文件，调用 ``writer.writerrow``，传入一个 :term:`iterable` 参"
"数。"

msgid ""
"The CSV module takes care of quoting for you, so you don't have to worry "
"about escaping strings with quotes or commas in them. Pass ``writerow()`` "
"your raw strings, and it'll do the right thing."
msgstr ""
"CSV 模块为你处理了引号，所以你无需担心包含引号或逗号的字符串的转义问题。你需"
"要为 ``writerow()`` 传入原始字符串，它为你处理好一切。"

msgid "Streaming large CSV files"
msgstr "输出超大 CSV 文件"

msgid ""
"When dealing with views that generate very large responses, you might want "
"to consider using Django's :class:`~django.http.StreamingHttpResponse` "
"instead. For example, by streaming a file that takes a long time to generate "
"you can avoid a load balancer dropping a connection that might have "
"otherwise timed out while the server was generating the response."
msgstr ""
"当处理生成很多回复的视图时，你可能要考虑使用 Django 的 :class:`~django.http."
"StreamingHttpResponse` 作为替代。例如，要进行耗时的输出文件流的操作，你可以避"
"免负载均衡器在服务器输出耗时相应时，可能由于超时抛弃改连接。"

msgid ""
"In this example, we make full use of Python generators to efficiently handle "
"the assembly and transmission of a large CSV file::"
msgstr ""
"在本例中，我们充分利用 Python 的生成器，高效地处理大型 CSV 文件的装配和输出任"
"务::"

msgid "Using the template system"
msgstr "使用模板系统"

msgid ""
"Alternatively, you can use the :doc:`Django template system </topics/"
"templates>` to generate CSV. This is lower-level than using the convenient "
"Python :mod:`csv` module, but the solution is presented here for "
"completeness."
msgstr ""
"或者，你也能用 :doc:`Djano 模板系统 </topics/templates>` 生成 CSV。这比使用方"
"便的 :mod:`csv` 模块级别低点，但是，解决方案就在这，你可以选。"

msgid ""
"The idea here is to pass a list of items to your template, and have the "
"template output the commas in a :ttag:`for` loop."
msgstr "办法就是将项目列表传给模板，让模板在 :ttag:`for` 循环中输出逗号。"

msgid "Here's an example, which generates the same CSV file as above::"
msgstr "以下例子输出与前文一样的 CSV 文件::"

msgid ""
"The only difference between this example and the previous example is that "
"this one uses template loading instead of the CSV module. The rest of the "
"code -- such as the ``content_type='text/csv'`` -- is the same."
msgstr ""
"本例与前例唯一的不同是本例使用模板加载，而不是 CSV 模块。剩下的代码都一样，例"
"如  ``content_type='text/csv'``。"

msgid ""
"Then, create the template ``my_template_name.txt``, with this template code:"
msgstr "然后，用模板代码创建模板 ``my_template_name.txt``。"

msgid ""
"This short template iterates over the given data and displays a line of CSV "
"for each row. It uses the :tfilter:`addslashes` template filter to ensure "
"there aren't any problems with quotes."
msgstr ""
"这个简短的模板遍历所给的数据，并为每行生成一个 CSV 行。它利用 :tfilter:"
"`addslashes` 模板过滤器确保引号不会引发任何问题。"

msgid "Other text-based formats"
msgstr "其它文本格式"

msgid ""
"Notice that there isn't very much specific to CSV here -- just the specific "
"output format. You can use either of these techniques to output any text-"
"based format you can dream of. You can also use a similar technique to "
"generate arbitrary binary data; see :doc:`/howto/outputting-pdf` for an "
"example."
msgstr ""
"注意，这里并没有太多特定于 CSV 的内容——仅是特定的输出格式。你可以使用其中任意"
"一种输出你能想到文本内容。你也能用类似的技术生成任意二进制数据；参考 :doc:`/"
"howto/outputting-pdf` 的例子。"

msgid "How to create PDF files"
msgstr "如何创建 PDF 文件"

msgid ""
"This document explains how to output PDF files dynamically using Django "
"views. This is made possible by the excellent, open-source ReportLab_ Python "
"PDF library."
msgstr ""
"本文介绍如何用 Django 的视图动态输出 PDF 文件。该功能由绝佳的开源 ReportLab_ "
"Python  PDF 库提供。"

msgid ""
"The advantage of generating PDF files dynamically is that you can create "
"customized PDFs for different purposes -- say, for different users or "
"different pieces of content."
msgstr ""
"动态生成 PDF 文件的优点是你可以为不同的目的创建不同的自定义 PDF——例如，为不同"
"的用户或内容的不同片段生成 PDF。"

msgid ""
"For example, Django was used at kusports.com_ to generate customized, "
"printer-friendly NCAA tournament brackets, as PDF files, for people "
"participating in a March Madness contest."
msgstr ""
"例如，kusports.com_ 用 Django 将自定义的，打印友好的 NCAA 锦标赛树状图生成 "
"PDF 文件，发放给参加三月疯狂竞赛的人。"

msgid "Install ReportLab"
msgstr "安装 ReportLab"

msgid ""
"The ReportLab library is :pypi:`available on PyPI <reportlab>`. A `user "
"guide`_ (not coincidentally, a PDF file) is also available for download. You "
"can install ReportLab with ``pip``:"
msgstr ""
"ReportLab 库可以在 :pypi:`PyPI 上获取 <reportlab>`。还可以下载 `用户指南`_ "
"（巧合的是，它是一个 PDF 文件）。你可以使用 ``pip`` 安装 ReportLab："

msgid ""
"Test your installation by importing it in the Python interactive interpreter:"
msgstr "通过在 Python 交互式解释器中导入它来测试您的安装："

msgid "If that command doesn't raise any errors, the installation worked."
msgstr "若该命令未抛出任何错误，安装成功。"

msgid "Write your view"
msgstr "编写视图"

msgid ""
"The key to generating PDFs dynamically with Django is that the ReportLab API "
"acts on file-like objects, and Django's :class:`~django.http.FileResponse` "
"objects accept file-like objects."
msgstr ""
"利用 Django 动态生成 PDF 的关键是 ReportLab API 作用于类文件对象，而 Django "
"的 :class:`~django.http.FileResponse` 对象接收类文件对象。"

msgid "Here's a \"Hello World\" example::"
msgstr "这有个 \"Hello World\" 示例::"

msgid ""
"The response will automatically set the MIME type :mimetype:`application/"
"pdf` based on the filename extension. This tells browsers that the document "
"is a PDF file, rather than an HTML file or a generic :mimetype:`application/"
"octet-stream` binary content."
msgstr ""
"响应会自动基于文件扩展名将 MIME 类型设置为应用程序 :mimetype:`application/"
"pdf`。这告诉浏览器该文档是个 PDF 文件，而不是 HTML 文件或普通的应用程序 :"
"mimetype:`application/octet-stream` 二进制内容。"

msgid ""
"When ``as_attachment=True`` is passed to ``FileResponse``, it sets the "
"appropriate ``Content-Disposition`` header and that tells web browsers to "
"pop-up a dialog box prompting/confirming how to handle the document even if "
"a default is set on the machine. If the ``as_attachment`` parameter is "
"omitted, browsers will handle the PDF using whatever program/plugin they've "
"been configured to use for PDFs."
msgstr ""
"当将 ``as_attachment=True`` 传递给 ``FileResponse`` 时，它会设置适当的 "
"``Content-Disposition`` 标头，这会告诉 Web 浏览器弹出一个对话框，提示/确认如"
"何处理文档，即使在计算机上设置了默认程序也是如此。如果省略了 "
"``as_attachment`` 参数，浏览器将使用它们配置为处理 PDF 的任何程序/插件来处理 "
"PDF。"

msgid ""
"You can provide an arbitrary ``filename`` parameter. It'll be used by "
"browsers in the \"Save as...\" dialog."
msgstr "你也可以提供可选参数 ``filename``。浏览器的“另存为…”对话框会用到它。"

msgid ""
"You can hook into the ReportLab API: The same buffer passed as the first "
"argument to ``canvas.Canvas`` can be fed to the :class:`~django.http."
"FileResponse` class."
msgstr ""
"你可以作为第一个参数传递给 ``canvas.Canvas`` 的缓冲区也能传递给类 :class:"
"`~django.http.FileResponse` 类来使用 ReportLab API。"

msgid ""
"Note that all subsequent PDF-generation methods are called on the PDF object "
"(in this case, ``p``) -- not on ``buffer``."
msgstr ""
"注意，所有后续生成 PDF 的方法都是在 PDF 对象上调用的（本例中是 ``p``）——而不"
"是在 ``buffer`` 上调用。"

msgid ""
"Finally, it's important to call ``showPage()`` and ``save()`` on the PDF "
"file."
msgstr "最后，牢记在 PDF 文件上调用 ``showPage()`` 和 ``save()``。"

msgid ""
"ReportLab is not thread-safe. Some of our users have reported odd issues "
"with building PDF-generating Django views that are accessed by many people "
"at the same time."
msgstr ""
"ReportLab 不是线程安全的。某些用户已经报告了一些奇怪的 issue，在创建用于生成 "
"PDF 的 Django 视图时，这些视图被多个用户同时访问会出现问题。"

msgid "Other formats"
msgstr "其它格式"

msgid ""
"Notice that there isn't a lot in these examples that's PDF-specific -- just "
"the bits using ``reportlab``. You can use a similar technique to generate "
"any arbitrary format that you can find a Python library for. Also see :doc:`/"
"howto/outputting-csv` for another example and some techniques you can use "
"when generated text-based formats."
msgstr ""
"注意，这些例子中没有任何 PDF 特有的数据——只有使用 ``reportlab`` 的部分。你可"
"以用类似的技巧生成任意格式，只要你能找到对应的 Python 库。也请看看 :doc:`/"
"howto/outputting-csv`，看看另一个例子中，如何用一些技巧输出文本内容。"

msgid ""
"Django Packages provides a `comparison of packages <https://djangopackages."
"org/grids/g/pdf/>`_ that help generate PDF files from Django."
msgstr ""
"Django 包提供了一个 `包的比较 <https://djangopackages.org/grids/g/pdf/>`_ 有"
"助于用 Django 生成 PDF 文件。"

msgid "How to override templates"
msgstr "如何覆盖模板"

msgid ""
"In your project, you might want to override a template in another Django "
"application, whether it be a third-party application or a contrib "
"application such as ``django.contrib.admin``. You can either put template "
"overrides in your project's templates directory or in an application's "
"templates directory."
msgstr ""
"在项目中，你可以想要在另一个 Django 应用中重写模板，不论它是第三方应用或 "
"contrib 应用，例如 ``django.contrib.admin``。你可以将重写的模板置于工程的模板"
"目录或应用的模板目录。"

msgid ""
"If you have app and project templates directories that both contain "
"overrides, the default Django template loader will try to load the template "
"from the project-level directory first. In other words, :setting:`DIRS "
"<TEMPLATES-DIRS>` is searched before :setting:`APP_DIRS <TEMPLATES-"
"APP_DIRS>`."
msgstr ""
"若应用和工程的模板模板都包含被重写的模板，默认的 Django 模板加载器会先尝试加"
"载工程目录下的模板。换句话说，先查找 :setting:`DIRS <TEMPLATES-DIRS>`，其次 :"
"setting:`APP_DIRS <TEMPLATES-APP_DIRS>`。"

msgid ""
"Read :ref:`overriding-built-in-widget-templates` if you're looking to do "
"that."
msgstr "阅读 :ref:`重写内置视图模板` 若你正在找相关资料。"

msgid "Overriding from the project's templates directory"
msgstr "重写来自工程目录的模板"

msgid ""
"First, we'll explore overriding templates by creating replacement templates "
"in your project's templates directory."
msgstr "首先，我们探索用在工程模板目录创建替代模板的方法。"

msgid ""
"Let's say you're trying to override the templates for a third-party "
"application called ``blog``, which provides the templates ``blog/post.html`` "
"and ``blog/list.html``. The relevant settings for your project would look "
"like::"
msgstr ""
"假设你正在重写第三方应用 ``blog`` 的模板，该应用提供了 ``blog/post.html`` 和 "
"``blog/list.html`` 模板。工程关键配置如下::"

msgid ""
"The :setting:`TEMPLATES` setting and ``BASE_DIR`` will already exist if you "
"created your project using the default project template. The setting that "
"needs to be modified is :setting:`DIRS<TEMPLATES-DIRS>`."
msgstr ""
"若用模板工程模板创建工程，则 :setting:`TEMPLATES` 和 ``BASE_DIR`` 早已存在。"
"需要修改的配置是 :setting:`DIRS <TEMPLATES-DIRS>`。"

msgid ""
"These settings assume you have a ``templates`` directory in the root of your "
"project. To override the templates for the ``blog`` app, create a folder in "
"the ``templates`` directory, and add the template files to that folder:"
msgstr ""
"这些配置假定在工程根目录下有个 ``templates`` 目录。要重写 ``blog`` 应用的模"
"板，在 ``templates`` 目录中创建一个文件夹，然后将以下模板文件添加至该目录："

msgid ""
"The template loader first looks for templates in the ``DIRS`` directory. "
"When the views in the ``blog`` app ask for the ``blog/post.html`` and ``blog/"
"list.html`` templates, the loader will return the files you just created."
msgstr ""
"模板加载器会先查找 ``DIRS`` 目录下的模板。当 ``blog`` 应用中的视图要求 "
"``blog/post.html`` 和 ``blog/list.html`` 模板，加载器会返回你刚创建的文件。"

msgid "Overriding from an app's template directory"
msgstr "重写来自应用模板目录的模板"

msgid ""
"Since you're overriding templates located outside of one of your project's "
"apps, it's more common to use the first method and put template overrides in "
"a project's templates folder. If you prefer, however, it's also possible to "
"put the overrides in an app's template directory."
msgstr ""
"由于重写的模板位于工程应用之外，更常见的做法是使用第一个方法，然后将重写的模"
"板置于工程模板目录。然而，如果你偏爱将重写的模板放入应用模板目录，也是可以"
"的。"

msgid ""
"First, make sure your template settings are checking inside app directories::"
msgstr "首先，确保模板配置会搜索应用模板目录::"

msgid ""
"If you want to put the template overrides in an app called ``myapp`` and the "
"templates to override are named ``blog/list.html`` and ``blog/post.html``, "
"then your directory structure will look like:"
msgstr ""
"若你想重写名为 ``blog/list.html`` 和 ``blog/post.html`` 的模板，并将它们置于"
"名为 ``myapp`` 的应用中，那么目录结构应该看起来像这样："

msgid ""
"With :setting:`APP_DIRS<TEMPLATES-APP_DIRS>` set to ``True``, the template "
"loader will look in the app's templates directory and find the templates."
msgstr ""
"当 :setting:`APP_DIRS <TEMPLATES-APP_DIRS>` 置为 ``True`` 时，模板加载器会深"
"入应用的模板目录查找模板。"

msgid "Extending an overridden template"
msgstr "扩展复写模板"

msgid ""
"With your template loaders configured, you can extend a template using the :"
"ttag:`{% extends %}<extends>` template tag whilst at the same time "
"overriding it. This can allow you to make small customizations without "
"needing to reimplement the entire template."
msgstr ""
"当你配置好你的模板加载器后，你可以使用 :ttag:`{% extends %}` 模板标签的同时来"
"覆盖它。这样可以让你不用重写整个模板就可以做一些微小的改动。"

msgid ""
"For example, you can use this technique to add a custom logo to the ``admin/"
"base_site.html`` template:"
msgstr ""
"举个例子，你可以使用这项技术在 ``admin/base_site.html`` 管理员模板中添加自定"
"义的Logo："

msgid "``templates/admin/base_site.html``"
msgstr "``templates/admin/base_site.html``"

msgid "Key points to note:"
msgstr "关键注意点："

msgid ""
"The example creates a file at ``templates/admin/base_site.html`` that uses "
"the configured project-level ``templates`` directory to override ``admin/"
"base_site.html``."
msgstr ""
"这个例子创建了使用配置好的项目级 ``templates`` 目录创建了管理员文件 "
"``templates/admin/base_site.html`` 来覆盖管理员文件 ``admin/base_site."
"html`` 。"

msgid ""
"The new template extends ``admin/base_site.html``, which is the same "
"template as is being overridden."
msgstr "新的管理员模板拓展了  ``admin/base_site.html`` 并覆盖了它。"

msgid ""
"The template replaces just the ``branding`` block, adding a custom logo, and "
"using ``block.super`` to retain the prior content."
msgstr ""
"新模板只是替换了 ``branding`` 区域，添加了一个自定义的Logo，和使用了 ``block."
"super`` 以继承原有的内容。"

msgid ""
"The rest of the template is inherited unchanged from ``admin/base_site."
"html``."
msgstr "被继承的管理员模板 ``admin/base_site.html`` 的其他内容没有变化。"

msgid ""
"This technique works because the template loader does not consider the "
"already loaded override template (at ``templates/admin/base_site.html``) "
"when resolving the ``extends`` tag. Combined with ``block.super`` it is a "
"powerful technique to make small customizations."
msgstr ""
"这个技术起作用是因为当解析到 ``extends`` 标签时模板加载器不认为这是已经加载过"
"的有覆盖的模板（管理员模板位于 ``templates/admin/base_site.html``）。与 "
"``block.super`` 的结合是对原有内容做很小的改动的有力技术。"

msgid "How to deploy static files"
msgstr "如何部署静态文件"

msgid ""
"For an introduction to the use of :mod:`django.contrib.staticfiles`, see :"
"doc:`/howto/static-files/index`."
msgstr ""
"想要 :mod:`django.contrib.staticfiles` 的使用指南，请参考 :doc:`/howto/"
"static-files/index`。"

msgid "Serving static files in production"
msgstr "在生产环境提供静态文件服务"

msgid ""
"The basic outline of putting static files into production consists of two "
"steps: run the :djadmin:`collectstatic` command when static files change, "
"then arrange for the collected static files directory (:setting:"
"`STATIC_ROOT`) to be moved to the static file server and served. Depending "
"the ``staticfiles`` :setting:`STORAGES` alias, files may need to be moved to "
"a new location manually or the :func:`post_process <django.contrib."
"staticfiles.storage.StaticFilesStorage.post_process>` method of the "
"``Storage`` class might take care of that."
msgstr ""
"将静态文件投入生产中的基本步骤包括两个步骤：当静态文件更改时运行 :djadmin:"
"`collectstatic` 命令，然后安排将已收集的静态文件目录（:setting:"
"`STATIC_ROOT`）移动到静态文件服务器并提供服务。根据 ``staticfiles`` :setting:"
"`STORAGES` 别名，文件可能需要手动移动到新位置，或者 ``Storage`` 类的 :func:"
"`post_process <django.contrib.staticfiles.storage.StaticFilesStorage."
"post_process>` 方法可能会处理这个问题。"

msgid ""
"As with all deployment tasks, the devil's in the details. Every production "
"setup will be a bit different, so you'll need to adapt the basic outline to "
"fit your needs. Below are a few common patterns that might help."
msgstr ""
"像所有的部署任务一样，细节决定成败。每个生成环境的配置可能都有点不同个，所"
"以，需要调整基础配置以满足你的需求。以下是常见模式，可能对你有所帮助。"

msgid "Serving the site and your static files from the same server"
msgstr "在同一服务器提供站点和静态文件服务"

msgid ""
"If you want to serve your static files from the same server that's already "
"serving your site, the process may look something like:"
msgstr ""
"如果你想在早已提供站点服务器服务器上同时提供静态文件服务，操作步骤类似这样："

msgid "Push your code up to the deployment server."
msgstr "将代码推送至部署服务器。"

msgid ""
"On the server, run :djadmin:`collectstatic` to copy all the static files "
"into :setting:`STATIC_ROOT`."
msgstr ""
"在服务器上运行 :djadmin:`collectstatic`，将所有的静态文件拷贝至 :setting:"
"`STATIC_ROOT`。"

msgid ""
"Configure your web server to serve the files in :setting:`STATIC_ROOT` under "
"the URL :setting:`STATIC_URL`. For example, here's :ref:`how to do this with "
"Apache and mod_wsgi <serving-files>`."
msgstr ""
"配置 Web 服务器，使其在 :setting:`STATIC_URL` 下为 :setting:`STATIC_ROOT` 目"
"录下的文件提供静态文件服务。例如， :ref:`这里是如何以 Apache 配合 mod_wsgi 开"
"始 <serving-files>`。"

msgid ""
"You'll probably want to automate this process, especially if you've got "
"multiple web servers."
msgstr "你可能期望将该流程自动化，特别是在你有好几个 web 服务器的时候。"

msgid "Serving static files from a dedicated server"
msgstr "专用服务器提供静态文件服务"

msgid ""
"Most larger Django sites use a separate web server -- i.e., one that's not "
"also running Django -- for serving static files. This server often runs a "
"different type of web server -- faster but less full-featured. Some common "
"choices are:"
msgstr ""
"大多数大型 Django 网站使用一个单独的 Web 服务器——即一个不同时运行 Django 的服"
"务器——来提供静态文件。这台服务器通常运行不同类型的网络服务器——速度更快，但功"
"能不全。一些常见的选择是："

msgid ""
"Configuring these servers is out of scope of this document; check each "
"server's respective documentation for instructions."
msgstr "如何配置这些服务器超出了本文范围；查阅这些服务器各自的文档获取介绍。"

msgid ""
"Since your static file server won't be running Django, you'll need to modify "
"the deployment strategy to look something like:"
msgstr "由于静态文件服务器并不运行 Django，你需要将部署策略改成这样："

msgid "When your static files change, run :djadmin:`collectstatic` locally."
msgstr "当静态文件改变时，本地运行 :djadmin:`collectstatic`。"

msgid ""
"Push your local :setting:`STATIC_ROOT` up to the static file server into the "
"directory that's being served. `rsync <https://rsync.samba.org/>`_ is a "
"common choice for this step since it only needs to transfer the bits of "
"static files that have changed."
msgstr ""
"将本地 :setting:`STATIC_ROOT` 推送到静态文件服务器提供服务的目录。 `rsync "
"<https://rsync.samba.org/>`_ 是一个常见选项，因为这种配置只会传输文件修改部分"
"的数据流。"

msgid "Serving static files from a cloud service or CDN"
msgstr "从云服务或 CDN 提供静态文件服务"

msgid ""
"Another common tactic is to serve static files from a cloud storage provider "
"like Amazon's S3 and/or a CDN (content delivery network). This lets you "
"ignore the problems of serving static files and can often make for faster-"
"loading web pages (especially when using a CDN)."
msgstr ""
"另一个常见的策略是从云存储供应商，如亚马逊的 S3 和/或 CDN（内容交付网络）中提"
"供静态文件。这可以让你忽略提供静态文件的问题，而且通常可以使网页的加载速度更"
"快（特别是在使用 CDN 时）。"

msgid ""
"When using these services, the basic workflow would look a bit like the "
"above, except that instead of using ``rsync`` to transfer your static files "
"to the server you'd need to transfer the static files to the storage "
"provider or CDN."
msgstr ""
"使用这些服务时，基本的工作流程与上面类似，除了要将静态文件传输给存储服务商或 "
"CDN，而不是用 ``rsync`` 将静态文件传输给服务器。"

msgid ""
"There's any number of ways you might do this, but if the provider has an "
"API, you can use a :doc:`custom file storage backend </howto/custom-file-"
"storage>` to integrate the CDN with your Django project. If you've written "
"or are using a 3rd party custom storage backend, you can tell :djadmin:"
"`collectstatic` to use it by setting ``staticfiles`` in :setting:`STORAGES`."
msgstr ""
"有许多方法可以做到这一点，但如果提供商有一个 API，你可以使用一个 :doc:`自定义"
"文件存储后端 </howto/custom-file-storage>` 来将 CDN 集成到你的 Django 项目"
"中。如果你编写了或正在使用第三方的自定义存储后端，可以通过在 :setting:"
"`STORAGES` 中设置 ``staticfiles`` 来告诉 :djadmin:`collectstatic` 使用它。"

msgid ""
"For example, if you've written an S3 storage backend in ``myproject.storage."
"S3Storage`` you could use it with::"
msgstr ""
"例如，若你已在 ``myproject.storage.S3Storage`` 中写了一个 S3 存储后端，可以这"
"么用::"

msgid ""
"Once that's done, all you have to do is run :djadmin:`collectstatic` and "
"your static files would be pushed through your storage package up to S3. If "
"you later needed to switch to a different storage provider, you may only "
"have to change ``staticfiles`` in the :setting:`STORAGES` setting."
msgstr ""
"一旦完成了这些步骤，你只需运行 :djadmin:`collectstatic`，你的静态文件将通过存"
"储包上传到 S3。如果以后需要切换到不同的存储提供商，你可能只需更改 :setting:"
"`STORAGES` 设置中的 ``staticfiles``。"

msgid ""
"For details on how you'd write one of these backends, see :doc:`/howto/"
"custom-file-storage`. There are 3rd party apps available that provide "
"storage backends for many common file storage APIs. A good starting point is "
"the `overview at djangopackages.org <https://djangopackages.org/grids/g/"
"storage-backends/>`_."
msgstr ""
"关于如何编写这些后端的细节，参考 :doc:`/howto/custom-file-storage`。有很多可"
"用的第三方应用提供了针对常见文件存储 API 的存储后端。 `djangopackages.org 入"
"门 <https://djangopackages.org/grids/g/storage-backends/>`_ 是个不错的起点。"

msgid "The :setting:`STORAGES` setting was added."
msgstr ":setting:`STORAGES` 配置已添加。"

msgid "Learn more"
msgstr "了解更多"

msgid ""
"For complete details on all the settings, commands, template tags, and other "
"pieces included in :mod:`django.contrib.staticfiles`, see :doc:`the "
"staticfiles reference </ref/contrib/staticfiles>`."
msgstr ""
"想要了解所有配置项，命令，模板标签和 :mod:`django.contrib.staticfiles` 包含的"
"其它零碎的完整细节，参考 :doc:`staticfiles 参考 </ref/contrib/staticfiles>`。"

msgid "How to manage static files (e.g. images, JavaScript, CSS)"
msgstr "如何管理静态文件（如图片、JavaScript、CSS）"

msgid ""
"Websites generally need to serve additional files such as images, "
"JavaScript, or CSS. In Django, we refer to these files as \"static files\".  "
"Django provides :mod:`django.contrib.staticfiles` to help you manage them."
msgstr ""
"网站通常需要提供类似图片，JavaScript 或 CSS 的额外文件服务。在 Django 中，我"
"们将这些文件称为“静态文件”。Django 提供了 :mod:`django.contrib.staticfiles` "
"帮你管理它们。"

msgid "This page describes how you can serve these static files."
msgstr "本页介绍如何为这些静态文件提供服务。"

msgid "Configuring static files"
msgstr "配置静态文件"

msgid ""
"Make sure that ``django.contrib.staticfiles`` is included in your :setting:"
"`INSTALLED_APPS`."
msgstr "确保 :setting:`INSTALLED_APPS` 包含了 ``django.contrib.staticfiles``。"

msgid "In your settings file, define :setting:`STATIC_URL`, for example::"
msgstr "在配置文件中，定义 :setting:`STATIC_URL`，例子::"

msgid ""
"In your templates, use the :ttag:`static` template tag to build the URL for "
"the given relative path using the configured ``staticfiles`` :setting:"
"`STORAGES` alias."
msgstr ""
"在模板中，可以使用 :ttag:`static` 模板标签来使用配置的 ``staticfiles`` :"
"setting:`STORAGES` 别名构建给定相对路径的 URL。"

msgid ""
"Store your static files in a folder called ``static`` in your app. For "
"example ``my_app/static/my_app/example.jpg``."
msgstr ""
"将你的静态文件保存至程序中名为 ``static`` 的目录中。例如 ``my_app/static/"
"my_app/example.jpg``。"

msgid "Serving the files"
msgstr "为这些文件提供服务"

msgid ""
"In addition to these configuration steps, you'll also need to actually serve "
"the static files."
msgstr "除了这些配置步骤外，你还需要实际地为这些文件提供服务。"

msgid ""
"During development, if you use :mod:`django.contrib.staticfiles`, this will "
"be done automatically by :djadmin:`runserver` when :setting:`DEBUG` is set "
"to ``True`` (see :func:`django.contrib.staticfiles.views.serve`)."
msgstr ""
"开发时，使用 :mod:`django.contrib.staticfiles`，这一般会在 :setting:`DEBUG` "
"is set to ``True`` 情况下由 :djadmin:`runserver` 自动完成（参考 :func:"
"`django.contrib.staticfiles.views.serve`）。"

msgid ""
"This method is **grossly inefficient** and probably **insecure**, so it is "
"**unsuitable for production**."
msgstr "该方法 **极度低效** 且 **不怎么安全**，所以这 **不适合生产环境**。"

msgid ""
"See :doc:`/howto/static-files/deployment` for proper strategies to serve "
"static files in production environments."
msgstr ""
"参考 :doc:`/howto/static-files/deployment` 了解如何正确地在生产环境提供静态文"
"件服务的策略。"

msgid ""
"Your project will probably also have static assets that aren't tied to a "
"particular app. In addition to using a ``static/`` directory inside your "
"apps, you can define a list of directories (:setting:`STATICFILES_DIRS`) in "
"your settings file where Django will also look for static files. For "
"example::"
msgstr ""
"你的工程可能包含未与任何应用绑定的静态资源。除了在 apps 中使用 ``static/`` 目"
"录，你可以在配置文件中定义一个目录列表 (:setting:`STATICFILES_DIRS`) ，"
"Django 会从中寻找静态文件。例子::"

msgid ""
"See the documentation for the :setting:`STATICFILES_FINDERS` setting for "
"details on how ``staticfiles`` finds your files."
msgstr ""
"参考 :setting:`STATICFILES_FINDERS` 配置的文档了解 ``staticfiles`` 是如何找到"
"你的文件的细节。"

msgid "Static file namespacing"
msgstr "静态文件命名空间"

msgid ""
"Now we *might* be able to get away with putting our static files directly in "
"``my_app/static/`` (rather than creating another ``my_app`` subdirectory), "
"but it would actually be a bad idea. Django will use the first static file "
"it finds whose name matches, and if you had a static file with the same name "
"in a *different* application, Django would be unable to distinguish between "
"them. We need to be able to point Django at the right one, and the best way "
"to ensure this is by *namespacing* them. That is, by putting those static "
"files inside *another* directory named for the application itself."
msgstr ""
"现在，我们 *也许* 能直接将静态文件放入 ``my_app/static/`` 目录（而不是创建另"
"一个 ``my_app`` 子目录），不过这实际上是个坏主意。Django 会使用第一个名字匹配"
"的静态文件，若你在 *不同的* 应用程序中有一个同名静态文件，Django 无力区分它"
"们。我们需要为 Django 指出正确的那个，而最好的方式就是使用 *命名空间*。也就是"
"说，将这些静态文件放在 *另一个* 以应用程序名本身命名的目录下。"

msgid ""
"You can namespace static assets in :setting:`STATICFILES_DIRS` by "
"specifying :ref:`prefixes <staticfiles-dirs-prefixes>`."
msgstr ""
"你可以通过指定 :ref:`prefixes <staticfiles-dirs-prefixes>` 在 :setting:"
"`STATICFILES_DIRS` 中为静态资源做命名。"

msgid "Serving static files during development"
msgstr "开发时提供静态文件服务"

msgid ""
"If you use :mod:`django.contrib.staticfiles` as explained above, :djadmin:"
"`runserver` will do this automatically when :setting:`DEBUG` is set to "
"``True``. If you don't have ``django.contrib.staticfiles`` in :setting:"
"`INSTALLED_APPS`, you can still manually serve static files using the :func:"
"`django.views.static.serve` view."
msgstr ""
"若你使用了前文所述的 :mod:`django.contrib.staticfiles`， :djadmin:"
"`runserver` 会在 :setting:`DEBUG` 为 ``True`` 时自动处理。若你未在 :setting:"
"`INSTALLED_APPS` 中包含 ``django.contrib.staticfiles``，你仍能手动通过 :func:"
"`django.views.static.serve` 为静态文件提供服务。"

msgid ""
"This is not suitable for production use! For some common deployment "
"strategies, see :doc:`/howto/static-files/deployment`."
msgstr ""
"这不适合生产环境！常见的部署策略请参考 :doc:`/howto/static-files/"
"deployment`。"

msgid ""
"For example, if your :setting:`STATIC_URL` is defined as ``static/``, you "
"can do this by adding the following snippet to your ``urls.py``::"
msgstr ""
"例如，如果你的 :setting:`STATIC_URL` 定义为 ``static/``，你可以通过将以下片段"
"添加到你的 ``urls.py`` 中来实现："

msgid ""
"This helper function works only in debug mode and only if the given prefix "
"is local (e.g. ``static/``) and not a URL (e.g. ``http://static.example.com/"
"``)."
msgstr ""
"这个帮助函数只在调试模式下工作，而且只在给定的前缀是本地的（例如 ``static/"
"``），而不是一个 URL（例如 ``http://static.example.com/`` ）时才有效。"

msgid ""
"Also this helper function only serves the actual :setting:`STATIC_ROOT` "
"folder; it doesn't perform static files discovery like :mod:`django.contrib."
"staticfiles`."
msgstr ""
"当然，助手函数只为实际的 :setting:`STATIC_ROOT` 目录提供服务；它不会像 :mod:"
"`django.contrib.staticfiles` 一样搜索静态文件。"

msgid ""
"Finally, static files are served via a wrapper at the WSGI application "
"layer. As a consequence, static files requests do not pass through the "
"normal :doc:`middleware chain </topics/http/middleware>`."
msgstr ""
"最后，静态文件通过 WSGI 应用程序层的包装器提供服务。因此，静态文件请求不会经"
"过正常的 :doc:`中间件链 </topics/http/middleware>`。"

msgid "Serving files uploaded by a user during development"
msgstr "开发期间保存用户上传的文件"

msgid ""
"During development, you can serve user-uploaded media files from :setting:"
"`MEDIA_ROOT` using the :func:`django.views.static.serve` view."
msgstr ""
"开发期间，你能用 :func:`django.views.static.serve` 视图为用户上传的媒体文件提"
"供服务。"

msgid ""
"For example, if your :setting:`MEDIA_URL` is defined as ``media/``, you can "
"do this by adding the following snippet to your :setting:`ROOT_URLCONF`::"
msgstr ""
"例如，如果你的 :setting:`MEDIA_URL` 定义为 ``media/``，你可以通过将以下片段添"
"加到你的 :setting:`ROOT_URLCONF` 中来实现："

msgid ""
"This helper function works only in debug mode and only if the given prefix "
"is local (e.g. ``media/``) and not a URL (e.g. ``http://media.example.com/"
"``)."
msgstr ""
"这个帮助函数只在调试模式下工作，而且只在给定的前缀是本地的（例如 ``media/"
"``），而不是一个URL（例如 ``http://media.example.com/`` ）时才有效。"

msgid ""
"When running tests that use actual HTTP requests instead of the built-in "
"testing client (i.e. when using the built-in :class:`LiveServerTestCase "
"<django.test.LiveServerTestCase>`) the static assets need to be served along "
"the rest of the content so the test environment reproduces the real one as "
"faithfully as possible, but ``LiveServerTestCase`` has only very basic "
"static file-serving functionality: It doesn't know about the finders feature "
"of the ``staticfiles`` application and assumes the static content has "
"already been collected under :setting:`STATIC_ROOT`."
msgstr ""
"运行使用真实 HTTP 请求（而不是内置的测试客户端，即内置的 :class:"
"`LiveServerTestCase <django.test.LiveServerTestCase>`）的测试用例时，静态资源"
"要与剩余内容分别提供服务，这样，测试环境才能尽量重现真实的问题。但 "
"``LiveServerTestCase`` 只拥有非常基本的为静态文件提供服务的能力：它并不知道 "
"``staticfiles`` 应用的查找功能，且总是假设静态内容已被收集至 :setting:"
"`STATIC_ROOT` 目录下。"

msgid ""
"Because of this, ``staticfiles`` ships its own :class:`django.contrib."
"staticfiles.testing.StaticLiveServerTestCase`, a subclass of the built-in "
"one that has the ability to transparently serve all the assets during "
"execution of these tests in a way very similar to what we get at development "
"time with ``DEBUG = True``, i.e. without having to collect them using :"
"djadmin:`collectstatic` first."
msgstr ""
"因此， ``staticfiles`` 自带了 :class:`django.contrib.staticfiles.testing."
"StaticLiveServerTestCase`，这是一个内置子类，能够透明地以类似我们在开发阶段 "
"``DEBUG = True`` 时获得的方式为所有静态资源在测试期间提供服务。即无需先用 :"
"djadmin:`collectstatic` 收集它们。"

msgid "Deployment"
msgstr "部署"

msgid ""
":mod:`django.contrib.staticfiles` provides a convenience management command "
"for gathering static files in a single directory so you can serve them "
"easily."
msgstr ""
":mod:`django.contrib.staticfiles` 提供了一个便利的管理命令，用于将静态文件收"
"集至独立目录，方便你为它们提供服务。"

msgid ""
"Set the :setting:`STATIC_ROOT` setting to the directory from which you'd "
"like to serve these files, for example::"
msgstr ""
"将 :setting:`STATIC_ROOT` 配置成你喜欢的目录，在这个目录提供服务，例如::"

msgid "Run the :djadmin:`collectstatic` management command:"
msgstr "运行 :djadmin:`collectstatic` 管理命令："

msgid ""
"This will copy all files from your static folders into the :setting:"
"`STATIC_ROOT` directory."
msgstr "这将会把静态目录下的所有文件拷贝至 :setting:`STATIC_ROOT` 目录。"

msgid ""
"Use a web server of your choice to serve the files. :doc:`/howto/static-"
"files/deployment` covers some common deployment strategies for static files."
msgstr ""
"选一个 Web 服务器为这些文件提供服务。 文档 :doc:`/howto/static-files/"
"deployment` 介绍了静态文件的常见部署策略。"

msgid ""
"This document has covered the basics and some common usage patterns. For "
"complete details on all the settings, commands, template tags, and other "
"pieces included in :mod:`django.contrib.staticfiles`, see :doc:`the "
"staticfiles reference </ref/contrib/staticfiles>`."
msgstr ""
"本文档已覆盖基础和常见模式。对于所有配置项，命令，模板标签和其他包含在 :mod:"
"`django.contrib.staticfiles` 碎片的全部细节，参考 :doc:`静态文件参考 </ref/"
"contrib/staticfiles>`。"

msgid "How to upgrade Django to a newer version"
msgstr "如何将 Django 更新至新的版本"

msgid ""
"While it can be a complex process at times, upgrading to the latest Django "
"version has several benefits:"
msgstr "虽然有时是个复杂的过程，将 Django 升级到最新版有以下好处："

msgid "New features and improvements are added."
msgstr "新功能和优化"

msgid "Bugs are fixed."
msgstr "已修复的 bug。"

msgid ""
"Older version of Django will eventually no longer receive security updates. "
"(see :ref:`supported-versions-policy`)."
msgstr ""
"旧版 Django 最终将不再收到安全更新。（参考 :ref:`supported-versions-policy`）"

msgid ""
"Upgrading as each new Django release is available makes future upgrades less "
"painful by keeping your code base up to date."
msgstr ""
"随着每个新 Django 发行版的发布而升级，可以使您的代码库保持最新，从而减少将来"
"升级带来的痛苦。"

msgid ""
"Here are some things to consider to help make your upgrade process as smooth "
"as possible."
msgstr "有些事情需要你考虑，这有助于使升级流程尽可能顺滑。"

msgid "Required Reading"
msgstr "必读内容"

msgid ""
"If it's your first time doing an upgrade, it is useful to read the :doc:"
"`guide on the different release processes </internals/release-process>`."
msgstr ""
"若这是你第一次进行升级操作，那么阅读 :doc:`不同发行进程的指南 </internals/"
"release-process>` 就非常有用。"

msgid ""
"Afterward, you should familiarize yourself with the changes that were made "
"in the new Django version(s):"
msgstr "随后，您应该熟悉新的 Django 版本中所进行的更改："

msgid ""
"Read the :doc:`release notes </releases/index>` for each 'final' release "
"from the one after your current Django version, up to and including the "
"version to which you plan to upgrade."
msgstr ""
"阅读当前版本之后的每个“最终”版本的 :doc:`发行说明 </releases/index>` ，包括计"
"划升级的版本。"

msgid ""
"Look at the :doc:`deprecation timeline</internals/deprecation>` for the "
"relevant versions."
msgstr "阅读 :doc:`过期时间表 </internals/deprecation>` 获取相关版本信息。"

msgid ""
"Pay particular attention to backwards incompatible changes to get a clear "
"idea of what will be needed for a successful upgrade."
msgstr "特别注意向前兼容修改，清楚了解成功的升级需要做什么。"

msgid ""
"If you're upgrading through more than one feature version (e.g. 2.0 to 2.2), "
"it's usually easier to upgrade through each feature release incrementally "
"(2.0 to 2.1 to 2.2) rather than to make all the changes for each feature "
"release at once. For each feature release, use the latest patch release (e."
"g. for 2.1, use 2.1.15)."
msgstr ""
"若你更新的版本跨度超过一个特性版本（例如从 2.0 更新到 2.2），通常增量更新"
"（从 2.0 到 2.1 再到 2.2）每个版本会比一次性更新更容易。对于每个发布特性，使"
"用最新的补丁版本（例如，对于 2.1，使用 2.1.15）。"

msgid ""
"The same incremental upgrade approach is recommended when upgrading from one "
"LTS to the next."
msgstr ""
"从一个长期支持（LTS）版本更新至下一个长期更新版本时，特别推荐同样的增量更新方"
"法。"

msgid "Dependencies"
msgstr "依赖"

msgid ""
"In most cases it will be necessary to upgrade to the latest version of your "
"Django-related dependencies as well. If the Django version was recently "
"released or if some of your dependencies are not well-maintained, some of "
"your dependencies may not yet support the new Django version. In these cases "
"you may have to wait until new versions of your dependencies are released."
msgstr ""
"大多数情况下，将 Django 的依赖升至最新版本是必要的。若 Django 版本是最近发布"
"的，但某些依赖没有很好适配，这些依赖可能无法支持最新版的 Django。这种情况下，"
"你只能等新版本的依赖发布。"

msgid "Resolving deprecation warnings"
msgstr "处理过期警告"

msgid ""
"Before upgrading, it's a good idea to resolve any deprecation warnings "
"raised by your project while using your current version of Django. Fixing "
"these warnings before upgrading ensures that you're informed about areas of "
"the code that need altering."
msgstr ""
"在升级前，将使用当前 Django 版本引发的过期警告解决掉是个不错的注意。在升级前"
"修复这些警告能确保你了解代码中哪些部分需要修改。"

msgid ""
"In Python, deprecation warnings are silenced by default. You must turn them "
"on using the ``-Wa`` Python command line option or the :envvar:"
"`PYTHONWARNINGS` environment variable. For example, to show warnings while "
"running tests:"
msgstr ""
"在 Python 中，过期警告默认是静默的。你必须用 Python 的命令行选项 ``-Wa`` 或 :"
"envvar:`PYTHONWARNINGS` 环境变量将其打开。例如，在运行测试时显示警告："

msgid ""
"If you're not using the Django test runner, you may need to also ensure that "
"any console output is not captured which would hide deprecation warnings. "
"For example, if you use `pytest <https://docs.pytest.org/>`__:"
msgstr ""
"如果你没有使用 Django 测试运行器，还需要确保不捕获任何控制台输出，以防止隐藏"
"废弃警告。例如，如果你使用 `pytest <https://docs.pytest.org/>`__："

msgid ""
"Resolve any deprecation warnings with your current version of Django before "
"continuing the upgrade process."
msgstr "在继续升级流程前处理当前 Django 版本报告的所有过期警告。"

msgid ""
"Third party applications might use deprecated APIs in order to support "
"multiple versions of Django, so deprecation warnings in packages you've "
"installed don't necessarily indicate a problem. If a package doesn't support "
"the latest version of Django, consider raising an issue or sending a pull "
"request for it."
msgstr ""
"第三方应用可能会出于兼容多版本 Django 目的使用过期 APIs，所以你安装的应用报告"
"的过期警告可能并不是问题。若某个包不支持最新版的 Django，考虑为其创建一个 "
"issue 或发起一个 pull request。"

msgid "Installation"
msgstr "安装"

msgid ""
"Once you're ready, it is time to :doc:`install the new Django version </"
"topics/install>`. If you are using a :mod:`virtual environment <venv>` and "
"it is a major upgrade, you might want to set up a new environment with all "
"the dependencies first."
msgstr ""
"准备好后，就是 :doc:`安装新版 Django ` 的时候。若你正使用 :mod:`virtual "
"environment `，且这是一次关键性升级，你可能想要先配置一个包含所有依赖的环境。"

msgid ""
"If you installed Django with pip_, you can use the ``--upgrade`` or ``-U`` "
"flag:"
msgstr "若你用 pip_ 安装 Django，你可以使用 ``--upgrade`` 或 ``-U`` 标志："

msgid ""
"When the new environment is set up, :doc:`run the full test suite </topics/"
"testing/overview>` for your application. Again, it's useful to turn on "
"deprecation warnings on so they're shown in the test output (you can also "
"use the flag if you test your app manually using ``manage.py runserver``):"
msgstr ""
"当环境准备好后，先为应用 :doc:`运行完整的测试套件 </topics/testing/"
"overview>`。再说一次，将过期警告开关打开很有用，这样就能在测试输出中看到过期"
"警告（若你用 ``manage.py runserver`` 手动测试，也能有该标志）："

msgid ""
"After you have run the tests, fix any failures. While you have the release "
"notes fresh in your mind, it may also be a good time to take advantage of "
"new features in Django by refactoring your code to eliminate any deprecation "
"warnings."
msgstr ""
"在你运行测试，并修复所有问题后。由于你刚看了发布说明，可能现在也是重构代码，"
"消除所有过期警告，尝尝 Django 最新功能特性的好时机。"

msgid ""
"When you are sufficiently confident your app works with the new version of "
"Django, you're ready to go ahead and :doc:`deploy </howto/deployment/index>` "
"your upgraded Django project."
msgstr ""
"当你十分确信你的应用能兼容新版 Django 时，你就准备好去往下一步， :doc:`部署 "
"</howto/deployment/index>` 升级后的 Django 工程。"

msgid ""
"If you are using caching provided by Django, you should consider clearing "
"your cache after upgrading. Otherwise you may run into problems, for "
"example, if you are caching pickled objects as these objects are not "
"guaranteed to be pickle-compatible across Django versions. A past instance "
"of incompatibility was caching pickled :class:`~django.http.HttpResponse` "
"objects, either directly or indirectly via the :func:`~django.views."
"decorators.cache.cache_page` decorator."
msgstr ""
"若你使用 Django 提供的缓存，你需要考虑在升级后清空缓存。否则，你可能会卷入麻"
"烦中，举个例子，若你缓存了 pickled 对象，而这些对象并不能确保跨版本 pickle 兼"
"容。一个过期兼容性例子是缓存 pickled :class:`~django.http.HttpResponse` 对"
"象，不论是直接或间接由 :func:`~django.views.decorators.cache.cache_page` 装饰"
"器创建。"

msgid "How to install Django on Windows"
msgstr "如何在 Windows 上安装 Django"

msgid ""
"This document will guide you through installing Python 3.12 and Django on "
"Windows. It also provides instructions for setting up a virtual environment, "
"which makes it easier to work on Python projects. This is meant as a "
"beginner's guide for users working on Django projects and does not reflect "
"how Django should be installed when developing patches for Django itself."
msgstr ""
"本文将指导您在 Windows 上安装 Python 3.12 和 Django。它还提供了设置虚拟环境的"
"说明，这将使在 Python 项目上工作变得更容易。这是针对在 Django 项目上工作的初"
"学者的指南，不反映在开发 Django 本身的补丁时应该如何安装 Django。"

msgid ""
"The steps in this guide have been tested with Windows 10. In other versions, "
"the steps would be similar. You will need to be familiar with using the "
"Windows command prompt."
msgstr ""
"指南中的下列步骤已在 Windows 10上测试通过。其它版本上，步骤类似。你需要熟悉如"
"何使用 Windows 的命令提示符。"

msgid "Install Python"
msgstr "安装Python"

msgid ""
"Django is a Python web framework, thus requiring Python to be installed on "
"your machine. At the time of writing, Python 3.12 is the latest version."
msgstr ""
"Django 是一个 Python Web 框架，因此需要在您的计算机上安装 Python。在撰写本文"
"时，Python 3.12 是最新版本。"

msgid ""
"To install Python on your machine go to https://www.python.org/downloads/. "
"The website should offer you a download button for the latest Python "
"version. Download the executable installer and run it. Check the boxes next "
"to \"Install launcher for all users (recommended)\" then click \"Install "
"Now\"."
msgstr ""
"要在您的机器上安装 Python，请访问Python官方下载地址 https://www.python.org/"
"downloads/ 。 该网页应该为您提供最新 Python 版本的下载按钮。 下载可执行安装程"
"序并运行它。 选中 \"Install launcher for all users (recommended)\" 旁边的框，"
"然后单击 \"Install Now\"。 "

msgid ""
"After installation, open the command prompt and check that the Python "
"version matches the version you installed by executing:"
msgstr ""
"安装完成后，打开命令提示符并通过执行以下命令检查 Python 版本是否与您安装的版"
"本匹配："

msgid "For more details, see :doc:`python:using/windows` documentation."
msgstr "想知晓更多细节，请查看 :doc:`python:using/windows` 文档。"

msgid "About ``pip``"
msgstr "关于 ``pip``"

msgid ""
":pypi:`pip` is a package manager for Python and is included by default with "
"the Python installer. It helps to install and uninstall Python packages "
"(such as Django!). For the rest of the installation, we'll use ``pip`` to "
"install Python packages from the command line."
msgstr ""
":pypi:`pip` 是 Python 的包管理器，并且默认随 Python 安装程序一起提供。它有助"
"于从命令行安装和卸载 Python 包（例如 Django！）。在接下来的安装中，我们将使"
"用 ``pip`` 来从命令行安装 Python 包。"

msgid "Setting up a virtual environment"
msgstr "配置一个虚拟环境"

msgid ""
"It is best practice to provide a dedicated environment for each Django "
"project you create. There are many options to manage environments and "
"packages within the Python ecosystem, some of which are recommended in the "
"`Python documentation <https://packaging.python.org/guides/tool-"
"recommendations/>`_. Python itself comes with :doc:`venv <python:tutorial/"
"venv>` for managing environments which we will use for this guide."
msgstr ""
"最佳实践是为你创建的每一个Django项目创建一个独立的环境。在Python生态系统中有"
"许多可以用来管理环境和包的可选工具，一些在 `Python documentation <https://"
"packaging.python.org/guides/tool-recommendations/>`_ 被推荐过。我们将会在这份"
"指南中使用Python本身自带的 :doc:`venv <python:tutorial/venv>`  来管理环境。"

msgid ""
"To create a virtual environment for your project, open a new command prompt, "
"navigate to the folder where you want to create your project and then enter "
"the following:"
msgstr ""
"要为您的项目创建虚拟环境，请打开一个新的命令提示符，导航到您希望创建项目的文"
"件夹，然后输入以下命令："

msgid ""
"This will create a folder called 'project-name' if it does not already exist "
"and set up the virtual environment. To activate the environment, run:"
msgstr ""
"这将在不存在时创建一个名为' project-name '的文件夹，并设置虚拟环境。要激活该"
"环境，请运行以下命令："

msgid ""
"The virtual environment will be activated and you'll see \"(project-name)\" "
"next to the command prompt to designate that. Each time you start a new "
"command prompt, you'll need to activate the environment again."
msgstr ""
"虚拟环境就会激活，并且你会在命令提示符旁边看到 \"(project-name)\" 指向该环"
"境。每次你打开新的命令行窗口，你需要再次激活环境。"

msgid "Install Django"
msgstr "安装 Django"

msgid ""
"Django can be installed easily using ``pip`` within your virtual environment."
msgstr "Django 可以轻松地在你的虚拟环境中使用 ``pip`` 安装。"

msgid ""
"In the command prompt, ensure your virtual environment is active, and "
"execute the following command:"
msgstr "在命令提示符中，确保您的虚拟环境处于激活状态，并执行以下命令："

msgid "This will download and install the latest Django release."
msgstr "这将下载并安装最新的 Django 发布版本。"

msgid ""
"After the installation has completed, you can verify your Django "
"installation by executing ``django-admin --version`` in the command prompt."
msgstr ""
"安装完成后，你可以在命令提示符运行 ``django-admin --version`` 验证你安装的 "
"Django。"

msgid ""
"See :ref:`database-installation` for information on database installation "
"with Django."
msgstr "参考 :ref:`数据库安装` 了解如何通过 Django 安装数据库。"

msgid "Colored terminal output"
msgstr "彩色终端输出"

msgid ""
"A quality-of-life feature adds colored (rather than monochrome) output to "
"the terminal. In modern terminals this should work for both CMD and "
"PowerShell. If for some reason this needs to be disabled, set the "
"environmental variable :envvar:`DJANGO_COLORS` to ``nocolor``."
msgstr ""
"为终端添加了彩色（而不是单色）输出是一种能提升生活质量的功能。 在现代终端中，"
"这应该适用于 CMD 和 PowerShell。如果由于某种原因需要禁用它，请将环境变量  :"
"envvar:`DJANGO_COLORS` 设为 ``nocolor`` 。"

msgid ""
"On older Windows versions, or legacy terminals, :pypi:`colorama` 0.4.6+ must "
"be installed to enable syntax coloring:"
msgstr ""
"在旧版 Windows 或传统终端上，必须安装 :pypi:`colorama` 0.4.6+ 以启用语法着"
"色："

msgid "See :ref:`syntax-coloring` for more information on color settings."
msgstr "有关颜色配置的更多信息，请参阅 :ref:`syntax-coloring` 。"

msgid "Common pitfalls"
msgstr "常见失误"

msgid ""
"If ``django-admin`` only displays the help text no matter what arguments it "
"is given, there is probably a problem with the file association in Windows. "
"Check if there is more than one environment variable set for running Python "
"scripts in ``PATH``. This usually occurs when there is more than one Python "
"version installed."
msgstr ""
"若 ``django-admin`` 无论输入啥参数都只显示帮助信息，这可能是一个 Windos 的文"
"件关联问题。检查 ``PATH`` 中是否不止一个用于运行 Python 脚本的环境变量。该问"
"题通常在安装了多个 Python 版本时出现。"

msgid ""
"If you are connecting to the internet behind a proxy, there might be "
"problems in running the command ``py -m pip install Django``. Set the "
"environment variables for proxy configuration in the command prompt as "
"follows:"
msgstr ""
"如果你在代理后面连接到互联网，运行命令 ``py -m pip install Django`` 可能会出"
"现问题。可以在命令提示符中设置代理配置的环境变量，如下所示："

msgid ""
"In general, Django assumes that ``UTF-8`` encoding is used for I/O. This may "
"cause problems if your system is set to use a different encoding. Recent "
"versions of Python allow setting the :envvar:`PYTHONUTF8` environment "
"variable in order to force a ``UTF-8`` encoding. Windows 10 also provides a "
"system-wide setting by checking ``Use Unicode UTF-8 for worldwide language "
"support`` in :menuselection:`Language --> Administrative Language Settings --"
"> Change system locale` in system settings."
msgstr ""
"通常，Django 假定 UTF-8 编码用于 I/O。 如果您的系统设置为使用不同的编码，这可"
"能会导致问题。 最近版本的 Python 允许配置 :envvar:`PYTHONUTF8` 环境变量以强制"
"使用“UTF-8”编码。Windows 10 还通过在系统配置中的语言配置 :menuselection:"
"`Language --> Administrative Language Settings --> Change system locale` 中选"
"中 ``Use Unicode UTF-8 for worldwide language support`` 来进行系统范围的配"
"置。 "

msgid "How to create database migrations"
msgstr "如何创建数据库迁移"

msgid ""
"This document explains how to structure and write database migrations for "
"different scenarios you might encounter. For introductory material on "
"migrations, see :doc:`the topic guide </topics/migrations>`."
msgstr ""
"本文介绍了如何为可能遇到的不同场景组织和编写数据库迁移。关于迁移的介绍性资"
"料，参考 :doc:`专题指南</topics/migrations>`。"

msgid "Data migrations and multiple databases"
msgstr "数据迁移和多种数据库"

msgid ""
"When using multiple databases, you may need to figure out whether or not to "
"run a migration against a particular database. For example, you may want to "
"**only** run a migration on a particular database."
msgstr ""
"使用多种数据库时，你可能需要指定是否为特定数据库运行迁移。例如，你可能 **只想"
"** 为特定数据库运行迁移。"

msgid ""
"In order to do that you can check the database connection's alias inside a "
"``RunPython`` operation by looking at the ``schema_editor.connection.alias`` "
"attribute::"
msgstr ""
"为此，你可以在 ``RunPython`` 操作中检查数据库连接别名，通过查看 "
"``schema_editor.connection.alias`` 属性::"

msgid ""
"You can also provide hints that will be passed to the :meth:"
"`allow_migrate()` method of database routers as ``**hints``:"
msgstr ""
"你也能提供会以 ``**hints`` 传递给数据库路由器的 :meth:`allow_migrate()` 方法"
"的提示："

msgid "``myapp/dbrouters.py``"
msgstr "``myapp/dbrouters.py``"

msgid "Then, to leverage this in your migrations, do the following::"
msgstr "然后，要将其在迁移中生效，像下面这样做::"

msgid ""
"If your ``RunPython`` or ``RunSQL`` operation only affects one model, it's "
"good practice to pass ``model_name`` as a hint to make it as transparent as "
"possible to the router. This is especially important for reusable and third-"
"party apps."
msgstr ""
"若你的 ``RunPython`` 或 ``RunSQL`` 操作只影响了一个模型，为其传入 "
"``model_name`` 作为提示，使其对路由器更加透明。这对可复用的和第三方应用特别重"
"要。"

msgid "Migrations that add unique fields"
msgstr "添加独一无二字段的迁移"

msgid ""
"Applying a \"plain\" migration that adds a unique non-nullable field to a "
"table with existing rows will raise an error because the value used to "
"populate existing rows is generated only once, thus breaking the unique "
"constraint."
msgstr ""
"应用 “普通” 迁移，将新的唯一非空的字段添加到已拥有一些行的表格会抛出一个错"
"误，因为用于填充现有行的值只生成一次，从而打破了唯一约束。唯一非空字段即所有"
"行的该字段都不能为空，且值唯一，不能重复。"

msgid ""
"Therefore, the following steps should be taken. In this example, we'll add a "
"non-nullable :class:`~django.db.models.UUIDField` with a default value. "
"Modify the respective field according to your needs."
msgstr ""
"因此，需要做以下步骤。在本例中，我们将添加一个带默认值的非空 :class:`~django."
"db.models.UUIDField`。根据你的需要修改对应字段。"

msgid ""
"Add the field on your model with ``default=uuid.uuid4`` and ``unique=True`` "
"arguments (choose an appropriate default for the type of the field you're "
"adding)."
msgstr ""
"在模型中以 ``default=uuid.uuid4`` 和 ``unique=True`` 参数添加该字段（根据字段"
"类型，为其选择一个合适的默认值）。"

msgid ""
"Run the :djadmin:`makemigrations` command. This should generate a migration "
"with an ``AddField`` operation."
msgstr ""
"运行 :djadmin:`makemigrations` 命令。这将生成一个 ``AddField`` 操作的迁移。"

msgid ""
"Generate two empty migration files for the same app by running "
"``makemigrations myapp --empty`` twice. We've renamed the migration files to "
"give them meaningful names in the examples below."
msgstr ""
"通过运行 ``makemigrations myapp --empty`` 两次为同一应用生成两个相同的空迁移"
"文件。我们已在以下例子中将迁移文件重命名成有意义的名字。"

msgid ""
"Copy the ``AddField`` operation from the auto-generated migration (the first "
"of the three new files) to the last migration, change ``AddField`` to "
"``AlterField``, and add imports of ``uuid`` and ``models``. For example:"
msgstr ""
"从自动生成的迁移（3个新文件中的第一个）中将 ``AddField`` 操作拷贝至上一个迁"
"移，将 ``AddField`` 改为 ``AlterField``，添加 ``uuid`` 和 ``models`` 的导入。"
"例子："

msgid "``0006_remove_uuid_null.py``"
msgstr "``0006_remove_uuid_null.py``"

msgid ""
"Edit the first migration file. The generated migration class should look "
"similar to this:"
msgstr "编辑第一个迁移文件。生成的迁移类应该看起来像这样："

msgid "``0004_add_uuid_field.py``"
msgstr "``0004_add_uuid_field.py``"

msgid ""
"Change ``unique=True`` to ``null=True`` -- this will create the intermediary "
"null field and defer creating the unique constraint until we've populated "
"unique values on all the rows."
msgstr ""
"将 ``unique=True`` 改为 ``null=True``——这将创建中间 null 字段，并延迟创建唯一"
"性约束，直到我们已为所以行填充了唯一值。"

msgid ""
"In the first empty migration file, add a :class:`~django.db.migrations."
"operations.RunPython` or :class:`~django.db.migrations.operations.RunSQL` "
"operation to generate a unique value (UUID in the example) for each existing "
"row. Also add an import of ``uuid``. For example:"
msgstr ""
"在第一个空的迁移文件中，添加一个 :class:`~django.db.migrations.operations."
"RunPython` 或 :class:`~django.db.migrations.operations.RunSQL` 操作，为每个已"
"存在的行创建一个唯一值（本例中 UUID）。同时添加 ``uuid`` 的导入。例子："

msgid "``0005_populate_uuid_values.py``"
msgstr "``0005_populate_uuid_values.py``"

msgid ""
"Now you can apply the migrations as usual with the :djadmin:`migrate` "
"command."
msgstr "现在你能像往常一样用 :djadmin:`migrate` 应用迁移了。"

msgid ""
"Note there is a race condition if you allow objects to be created while this "
"migration is running. Objects created after the ``AddField`` and before "
"``RunPython`` will have their original ``uuid``’s overwritten."
msgstr ""
"注意，若你允许运行迁移时创建对象可能会造成竞争。 ``AddField`` 后和 "
"``RunPython`` 前创建的对象保留原先重写的 ``uuid`` 值。"

msgid "Non-atomic migrations"
msgstr "非原子性迁移"

msgid ""
"On databases that support DDL transactions (SQLite and PostgreSQL), "
"migrations will run inside a transaction by default. For use cases such as "
"performing data migrations on large tables, you may want to prevent a "
"migration from running in a transaction by setting the ``atomic`` attribute "
"to ``False``::"
msgstr ""
"对于支持 DDL 事务的数据库 (SQLite and PostgreSQL)，迁移默认运行在事务内。对于"
"类似在大数据表上运行数据迁移的场景，你可以通过将 ``atomic`` 属性置为 "
"``False`` 避免在事务中运行迁移::"

msgid ""
"Within such a migration, all operations are run without a transaction. It's "
"possible to execute parts of the migration inside a transaction using :func:"
"`~django.db.transaction.atomic()` or by passing ``atomic=True`` to "
"``RunPython``."
msgstr ""
"在这样的迁移种，所有的操作运行时都不含事务。通过使用 :func:`~django.db."
"transaction.atomic()` 或为 ``RunPython`` 传入 ``atomic=True`` 能将部分迁移置"
"于事务之中。"

msgid ""
"Here's an example of a non-atomic data migration that updates a large table "
"in smaller batches::"
msgstr ""
"这是一个例子，关于非原子性数据迁移操作，将更新大数据表的操作分为数个小批次::"

msgid ""
"The ``atomic`` attribute doesn't have an effect on databases that don't "
"support DDL transactions (e.g. MySQL, Oracle). (MySQL's `atomic DDL "
"statement support <https://dev.mysql.com/doc/refman/en/atomic-ddl.html>`_ "
"refers to individual statements rather than multiple statements wrapped in a "
"transaction that can be rolled back.)"
msgstr ""
"``atomic`` 属性对不支持 DDL 事务的数据库没有影响（例如 MySQL，Oracle）。"
"（MySQL 的 `原子性 DDL 语句支持 <https://dev.mysql.com/doc/refman/en/atomic-"
"ddl.html>`_ 指向独立的语句，而不是封装在能回滚的事务中的多句语句。）"

msgid "Controlling the order of migrations"
msgstr "控制迁移顺序"

msgid ""
"Django determines the order in which migrations should be applied not by the "
"filename of each migration, but by building a graph using two properties on "
"the ``Migration`` class: ``dependencies`` and ``run_before``."
msgstr ""
"Django 不是通过迁移的名字决定迁移执行顺序，而是通过在 ``迁移`` 类上使用两个属"
"性：  ``dependencies`` 和 ``run_before``。"

msgid ""
"If you've used the :djadmin:`makemigrations` command you've probably already "
"seen ``dependencies`` in action because auto-created migrations have this "
"defined as part of their creation process."
msgstr ""
"若你用过 :djadmin:`makemigrations` 命令，你可能早已在运行时见过 "
"``dependencies``，因为自动创建的迁移将此定义为其创建过程的一部分。"

msgid "The ``dependencies`` property is declared like this::"
msgstr "``依赖`` 属性像这样申明::"

msgid ""
"Usually this will be enough, but from time to time you may need to ensure "
"that your migration runs *before* other migrations. This is useful, for "
"example, to make third-party apps' migrations run *after* your :setting:"
"`AUTH_USER_MODEL` replacement."
msgstr ""
"通常这就够用了，但是有很多次，你总是需要确认你的迁移运行在其它迁移 *之前*。例"
"如，这对于让第三方应用的迁移运行在替换 :setting:`AUTH_USER_MODEL` 之后就很有"
"用。"

msgid ""
"To achieve this, place all migrations that should depend on yours in the "
"``run_before`` attribute on your ``Migration`` class::"
msgstr ""
"要实现此目的，将所有需要先运行的迁移置于你的 ``Migration`` 类的 "
"``run_before`` 属性::"

msgid ""
"Prefer using ``dependencies`` over ``run_before`` when possible. You should "
"only use ``run_before`` if it is undesirable or impractical to specify "
"``dependencies`` in the migration which you want to run after the one you "
"are writing."
msgstr ""
"尽可能使用 ``dependencies``，而不是 ``run_before``。只有在在特定迁移中添加 "
"``dependencies`` 使其运行于你编写的迁移之后是没希望的和不切实际的情况下，你才"
"能使用 ``run_before``。"

msgid "Migrating data between third-party apps"
msgstr "在第三方应用程序中迁移数据"

msgid ""
"You can use a data migration to move data from one third-party application "
"to another."
msgstr "你可以使用数据迁移把数据从一个第三方应用程序中转移到另一个。"

msgid ""
"If you plan to remove the old app later, you'll need to set the "
"``dependencies`` property based on whether or not the old app is installed. "
"Otherwise, you'll have missing dependencies once you uninstall the old app. "
"Similarly, you'll need to catch :exc:`LookupError` in the ``apps."
"get_model()`` call that retrieves models from the old app. This approach "
"allows you to deploy your project anywhere without first installing and then "
"uninstalling the old app."
msgstr ""
"如果你计划要移除旧应用程序，则需要根据是否安装旧应用程序来设置 ``依赖`` 属"
"性。否则，一旦你卸载旧应用程序，就会缺失依赖项。同样，你需要在调用 ``app."
"get_model()`` 时捕获 :exc:`LookupError`，前者在旧应用程序中检索模型。这种方法"
"允许你在任何地方部署项目，而无需先安装并且卸载旧应用程序。"

msgid "Here's a sample migration:"
msgstr "这是一个迁移示例："

msgid "``myapp/migrations/0124_move_old_app_to_new_app.py``"
msgstr "``myapp/migrations/0124_move_old_app_to_new_app.py``"

msgid ""
"Also consider what you want to happen when the migration is unapplied. You "
"could either do nothing (as in the example above) or remove some or all of "
"the data from the new application. Adjust the second argument of the :mod:"
"`~django.db.migrations.operations.RunPython` operation accordingly."
msgstr ""
"另外在迁移未执行时，请考虑好什么是你想要发生的。你可以什么都不做（就像上面的"
"示例）或者从新应用中移除一些或全部的数据。相应的调整 :mod:`~django.db."
"migrations.operations.RunPython` 操作的第二个参数。"

msgid "Changing a ``ManyToManyField`` to use a ``through`` model"
msgstr "通过使用 ``through`` 模型来更改 ``ManyToManyField`` 字段。"

msgid ""
"If you change a :class:`~django.db.models.ManyToManyField` to use a "
"``through`` model, the default migration will delete the existing table and "
"create a new one, losing the existing relations. To avoid this, you can use :"
"class:`.SeparateDatabaseAndState` to rename the existing table to the new "
"table name while telling the migration autodetector that the new model has "
"been created. You can check the existing table name through :djadmin:"
"`sqlmigrate` or :djadmin:`dbshell`. You can check the new table name with "
"the through model's ``_meta.db_table`` property. Your new ``through`` model "
"should use the same names for the ``ForeignKey``\\s as Django did. Also if "
"it needs any extra fields, they should be added in operations after :class:`."
"SeparateDatabaseAndState`."
msgstr ""
"如果您将类 :class:`~django.db.models.ManyToManyField` 更改为使用 ``through`` "
"模型，默认迁移将删除现有表并创建新表，从而丢失现有关系。 为避免这种情况，您可"
"以使用类 :class:`.SeparateDatabaseAndState` 将现有表重命名为新表名，同时告诉"
"迁移自动检测器已创建新模型。 您可以通过 :djadmin:`sqlmigrate` 或 :djadmin:"
"`dbshell` 检查现有表名。您可以使用直通模型的 ``_meta.db_table`` 属性检查新表"
"名称。 您的新 ``through`` 模型应该使用与 Django 相同的 ``ForeignKey``\\s 名"
"称。 此外，如果它需要任何额外的字段，它们应该在类 :class:`."
"SeparateDatabaseAndState` 之后添加到操作中。"

msgid ""
"For example, if we had a ``Book`` model with a ``ManyToManyField`` linking "
"to ``Author``, we could add a through model ``AuthorBook`` with a new field "
"``is_primary``, like so::"
msgstr ""
"例如，假如你有一个 ``Book`` 模型，它通过 ``ManyToManyField``  链接 "
"``Author`` 模型，我们可以通过像下面这样添加一个带有新字段 ``is_primary`` 的中"
"间模型 ``AuthorBook`` ::"

msgid "Changing an unmanaged model to managed"
msgstr "将非托管模型变为托管的"

msgid ""
"If you want to change an unmanaged model (:attr:`managed=False <django.db."
"models.Options.managed>`) to managed, you must remove ``managed=False`` and "
"generate a migration before making other schema-related changes to the "
"model, since schema changes that appear in the migration that contains the "
"operation to change ``Meta.managed`` may not be applied."
msgstr ""
"如果你想要将非托管模型 (:attr:`managed=False <django.db.models.Options."
"managed>`) 变为托管的，你必须移除 ``managed=False`` 并且在对此模型做其他模式"
"相关的改变前生成一次迁移，因为如果迁移中出现模式改变，对 ``Meta.managed`` 的"
"修改操作不会被执行。"
