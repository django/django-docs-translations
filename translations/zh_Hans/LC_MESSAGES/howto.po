# SOME DESCRIPTIVE TITLE.
# Copyright (C) Django Software Foundation and contributors
# This file is distributed under the same license as the Django package.
#
# Translators:
# Arthur Wu <dandelionstill@gmail.com>, 2018
# Bai HuanCheng <xiqingongzi@gmail.com>, 2018
# belitex, 2018
# Bai HuanCheng <xiqingongzi@gmail.com>, 2018
# CabbSir <cabbsir@gmail.com>, 2018
# Cell, 2018
# David <huangtao0202@gmail.com>, 2018
# Dogify <595572594@qq.com>, 2018-2019
# FPlust Lu <fplustlu@gmail.com>, 2018
# Frost Ming <mianghong@gmail.com>, 2018
# JINGMING DAI <d664216@gmail.com>, 2018
# Jin Song <jinsong0926@hotmail.com>, 2019
# Kevin Lee <rootkitcn@live.com>, 2018
# kurtchen1988 <kurtcobain1988824@hotmail.com>, 2018
# kurtchen1988 <kurtcobain1988824@hotmail.com>, 2018
# Kwen Stephen <hyuncankun@outlook.com>, 2018
# kyle xu <tsingx@hotmail.com>, 2017
# Le Yang <youngleocn@qq.com>, 2018
# shengzhulst <lishiting1996@outlook.com>, 2018
# MattGook <matthewpangwm@gmail.com>, 2019
# mrgaolei <gaolei@liheran.com>, 2018
# radish sx <radishxtop@gmail.com>, 2017
# raingolee <raingolee@gmail.com>, 2018
# ryan rain <holidaylover2010@gmail.com>, 2018
# tianlong zhou <tlongzou@gmail.com>, 2019
# Vincent Chan, 2018
# Xiang Yu <bupt.aswmtjdsj@gmail.com>, 2013
# xin.wang <asimplelife@live.com>, 2018
# enginewang <engine74396@gmail.com>, 2018
# ykh <614457662@qq.com>, 2018
# VinCiLord <lxfyok@gmail.com>, 2018
# zwithz1998, 2018
# 吴彬 <xiake21x@qq.com>, 2016
# 奇泽 吴 <wuqize5109@163.com>, 2018
# 尔茂 (￣︶￣)↗ 涨 <973657283@qq.com>, 2018
# 得鑫 李 <lidexin911@126.com>, 2018
# Yang Zeyu (扩散性百万甜面包) <Himself6565@gmail.com>, 2018
# 景隆 王 <Arsenal591@126.com>, 2018
# Yang Zeyu (扩散性百万甜面包) <Himself6565@gmail.com>, 2018
# 空 镜 <87647703@qq.com>, 2018
# Dogify <595572594@qq.com>, 2019
msgid ""
msgstr ""
"Project-Id-Version: django-docs\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-05-20 04:25-0500\n"
"PO-Revision-Date: 2019-05-20 15:00+0000\n"
"Last-Translator: Dogify <595572594@qq.com>\n"
"Language-Team: Chinese (China) (http://www.transifex.com/django/django-docs/"
"language/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

msgid "Authentication using ``REMOTE_USER``"
msgstr "使用 ``REMOTE_USER`` 进行身份验证"

msgid ""
"This document describes how to make use of external authentication sources "
"(where the Web server sets the ``REMOTE_USER`` environment variable) in your "
"Django applications.  This type of authentication solution is typically seen "
"on intranet sites, with single sign-on solutions such as IIS and Integrated "
"Windows Authentication or Apache and `mod_authnz_ldap`_, `CAS`_, `Cosign`_, "
"`WebAuth`_, `mod_auth_sspi`_, etc."
msgstr ""
"本文档描述如何在 Django 应用中使用外部身份验证资源（在 web 服务器上设置 "
"``REMOTE_USER`` 环境变量的地方）。这种类型的身份验证方法一般用在使用了单点登"
"录方案的内部网站上，比如 IIS 和 Windows 一体化验证或者 Apache 和 "
"`mod_authnz_ldap`_, `CAS`_, `Cosign`_, `WebAuth`_, `mod_auth_sspi`_ 等等。"

msgid ""
"When the Web server takes care of authentication it typically sets the "
"``REMOTE_USER`` environment variable for use in the underlying application.  "
"In Django, ``REMOTE_USER`` is made available in the :attr:`request.META "
"<django.http.HttpRequest.META>` attribute.  Django can be configured to make "
"use of the ``REMOTE_USER`` value using the ``RemoteUserMiddleware`` or "
"``PersistentRemoteUserMiddleware``, and :class:`~django.contrib.auth."
"backends.RemoteUserBackend` classes found in :mod:`django.contrib.auth`."
msgstr ""
"当 Web 服务器负责鉴权时，通常会设置 ``REMOTE_USER`` 环境变量，这是为了在底层"
"应用中使用。在 Django 中， ``REMOTE_USER`` 是作为 :attr:`request.META "
"<django.http.HttpRequest.META>` 的参数来使用的。如果想在 Django 中使用 "
"``REMOTE_USER``,  可以通过配置 ``RemoteUserMiddleware`` 中间件， "
"``PersistentRemoteUserMiddleware`` 中间件，或者继承在 :mod:`django.contrib."
"auth` 中的 :class:`~django.contrib.auth.backends.RemoteUserBackend` 来实现。"

msgid "Configuration"
msgstr "配置"

msgid ""
"First, you must add the :class:`django.contrib.auth.middleware."
"RemoteUserMiddleware` to the :setting:`MIDDLEWARE` setting **after** the :"
"class:`django.contrib.auth.middleware.AuthenticationMiddleware`::"
msgstr ""
"首先，你需要向配置文件的 :setting:`MIDDLEWARE` 键中，在 :class:`django."
"contrib.auth.middleware.AuthenticationMiddleware` 的 **后面** 添加 :class:"
"`django.contrib.auth.middleware.RemoteUserMiddleware` ::"

msgid ""
"Next, you must replace the :class:`~django.contrib.auth.backends."
"ModelBackend` with :class:`~django.contrib.auth.backends.RemoteUserBackend` "
"in the :setting:`AUTHENTICATION_BACKENDS` setting::"
msgstr ""
"然后，你需要将设置中的 :setting:`AUTHENTICATION_BACKENDS` setting:: 键值由 :"
"class:`~django.contrib.auth.backends.ModelBackend` 替换为 :class:`~django."
"contrib.auth.backends.RemoteUserBackend`::"

msgid ""
"With this setup, ``RemoteUserMiddleware`` will detect the username in "
"``request.META['REMOTE_USER']`` and will authenticate and auto-login that "
"user using the :class:`~django.contrib.auth.backends.RemoteUserBackend`."
msgstr ""
"通过此项设置， ``RemoteUserMiddleware`` 可以检测 ``request."
"META['REMOTE_USER']`` 中的用户名，而且可以认证和自动登录用户使用的 :class:"
"`~django.contrib.auth.backends.RemoteUserBackend`。"

msgid ""
"Be aware that this particular setup disables authentication with the default "
"``ModelBackend``. This means that if the ``REMOTE_USER`` value is not set "
"then the user is unable to log in, even using Django's admin interface. "
"Adding ``'django.contrib.auth.backends.ModelBackend'`` to the "
"``AUTHENTICATION_BACKENDS`` list will use ``ModelBackend`` as a fallback if "
"``REMOTE_USER`` is absent, which will solve these issues."
msgstr ""
"要注意这项设置将导致无法使用默认的 ``ModelBackend`` 验证。也就是说如果 "
"``REMOTE_USER`` 的值没有指定则该用户将无法登录，即使通过 Django 的管理后台。"
"要解决这些问题，把 ``'django.contrib.auth.backends.ModelBackend'`` 加入 "
"``AUTHENTICATION_BACKENDS`` 列表中，则当 ``REMOTE_USER`` 未指定时，就会回退使"
"用 ``ModelBackend``。"

msgid ""
"Django's user management, such as the views in ``contrib.admin`` and the :"
"djadmin:`createsuperuser` management command, doesn't integrate with remote "
"users. These interfaces work with users stored in the database regardless of "
"``AUTHENTICATION_BACKENDS``."
msgstr ""
"Django 的用户管理系统，比如 ``contrib.admin`` 中的视图函数及 :djadmin:"
"`createsuperuser` 的管理命令，都没有与远程用户集成。这些接口只工作在数据库中"
"存储的用户上，无论 ``AUTHENTICATION_BACKENDS`` 为何值。"

msgid ""
"Since the ``RemoteUserBackend`` inherits from ``ModelBackend``, you will "
"still have all of the same permissions checking that is implemented in "
"``ModelBackend``."
msgstr ""
"因为 ``RemoteUserBackend`` 继承自 ``ModelBackend``, 您仍将拥有在  "
"``ModelBackend`` 中实现的所有相同的权限检查。"

msgid ""
"Users with :attr:`is_active=False <django.contrib.auth.models.User."
"is_active>` won't be allowed to authenticate. Use :class:`~django.contrib."
"auth.backends.AllowAllUsersRemoteUserBackend` if you want to allow them to."
msgstr ""
"具有 :attr:`is_active=False <django.contrib.auth.models.User.is_active>` 的用"
"户将被禁止验证。你可以使用 :class:`~django.contrib.auth.backends."
"AllowAllUsersRemoteUserBackend` 来允许验证。"

msgid ""
"If your authentication mechanism uses a custom HTTP header and not "
"``REMOTE_USER``, you can subclass ``RemoteUserMiddleware`` and set the "
"``header`` attribute to the desired ``request.META`` key.  For example::"
msgstr ""
"如果你的验证机制使用一个自定义的 HTTP 头部而不是 ``REMOTE_USER``，你可以构建"
"一个 ``RemoteUserMiddleWare`` 的子类然后把 ``header`` 属性设成你希望的 "
"``request.META`` 键值。例如::"

msgid ""
"Be very careful if using a ``RemoteUserMiddleware`` subclass with a custom "
"HTTP header. You must be sure that your front-end web server always sets or "
"strips that header based on the appropriate authentication checks, never "
"permitting an end-user to submit a fake (or \"spoofed\") header value. Since "
"the HTTP headers ``X-Auth-User`` and ``X-Auth_User`` (for example) both "
"normalize to the ``HTTP_X_AUTH_USER`` key in ``request.META``, you must also "
"check that your web server doesn't allow a spoofed header using underscores "
"in place of dashes."
msgstr ""
"使用具有自定义HTTP头部的 ``RemoteUserMiddleware`` 子类时需要特别小心。你要确"
"保你的前端服务器基于验证检查结果正确设置或去除了该头部，禁止任何终端用户提交"
"一个仿冒的头部值。因为HTTP头部 ``X-Auth-User`` 与（比方说） ``X-Auth_User`` "
"都会标准化为 ``request.META`` 的 ``HTTP_X_AUTH_USER`` 键，你必须确保你的服务"
"器不允许头部使用下划线来替代横杠。"

msgid ""
"This warning doesn't apply to ``RemoteUserMiddleware`` in its default "
"configuration with ``header = 'REMOTE_USER'``, since a key that doesn't "
"start with ``HTTP_`` in ``request.META`` can only be set by your WSGI "
"server, not directly from an HTTP request header."
msgstr ""
"这个警告不适用于 ``RemoteUserMiddlewar``，它的默认配置为 ``header "
"='REMOTE_USER'``, 因为在 ``request.META`` 中不存在以 ``HTTP_`` 开始的键可以只"
"由WSGI服务器设置, 而不能直接来自HTTP请求头部."

msgid ""
"If you need more control, you can create your own authentication backend "
"that inherits from :class:`~django.contrib.auth.backends.RemoteUserBackend` "
"and override one or more of its attributes and methods."
msgstr ""
"如果你需要更多控制, 你可以通过继承 :class:`~django.contrib.auth.backends."
"RemoteUserBackend`  并且覆盖其一个或多个属性和方法来创建你自己的验证后端."

msgid "Using ``REMOTE_USER`` on login pages only"
msgstr "仅在登录界面使用 ``REMOTE_USER``"

msgid ""
"The ``RemoteUserMiddleware`` authentication middleware assumes that the HTTP "
"request header ``REMOTE_USER`` is present with all authenticated requests. "
"That might be expected and practical when Basic HTTP Auth with ``htpasswd`` "
"or other simple mechanisms are used, but with Negotiate (GSSAPI/Kerberos) or "
"other resource intensive authentication methods, the authentication in the "
"front-end HTTP server is usually only set up for one or a few login URLs, "
"and after successful authentication, the application is supposed to maintain "
"the authenticated session itself."
msgstr ""
"``RemoteUserMiddleware`` 验证中间件假定所有已验证的请求都包含 "
"``REMOTE_USER`` 头部。这可能对于使用 ``htpasswd`` 或其他简单机制的基础 HTTP "
"验证方式是很自然的，然而对于协商验证（GSSAP/Kerberos）或其他资源密集的验证方"
"式来说，前端 HTTP 服务器的验证通常只在几个登录的 URL 上存在，在验证成功之后，"
"应用需要自己维护已验证的会话。"

msgid ""
":class:`~django.contrib.auth.middleware.PersistentRemoteUserMiddleware` "
"provides support for this use case. It will maintain the authenticated "
"session until explicit logout by the user. The class can be used as a drop-"
"in replacement of :class:`~django.contrib.auth.middleware."
"RemoteUserMiddleware` in the documentation above."
msgstr ""
":class:`~django.contrib.auth.middleware.PersistentRemoteUserMiddleware` 就针"
"对这个使用场景提供了支持。除非用户显式地退出登录，它将一直保留已认证的会话。"
"这个中间件可以代替上文中的 :class:`~django.contrib.auth.middleware."
"RemoteUserMiddleware`。"

msgid "Writing a custom storage system"
msgstr "编写一个自定义存储系统"

msgid ""
"If you need to provide custom file storage -- a common example is storing "
"files on some remote system -- you can do so by defining a custom storage "
"class. You'll need to follow these steps:"
msgstr ""
"如果你需要提供自定义文件储存功能——一个普通的例子是，把文件储存在远程系统中——"
"自定义一个存储类可以完成这一任务来完成。下面是需要完成的具体步骤："

msgid ""
"Your custom storage system must be a subclass of ``django.core.files.storage."
"Storage``::"
msgstr ""
"你自定义的存储系统必须为 ``Django.core.files.storage.Storage`` 的一个子类::"

msgid ""
"Django must be able to instantiate your storage system without any "
"arguments. This means that any settings should be taken from ``django.conf."
"settings``::"
msgstr ""
"Django 必须能以无参数实例化你的存储系统。意味着所有设置都应从 ``dango.conf."
"settings`` 中获取::"

msgid ""
"Your storage class must implement the :meth:`_open()` and :meth:`_save()` "
"methods, along with any other methods appropriate to your storage class. See "
"below for more on these methods."
msgstr ""
"在你的存储类中，除了其他自定义的方法外，还必须实现  :meth:`_open()` 以及 :"
"meth:`_save()` 方法。关于这些方法，详情请查看下面的信息。"

msgid ""
"In addition, if your class provides local file storage, it must override the "
"``path()`` method."
msgstr "另外，如果你的类提供了本地文件存储，它必须重写  ``path()`` 方法。"

msgid ""
"Your storage class must be :ref:`deconstructible <custom-deconstruct-"
"method>` so it can be serialized when it's used on a field in a migration. "
"As long as your field has arguments that are themselves :ref:`serializable "
"<migration-serializing>`, you can use the ``django.utils.deconstruct."
"deconstructible`` class decorator for this (that's what Django uses on "
"FileSystemStorage)."
msgstr ""
"您的存储类必须是 :ref:`deconstructible <custom-deconstruct-method>`，以便在迁"
"移中的字段上使用它时可以序列化。 只要你的字段有自己的参数 :ref:`serializable "
"<migration-serializing>`，你可以使用 ``django.utils.deconstruct."
"deconstructible`` 类装饰器（这是 Django 在 FileSystemStorage 上使用的）。"

msgid ""
"By default, the following methods raise `NotImplementedError` and will "
"typically have to be overridden:"
msgstr "通常，下面的方法会引发一个 `NotImplementedError`，并通常必须被重写。"

msgid ":meth:`Storage.delete`"
msgstr ":meth:`Storage.delete`"

msgid ":meth:`Storage.exists`"
msgstr ":meth:`Storage.exists`"

msgid ":meth:`Storage.listdir`"
msgstr ":meth:`Storage.listdir`"

msgid ":meth:`Storage.size`"
msgstr ":meth:`Storage.size`"

msgid ":meth:`Storage.url`"
msgstr ":meth:`Storage.url`"

msgid ""
"Note however that not all these methods are required and may be deliberately "
"omitted. As it happens, it is possible to leave each method unimplemented "
"and still have a working Storage."
msgstr ""
"可是，记住并非所有这些方法都是需要的，并且可能故意被省略。正因为如此，让每个"
"方法未实现并仍然拥有一个可用储存是可能的。"

msgid ""
"By way of example, if listing the contents of certain storage backends turns "
"out to be expensive, you might decide not to implement `Storage.listdir`."
msgstr ""
"举例来说，如果列出某些存储后端的内容会比较消耗性能，那么您可以决定不实现 "
"`Storage.listdir` 方法。"

msgid ""
"Another example would be a backend that only handles writing to files. In "
"this case, you would not need to implement any of the above methods."
msgstr ""
"另一个例子是只处理写入文件的后端。在这种情况下，你不需要实现上述任何方法。"

msgid ""
"Ultimately, which of these methods are implemented is up to you. Leaving "
"some methods unimplemented will result in a partial (possibly broken) "
"interface."
msgstr ""
"最终，你决定实现这些方法中的哪一个。一些方法未实现结果会生成部分（可能会损坏"
"的）接口。"

msgid ""
"You'll also usually want to use hooks specifically designed for custom "
"storage objects. These are:"
msgstr "你可能也经常会用到专为自定义存储对象设计的钩子函数。他们是："

msgid "**Required**."
msgstr "**要求**。"

msgid ""
"Called by ``Storage.open()``, this is the actual mechanism the storage class "
"uses to open the file. This must return a ``File`` object, though in most "
"cases, you'll want to return some subclass here that implements logic "
"specific to the backend storage system."
msgstr ""
"它将被 ``Storage.open()`` 调用，前者才是存储类用来打开文件的真正机制，这个方"
"法必须要返回一个 ``文件`` 对象。尽管在大多数时候，你想要这个方法返回一个继承"
"于特定逻辑的后台存储系统的子类。"

msgid ""
"Called by ``Storage.save()``. The ``name`` will already have gone through "
"``get_valid_name()`` and ``get_available_name()``, and the ``content`` will "
"be a ``File`` object itself."
msgstr ""
"被称为 ``Storage.save()``。这个 ``name`` 会早已经历 ``get_valid_name()`` 和 "
"``get_available_name()``，并且 ``content`` 将会成为 ``File`` 对象自身。"

msgid ""
"Should return the actual name of name of the file saved (usually the "
"``name`` passed in, but if the storage needs to change the file name return "
"the new name instead)."
msgstr ""
"应该返回保存的文件名的实际名称（通常是传入“name”，但如果内存需要改变文件名，"
"则返回新名称）。"

msgid ""
"Returns a filename suitable for use with the underlying storage system. The "
"``name`` argument passed to this method is either the original filename sent "
"to the server or, if ``upload_to`` is a callable, the filename returned by "
"that method after any path information is removed. Override this to "
"customize how non-standard characters are converted to safe filenames."
msgstr ""
"返回适用于底层存储系统的文件名。 传递给此方法的 ``name`` 参数既不是发送给服务"
"器的原始文件名，如果 ``upload_to`` 是可调用的，则在删除任何路径信息后由该方法"
"返回的文件名。 重写此操作可以自定义如何将非标准字符转换为安全文件名。"

msgid ""
"The code provided on ``Storage`` retains only alpha-numeric characters, "
"periods and underscores from the original filename, removing everything else."
msgstr ""
"“Storage”上提供的代码仅保留原始文件名中的字母数字字符，句点和下划线，并删除其"
"他所有内容。"

msgid ""
"Returns a filename that is available in the storage mechanism, possibly "
"taking the provided filename into account. The ``name`` argument passed to "
"this method will have already cleaned to a filename valid for the storage "
"system, according to the ``get_valid_name()`` method described above."
msgstr ""
"返回存储机制中可用的文件名，可能会考虑提供的文件名。 根据上述 "
"``get_valid_name()`` 方法，传递给此方法的 ``name`` 参数已经被清除为一个对存储"
"系统有效的文件名。"

msgid ""
"The length of the filename will not exceed ``max_length``, if provided. If a "
"free unique filename cannot be found, a :exc:`SuspiciousFileOperation "
"<django.core.exceptions.SuspiciousOperation>` exception is raised."
msgstr ""
"返回的文件名的长度不会超过 ``max_length``，如果该参数被提供的话。若找不到一个"
"可用的独一无二的文件名，则抛出一个 :exc:`SuspiciousFileOperation <django."
"core.exceptions.SuspiciousOperation>` 异常。"

msgid ""
"If a file with ``name`` already exists, an underscore plus a random 7 "
"character alphanumeric string is appended to the filename before the "
"extension."
msgstr ""
"如果已经存在一个 ``name`` 的文件，则会在扩展后缀前添加下划线和 7 位随机字母。"

msgid "Custom Lookups"
msgstr "自定义查询器"

msgid ""
"Django offers a wide variety of :ref:`built-in lookups <field-lookups>` for "
"filtering (for example, ``exact`` and ``icontains``). This documentation "
"explains how to write custom lookups and how to alter the working of "
"existing lookups. For the API references of lookups, see the :doc:`/ref/"
"models/lookups`."
msgstr ""
"Django 提供了各种各样的 :ref:`内置查询器 <field-lookups>` （例如， ``exact`` "
"和 ``icontains`` ）。本文档解释了如何编写自定义查询器以及如何更改已有查询器的"
"工作方式。 有关 lookup 的 API 参考，请参阅 :doc:`/ref/models/lookups`。"

msgid "A simple lookup example"
msgstr "一个简单的查询器示例"

msgid ""
"Let's start with a simple custom lookup. We will write a custom lookup "
"``ne`` which works opposite to ``exact``. ``Author.objects."
"filter(name__ne='Jack')`` will translate to the SQL::"
msgstr ""
"让我们从一个典型的自定义查询器开始。我们编写一个自定义查询器 ``ne``，它与 "
"``exact`` 相反。``Author.objects.filter(name__ne='Jack')`` 将会转换成 SQL::"

msgid ""
"This SQL is backend independent, so we don't need to worry about different "
"databases."
msgstr "SQL 会自动适配不同的后端，所以我们不需要为使用不同的数据库而担心。"

msgid ""
"There are two steps to making this work. Firstly we need to implement the "
"lookup, then we need to tell Django about it. The implementation is quite "
"straightforward::"
msgstr ""
"完成此工作需要两个步骤。第一首先我们需要实现查询器，第二我们需要将它告知 "
"Django。 查询器的实现非常简单::"

msgid ""
"To register the ``NotEqual`` lookup we will just need to call "
"``register_lookup`` on the field class we want the lookup to be available. "
"In this case, the lookup makes sense on all ``Field`` subclasses, so we "
"register it with ``Field`` directly::"
msgstr ""
"要注册 ``NotEqual`` 查询器，我们只需在对应字段类上调用 ``register_lookup`` 方"
"法。 在这种情况下，查询器对所有 ``Field`` 子类都生效，所以我们直接用 "
"``Field`` 注册它::"

msgid "Lookup registration can also be done using a decorator pattern::"
msgstr "查询器注册也可以用修饰模式来完成::"

msgid ""
"We can now use ``foo__ne`` for any field ``foo``. You will need to ensure "
"that this registration happens before you try to create any querysets using "
"it. You could place the implementation in a ``models.py`` file, or register "
"the lookup in the ``ready()`` method of an ``AppConfig``."
msgstr ""
"现在我们可以用 ``foo__ne`` 来代表 ``foo`` 的任意字段。你需要确保注册行为发生"
"在创建任意的 queryset 之前。你可以在 ``models.py`` 文件内设置它，或者在 "
"``AppConfig`` 的 ``ready()`` 方法中注册它。"

msgid ""
"Taking a closer look at the implementation, the first required attribute is "
"``lookup_name``. This allows the ORM to understand how to interpret "
"``name__ne`` and use ``NotEqual`` to generate the SQL. By convention, these "
"names are always lowercase strings containing only letters, but the only "
"hard requirement is that it must not contain the string ``__``."
msgstr ""
"仔细观察实现过程，第一个要求的属性是 ``lookup_name``。它能让 ORM 理解如何编"
"译 ``name_ne`` 并使用 ``NotEqual`` 来建立 SQL 语句。按照惯例，这些名字应该总"
"是仅包含小写字母的字符串，但是绝对不能包含双下划线 ``__``。"

msgid ""
"We then need to define the ``as_sql`` method. This takes a ``SQLCompiler`` "
"object, called ``compiler``,  and the active database connection. "
"``SQLCompiler`` objects are not documented, but the only thing we need to "
"know about them is that they have a ``compile()`` method which returns a "
"tuple containing an SQL string, and the parameters to be interpolated into "
"that string. In most cases, you don't need to use it directly and can pass "
"it on to ``process_lhs()`` and ``process_rhs()``."
msgstr ""
"之后我们需要定义 ``as_sql`` 方法。此方法需要一个 ``SQLCompiler`` 对象, 被叫"
"做 ``compiler``，和一个有效的数据库连接。``SQLCompller`` 对象没有文档，我们只"
"需要知道它有一个 ``compile()`` 方法可以返回一个包括 SQL 字符串的元组，和插入"
"这个字符串的参数。大部分情况下，你不需要直接使用这个对象你可以把它传送给 "
"``process_lhs()`` 和 ``process_rhs()``。"

msgid ""
"A ``Lookup`` works against two values, ``lhs`` and ``rhs``, standing for "
"left-hand side and right-hand side. The left-hand side is usually a field "
"reference, but it can be anything implementing the :ref:`query expression "
"API <query-expression>`. The right-hand is the value given by the user. In "
"the example ``Author.objects.filter(name__ne='Jack')``, the left-hand side "
"is a reference to the ``name`` field of the ``Author`` model, and ``'Jack'`` "
"is the right-hand side."
msgstr ""
"``Lookup`` 工作依靠两个值，``lhs`` 和 ``rhs``，代表左右两边，左边是一个字段参"
"考，它可以是任何实现了 :ref:`查询表达式 API <query-expression>` 的实例。右边"
"是一个用户给定的数值。举个例子： ``Author.objects.filter(name__ne='Jack')``，"
"左边是 ``Author`` 模型的 ``name`` 字段，右边是 ``'Jack'``。"

msgid ""
"We call ``process_lhs`` and ``process_rhs`` to convert them into the values "
"we need for SQL using the ``compiler`` object described before. These "
"methods return tuples containing some SQL and the parameters to be "
"interpolated into that SQL, just as we need to return from our ``as_sql`` "
"method. In the above example, ``process_lhs`` returns ``('\"author\".\"name"
"\"', [])`` and ``process_rhs`` returns ``('\"%s\"', ['Jack'])``. In this "
"example there were no parameters for the left hand side, but this would "
"depend on the object we have, so we still need to include them in the "
"parameters we return."
msgstr ""
"我们利用 ``process_lhs`` 和 ``process_rhs`` 将他们转换为我们期望值，用于之前"
"介绍的 ``compiler`` 对象执行 SQL。这俩方法返回一个元组，包含一些 SQL 语句和插"
"入 SQL 语句一些参数，就像是 ``as_sql`` 方法需要返回的。前文所述的例子中，"
"``process_lhs`` 返回 ``('\"author\".\"name\"', [])``，``process_lhs`` 返回 "
"``('\"%s\"', ['Jack'])``。在这个例子里面没有手边的参数，这需要看情况而定，所"
"以我们仍需要在返回结果时包括这些参数。"

msgid ""
"Finally we combine the parts into an SQL expression with ``<>``, and supply "
"all the parameters for the query. We then return a tuple containing the "
"generated SQL string and the parameters."
msgstr ""
"最后，我们将这些部分组合成一个带有 ``<>`` 的 SQL 表达式，并提供查询的所有参"
"数。 然后我们返回一个包含生成的 SQL 字符串和参数的元组。"

msgid "A simple transformer example"
msgstr "一个简单的转换器示例"

msgid ""
"The custom lookup above is great, but in some cases you may want to be able "
"to chain lookups together. For example, let's suppose we are building an "
"application where we want to make use of the ``abs()`` operator. We have an "
"``Experiment`` model which records a start value, end value, and the change "
"(start - end). We would like to find all experiments where the change was "
"equal to a certain amount (``Experiment.objects.filter(change__abs=27)``), "
"or where it did not exceed a certain amount (``Experiment.objects."
"filter(change__abs__lt=27)``)."
msgstr ""
"上面的自定义查询器没问题，但在某些情况下，您可能希望能够将一些查询器链接在一"
"起。 例如，假设我们正在构建一个使用 ``abs()`` 运算的应用程序。我们有一个 "
"``Experiment`` 模型，它记录起始值，结束值和差值（起始 - 结束）。 我们想找到 "
"change 属性等于某个数值的所有 Experiment 对象(``Experiment.objects."
"filter(change__abs = 27)``)，change属性没有超过一定数量的 Experiment 对象"
"(``Experiment.objects.filter(change__abs__lt= 27)``)。"

msgid ""
"This example is somewhat contrived, but it nicely demonstrates the range of "
"functionality which is possible in a database backend independent manner, "
"and without duplicating functionality already in Django."
msgstr ""
"这个例子有点刻意，但它很好地演示了以数据库后端独立方式可能实现的功能范围，并"
"且没有重复 Django 中的功能。"

msgid ""
"We will start by writing an ``AbsoluteValue`` transformer. This will use the "
"SQL function ``ABS()`` to transform the value before comparison::"
msgstr ""
"我们将从编写一个 ``AbsoluteValue`` 变换器开始。 这将使用 SQL 中的 ``ABS()`` "
"函数在比较进行之前转换值::"

msgid "Next, let's register it for ``IntegerField``::"
msgstr "下一步，让我们为其注册 ``IntrgerField``::"

msgid ""
"We can now run the queries we had before. ``Experiment.objects."
"filter(change__abs=27)`` will generate the following SQL::"
msgstr ""
"我们现在可以运行之前的查询。``Experiment.objects.filter(change__abs=27)`` 将"
"生成以下 SQL::"

msgid ""
"By using ``Transform`` instead of ``Lookup`` it means we are able to chain "
"further lookups afterwards. So ``Experiment.objects."
"filter(change__abs__lt=27)`` will generate the following SQL::"
msgstr ""
"通过使用 ``Transform`` 而不是 ``Lookup``，这意味着我们可以在之后链接进一步的"
"查找。 所以 ``Experiment.objects.filter(change__abs__lt=27)`` 将生成以下 "
"SQL ::"

msgid ""
"Note that in case there is no other lookup specified, Django interprets "
"``change__abs=27`` as ``change__abs__exact=27``."
msgstr ""
"请注意，如果没有指定其他查找定义，Django则会将 ``change__abs=27`` 解析为 "
"``change__abs__exact=27``。"

msgid ""
"This also allows the result to be used in ``ORDER BY`` and ``DISTINCT ON`` "
"clauses. For example ``Experiment.objects.order_by('change__abs')`` "
"generates::"
msgstr ""
"这也允许结果用于 ``ORDER BY`` 和 ``DISTINCT ON`` 子句。例如 ``Experiment."
"objects.order_by('change__abs')`` 会生成::"

msgid ""
"And on databases that support distinct on fields (such as PostgreSQL), "
"``Experiment.objects.distinct('change__abs')`` generates::"
msgstr ""
"在支持字段去重的数据库（例如 PostgreSQL）上，语句 ``Experiment.objects."
"distinct('change__abs')`` 会生成::"

msgid ""
"Ordering and distinct support as described in the last two paragraphs was "
"added."
msgstr "上两段所提到的排序与去重的支持被加入了。"

msgid ""
"When looking for which lookups are allowable after the ``Transform`` has "
"been applied, Django uses the ``output_field`` attribute. We didn't need to "
"specify this here as it didn't change, but supposing we were applying "
"``AbsoluteValue`` to some field which represents a more complex type (for "
"example a point relative to an origin, or a complex number) then we may have "
"wanted to specify that the transform returns a ``FloatField`` type for "
"further lookups. This can be done by adding an ``output_field`` attribute to "
"the transform::"
msgstr ""
"当我们在应用 ``Transform`` 之后查找允许执行哪些查找时，Django 使用 "
"``output_field`` 属性。 我们不需要在这里指定它，因为它没有改变，但假设我们将 "
"``AbsoluteValue`` 应用于某个字段，该字段表示更复杂的类型（例如，相对于原点的"
"点或复数） 那么我们可能想要指定转换返回一个 ``FloatField`` 类型以进行进一步的"
"查找。 这可以通过在变换中添加 ``output_field`` 属性来完成::"

msgid ""
"This ensures that further lookups like ``abs__lte`` behave as they would for "
"a ``FloatField``."
msgstr "这确保了像 ``abs__lte`` 这样的进一步查找与对 ``FloatField`` 一致。"

msgid "Writing an efficient ``abs__lt`` lookup"
msgstr "编写一个高效的 ``abs__lt`` 查找"

msgid ""
"When using the above written ``abs`` lookup, the SQL produced will not use "
"indexes efficiently in some cases. In particular, when we use "
"``change__abs__lt=27``, this is equivalent to ``change__gt=-27`` AND "
"``change__lt=27``. (For the ``lte`` case we could use the SQL ``BETWEEN``)."
msgstr ""
"当使用上面写的 ``abs`` 查找时，生成的 SQL 在某些情况下不会有效地使用索引。 特"
"别是，当我们使用 ``change__abs__lt=27`` 时，这相当于 ``change__gt=-27`` 和 "
"``change__lt=27``。（对于 ``lte`` 情况，我们可以使用 SQL ``BETWEEN``）。"

msgid ""
"So we would like ``Experiment.objects.filter(change__abs__lt=27)`` to "
"generate the following SQL::"
msgstr ""
"因此, 我们希望 ``Experiment.objects.filter(change__abs__lt=27)`` 能生成以下 "
"SQL::"

msgid "The implementation is::"
msgstr "实现方式是::"

msgid ""
"There are a couple of notable things going on. First, "
"``AbsoluteValueLessThan`` isn't calling ``process_lhs()``. Instead it skips "
"the transformation of the ``lhs`` done by ``AbsoluteValue`` and uses the "
"original ``lhs``. That is, we want to get ``\"experiments\".\"change\"`` not "
"``ABS(\"experiments\".\"change\")``. Referring directly to ``self.lhs.lhs`` "
"is safe as ``AbsoluteValueLessThan`` can be accessed only from the "
"``AbsoluteValue`` lookup, that is the ``lhs`` is always an instance of "
"``AbsoluteValue``."
msgstr ""
"这里有几件值得注意的事情。首先，``AbsoluteValueLessThan`` 没有调用 "
"``process_lhs()``。 相反，它会跳过由 ``AbsoluteValue`` 完成的 ``lhs`` 的转"
"换，并使用原始的 ``lhs``。也就是说，我们希望得到 ``\"experiments\".\"change"
"\"``，而不是 ``ABS(\"experiments\".\"change\")`` 。直接引用 ``self.lhs.lhs`` "
"是安全的，因为 ``AbsoluteValueLessThan`` 只能从 ``AbsoluteValue`` lookup 访"
"问，即 ``lhs`` 总是 ``AbsoluteValue`` 的实例。"

msgid ""
"Notice also that  as both sides are used multiple times in the query the "
"params need to contain ``lhs_params`` and ``rhs_params`` multiple times."
msgstr ""
"另请注意，由于在查询中多次使用两边，所以需要多次包含 ``lhs_params`` 和 "
"``rhs_params`` 参数。"

msgid ""
"The final query does the inversion (``27`` to ``-27``) directly in the "
"database. The reason for doing this is that if the ``self.rhs`` is something "
"else than a plain integer value (for example an ``F()`` reference) we can't "
"do the transformations in Python."
msgstr ""
"最后的查询直接在数据库中进行反转（ `27` 到 `-27` ）。 这样做的原因是，如果 "
"``self.rhs`` 不是普通的整数值（例如 `F()` 引用），我们就不能在 Python 中进行"
"转换。"

msgid ""
"In fact, most lookups with ``__abs`` could be implemented as range queries "
"like this, and on most database backends it is likely to be more sensible to "
"do so as you can make use of the indexes. However with PostgreSQL you may "
"want to add an index on ``abs(change)`` which would allow these queries to "
"be very efficient."
msgstr ""
"实际上，大多数的利用 ``__abs`` 的查找都可以被转换为类似此的范围查找，且在大多"
"数数据库后端来说，这样做能更好的利用索引。不过，对于 PostgreSQL，你可能会为 "
"``abs(change)`` 添加索引，这会使查找更加高效。"

msgid "A bilateral transformer example"
msgstr "一个双向转换器示例"

msgid ""
"The ``AbsoluteValue`` example we discussed previously is a transformation "
"which applies to the left-hand side of the lookup. There may be some cases "
"where you want the transformation to be applied to both the left-hand side "
"and the right-hand side. For instance, if you want to filter a queryset "
"based on the equality of the left and right-hand side insensitively to some "
"SQL function."
msgstr ""
"前文所述的 ``AbsoluteValue`` 例子实现了左侧查询。在某些场景下，你期望转换器同"
"时作用于左侧和右侧。例如，如果你想在左侧基于等式进行过滤，而右侧对于某些 SQL "
"函数不敏感。"

msgid ""
"Let's examine the simple example of case-insensitive transformation here. "
"This transformation isn't very useful in practice as Django already comes "
"with a bunch of built-in case-insensitive lookups, but it will be a nice "
"demonstration of bilateral transformations in a database-agnostic way."
msgstr ""
"让我们在此测试这个简单的大小写转换器。这个转换器实际上不是非常实用，因为 "
"Django 早已内置了一堆大小写敏感查询器，但它很好的以一种与数据库无关的方式演示"
"了双向转换。"

msgid ""
"We define an ``UpperCase`` transformer which uses the SQL function "
"``UPPER()`` to transform the values before comparison. We define :attr:"
"`bilateral = True <django.db.models.Transform.bilateral>` to indicate that "
"this transformation should apply to both ``lhs`` and ``rhs``::"
msgstr ""
"我们定义了一个 ``UpperCase`` 转换器，使用了 SQL 函数 ``UPPER()``，在比较之前"
"转换值。我们定义了:attr:`bilateral = True <django.db.models.Transform."
"bilateral>` 指明此转换应同时用于 ``lhs`` 和 ``rhs``::"

msgid "Next, let's register it::"
msgstr "下一步, 让我们注册它::"

msgid ""
"Now, the queryset ``Author.objects.filter(name__upper=\"doe\")`` will "
"generate a case insensitive query like this::"
msgstr ""
"现在，这个查询集 ``Author.objects.filter(name__upper=\"doe\")`` 会生成一个像"
"这样的不区分大小写的查询::"

msgid "Writing alternative implementations for existing lookups"
msgstr "为现有的查找编写代替实现"

msgid ""
"Sometimes different database vendors require different SQL for the same "
"operation. For this example we will rewrite a custom implementation for "
"MySQL for the NotEqual operator. Instead of ``<>`` we will be using ``!=`` "
"operator. (Note that in reality almost all databases support both, including "
"all the official databases supported by Django)."
msgstr ""
"有时候，不同的数据库提供商对相同的操作要求不同的 SQL 语句。针对此例子，我们会"
"为 MySQL 重写 NotEqual 操作符。使用 ``!=`` 操作符替代 ``<>``。（注意，实际上"
"几乎所有的数据两者都支持，包括 Django 支持的所有正式数据库）。"

msgid ""
"We can change the behavior on a specific backend by creating a subclass of "
"``NotEqual`` with an ``as_mysql`` method::"
msgstr ""
"我们可以通过使用 ``as_mysql`` 方法创建 ``NotEqual`` 的子类来更改特定后端的行"
"为::"

msgid ""
"We can then register it with ``Field``. It takes the place of the original "
"``NotEqual`` class as it has the same ``lookup_name``."
msgstr ""
"接着，我们可以里利用 ``Field`` 注册它。它会替换之前的 ``NotEqual`` 类，因为拥"
"有相同的 ``lookup_name``。"

msgid ""
"When compiling a query, Django first looks for ``as_%s % connection.vendor`` "
"methods, and then falls back to ``as_sql``. The vendor names for the in-"
"built backends are ``sqlite``, ``postgresql``, ``oracle`` and ``mysql``."
msgstr ""
"编译查询指令是，Django 先查找 ``as_%s % connection.vendor`` 方法，其次 "
"``as_sql``。内置后端的提供商名为 ``sqlite``，``postgresql``，``oracle`` 和 "
"``mysql``。"

msgid "How Django determines the lookups and transforms which are used"
msgstr "Django 是如何取舍查询器和转换器的"

msgid ""
"In some cases you may wish to dynamically change which ``Transform`` or "
"``Lookup`` is returned based on the name passed in, rather than fixing it. "
"As an example, you could have a field which stores coordinates or an "
"arbitrary dimension, and wish to allow a syntax like ``."
"filter(coords__x7=4)`` to return the objects where the 7th coordinate has "
"value 4. In order to do this, you would override ``get_lookup`` with "
"something like::"
msgstr ""
"某些场景下，你可能期望基于传入的名字动态地返回 ``Transform`` 或 ``Lookup``，"
"而不是指定。例如，有一个字段，存储了一些坐标或尺寸，期望使用以下语法 ``."
"filter(coords__x7=4)`` 返回第七个值为 4 的坐标。为此，你需要用以下内容重写 "
"``get_lookup``::"

msgid ""
"You would then define ``get_coordinate_lookup`` appropriately to return a "
"``Lookup`` subclass which handles the relevant value of ``dimension``."
msgstr ""
"随后你需要定义 ``get_coordinate_lookup`` 正确地返回一个 ``Lookup`` 子类，用于"
"处理 ``dimension`` 的相关值。"

msgid ""
"There is a similarly named method called ``get_transform()``. "
"``get_lookup()`` should always return a ``Lookup`` subclass, and "
"``get_transform()`` a ``Transform`` subclass. It is important to remember "
"that ``Transform`` objects can be further filtered on, and ``Lookup`` "
"objects cannot."
msgstr ""
"有个类似的名字叫做 ``get_transform()``。``get_lookup()`` 总是要返回 "
"``Lookup`` 子类，而 ``get_transform`` 要返回 ``Transform`` 子类。千万牢记，"
"``Transform`` 对象能被进一步过滤，而 ``Lookup`` 对象不能。"

msgid ""
"When filtering, if there is only one lookup name remaining to be resolved, "
"we will look for a ``Lookup``. If there are multiple names, it will look for "
"a ``Transform``. In the situation where there is only one name and a "
"``Lookup`` is not found, we look for a ``Transform`` and then the ``exact`` "
"lookup on that ``Transform``. All call sequences always end with a "
"``Lookup``. To clarify:"
msgstr ""
"过滤时，若只能找到一个名字，我们会查找 ``Lookup``。如果有多个名字，将会寻找 "
"``Transform``。在某种情况下，仅有一个名字，且未找到 ``Lookup``，我们将查找 "
"``Transform``，并附加 ``exact`` 查询器。所以的系列调用都以一个 ``Lookup`` 结"
"束。简单说明："

msgid ""
"``.filter(myfield__mylookup)`` will call ``myfield.get_lookup('mylookup')``."
msgstr ""
"``.filter(myfield__mylookup)`` 将会调用 ``myfield.get_lookup('mylookup')``。"

msgid ""
"``.filter(myfield__mytransform__mylookup)`` will call ``myfield."
"get_transform('mytransform')``, and then ``mytransform."
"get_lookup('mylookup')``."
msgstr ""
"``.filter(myfield__mytransform__mylookup)`` 将会调用 ``myfield."
"get_transform('mytransform')``, 接着调用 ``mytransform."
"get_lookup('mylookup')``。"

msgid ""
"``.filter(myfield__mytransform)`` will first call ``myfield."
"get_lookup('mytransform')``, which will fail, so it will fall back to "
"calling ``myfield.get_transform('mytransform')`` and then ``mytransform."
"get_lookup('exact')``."
msgstr ""
"``.filter(myfield__mytransform)`` 会先调用 ``myfield."
"get_lookup('mytransform')``，失败，然后回滚调用 ``myfield."
"get_transform('mytransform')``，随后返回 ``mytransform."
"get_lookup('exact')``。"

msgid "Writing custom ``django-admin`` commands"
msgstr "编写自定义 ``django-admin`` 命令"

msgid ""
"Applications can register their own actions with ``manage.py``. For example, "
"you might want to add a ``manage.py`` action for a Django app that you're "
"distributing. In this document, we will be building a custom ``closepoll`` "
"command for the ``polls`` application from the :doc:`tutorial</intro/"
"tutorial01>`."
msgstr ""
"应用能通过 ``manage.py`` 注册自定义活动。例如，你想为你发布的一个 Django 应用"
"添加 ``manage.py`` 行为。我们将为 :doc:`教程 </intro/tutorial01>` 中的 "
"``polls`` 应用构建自定义 ``closepoll`` 命令。"

msgid ""
"To do this, just add a ``management/commands`` directory to the application. "
"Django will register a ``manage.py`` command for each Python module in that "
"directory whose name doesn't begin with an underscore. For example::"
msgstr ""
"为达此目的，只需为应用添加一个 ``management/commands`` 目录。Django 会为每个"
"名字不以下划线开头的 Python 模块注册一个 ``manage.py`` 命令。比如::"

msgid ""
"In this example, the ``closepoll`` command will be made available to any "
"project that includes the ``polls`` application in :setting:`INSTALLED_APPS`."
msgstr ""
"在本例中，``closepoll`` 命令将对 :setting:`INSTALLED_APPS` 配置的所有包含 "
"``polls`` 应用的项目可用。"

msgid ""
"The ``_private.py`` module will not be available as a management command."
msgstr "``_private.py`` 模型不会以管理命令的形式提供。"

msgid ""
"The ``closepoll.py`` module has only one requirement -- it must define a "
"class ``Command`` that extends :class:`BaseCommand` or one of its :ref:"
"`subclasses<ref-basecommand-subclasses>`."
msgstr ""
"``closepoll.py`` 模块只有一个要求——必须定义 ``Command`` 类，继承自 :class:"
"`BaseCommand` 或其子类。"

msgid "Standalone scripts"
msgstr "独立的脚本"

msgid ""
"Custom management commands are especially useful for running standalone "
"scripts or for scripts that are periodically executed from the UNIX crontab "
"or from Windows scheduled tasks control panel."
msgstr ""
"自定义管理命令在运行独立脚本命令方面十分有用，也可用于 UNIX 的周期性 crontab "
"任务，或是 Windows 的定时任务。"

msgid ""
"To implement the command, edit ``polls/management/commands/closepoll.py`` to "
"look like this::"
msgstr "为实现此命令，像这样编辑 ``polls/management/commands/closepoll.py``::"

msgid ""
"When you are using management commands and wish to provide console output, "
"you should write to ``self.stdout`` and ``self.stderr``, instead of printing "
"to ``stdout`` and ``stderr`` directly. By using these proxies, it becomes "
"much easier to test your custom command. Note also that you don't need to "
"end messages with a newline character, it will be added automatically, "
"unless you specify the ``ending`` parameter::"
msgstr ""
"当你使用管理命令时，期望在终端输出内容，你需要 write 至 ``self.stdout`` 和 "
"``self.stderr``，而不是直接 print 至 ``stdout`` 和 ``stderr``。利用这些代理，"
"测试定义命令会更方便。也请注意下，你不需要为消息添加一个新行字符，它会自动添"
"加，除非你指定了 ``ending`` 参数::"

msgid ""
"The new custom command can be called using ``python manage.py closepoll "
"<poll_ids>``."
msgstr "这个新的自定义命令能用 ``python manage.py closepoll <poll_id>`` 调用。"

msgid ""
"The ``handle()`` method takes one or more ``poll_ids`` and sets ``poll."
"opened`` to ``False`` for each one. If the user referenced any nonexistent "
"polls, a :exc:`CommandError` is raised. The ``poll.opened`` attribute does "
"not exist in the :doc:`tutorial</intro/tutorial01>` and was added to ``polls."
"models.Question`` for this example."
msgstr ""
"``handle()`` 方法接受一个或多个 ``poll_ids``，并将每个 ``poll.opened`` 设置"
"为 ``False``。若用户传入了不存在的 polls，将会抛出 :exc:`CommandError`。:doc:"
"`教程 </intro/tutorial01>` 中不存在 ``poll.opened`` 属性，只是这里为了本例添"
"加至 ``polls.models.Question`` 的。"

msgid "Accepting optional arguments"
msgstr "接受可选参数"

msgid ""
"The same ``closepoll`` could be easily modified to delete a given poll "
"instead of closing it by accepting additional command line options. These "
"custom options can be added in the :meth:`~BaseCommand.add_arguments` method "
"like this::"
msgstr ""
"``closepoll`` 通过简单地添加几个命令选项，就能删除指定 poll，替代之前的关闭行"
"为。这些自定义选项能被加入至 :meth:`~BaseCommand.add_arguments` 方法，就像这"
"样::"

msgid ""
"The option (``delete`` in our example) is available in the options dict "
"parameter of the handle method. See the :py:mod:`argparse` Python "
"documentation for more about ``add_argument`` usage."
msgstr ""
"选项（本例中 ``delete``）是由 handle 方法的 options 字典参数传入的。参见 "
"Python 文档查询 :py:mod:`argparse`，获取更多 ``add_argument`` 的用法。"

msgid ""
"In addition to being able to add custom command line options, all :doc:"
"`management commands</ref/django-admin>` can accept some default options "
"such as :option:`--verbosity` and :option:`--traceback`."
msgstr ""
"为了能添加自定义命令选项，所以的 :doc:`管理命令 </ref/django-admin>` 都能接受"
"一些默认选项，例如 :option:`--verbosity` 和 :option:`--traceback`。"

msgid "Management commands and locales"
msgstr "管理命令和地点(locales)"

msgid ""
"By default, management commands are executed with the current active locale."
msgstr "默认情况下，管理命令以当前激活地点执行。"

msgid ""
"If, for some reason, your custom management command must run without an "
"active locale (for example, to prevent translated content from being "
"inserted into the database), deactivate translations using the "
"``@no_translations`` decorator on your :meth:`~BaseCommand.handle` method::"
msgstr ""
"如果出于某些原因，自定义管理命令必须不以某个地点执行（比如，为了避免将已翻译"
"的内容存入数据库），可在 :meth:`~BaseCommand.handle` 方法中利用 "
"``@no_translations`` 装饰器禁用翻译行为::"

msgid ""
"Since translation deactivation requires access to configured settings, the "
"decorator can't be used for commands that work without configured settings."
msgstr ""
"由于禁用翻译需要使用配置文件，故装饰器不能用于那些不加载配置文件的命令。"

msgid ""
"The ``@no_translations`` decorator is new. In older versions, translations "
"are deactivated before running a command unless the command's "
"``leave_locale_alone`` attribute (now removed) is set to ``True``."
msgstr ""
"``@no_tanslations`` 装饰器是新的。在旧版本中，运行命令时，翻译行为默认是关闭"
"的，除非命令的 ``leave_locale_alone`` 属性（现已移除）被置为 ``True``。"

msgid "Testing"
msgstr "测试"

msgid ""
"Information on how to test custom management commands can be found in the :"
"ref:`testing docs <topics-testing-management-commands>`."
msgstr ""
"关于如何测试自定义管理命令的内容可在 :ref:`测试文档 <topics-testing-"
"management-commands>` 中找到。"

msgid "Overriding commands"
msgstr "覆盖命令"

msgid ""
"Django registers the built-in commands and then searches for commands in :"
"setting:`INSTALLED_APPS` in reverse. During the search, if a command name "
"duplicates an already registered command, the newly discovered command "
"overrides the first."
msgstr ""
"Django 先注册内置命令，然后按相反的顺序在 :setting:`INSTALLED_APPS` 查找命"
"令。在查找时，如果一个命令和已注册的命令重名，这个新发现的命令会覆盖第一个命"
"令。"

msgid ""
"In other words, to override a command, the new command must have the same "
"name and its app must be before the overridden command's app in :setting:"
"`INSTALLED_APPS`."
msgstr ""
"换句话说，为了覆盖一个命令，新命令必须有同样的名字并且它的 app 在 :setting:"
"`INSTALLED_APPS` 中必须排在被覆盖命令 app 的前面。"

msgid ""
"Management commands from third-party apps that have been unintentionally "
"overridden can be made available under a new name by creating a new command "
"in one of your project's apps (ordered before the third-party app in :"
"setting:`INSTALLED_APPS`) which imports the ``Command`` of the overridden "
"command."
msgstr ""
"第三方应用提供的管理命令若被不小心重写，能通过在你项目中的某个应用（在 :"
"setting:`INSTALLED_APPS` 配置在第三方应用之前）创建新命令的方式为其取个别名，"
"另其能被调用。这个应用需要导入被重写的 ``Command``。"

msgid "Command objects"
msgstr "命令对象"

msgid "The base class from which all management commands ultimately derive."
msgstr "所有管理命令最终派生的基类。"

msgid ""
"Use this class if you want access to all of the mechanisms which parse the "
"command-line arguments and work out what code to call in response; if you "
"don't need to change any of that behavior, consider using one of its :ref:"
"`subclasses<ref-basecommand-subclasses>`."
msgstr ""
"如果你想处理解析命令行参数，决定调用什么代码的过程，使用这个类。如果你不需要"
"改变任何行为，考虑直接使用它的某个 :ref:`子类 <ref-basecommand-subclasses>`。"

msgid ""
"Subclassing the :class:`BaseCommand` class requires that you implement the :"
"meth:`~BaseCommand.handle` method."
msgstr ""
"继承 :class:`BaseCommand` 要求你重写 :meth:`~BaseCommand.handle` 方法。"

msgid "Attributes"
msgstr "属性"

msgid ""
"All attributes can be set in your derived class and can be used in :class:"
"`BaseCommand`’s :ref:`subclasses<ref-basecommand-subclasses>`."
msgstr ""
"能被你派生的子类设置的，且能被 :class:`BaseCommand` 的 :ref:`子类 <ref-"
"basecommand-subclasses>` 使用的属性。"

msgid ""
"A short description of the command, which will be printed in the help "
"message when the user runs the command ``python manage.py help <command>``."
msgstr ""
"命令简介，当用户运行命令 ``python manage.py help <command>`` 时包含在打印的帮"
"助信息内。"

msgid ""
"If your command defines mandatory positional arguments, you can customize "
"the message error returned in the case of missing arguments. The default is "
"output by :py:mod:`argparse` (\"too few arguments\")."
msgstr ""
"如果你的命令定义了必须的位置参数，你可以在缺失参数时返回自定义错误消息。默认"
"输出由 :py:mod:`argparse` 打印(\"too few arguments\")。"

msgid ""
"A boolean indicating whether the command outputs SQL statements; if "
"``True``, the output will automatically be wrapped with ``BEGIN;`` and "
"``COMMIT;``. Default value is ``False``."
msgstr ""
"一个布尔值，决定命令是否暑输出 SQL 语句；若为 ``True``，输出内容会自动以 "
"``BEGIN;`` 和 ``COMMIT;`` 包裹。默认值为 ``False``。"

msgid ""
"A boolean; if ``True``, the command prints a warning if the set of "
"migrations on disk don't match the migrations in the database. A warning "
"doesn't prevent the command from executing. Default value is ``False``."
msgstr ""
"一个布尔值；若为 ``True``，命令会在硬盘上存储的 migrations 与 数据库中的不一"
"致时打印警告。警告不会阻止命令执行。默认值为 ``False``。"

msgid ""
"A boolean; if ``True``, the entire Django project will be checked for "
"potential problems prior to executing the command. Default value is ``True``."
msgstr ""
"一个布尔值；若为 ``True``，会在执行命令前完整地检验 Django 项目，确定是否有潜"
"在的问题。默认值为 ``True``。"

msgid ""
"An instance attribute that helps create colored output when writing to "
"``stdout`` or ``stderr``. For example::"
msgstr "一个实例属性，用于向 ``stdout`` 或 ``stderr`` 输出彩色内容。例如::"

msgid ""
"See :ref:`syntax-coloring` to learn how to modify the color palette and to "
"see the available styles (use uppercased versions of the \"roles\" described "
"in that section)."
msgstr ""
"参考 :ref:`syntax-coloring` 了解如何修改调色板与现成的样式（使用本节介绍的大"
"写字母版本的 \"roles\"）。"

msgid ""
"If you pass the :option:`--no-color` option when running your command, all "
"``self.style()`` calls will return the original string uncolored."
msgstr ""
"如果运行命令时传递了 :option:`--no-color` 选项，所有的 ``self.style()`` 调用"
"会返回未染色的原始字符串。"

msgid "Methods"
msgstr "方法"

msgid ""
":class:`BaseCommand` has a few methods that can be overridden but only the :"
"meth:`~BaseCommand.handle` method must be implemented."
msgstr ""
":class:`BaseCommand` 有很多方法可供重写，不过仅有 :meth:`~BaseCommand."
"handle` 是必须实现的。"

msgid "Implementing a constructor in a subclass"
msgstr "子类中实现构造器"

msgid ""
"If you implement ``__init__`` in your subclass of :class:`BaseCommand`, you "
"must call :class:`BaseCommand`’s ``__init__``::"
msgstr ""
"若 :class:`BaseCommand` 的子类实现了 ``__init__`` 方法，那么就必须调用 :"
"class:`BaseCommand` 的 ``__init__``::"

msgid ""
"Returns a ``CommandParser`` instance, which is an :class:`~argparse."
"ArgumentParser` subclass with a few customizations for Django."
msgstr ""
"返回一个 ``CommandParser`` 实例，它是 :class:`~argparse.ArgumentParser` 的子"
"类，包含一些针对 Django 的个性化设计。"

msgid ""
"You can customize the instance by overriding this method and calling "
"``super()`` with ``kwargs`` of :class:`~argparse.ArgumentParser` parameters."
msgstr ""
"你可以自定义这个实例，通过重写此方法，并为  ``super()`` 方法传入值为 :class:"
"`~argparse.ArgumentParser` 的 ``kwargs`` 参数。"

msgid "``kwargs`` was added."
msgstr "``kwargs`` 被添加了。"

msgid ""
"Entry point to add parser arguments to handle command line arguments passed "
"to the command. Custom commands should override this method to add both "
"positional and optional arguments accepted by the command. Calling "
"``super()`` is not needed when directly subclassing ``BaseCommand``."
msgstr ""
"添加命令行转换参数的入口，用于处理传给命令行的参数。自定义命令需要重写此方"
"法，并同时添加命令接受的位置参数和可选参数。直接使用 ``BaseCommand`` 的子类时"
"无需调用 ``super()``。"

msgid ""
"Returns the Django version, which should be correct for all built-in Django "
"commands. User-supplied commands can override this method to return their "
"own version."
msgstr ""
"返回 Django 版本，内置 Django 命令必须正确返回。用户实现的命令可以重写此方法"
"返回自己的版本。"

msgid ""
"Tries to execute this command, performing system checks if needed (as "
"controlled by the :attr:`requires_system_checks` attribute). If the command "
"raises a :exc:`CommandError`, it's intercepted and printed to stderr."
msgstr ""
"试着执行此命令，如果需要的话，进行系统检查（由 :attr:"
"`requires_system_checks` 控制）。若命令抛出 :exc:`CommandError`，这会导致命令"
"中断，并将错误输出至 stderr。"

msgid "Calling a management command in your code"
msgstr "在你的代码中调用管理命令"

msgid ""
"``execute()`` should not be called directly from your code to execute a "
"command. Use :func:`~django.core.management.call_command` instead."
msgstr ""
"执行命令时，不要从代码直接调用 ``execute()`` 方法。而是使用 :func:`~django."
"core.management.call_command`。"

msgid "The actual logic of the command. Subclasses must implement this method."
msgstr "命令的实际逻辑处理。子类必须实现此方法。"

msgid ""
"It may return a string which will be printed to ``stdout`` (wrapped by "
"``BEGIN;`` and ``COMMIT;`` if :attr:`output_transaction` is ``True``)."
msgstr ""
"此方法可能会返回一个字符串，输出至 ``stdout`` （若 :attr:"
"`output_transaction` 为 ``True``，则由 ``BEGIN;`` 和 ``COMMIT`` 包裹）。"

msgid ""
"Uses the system check framework to inspect the entire Django project for "
"potential problems. Serious problems are raised as a :exc:`CommandError`; "
"warnings are output to stderr; minor notifications are output to stdout."
msgstr ""
"利用系统检查框架校验 Django 项目是否存在隐含的问题。严重的问题会抛出 :exc:"
"`CommandError`；警告会输出至 stderr；次要通知输出至 stdout。"

msgid ""
"If ``app_configs`` and ``tags`` are both ``None``, all system checks are "
"performed. ``tags`` can be a list of check tags, like ``compatibility`` or "
"``models``."
msgstr ""
"若 ``app_configs`` 和 ``tags`` 均为 ``None``，所以的系统检查项都会被运行。"
"``tags`` 能是一个检查标签的列表，例如 ``compatibility`` 或 ``models``。"

msgid "``BaseCommand`` subclasses"
msgstr "``BaseCommand`` 的子类"

msgid ""
"A management command which takes one or more installed application labels as "
"arguments, and does something with each of them."
msgstr "管理命令接受一个或多个应用标签参数，并对每项应用做某些事。"

msgid ""
"Rather than implementing :meth:`~BaseCommand.handle`, subclasses must "
"implement :meth:`~AppCommand.handle_app_config`, which will be called once "
"for each application."
msgstr ""
"子类必须实现 :meth:`~AppCommand.handle_app_config`，而不是 :meth:"
"`~BaseCommand.handle`。此方法会为每个应用调用一次。"

msgid ""
"Perform the command's actions for ``app_config``, which will be an :class:"
"`~django.apps.AppConfig` instance corresponding to an application label "
"given on the command line."
msgstr ""
"为 ``app_config`` 运行命令，这会是 :class:`~django.apps.AppConfig` 的实例，并"
"指向命令行给定的应用标签。"

msgid ""
"A management command which takes one or more arbitrary arguments (labels) on "
"the command line, and does something with each of them."
msgstr ""
"一个管理命令，从命令行接受一个或任意多个参数(labels)，并针对每项做些事情。"

msgid ""
"Rather than implementing :meth:`~BaseCommand.handle`, subclasses must "
"implement :meth:`~LabelCommand.handle_label`, which will be called once for "
"each label."
msgstr ""
"子类必须实现 :meth:`~LabelCommand.handle_label`，而不是 :meth:`~BaseCommand."
"handle`。此方法会为每个应用调用一次。"

msgid ""
"A string describing the arbitrary arguments passed to the command. The "
"string is used in the usage text and error messages of the command. Defaults "
"to ``'label'``."
msgstr ""
"一个字符串，介绍了传递给命令的任意多个参数。此字符串用于命令的用法文本和错误"
"消息。默认为 ``'label'``。"

msgid ""
"Perform the command's actions for ``label``, which will be the string as "
"given on the command line."
msgstr "运行 ``label`` 指定的命令动作，由命令行传入的字符串指定。"

msgid "Command exceptions"
msgstr "命令异常"

msgid ""
"Exception class indicating a problem while executing a management command."
msgstr "异常类说明在运行管理命令时出错了。"

msgid ""
"If this exception is raised during the execution of a management command "
"from a command line console, it will be caught and turned into a nicely-"
"printed error message to the appropriate output stream (i.e., stderr); as a "
"result, raising this exception (with a sensible description of the error) is "
"the preferred way to indicate that something has gone wrong in the execution "
"of a command."
msgstr ""
"如果异常是在命令行控制台运行管理命令时抛出的，它会被捕获，并转换为打印友好的"
"错误信息，输出至合适的流（例如 stderr）;作为结果，抛出异常（包含清晰的错误介"
"绍）是一个不错的说明运行命令过程中出错的方式。"

msgid ""
"If a management command is called from code through :func:`~django.core."
"management.call_command`, it's up to you to catch the exception when needed."
msgstr ""
"如果管理命令是由 :func:`~django.core.management.call_command` 调用的，是否捕"
"获异常取决于你。"

msgid "Writing custom model fields"
msgstr "编写自定义模型字段(model fields)"

msgid "Introduction"
msgstr "介绍"

msgid ""
"The :doc:`model reference </topics/db/models>` documentation explains how to "
"use Django's standard field classes -- :class:`~django.db.models."
"CharField`, :class:`~django.db.models.DateField`, etc. For many purposes, "
"those classes are all you'll need. Sometimes, though, the Django version "
"won't meet your precise requirements, or you'll want to use a field that is "
"entirely different from those shipped with Django."
msgstr ""
":doc:`字段参考 </topics/db/models>` 文档介绍了如何使用 Django 的标准字段类"
"—— :class:`~django.db.models.CharField`， :class:`~django.db.models."
"DateField`，等等。大多数情况下，这些类就是你需要的。虽然有时候，Django 的版本"
"不能精确地匹配你的需求，或者你想使用的字段与 Django 内置的完全不同。"

msgid ""
"Django's built-in field types don't cover every possible database column "
"type -- only the common types, such as ``VARCHAR`` and ``INTEGER``. For more "
"obscure column types, such as geographic polygons or even user-created types "
"such as `PostgreSQL custom types`_, you can define your own Django ``Field`` "
"subclasses."
msgstr ""
"Django 内置的字段类型并未覆盖所有可能的数据库字段类型——只有常见的类型，例如 "
"``VARCHAR`` 和 ``INTEGER``。对于更多模糊的列类型，例如地理多边形（geographic "
"polygons），甚至是用户创建的类型，例如 `PostgreSQL custom types`_，你可以自定"
"义 Django 的 ``Field`` 子类。"

msgid ""
"Alternatively, you may have a complex Python object that can somehow be "
"serialized to fit into a standard database column type. This is another case "
"where a ``Field`` subclass will help you use your object with your models."
msgstr ""
"或者，你有一个复杂的 Python 对象，它可以以某种形式序列化，适应标准的数据库列"
"类型。这是另一个 ``Field`` 子类能帮助你配合模型使用你的对象的示例。"

msgid "Our example object"
msgstr "我们的示例对象"

msgid ""
"Creating custom fields requires a bit of attention to detail. To make things "
"easier to follow, we'll use a consistent example throughout this document: "
"wrapping a Python object representing the deal of cards in a hand of "
"Bridge_. Don't worry, you don't have to know how to play Bridge to follow "
"this example. You only need to know that 52 cards are dealt out equally to "
"four players, who are traditionally called *north*, *east*, *south* and "
"*west*.  Our class looks something like this::"
msgstr ""
"创建自定义字段要求注意一些细节。为了简化问题，我们在本文档中全程使用同一实"
"例：封装一个 Python 对象，代表手上 桥牌_ 的细节。不要担心，你不需要知道如何玩"
"桥牌就能学习此例子。你只需知道 52 张牌被均分给 4 个玩家，一般称他们 *北*，*东"
"*，*南* 和 *西*。我们的类长这样::"

msgid ""
"This is just an ordinary Python class, with nothing Django-specific about "
"it. We'd like to be able to do things like this in our models (we assume the "
"``hand`` attribute on the model is an instance of ``Hand``)::"
msgstr ""
"这仅是个普通的 Python 类，不添加任何 Django 指定的内容。我们对模型做这样的事"
"（我们假定模型 ``hand`` 属性的值为 ``Hand`` 的实例）::"

msgid ""
"We assign to and retrieve from the ``hand`` attribute in our model just like "
"any other Python class. The trick is to tell Django how to handle saving and "
"loading such an object."
msgstr ""
"对模型中的 ``hand`` 属性的赋值与取值操作与其它 Python 类一直。技巧是告诉 "
"Django 如何保存和加载对象。"

msgid ""
"In order to use the ``Hand`` class in our models, we **do not** have to "
"change this class at all. This is ideal, because it means you can easily "
"write model support for existing classes where you cannot change the source "
"code."
msgstr ""
"为了在模型中使用 ``Hand`` 类，我们 **不** 需要修改这个类。这很不错，因为这以"
"为着你仅需为已存在的类编写模型支持，即便你不能修改源码。"

msgid ""
"You might only be wanting to take advantage of custom database column types "
"and deal with the data as standard Python types in your models; strings, or "
"floats, for example. This case is similar to our ``Hand`` example and we'll "
"note any differences as we go along."
msgstr ""
"你可能只想要自定义数据库列的优点，并在模型中像使用标准 Python 那样；字符串，"
"或浮点数，等等。这种情况与 ``Hand`` 例子类似，在进行过程中，我们将注意到差"
"异。"

msgid "Background theory"
msgstr "背后的理论"

msgid "Database storage"
msgstr "数据库存储"

msgid ""
"The simplest way to think of a model field is that it provides a way to take "
"a normal Python object -- string, boolean, ``datetime``, or something more "
"complex like ``Hand`` -- and convert it to and from a format that is useful "
"when dealing with the database (and serialization, but, as we'll see later, "
"that falls out fairly naturally once you have the database side under "
"control)."
msgstr ""
"最简单的理解模型字段的方式就是它以 Python 对象的方式展示——字符串，布尔值， "
"``datetime``，或其它更复杂的东西，比如 ``Hand``——将它与某种格式之间来回转换，"
"这在处理数据库（或序列化）时很有用（但是，像我们稍后看到的，一旦您控制了数据"
"库端，就会很自然地出现这种情况）。"

msgid ""
"Fields in a model must somehow be converted to fit into an existing database "
"column type. Different databases provide different sets of valid column "
"types, but the rule is still the same: those are the only types you have to "
"work with. Anything you want to store in the database must fit into one of "
"those types."
msgstr ""
"模型中的字段必须能以某种方式转换为已存在的数据库列类型。不能的数据库提供不同"
"的可用列类型集，但规则仍相同：你只需要处理这些类型。你想存在数据库中的任何数"
"据都必须能适配这些类型中的某一个。"

msgid ""
"Normally, you're either writing a Django field to match a particular "
"database column type, or there's a fairly straightforward way to convert "
"your data to, say, a string."
msgstr ""
"一般来说，你可以编写一个 Django 字段来适配特定是数据库列类型，或者已存在一个"
"直接承载你数据的类型，例如，字符串。"

msgid ""
"For our ``Hand`` example, we could convert the card data to a string of 104 "
"characters by concatenating all the cards together in a pre-determined order "
"-- say, all the *north* cards first, then the *east*, *south* and *west* "
"cards. So ``Hand`` objects can be saved to text or character columns in the "
"database."
msgstr ""
"对于我们的 ``Hand`` 示例，我们能将卡片数据转换为一个 104 个字符的字符串，通过"
"以预定义的顺序连接所有卡片——也就是说，先连接 *北* 所拥有的卡，随后是 *东*， *"
"南*，和 *西*。所有 ``Hand`` 对象能被保存在数据库中的文本或字符列中。"

msgid "What does a field class do?"
msgstr "一个字段(Field)类做了什么？"

msgid ""
"All of Django's fields (and when we say *fields* in this document, we always "
"mean model fields and not :doc:`form fields </ref/forms/fields>`) are "
"subclasses of :class:`django.db.models.Field`. Most of the information that "
"Django records about a field is common to all fields -- name, help text, "
"uniqueness and so forth. Storing all that information is handled by "
"``Field``. We'll get into the precise details of what ``Field`` can do later "
"on; for now, suffice it to say that everything descends from ``Field`` and "
"then customizes key pieces of the class behavior."
msgstr ""
"所有的 Django 字段（本页提到的 *字段* 均指模型字段，而不是 :doc:`表单字段 </"
"ref/forms/fields>`）都是 :class:`django.db.models.Field` 的子类。对于所有字"
"段，Django 记录的大部分信息是一样的——名字，帮助文本，是否唯一，等等。存储行为"
"由 ``Field`` 处理。稍后，我们会深入了解 ``Field`` 能做什么；现在， 可以说万物"
"源于 ``Field``，并在其基础上自定义了类的关键行为。"

msgid ""
"It's important to realize that a Django field class is not what is stored in "
"your model attributes. The model attributes contain normal Python objects. "
"The field classes you define in a model are actually stored in the ``Meta`` "
"class when the model class is created (the precise details of how this is "
"done are unimportant here). This is because the field classes aren't "
"necessary when you're just creating and modifying attributes. Instead, they "
"provide the machinery for converting between the attribute value and what is "
"stored in the database or sent to the :doc:`serializer </topics/"
"serialization>`."
msgstr ""
"了解 Django 字段类不保存在模型属性中很重要。模型属性包含普通的 Python 对象。"
"你所以定义的字段类实际上在模型类创建时在 ``Meta`` 类中（这是如何实现的在这里"
"不重要）。这是因为在仅创建和修改属性时，字段类不是必须的。相反，他们提供了属"
"性值间转换的机制，并决定了什么被存入数据库或发送给 :doc:`序列化器 </topics/"
"serialization>`。"

msgid ""
"Keep this in mind when creating your own custom fields. The Django ``Field`` "
"subclass you write provides the machinery for converting between your Python "
"instances and the database/serializer values in various ways (there are "
"differences between storing a value and using a value for lookups, for "
"example). If this sounds a bit tricky, don't worry -- it will become clearer "
"in the examples below. Just remember that you will often end up creating two "
"classes when you want a custom field:"
msgstr ""
"在你创建自定义字段时牢记这点。你所写的 Django 的 ``Field`` 子类提供了多种在 "
"Python 实例和数据库/序列化器之间的转换机制（比如，保存值和使用值进行查询之间"
"是不同的）。听起来有点迷糊，但别担心——通过以下的例子会清晰起来。只要记住，在"
"你需要一个自定义字段时，只需创建两个类："

msgid ""
"The first class is the Python object that your users will manipulate. They "
"will assign it to the model attribute, they will read from it for displaying "
"purposes, things like that. This is the ``Hand`` class in our example."
msgstr ""
"第一个类是用户需要操作的 Python 对象。它们会复制给模型属性，它们会为了显示而"
"读取属性，就想这样。这里本例中的 ``Hand`` 类。"

msgid ""
"The second class is the ``Field`` subclass. This is the class that knows how "
"to convert your first class back and forth between its permanent storage "
"form and the Python form."
msgstr ""
"第二类是 ``Field`` 的子类。这个类知道如何在永久存储格式和 Python 格式之间来回"
"转换。"

msgid "Writing a field subclass"
msgstr "编写一个 field 子类"

msgid ""
"When planning your :class:`~django.db.models.Field` subclass, first give "
"some thought to which existing :class:`~django.db.models.Field` class your "
"new field is most similar to. Can you subclass an existing Django field and "
"save yourself some work? If not, you should subclass the :class:`~django.db."
"models.Field` class, from which everything is descended."
msgstr ""
"计划编写第一个 :class:`~django.db.models.Field` 子类时，需要先想想新字段和哪"
"个已有的 :class:`~django.db.models.Field` 最相似。你会继承 Django 字段节约你"
"的时间吗？如果不会，你需要继承 :class:`~django.db.models.Field` 类，从它继承"
"了一切。"

msgid ""
"Initializing your new field is a matter of separating out any arguments that "
"are specific to your case from the common arguments and passing the latter "
"to the ``__init__()`` method of :class:`~django.db.models.Field` (or your "
"parent class)."
msgstr ""
"初始化新字段有点麻烦，因为要从公共参数中分离你需要的参数，并将剩下的传给父"
"类 :class:`~django.db.models.Field` 的 ``__init__()`` 方法（或你的父类）。"

msgid ""
"In our example, we'll call our field ``HandField``. (It's a good idea to "
"call your :class:`~django.db.models.Field` subclass ``<Something>Field``, so "
"it's easily identifiable as a :class:`~django.db.models.Field` subclass.) It "
"doesn't behave like any existing field, so we'll subclass directly from :"
"class:`~django.db.models.Field`::"
msgstr ""
"在本例中，我们会调用 ``HandField``。（调用你的 :class:`~django.db.models."
"Field` 子类这个主意也很不错，所以认证为一个 :class:`~django.db.models.Field` "
"很简单。）它并不表现的像任何已存在的字段，所以我们将直接继承自 :class:"
"`~django.db.models.Field`::"

msgid ""
"Our ``HandField`` accepts most of the standard field options (see the list "
"below), but we ensure it has a fixed length, since it only needs to hold 52 "
"card values plus their suits; 104 characters in total."
msgstr ""
"我们的 ``HandField`` 接收大多数标准字段选项（参考下面的列表），但是我们确定参"
"数是定长的，因为它只需要保存 52 个卡片和它们的值；总计 104 个字符。"

msgid ""
"Many of Django's model fields accept options that they don't do anything "
"with. For example, you can pass both :attr:`~django.db.models.Field."
"editable` and :attr:`~django.db.models.DateField.auto_now` to a :class:"
"`django.db.models.DateField` and it will simply ignore the :attr:`~django.db."
"models.Field.editable` parameter (:attr:`~django.db.models.DateField."
"auto_now` being set implies ``editable=False``). No error is raised in this "
"case."
msgstr ""
"许多 Django 模板接收一堆不处理的选项。你可以同时给 :class:`django.db.models."
"DateField` 传入 :attr:`~django.db.models.Field.editable` 和 :attr:`~django."
"db.models.DateField.auto_now`，它会直接忽略 :attr:`~django.db.models.Field."
"editable` 参数（:attr:`~django.db.models.DateField.auto_now` 被设置意味着 "
"``editable=False``）。本例无错误抛出。"

msgid ""
"This behavior simplifies the field classes, because they don't need to check "
"for options that aren't necessary. They just pass all the options to the "
"parent class and then don't use them later on. It's up to you whether you "
"want your fields to be more strict about the options they select, or to use "
"the simpler, more permissive behavior of the current fields."
msgstr ""
"此行为简化了字段类，因为它们无需检查不需要的选项。它们直接将所有选项传给父"
"类，就是后面爸爸不爱。是否对选项应用更严格的规则，还是更简单，更宽容的行为，"
"这取决于你。"

msgid "The ``Field.__init__()`` method takes the following parameters:"
msgstr "``Field.__init__()`` 方法接收以下参数:"

msgid ":attr:`~django.db.models.Field.verbose_name`"
msgstr ":attr:`~django.db.models.Field.verbose_name`"

msgid "``name``"
msgstr "``name``"

msgid ":attr:`~django.db.models.Field.primary_key`"
msgstr ":attr:`~django.db.models.Field.primary_key`"

msgid ":attr:`~django.db.models.CharField.max_length`"
msgstr ":attr:`~django.db.models.CharField.max_length`"

msgid ":attr:`~django.db.models.Field.unique`"
msgstr ":attr:`~django.db.models.Field.unique`"

msgid ":attr:`~django.db.models.Field.blank`"
msgstr ":attr:`~django.db.models.Field.blank`"

msgid ":attr:`~django.db.models.Field.null`"
msgstr ":attr:`~django.db.models.Field.null`"

msgid ":attr:`~django.db.models.Field.db_index`"
msgstr ":attr:`~django.db.models.Field.db_index`"

msgid ""
"``rel``: Used for related fields (like :class:`ForeignKey`). For advanced "
"use only."
msgstr "``rel``: 用于关联字段（像是： :class:`ForeignKey`）。仅用于进阶用途。"

msgid ":attr:`~django.db.models.Field.default`"
msgstr ":attr:`~django.db.models.Field.default`"

msgid ":attr:`~django.db.models.Field.editable`"
msgstr ":attr:`~django.db.models.Field.editable`"

msgid ""
"``serialize``: If ``False``, the field will not be serialized when the model "
"is passed to Django's :doc:`serializers </topics/serialization>`. Defaults "
"to ``True``."
msgstr ""
"``serialize``: 若为 ``False``，字段传给 Django 的 :doc:`序列化器 </topics/"
"serialization>` 时不会被序列化。默认为 ``True``。"

msgid ":attr:`~django.db.models.Field.unique_for_date`"
msgstr ":attr:`~django.db.models.Field.unique_for_date`"

msgid ":attr:`~django.db.models.Field.unique_for_month`"
msgstr ":attr:`~django.db.models.Field.unique_for_month`"

msgid ":attr:`~django.db.models.Field.unique_for_year`"
msgstr ":attr:`~django.db.models.Field.unique_for_year`"

msgid ":attr:`~django.db.models.Field.choices`"
msgstr ":attr:`~django.db.models.Field.choices`"

msgid ":attr:`~django.db.models.Field.help_text`"
msgstr ":attr:`~django.db.models.Field.help_text`"

msgid ":attr:`~django.db.models.Field.db_column`"
msgstr ":attr:`~django.db.models.Field.db_column`"

msgid ""
":attr:`~django.db.models.Field.db_tablespace`: Only for index creation, if "
"the backend supports :doc:`tablespaces </topics/db/tablespaces>`. You can "
"usually ignore this option."
msgstr ""
":attr:`~django.db.models.Field.db_tablespace`: 仅为创建索引，如果后端支持 :"
"doc:`tablespaces </topics/db/tablespaces>`。一般情况下你可以忽略此选项。"

msgid ""
":attr:`~django.db.models.Field.auto_created`: ``True`` if the field was "
"automatically created, as for the :class:`~django.db.models.OneToOneField` "
"used by model inheritance. For advanced use only."
msgstr ""
":attr:`~django.db.models.Field.auto_created`:若字段是自动创建的，则为 "
"``True``，用于 :class:`~django.db.models.OneToOneField` 的模型继承。仅用于进"
"阶用途。"

msgid ""
"All of the options without an explanation in the above list have the same "
"meaning they do for normal Django fields. See the :doc:`field documentation "
"</ref/models/fields>` for examples and details."
msgstr ""
"上述列表中所有无解释的选项与在普通 Django 字段中的作用一样。参见 :doc:`字段文"
"档 </ref/models/fields>` 获取例子和细节信息。"

msgid "Field deconstruction"
msgstr "字段解析"

msgid ""
"The counterpoint to writing your ``__init__()`` method is writing the :meth:"
"`~.Field.deconstruct` method. It's used during :doc:`model migrations </"
"topics/migrations>` to tell Django how to take an instance of your new field "
"and reduce it to a serialized form - in particular, what arguments to pass "
"to ``__init__()`` to re-create it."
msgstr ""
"与编写 ``__init__()`` 方法相对是编写 :meth:`~.Field.deconstruct` 方法。它在 :"
"doc:`模型迁移 </topics/migrations>` 期间告诉 Django 如何获取你的新字段的一个"
"实例，并将其转为序列化形式——特别是，传递什么参数给 ``__init__()`` 来重新创建"
"它。"

msgid ""
"If you haven't added any extra options on top of the field you inherited "
"from, then there's no need to write a new ``deconstruct()`` method. If, "
"however, you're changing the arguments passed in ``__init__()`` (like we are "
"in ``HandField``), you'll need to supplement the values being passed."
msgstr ""
"如果你未在继承的字段之前添加任何选项，就不需要编写新的 ``deconstruct()`` 方"
"法。然而，如果你正在修改传递给 ``__init__()`` 的参数（像 ``HandField`` 中的一"
"样），你需要增补被传递的值。"

msgid ""
"The contract of ``deconstruct()`` is simple; it returns a tuple of four "
"items: the field's attribute name, the full import path of the field class, "
"the positional arguments (as a list), and the keyword arguments (as a dict). "
"Note this is different from the ``deconstruct()`` method :ref:`for custom "
"classes <custom-deconstruct-method>` which returns a tuple of three things."
msgstr ""
"拼接 ``deconstruct()`` 非常简单；它返回包含 4 个项目的原则：字段属性名，字段"
"类的完整导入路径，可选参数（列表），和关键字参数（字典）。注意，这与 :ref:`为"
"自定义类 <custom-deconstruct-method>` 的 ``deconstruct`` 方法不同，它返回包"
"含 3个项目的元组。"

msgid ""
"As a custom field author, you don't need to care about the first two values; "
"the base ``Field`` class has all the code to work out the field's attribute "
"name and import path. You do, however, have to care about the positional and "
"keyword arguments, as these are likely the things you are changing."
msgstr ""
"作为自定义字段的作者，你不需要担心前两个值；基类 ``Field`` 已包含处理字段属性"
"名和导入路径的代码。然后，你仍必须关注位置参数和关键字参数，这些是你最有可能"
"改的东西。"

msgid ""
"For example, in our ``HandField`` class we're always forcibly setting "
"max_length in ``__init__()``. The ``deconstruct()`` method on the base "
"``Field`` class will see this and try to return it in the keyword arguments; "
"thus, we can drop it from the keyword arguments for readability::"
msgstr ""
"例如，在 ``HandField`` 类中，我们总是强制设置 ``__init__()`` 的长度。基类 "
"``Field`` 中的 ``deconstruct()`` 方法会看到这个值，并尝试在关键字参数中返回"
"它；因此，我们能为了可读性从关键字参数中剔除它::"

msgid ""
"If you add a new keyword argument, you need to write code in "
"``deconstruct()`` that puts its value into ``kwargs`` yourself. You should "
"also omit the value from ``kwargs`` when it isn't necessary to reconstruct "
"the state of the field, such as when the default value is being used::"
msgstr ""
"若你添加了一个新的关键字参数，你需要在 ``deconstruct`` 中新增代码，将其值传"
"入 ``kwargs``。如果不需要字段的重构状态，比如使用默认值的情况，还应该忽略 "
"``kwargs`` 中的值。"

msgid ""
"More complex examples are beyond the scope of this document, but remember - "
"for any configuration of your Field instance, ``deconstruct()`` must return "
"arguments that you can pass to ``__init__`` to reconstruct that state."
msgstr ""
"更多的复杂例子超出本文的范围，但是请牢记——对于你的字段实例的任意配置，"
"``deconstruct()`` 必须返回能传递给 ``__init__`` 的参数重构状态。"

msgid ""
"Pay extra attention if you set new default values for arguments in the "
"``Field`` superclass; you want to make sure they're always included, rather "
"than disappearing if they take on the old default value."
msgstr ""
"如果你在父类 ``Field`` 中设置了新的默认值需要额外注意；说明你希望总是包含它"
"们，而不是在它们采用旧有值时消失。"

msgid ""
"In addition, try to avoid returning values as positional arguments; where "
"possible, return values as keyword arguments for maximum future "
"compatibility. Of course, if you change the names of things more often than "
"their position in the constructor's argument list, you might prefer "
"positional, but bear in mind that people will be reconstructing your field "
"from the serialized version for quite a while (possibly years), depending "
"how long your migrations live for."
msgstr ""
"也就是说，尽量避免以位置参数返回值；可能的话，尽量以关键字参数返回，未来能更"
"好的扩展。当然，如果你在构造器的参数列表中，修改参数名比参数位置更频繁的话，"
"你可能更倾向于位置参数，但是，牢记于心，未来别人会从序列化版本中重新构建你的"
"字段，可能是一小会后（可能数年后），这取决于你的迁移持续的时间。"

msgid ""
"You can see the results of deconstruction by looking in migrations that "
"include the field, and you can test deconstruction in unit tests by just "
"deconstructing and reconstructing the field::"
msgstr ""
"你能查看析构的结果，通过观察包含字段的迁移。你也能在单元测试中测试析构，只要"
"简单的测试析构和重构字段::"

msgid "Changing a custom field's base class"
msgstr "修改自定义字段的基类"

msgid ""
"You can't change the base class of a custom field because Django won't "
"detect the change and make a migration for it. For example, if you start "
"with::"
msgstr ""
"你可能修改自定义字段的基类，因为 Django 无法检测到修改，并为其实施迁移。例"
"如，如果你先这样::"

msgid ""
"and then decide that you want to use ``TextField`` instead, you can't change "
"the subclass like this::"
msgstr "随后决定继承自 ``TextField``，你不能像这样修改子类::"

msgid ""
"Instead, you must create a new custom field class and update your models to "
"reference it::"
msgstr "替代方法是，你必须新建一个自定义字段类，并将你的模型指向此类::"

msgid ""
"As discussed in :ref:`removing fields <migrations-removing-model-fields>`, "
"you must retain the original ``CustomCharField`` class as long as you have "
"migrations that reference it."
msgstr ""
"就像文档 :ref:`移除字段 <migrations-removing-model-fields>` 中讨论的一样，你"
"必须保留原 ``CustomCharField`` 类只要你还有迁移指向它。"

msgid "Documenting your custom field"
msgstr "为自定义字段编写文档"

msgid ""
"As always, you should document your field type, so users will know what it "
"is. In addition to providing a docstring for it, which is useful for "
"developers, you can also allow users of the admin app to see a short "
"description of the field type via the :doc:`django.contrib.admindocs </ref/"
"contrib/admin/admindocs>` application. To do this simply provide descriptive "
"text in a :attr:`~Field.description` class attribute of your custom field. "
"In the above example, the description displayed by the ``admindocs`` "
"application for a ``HandField`` will be 'A hand of cards (bridge style)'."
msgstr ""
"像之前一样，你需要为自定义字段类型编写文档，这样用户就会知道这他喵到底是啥。"
"除了为其提供 docstring （对开发者很有用）外，你也需要让后台用户通过 :doc:"
"`django.contrib.admindocs </ref/contrib/admin/admindocs>` 看到一个关于字段类"
"型的简单介绍。只需简单地在自定义字段的 :attr:`~Field.description` 属性提供描"
"述性文本。在上述例子中，由 ``admindocs`` 应用为 ``HandField`` 字段提供的描述"
"是 'A hand of cards (bridge style)'。"

msgid ""
"In the :mod:`django.contrib.admindocs` display, the field description is "
"interpolated with ``field.__dict__`` which allows the description to "
"incorporate arguments of the field. For example, the description for :class:"
"`~django.db.models.CharField` is::"
msgstr ""
"在 :mod:`django.contrib.admindocs` 展示的内容中，字段描述在 ``field."
"__dict__`` 中差值，它允许描述包含字段参数。例如， :class:`~django.db.models."
"CharField` 的说明是::"

msgid "Useful methods"
msgstr "实用方法"

msgid ""
"Once you've created your :class:`~django.db.models.Field` subclass, you "
"might consider overriding a few standard methods, depending on your field's "
"behavior. The list of methods below is in approximately decreasing order of "
"importance, so start from the top."
msgstr ""
"一旦你已创建了 :class:`~django.db.models.Field` 的子类，你可能会考虑重写一些"
"标准方法，这取决于你的字段行为。以下列表中的方法大致按重要性降序排列，即从上"
"至下。"

msgid "Custom database types"
msgstr "自定义数据库类型"

msgid ""
"Say you've created a PostgreSQL custom type called ``mytype``. You can "
"subclass ``Field`` and implement the :meth:`~Field.db_type` method, like so::"
msgstr ""
"假设你已创建了一个 PostgreSQL 自定义字段，名叫 ``mytype``。你可以继承 "
"``Field`` 并实现 :meth:`~Field.db_type` 方法，像这样::"

msgid ""
"Once you have ``MytypeField``, you can use it in any model, just like any "
"other ``Field`` type::"
msgstr ""
"只要已建立 ``MytypeField``，你就能像使用其它 ``Field`` 类型一样在模型中使用"
"它::"

msgid ""
"If you aim to build a database-agnostic application, you should account for "
"differences in database column types. For example, the date/time column type "
"in PostgreSQL is called ``timestamp``, while the same column in MySQL is "
"called ``datetime``. The simplest way to handle this in a :meth:`~Field."
"db_type` method is to check the ``connection.settings_dict['ENGINE']`` "
"attribute."
msgstr ""
"如果你意在构建一个兼容各种数据库的应用，你需要了解不同数据库列之间的差异。举"
"个例子，PostgreSQL 中的 date/time 列类型叫做 ``timestamp``，而 MySQL 中相同的"
"列叫做 ``datetime``。最简单的处理此问题的方法是在 :meth:`~Field.db_type` 方法"
"中检查 ``connection.settings_dict['ENGINE']`` 属性。"

msgid "For example::"
msgstr "例子::"

msgid ""
"The :meth:`~Field.db_type` and :meth:`~Field.rel_db_type` methods are called "
"by Django when the framework constructs the ``CREATE TABLE`` statements for "
"your application -- that is, when you first create your tables. The methods "
"are also called when constructing a ``WHERE`` clause that includes the model "
"field -- that is, when you retrieve data using QuerySet methods like "
"``get()``, ``filter()``, and ``exclude()`` and have the model field as an "
"argument. They are not called at any other time, so it can afford to execute "
"slightly complex code, such as the ``connection.settings_dict`` check in the "
"above example."
msgstr ""
":meth:`~Field.db_type` 和 :meth:`~Field.rel_db_type` 方法由 Django 框架在为应"
"用构建 ``CREATE TABLE`` 语句时调用——即你第一次创建数据表的时候。这些方法也在"
"构建一个包含此模型字段的 ``WHERE`` 字句时调用——即你在利用 QuerySet 方法"
"(``get()``, ``filter()``, 和 ``exclude()``)检出数据时或将此模型字段作为参数"
"时。它们在其它时间不会被调用，故它们能承担执行有点小复杂的代码，例如上述的 "
"``connection.settings_dict`` 例子。"

msgid ""
"Some database column types accept parameters, such as ``CHAR(25)``, where "
"the parameter ``25`` represents the maximum column length. In cases like "
"these, it's more flexible if the parameter is specified in the model rather "
"than being hard-coded in the ``db_type()`` method. For example, it wouldn't "
"make much sense to have a ``CharMaxlength25Field``, shown here::"
msgstr ""
"某些数据库列类型接受参数，例如 ``CHAR(25)``，参数 ``25`` 表示列的最大长度。类"
"似用例中，该参数若在模型中指定比硬编码在 ``db_type()`` 方法中更灵活。举个例"
"子，构建 ``CharMaxlength25Field`` 没多大意义，如下所示::"

msgid ""
"The better way of doing this would be to make the parameter specifiable at "
"run time -- i.e., when the class is instantiated. To do that, just implement "
"``Field.__init__()``, like so::"
msgstr ""
"更好的方式是在运行时指定参数值——即类实例化的时候。只需像这样实现 ``Field."
"__init__()`` 即可::"

msgid ""
"Finally, if your column requires truly complex SQL setup, return ``None`` "
"from :meth:`.db_type`. This will cause Django's SQL creation code to skip "
"over this field. You are then responsible for creating the column in the "
"right table in some other way, of course, but this gives you a way to tell "
"Django to get out of the way."
msgstr ""
"最后，如果你的列真的要求配置复杂的 SQL，从 :meth:`.db_type` 返回 ``None``。这"
"会让 Django 创建 SQL 的代码跳过该字段。随后你需要负责为该字段在正确的表中以某"
"种方式创建列，这种方式允许你告诉 Django 不处理此事。"

msgid ""
"The :meth:`~Field.rel_db_type` method is called by fields such as "
"``ForeignKey`` and ``OneToOneField`` that point to another field to "
"determine their database column data types. For example, if you have an "
"``UnsignedAutoField``, you also need the foreign keys that point to that "
"field to use the same data type::"
msgstr ""
":meth:`~Field.rel_db_type` 方法由字段调用，例如 ``ForeignKey`` 和 "
"``OneToOneField`` ，这些通过指向另一个字段来决定数据库列类型的字段。举个例"
"子，如果你有个 ``UnsignedAutoField``，你也需要指向该字段的外键使用相同的数据"
"类型::"

msgid "Converting values to Python objects"
msgstr "将值转为 Python 对象"

msgid ""
"If your custom :class:`~Field` class deals with data structures that are "
"more complex than strings, dates, integers, or floats, then you may need to "
"override :meth:`~Field.from_db_value` and :meth:`~Field.to_python`."
msgstr ""
"若自定义 :class:`~Field` 处理的数据结构比字符串，日期，整型，或浮点型更复杂，"
"你可能需要重写 :meth:`~Field.from_db_value` 和 :meth:`~Field.to_python`。"

msgid ""
"If present for the field subclass, ``from_db_value()`` will be called in all "
"circumstances when the data is loaded from the database, including in "
"aggregates and :meth:`~django.db.models.query.QuerySet.values` calls."
msgstr ""
"若要展示字段的子类， ``from_db_value()`` 将会在从数据库中载入的生命周期中调"
"用，包括聚集和 :meth:`~django.db.models.query.QuerySet.values` 调用。"

msgid ""
"``to_python()`` is called by deserialization and during the :meth:`~django."
"db.models.Model.clean` method used from forms."
msgstr ""
"``to_python()`` 在反序列化时和为表单应用 :meth:`~django.db.models.Model."
"clean` 时调用。"

msgid ""
"As a general rule, ``to_python()`` should deal gracefully with any of the "
"following arguments:"
msgstr "作为通用规则， ``to_python`` 应该平滑地处理以下参数："

msgid ""
"An instance of the correct type (e.g., ``Hand`` in our ongoing example)."
msgstr "一个正确的类型（本业持续介绍的例子 ``Hand`` ）。"

msgid "A string"
msgstr "一个字符串"

msgid "``None`` (if the field allows ``null=True``)"
msgstr "``None`` （若字段允许 ``null=True``）"

msgid ""
"In our ``HandField`` class, we're storing the data as a VARCHAR field in the "
"database, so we need to be able to process strings and ``None`` in the "
"``from_db_value()``. In ``to_python()``, we need to also handle ``Hand`` "
"instances::"
msgstr ""
"在 ``HandField`` 类中，我们在数据库中以 VARCHAR 字段的形式存储数据，所以我们"
"要能在 ``from_db_value()`` 中处理字符串和 ``None``。在 ``to_python()`` 中，我"
"们也需要处理 ``Hand`` 实例::"

msgid ""
"Notice that we always return a ``Hand`` instance from these methods. That's "
"the Python object type we want to store in the model's attribute."
msgstr ""
"注意，我们总是为这些方法返回一个 ``Hand`` 实例。这就是我们要保存在模型属性中"
"的 Python 对象类型。"

msgid ""
"For ``to_python()``, if anything goes wrong during value conversion, you "
"should raise a :exc:`~django.core.exceptions.ValidationError` exception."
msgstr ""
"对于 ``to_python()`` 来说，如果在值转换过程中出现任何问题，你应该抛出一个 :"
"exc:`~django.core.exceptions.ValidationError` 异常。"

msgid "Converting Python objects to query values"
msgstr "将 Python 转为查询值"

msgid ""
"Since using a database requires conversion in both ways, if you override :"
"meth:`~Field.to_python` you also have to override :meth:`~Field."
"get_prep_value` to convert Python objects back to query values."
msgstr ""
"使用数据库需要双向转换，如果你重写了 :meth:`~Field.to_python` 方法，你也必须"
"重写 :meth:`~Field.get_prep_value` 将 Python 对象转回查询值。"

msgid ""
"If your custom field uses the ``CHAR``, ``VARCHAR`` or ``TEXT`` types for "
"MySQL, you must make sure that :meth:`.get_prep_value` always returns a "
"string type. MySQL performs flexible and unexpected matching when a query is "
"performed on these types and the provided value is an integer, which can "
"cause queries to include unexpected objects in their results. This problem "
"cannot occur if you always return a string type from :meth:`.get_prep_value`."
msgstr ""
"如果你使用了 MySQL 的 ``CHAR``，``VARCHAR`` 或 ``TEXT`` 类型，你必须确保 :"
"meth:`.get_prep_value` 总是返回一个字符串。在 MySQL 中对这些类型操作时非常灵"
"活，甚至有时超出预期，在传入值为正数时，检出结果可能包含非期望的结果。这个问"
"题不会在你总为 :meth:`.get_prep_value` 返回字符串类型的时候出现。"

msgid "Converting query values to database values"
msgstr "将查询值转为数据库值"

msgid ""
"Some data types (for example, dates) need to be in a specific format before "
"they can be used by a database backend. :meth:`~Field.get_db_prep_value` is "
"the method where those conversions should be made. The specific connection "
"that will be used for the query is passed as the ``connection`` parameter. "
"This allows you to use backend-specific conversion logic if it is required."
msgstr ""
"某些数据类型（比如 dates）在数据库后端处理前要转为某种特定格式。 :meth:"
"`~Field.get_db_prep_value` 实现了这种转换。查询所以使用的连接由 "
"``connection`` 参数指定。这允许你在需要时指定后台要求的转换逻辑。"

msgid ""
"For example, Django uses the following method for its :class:`BinaryField`::"
msgstr "例如，Django 为其 :class:`BinaryField` 利用以下方法::"

msgid ""
"In case your custom field needs a special conversion when being saved that "
"is not the same as the conversion used for normal query parameters, you can "
"override :meth:`~Field.get_db_prep_save`."
msgstr ""
"万一自定义字段需要与普通查询参数使用的转换不同的转换规则，你可以重写 :meth:"
"`~Field.get_db_prep_save`。"

msgid "Preprocessing values before saving"
msgstr "在保存前预处理数值"

msgid ""
"If you want to preprocess the value just before saving, you can use :meth:"
"`~Field.pre_save`. For example, Django's :class:`~django.db.models."
"DateTimeField` uses this method to set the attribute correctly in the case "
"of :attr:`~django.db.models.DateField.auto_now` or :attr:`~django.db.models."
"DateField.auto_now_add`."
msgstr ""
"如果你要在保存前预处理值，你可以调用 :meth:`~Field.pre_save`。举个例子，"
"Django 的 :class:`~django.db.models.DateTimeField` 在 :attr:`~django.db."
"models.DateField.auto_now` 或 :attr:`~django.db.models.DateField."
"auto_now_add` 中利用此方法正确设置属性。"

msgid ""
"If you do override this method, you must return the value of the attribute "
"at the end. You should also update the model's attribute if you make any "
"changes to the value so that code holding references to the model will "
"always see the correct value."
msgstr ""
"如果你重写了此方法，你必须在最后返回该属性的值。如果修改了值，那么你也需要更"
"新模型属性，这样持有该引用的模型总会看到正确的值。"

msgid "Specifying the form field for a model field"
msgstr "为模型字段指定表单字段"

msgid ""
"To customize the form field used by :class:`~django.forms.ModelForm`, you "
"can override :meth:`~Field.formfield`."
msgstr ""
"为了自定义 :class:`~django.forms.ModelForm` 使用的表单属性，你必须重写 :meth:"
"`~Field.formfield`。"

msgid ""
"The form field class can be specified via the ``form_class`` and "
"``choices_form_class`` arguments; the latter is used if the field has "
"choices specified, the former otherwise. If these arguments are not "
"provided, :class:`~django.forms.CharField` or :class:`~django.forms."
"TypedChoiceField` will be used."
msgstr ""
"表单字段类能通过 ``form_class`` 和 ``choices_form_class`` 参数指定；如果字段"
"指定了选项，则使用后者，反之前者。若未提供这些参数，将会使用 :class:`~django."
"forms.CharField` 或 :class:`~django.forms.TypedChoiceField`。"

msgid ""
"All of the ``kwargs`` dictionary is passed directly to the form field's "
"``__init__()`` method. Normally, all you need to do is set up a good default "
"for the ``form_class`` (and maybe ``choices_form_class``) argument and then "
"delegate further handling to the parent class. This might require you to "
"write a custom form field (and even a form widget). See the :doc:`forms "
"documentation </topics/forms/index>` for information about this."
msgstr ""
"完整的 ``kwargs`` 被直接传递给表单字段的 ``__init__()`` 方法。一般的，你要做"
"的全部工作就是为 ``form_class`` 参数配置一个合适的默认值，并在随后委托父类处"
"理。这可能要求你编写一个自定义表单字段（甚至表单视图）。查看 :doc:`表单文件材"
"料 </topics/forms/index>` 获取相关信息。"

msgid ""
"Continuing our ongoing example, we can write the :meth:`~Field.formfield` "
"method as::"
msgstr "承接上面的例子，我们能这样编写 :meth:`~Field.formfield` 方法::"

msgid ""
"This assumes we've imported a ``MyFormField`` field class (which has its own "
"default widget). This document doesn't cover the details of writing custom "
"form fields."
msgstr ""
"这假定我们已导入 ``MyFormField`` 字段类（它有默认视图）。本页文档未覆盖编写自"
"定义表单字段的细节。"

msgid "Emulating built-in field types"
msgstr "仿造内置字段类型"

msgid ""
"If you have created a :meth:`.db_type` method, you don't need to worry "
"about :meth:`.get_internal_type` -- it won't be used much. Sometimes, "
"though, your database storage is similar in type to some other field, so you "
"can use that other field's logic to create the right column."
msgstr ""
"若你已创建了 :meth:`.db_type` 方法，你无需担心 :meth:`.get_internal_type` 方"
"法——它并不常用。虽然很多时候，数据库存储行为和其他字段类似，所以你能直接用其"
"它字段的逻辑创建正确的列。"

msgid ""
"No matter which database backend we are using, this will mean that :djadmin:"
"`migrate` and other SQL commands create the right column type for storing a "
"string."
msgstr ""
"无论我们使用了哪个数据库后端， :djadmin:`migrate` 或其它 SQL 命令总会在保存字"
"符串时为其创建正确的列类型。"

msgid ""
"If :meth:`.get_internal_type` returns a string that is not known to Django "
"for the database backend you are using -- that is, it doesn't appear in "
"``django.db.backends.<db_name>.base.DatabaseWrapper.data_types`` -- the "
"string will still be used by the serializer, but the default :meth:`~Field."
"db_type` method will return ``None``. See the documentation of :meth:`~Field."
"db_type` for reasons why this might be useful. Putting a descriptive string "
"in as the type of the field for the serializer is a useful idea if you're "
"ever going to be using the serializer output in some other place, outside of "
"Django."
msgstr ""
"若 :meth:`.get_internal_type` 返回了当前数据库后端（即 ``django.db.backends."
"<db_name>.base.DatabaseWrapper.data_types`` 中未出现的后端）无法理解的字符串"
"——该字符串仍会被序列化器使用的，但是默认的 :meth:`~Field.db_type` 方法会返回 "
"``None``。查阅文档 :meth:`~Field.db_type` 了解为啥有用。如果您打算在 Django "
"之外的其他地方使用序列化器输出，那么将描述性字符串作为序列化器的字段类型是一"
"个有用的想法。"

msgid "Converting field data for serialization"
msgstr "为序列化转换字段数据"

msgid ""
"To customize how the values are serialized by a serializer, you can "
"override :meth:`~Field.value_to_string`. Using :meth:`~Field."
"value_from_object` is the best way to get the field's value prior to "
"serialization. For example, since ``HandField`` uses strings for its data "
"storage anyway, we can reuse some existing conversion code::"
msgstr ""
"自定义序列化器序列化值的流程，你要重写 :meth:`~Field.value_to_string`。使用 :"
"meth:`~Field.value_to_string` 是在序列化之前获取字段值的最佳方法。举个例子，"
"由于 ``HandField`` 使用字符串存储数据，我们能复用一些已有代码::"

msgid "Some general advice"
msgstr "一些通用建议"

msgid ""
"Writing a custom field can be a tricky process, particularly if you're doing "
"complex conversions between your Python types and your database and "
"serialization formats. Here are a couple of tips to make things go more "
"smoothly:"
msgstr ""
"编写自定义字段是个棘手的，尤其是在 Python 类，数据库，序列化格式之间进行复杂"
"转换的时候。下面有几个让事情更顺利的建议："

msgid ""
"Look at the existing Django fields (in :file:`django/db/models/fields/"
"__init__.py`) for inspiration. Try to find a field that's similar to what "
"you want and extend it a little bit, instead of creating an entirely new "
"field from scratch."
msgstr ""
"借鉴已有的 Django 字段（位于 :file:`django/db/models/fields/__init__.py`）。"
"试着找到一个与你目标类似的字段，而不是从零开始创建。"

msgid ""
"Put a ``__str__()`` method on the class you're wrapping up as a field. There "
"are a lot of places where the default behavior of the field code is to call "
"``str()`` on the value. (In our examples in this document, ``value`` would "
"be a ``Hand`` instance, not a ``HandField``). So if your ``__str__()`` "
"method automatically converts to the string form of your Python object, you "
"can save yourself a lot of work."
msgstr ""
"为字段类添加一个 ``__str__()`` 方法。在很多地方，字段代码的默认行为是对值调"
"用 ``str()``。（本页文档中， ``value`` 会是一个 ``Hand`` 实例，而不是 "
"``HandField``）。所以 ``__str()`` 方法会自动将 Python 对象转为字符串格式，帮"
"你剩下不少时间。 "

msgid "Writing a ``FileField`` subclass"
msgstr "编写一个 ``FileField`` 子类"

msgid ""
"In addition to the above methods, fields that deal with files have a few "
"other special requirements which must be taken into account. The majority of "
"the mechanics provided by ``FileField``, such as controlling database "
"storage and retrieval, can remain unchanged, leaving subclasses to deal with "
"the challenge of supporting a particular type of file."
msgstr ""
"除了上述方法外，处理文件的字段还有一些必须考虑到的特殊要求。 ``FileField`` 提"
"供的大部分机制（像是操作数据库存储和检索）能保持不变，让子类面对支持特殊文件"
"的挑战。"

msgid ""
"Django provides a ``File`` class, which is used as a proxy to the file's "
"contents and operations. This can be subclassed to customize how the file is "
"accessed, and what methods are available. It lives at ``django.db.models."
"fields.files``, and its default behavior is explained in the :doc:`file "
"documentation </ref/files/file>`."
msgstr ""
"Django 提供一个 ``File`` 类，作为文件内容和文件操作的代理。可以继承该类自定义"
"访问文件的方式，哪些方法是可用的。它位于 ``django.db.models.fields.files``，"
"它的默认行为在 :doc:`file 文档 </ref/files/file>` 中介绍。"

msgid ""
"Once a subclass of ``File`` is created, the new ``FileField`` subclass must "
"be told to use it. To do so, simply assign the new ``File`` subclass to the "
"special ``attr_class`` attribute of the ``FileField`` subclass."
msgstr ""
"一旦创建了 ``File`` 子类，必须说明要使用新子类 ``FileField``。为此，只需为 "
"``FileField`` 的子类的 ``attr_class`` 指定新的 ``File`` 子类。"

msgid "A few suggestions"
msgstr "一些建议"

msgid ""
"In addition to the above details, there are a few guidelines which can "
"greatly improve the efficiency and readability of the field's code."
msgstr ""
"除了上述细节，下面还有一些准则，有助于极大地提高字段代码的效率和可读性。"

msgid ""
"The source for Django's own ``ImageField`` (in ``django/db/models/fields/"
"files.py``) is a great example of how to subclass ``FileField`` to support a "
"particular type of file, as it incorporates all of the techniques described "
"above."
msgstr ""
"Django 的 ``ImageField`` 的源码（位于 ``django/db/models/fields/files.py``）"
"就是个展示如何继承 ``FileField`` 支持特定文件的不错例子，因为它包含了上述所有"
"技巧。"

msgid ""
"Cache file attributes wherever possible. Since files may be stored in remote "
"storage systems, retrieving them may cost extra time, or even money, that "
"isn't always necessary. Once a file is retrieved to obtain some data about "
"its content, cache as much of that data as possible to reduce the number of "
"times the file must be retrieved on subsequent calls for that information."
msgstr ""
"尽可能的缓存文件属性。因为文件可能保存在远端存储系统中，检出它们会消耗额外的"
"时间，甚至是钱，且不总是必要的。一旦检出某个文件，获取其内容，尽可能缓存所有"
"数据，以减少后续调用再次检索文件的次数。"

msgid "Custom template tags and filters"
msgstr "自定义模板（template）的标签（tags）和过滤器（filters）"

msgid ""
"Django's template language comes with a wide variety of :doc:`built-in tags "
"and filters </ref/templates/builtins>` designed to address the presentation "
"logic needs of your application. Nevertheless, you may find yourself needing "
"functionality that is not covered by the core set of template primitives. "
"You can extend the template engine by defining custom tags and filters using "
"Python, and then make them available to your templates using the :ttag:`{% "
"load %}<load>` tag."
msgstr ""
"Django  模板语言包含了很多 :doc:`内置 tags 和 filters </ref/templates/"
"builtins>`，设计目的是满足应用需要占位逻辑需求。极少情况下，你可能发现需要的"
"功能未被核心模板集覆盖。你能通过 Python 代码自定义 tags 和 filters 扩展集成模"
"板引擎，通过 :ttag:`{% load %} <load>` 标签使其可用。"

msgid "Code layout"
msgstr "代码布局"

msgid ""
"The most common place to specify custom template tags and filters is inside "
"a Django app. If they relate to an existing app, it makes sense to bundle "
"them there; otherwise, they can be added to a new app. When a Django app is "
"added to :setting:`INSTALLED_APPS`, any tags it defines in the conventional "
"location described below are automatically made available to load within "
"templates."
msgstr ""
"定制自定义模板 tags 和 filters 的位置就是 Django 应用内。如果它们关联至某个已"
"存在的应用，在那里将它们打包就很有用；否则，它们能被添加至新应用。当一个 "
"Django 应用被添加至 :setting:`INSTALLED_APPS`，所以其在常规位置（下面介绍）定"
"义的标签都可以在模板中自动加载。"

msgid ""
"The app should contain a ``templatetags`` directory, at the same level as "
"``models.py``, ``views.py``, etc. If this doesn't already exist, create it - "
"don't forget the ``__init__.py`` file to ensure the directory is treated as "
"a Python package."
msgstr ""
"该应用应包含一个 ``templatetags`` 目录，与 ``models.py``， ``views.py`` 等同"
"级。若该目录不存在，创建它——不要忘了用 ``__init__.py`` 文件确保目录被视作一"
"个 Python 包。"

msgid "Development server won't automatically restart"
msgstr "开发服务器并不会自动重启"

msgid ""
"After adding the ``templatetags``  module, you will need to restart your "
"server before you can use the tags or filters in templates."
msgstr ""
"添加 ``templatetags`` 模块后，你需要重启服务器，这样才能在模板中使用 tags 和 "
"filters。"

msgid ""
"Your custom tags and filters will live in a module inside the "
"``templatetags`` directory. The name of the module file is the name you'll "
"use to load the tags later, so be careful to pick a name that won't clash "
"with custom tags and filters in another app."
msgstr ""
"自定义的 tags 和 filters 会保存在模块名为 ``templatetags`` 的目录内。模块文件"
"的名字即稍候你用来加载 tags 的名字，所以小心不要采用一个可能与其它应用自定义"
"的 tags 和 filters 冲突的名字。"

msgid ""
"For example, if your custom tags/filters are in a file called ``poll_extras."
"py``, your app layout might look like this::"
msgstr ""
"例如，如果你的 tags/filters 保存在一个名为 ``poll_extras.py`` 的文件中，你的"
"应用布局可能看起来像这样::"

msgid "And in your template you would use the following:"
msgstr "在模板中你会使用以下代码："

msgid ""
"The app that contains the custom tags must be in :setting:`INSTALLED_APPS` "
"in order for the :ttag:`{% load %}<load>` tag to work. This is a security "
"feature: It allows you to host Python code for many template libraries on a "
"single host machine without enabling access to all of them for every Django "
"installation."
msgstr ""
"为了使 :ttag:`{% load %}<load>` 标签生效，包含自定义标签的应用必须包含在 :"
"setting:`INSTALLED_APPS` 中。这是个安全特性：它允许你在一个主机上持有多个模板"
"库，而不是让每个 Django 安装都能访问所有的库。"

msgid ""
"There's no limit on how many modules you put in the ``templatetags`` "
"package. Just keep in mind that a :ttag:`{% load %}<load>` statement will "
"load tags/filters for the given Python module name, not the name of the app."
msgstr ""
"我们并未限制放入 ``templatetags`` 包中的模块数量。只需牢记 :ttag:`{% load %}"
"<load>` 语句会加载名字指定 Python 模块的 tags/filters，而不是应用。"

msgid ""
"To be a valid tag library, the module must contain a module-level variable "
"named ``register`` that is a ``template.Library`` instance, in which all the "
"tags and filters are registered. So, near the top of your module, put the "
"following::"
msgstr ""
"要成为一个可用的 tag 库，模块必须包含一个名为 ``register`` 的模块级变量，它是"
"一个 ``template.Library`` 实例。所有的 tags 和 filters 均在其中注册。所以，在"
"模块的开始，输入以下内容::"

msgid ""
"Alternatively, template tag modules can be registered through the "
"``'libraries'`` argument to :class:`~django.template.backends.django."
"DjangoTemplates`. This is useful if you want to use a different label from "
"the template tag module name when loading template tags. It also enables you "
"to register tags without installing an application."
msgstr ""
"或者，模板标签模块能通过 :class:`~django.template.backends.django."
"DjangoTemplates` 的 ``'libraries'`` 参数注册。这在加载模板名字时，想为模板标"
"签起个别名时很有用。这也让你能在未安装应用的情况下注册标签。"

msgid "Behind the scenes"
msgstr "幕后"

msgid ""
"For a ton of examples, read the source code for Django's default filters and "
"tags. They're in ``django/template/defaultfilters.py`` and ``django/template/"
"defaulttags.py``, respectively."
msgstr ""
"要查看超多的例子，查阅 Django 默认的 filters 和 tags 源码。它们分别位于 "
"``django/template/defaultfilters.py`` 和  ``django/template/defaulttags."
"py``。"

msgid "For more information on the :ttag:`load` tag, read its documentation."
msgstr "更多关于 :ttag:`load` 标签的信息，阅读本文档。"

msgid "Writing custom template filters"
msgstr "编写自定义的模板过滤器"

msgid ""
"Custom filters are just Python functions that take one or two arguments:"
msgstr "自定义的过滤器就是一些有一到两个参数的 Python 函数"

msgid "The value of the variable (input) -- not necessarily a string."
msgstr "（输入的）变量的值，不一定得是字符串类型"

msgid ""
"The value of the argument -- this can have a default value, or be left out "
"altogether."
msgstr "而参数的值，它们可以有一个默认值，或者被排除在外"

msgid ""
"For example, in the filter ``{{ var|foo:\"bar\" }}``, the filter ``foo`` "
"would be passed the variable ``var`` and the argument ``\"bar\"``."
msgstr ""
"举个例子，在过滤器 ``{{ var|foo:\"bar\" }}`` 中，变量 ``var`` 和参数 ``bar`` "
"会传递给过滤器 ``foo``。"

msgid ""
"Since the template language doesn't provide exception handling, any "
"exception raised from a template filter will be exposed as a server error. "
"Thus, filter functions should avoid raising exceptions if there is a "
"reasonable fallback value to return. In case of input that represents a "
"clear bug in a template, raising an exception may still be better than "
"silent failure which hides the bug."
msgstr ""
"因为模板语言不提供异常处理机制，所以任何从模板过滤器中抛出的异常都将被视为服"
"务器异常。因此，如果有一个合理的返回值将要被返回的话，过滤器函数应当避免产生"
"异常。万一模板中出现有明显错误的输入，产生异常也仍然比隐藏这个 bug 要好。"

msgid "Here's an example filter definition::"
msgstr "这是一个过滤器定义的例子::"

msgid "And here's an example of how that filter would be used:"
msgstr "这个例子展示了如何使用这个过滤器："

msgid ""
"Most filters don't take arguments. In this case, just leave the argument out "
"of your function. Example::"
msgstr ""
"大部分的过滤器并没有参数。这样的话，只需要把这些参数从你的函数中去掉就好。例"
"子如下："

msgid "Registering custom filters"
msgstr "注册自定义过滤器"

msgid ""
"Once you've written your filter definition, you need to register it with "
"your ``Library`` instance, to make it available to Django's template "
"language::"
msgstr ""
"每当你写好你的过滤器定义的时候，你需要用你的 ``Library`` 实例去注册它，从而让"
"它对于 Django 模板语言而言是可用的"

msgid "The ``Library.filter()`` method takes two arguments:"
msgstr "``Library.filter()`` 方法有两个参数："

msgid "The name of the filter -- a string."
msgstr "过滤器的名称——字符串。"

msgid ""
"The compilation function -- a Python function (not the name of the function "
"as a string)."
msgstr "编辑函数——一个 Python 函数（不是函数名的字符串）。"

msgid "You can use ``register.filter()`` as a decorator instead::"
msgstr "你也能以装饰器的模式使用 ``register.filter()``::"

msgid ""
"If you leave off the ``name`` argument, as in the second example above, "
"Django will use the function's name as the filter name."
msgstr ""
"若你不填 ``name`` 参数，像第二个例子展示的一样，Django 会将函数名当做过滤器"
"名。"

msgid ""
"Finally, ``register.filter()`` also accepts three keyword arguments, "
"``is_safe``, ``needs_autoescape``, and ``expects_localtime``. These "
"arguments are described in :ref:`filters and auto-escaping <filters-auto-"
"escaping>` and :ref:`filters and time zones <filters-timezones>` below."
msgstr ""
"最后， ``register.filter()`` 也接受 3 个关键字参数， ``is_sage``， "
"``needs_autoescape``，和 ``expects_localtime``。这些参数在下面的 :ref:`过滤器"
"和自动转义 <filters-auto-escaping>` 和 :ref:`过滤器和时区 <filters-"
"timezones>` 介绍。"

msgid "Template filters that expect strings"
msgstr "模板过滤器期望字符串"

msgid ""
"If you're writing a template filter that only expects a string as the first "
"argument, you should use the decorator ``stringfilter``. This will convert "
"an object to its string value before being passed to your function::"
msgstr ""
"如果编写只接收一个字符串作为第一个参数的模板过滤器，你需要使用 "
"``stringfilter`` 的装饰器。它会将参数前转为字符串后传递给函数::"

msgid ""
"This way, you'll be able to pass, say, an integer to this filter, and it "
"won't cause an ``AttributeError`` (because integers don't have ``lower()`` "
"methods)."
msgstr ""
"这样，您就可以将一个整数传递给这个过滤器，而不会导致 ``AttributeError`` (因为"
"整数没有 ``lower()`` 方法)。"

msgid "Filters and auto-escaping"
msgstr "过滤器和自动转义"

msgid ""
"When writing a custom filter, give some thought to how the filter will "
"interact with Django's auto-escaping behavior. Note that two types of "
"strings can be passed around inside the template code:"
msgstr "编写自定义过滤器时，考虑一下过滤器将如何与 Django 的自动转义行为交互。"

msgid ""
"**Raw strings** are the native Python strings. On output, they're escaped if "
"auto-escaping is in effect and presented unchanged, otherwise."
msgstr ""
"**原始字符串** 指原生 Python 字符串。在输出时，如果自动转义生效，则对它们进行"
"转义，否则将保持不变。"

msgid ""
"**Safe strings** are strings that have been marked safe from further "
"escaping at output time. Any necessary escaping has already been done. "
"They're commonly used for output that contains raw HTML that is intended to "
"be interpreted as-is on the client side."
msgstr ""
"**安全字符串** 是在输出时被标记为安全的字符串，不会进一步转义。必要的转义已在"
"之前完成。它们通常用于原样输出 HTML，HTML 会在客户端被解释。"

msgid ""
"Internally, these strings are of type :class:`~django.utils.safestring."
"SafeText`. You can test for them using code like::"
msgstr ""
"实质上，这些字符串是 :class:`~django.utils.safestring.SafeText` 类的实例。你"
"能用以下代码测试它们::"

msgid "Template filter code falls into one of two situations:"
msgstr "模板过滤器代码有两种情况："

msgid ""
"Your filter does not introduce any HTML-unsafe characters (``<``, ``>``, "
"``'``, ``\"`` or ``&``) into the result that were not already present. In "
"this case, you can let Django take care of all the auto-escaping handling "
"for you. All you need to do is set the ``is_safe`` flag to ``True`` when you "
"register your filter function, like so::"
msgstr ""
"你的过滤器不会将任何 HTML 不安全的字符(``<``, ``>``, ``'``, ``\"`` or ``&``)"
"引入尚未出现的结果中。这种情况下，可以让 Django 自动为您处理所有的转义操作。"
"你只需在注册自己的过滤器函数时，将 ``is_safe`` 标志置为 ``True``，像这样::"

msgid ""
"This flag tells Django that if a \"safe\" string is passed into your filter, "
"the result will still be \"safe\" and if a non-safe string is passed in, "
"Django will automatically escape it, if necessary."
msgstr ""
"该标志告诉 Django，若一个“安全”字符串传给您的过滤器，结果仍会是安全的。若传入"
"了不安全的字符串，Django 会在需要时自动转义。"

msgid ""
"You can think of this as meaning \"this filter is safe -- it doesn't "
"introduce any possibility of unsafe HTML.\""
msgstr "你可以这么认为，“过滤器是安全的——它不会产生任何不安全的 HTML。”"

msgid ""
"The reason ``is_safe`` is necessary is because there are plenty of normal "
"string operations that will turn a ``SafeData`` object back into a normal "
"``str`` object and, rather than try to catch them all, which would be very "
"difficult, Django repairs the damage after the filter has completed."
msgstr ""
"一定要 ``is_safe`` 的原因是大量的字符串操作会将 ``SafeData`` 对象返回为普通 "
"``str`` 对象，而不是尝试全部捕获（挺难的），Django 在过滤完成后尝试修复这些损"
"伤。"

msgid ""
"For example, suppose you have a filter that adds the string ``xx`` to the "
"end of any input. Since this introduces no dangerous HTML characters to the "
"result (aside from any that were already present), you should mark your "
"filter with ``is_safe``::"
msgstr ""
"举例来说，假定有个过滤器，会在任何输入后追加 ``xx``。由于此操作不会在结果产生"
"任何 HTML 危险的字符（除了那些已存在的），你需要用 ``is_safe`` 标记你的过滤"
"器::"

msgid ""
"When this filter is used in a template where auto-escaping is enabled, "
"Django will escape the output whenever the input is not already marked as "
"\"safe\"."
msgstr ""
"当该过滤器对某个启用了自动转义的模板生效时，Django 会对输出自动转义，不管输入"
"是否被标记为“安全的”。"

msgid ""
"By default, ``is_safe`` is ``False``, and you can omit it from any filters "
"where it isn't required."
msgstr ""
"默认情况下， ``is_sate`` 为 ``False``，你可以为不要求此项的过滤器忽略它。"

msgid ""
"Be careful when deciding if your filter really does leave safe strings as "
"safe. If you're *removing* characters, you might inadvertently leave "
"unbalanced HTML tags or entities in the result. For example, removing a "
"``>`` from the input might turn ``<a>`` into ``<a``, which would need to be "
"escaped on output to avoid causing problems. Similarly, removing a semicolon "
"(``;``) can turn ``&amp;`` into ``&amp``, which is no longer a valid entity "
"and thus needs further escaping. Most cases won't be nearly this tricky, but "
"keep an eye out for any problems like that when reviewing your code."
msgstr ""
"在确定过滤器是否确实将安全字符串保留为安全字符串时要千万小心。如果你正在 **删"
"除** 字符，你可能不经意的在结果中留下不成对的 HTML 标记或实体。例如，从输入中"
"删除一个 ``>`` 可能将 ``<a>`` 转为 ``<a``，后者可能需要转移，避免导致输出错"
"误。类似的，删除一个分号(``;``)会将 ``&amp;`` 转为 ``&amp``，后者不再是一个有"
"效的实体，因此需要转义。大多数情况下都没这么复杂，但是检查代码时要注意类似的"
"问题。"

msgid ""
"Marking a filter ``is_safe`` will coerce the filter's return value to a "
"string.  If your filter should return a boolean or other non-string value, "
"marking it ``is_safe`` will probably have unintended consequences (such as "
"converting a boolean False to the string 'False')."
msgstr ""
"标记过滤器的 ``is_safe`` 会强制该过滤器的返回值为字符串。如果你的过滤器要返回"
"一个布尔值或非字符串值，将其标记为 ``is_safe`` 可能会导致出乎意料的结果（类似"
"将一个布尔值 False 转为字符串 'False'）。"

msgid ""
"Alternatively, your filter code can manually take care of any necessary "
"escaping. This is necessary when you're introducing new HTML markup into the "
"result. You want to mark the output as safe from further escaping so that "
"your HTML markup isn't escaped further, so you'll need to handle the input "
"yourself."
msgstr ""
"或者，你的过滤器代码要手动关注必须的转义操作。这在输出新 HTML 标记时是必须"
"的。想要避免你的 HTML 标记不被后续操作转义，你要将输出标记为安全的，且需要自"
"己处理输入。"

msgid ""
"To mark the output as a safe string, use :func:`django.utils.safestring."
"mark_safe`."
msgstr ""
"要将输出标记为安全字符串，使用 :func:`django.utils.safestring.mark_safe`。"

msgid ""
"Be careful, though. You need to do more than just mark the output as safe. "
"You need to ensure it really *is* safe, and what you do depends on whether "
"auto-escaping is in effect. The idea is to write filters that can operate in "
"templates where auto-escaping is either on or off in order to make things "
"easier for your template authors."
msgstr ""
"不过还是要小心，你要做的不只是将输出标记为安全的。你需要确保它 *真的是* 安全"
"的，你所做的取决于自动转义是否生效。理想状态下，编写的过滤器在自动转义开启与"
"关闭的情况下均能正确的操作模板，这样模板作者用起来就更简单了。 "

msgid ""
"In order for your filter to know the current auto-escaping state, set the "
"``needs_autoescape`` flag to ``True`` when you register your filter "
"function. (If you don't specify this flag, it defaults to ``False``). This "
"flag tells Django that your filter function wants to be passed an extra "
"keyword argument, called ``autoescape``, that is ``True`` if auto-escaping "
"is in effect and ``False`` otherwise. It is recommended to set the default "
"of the ``autoescape`` parameter to ``True``, so that if you call the "
"function from Python code it will have escaping enabled by default."
msgstr ""
"为了让你的过滤器知道自动转移开关的状态，在你注册过滤器函数时将 "
"``needs_autoescape`` 标志（默认 ``False``）设置为 ``True``。该标志告诉 "
"Django 过滤器函数额外接受一个名为 ``autoescape`` 关键字参数，值为 ``True`` 时"
"说明自动转义生效中， ``False`` 说明关闭。推荐将 ``autoescape`` 参数的默认值设"
"为 ``True``，这样，从 Python 代码调用此函数时，默认开启自动转义功能。"

msgid ""
"For example, let's write a filter that emphasizes the first character of a "
"string::"
msgstr "例子，让我们编写一个强制大写字符串的首字母的过滤器::"

msgid ""
"The ``needs_autoescape`` flag and the ``autoescape`` keyword argument mean "
"that our function will know whether automatic escaping is in effect when the "
"filter is called. We use ``autoescape`` to decide whether the input data "
"needs to be passed through ``django.utils.html.conditional_escape`` or not. "
"(In the latter case, we just use the identity function as the \"escape\" "
"function.) The ``conditional_escape()`` function is like ``escape()`` except "
"it only escapes input that is **not** a ``SafeData`` instance. If a "
"``SafeData`` instance is passed to ``conditional_escape()``, the data is "
"returned unchanged."
msgstr ""
"``needs_autoescape`` 标志和 ``autoescape`` 关键字参数意味着函数会在过滤器被调"
"用时知道自动转义是否生效。我们利用 ``autoescape`` 来决定是否要将输入数据传递"
"给 ``django.utils.html.conditional_escape``。（后续实例中，我们仍使用同一函数"
"作为“转义”函数。） ``conditional_escape()`` 函数"

msgid ""
"Finally, in the above example, we remember to mark the result as safe so "
"that our HTML is inserted directly into the template without further "
"escaping."
msgstr ""
"最后，在上述例子中，我们牢记将结果标为安全的，所以 HMTL 未经转义就直接插入模"
"板中。"

msgid ""
"There's no need to worry about the ``is_safe`` flag in this case (although "
"including it wouldn't hurt anything). Whenever you manually handle the auto-"
"escaping issues and return a safe string, the ``is_safe`` flag won't change "
"anything either way."
msgstr ""
"这种场景下无需担心 ``is_safe`` 标志（虽然包含它不会有什么问题）。无论你何时决"
"定手动处理自动转义，并返回安全字符串， ``is_safe`` 标志不会有任何影响。"

msgid "Avoiding XSS vulnerabilities when reusing built-in filters"
msgstr "在重用内置过滤器时避免 XSS 漏洞"

msgid ""
"Django's built-in filters have ``autoescape=True`` by default in order to "
"get the proper autoescaping behavior and avoid a cross-site script "
"vulnerability."
msgstr ""
"Django 内置的过滤器默认配置 ``autoescape=True``，获取合适的自动转义行为，并避"
"免跨站脚本漏洞。"

msgid ""
"In older versions of Django, be careful when reusing Django's built-in "
"filters as ``autoescape`` defaults to ``None``. You'll need to pass "
"``autoescape=True`` to get autoescaping."
msgstr ""
"在旧版本的 Django 中，复用 Django 内置过滤器时要小心，因为 ``自动转义`` 默认"
"为 ``None``。你需要传入 ``autoescape=True`` 启用自动转义。"

msgid ""
"For example, if you wanted to write a custom filter called "
"``urlize_and_linebreaks`` that combined the :tfilter:`urlize` and :tfilter:"
"`linebreaksbr` filters, the filter would look like::"
msgstr ""
"举个例子，如果你想编写一个联合 :tfilter:`urlize` 和 :tfilter:`linebreaksbr` "
"过滤器的，名为 ``urlize_and_linebreaks`` 的自定义过滤器，可通过以下代码::"

msgid "Then:"
msgstr "接下来："

msgid "would be equivalent to:"
msgstr "等价于："

msgid "Filters and time zones"
msgstr "过滤器和时区"

msgid ""
"If you write a custom filter that operates on :class:`~datetime.datetime` "
"objects, you'll usually register it with the ``expects_localtime`` flag set "
"to ``True``::"
msgstr ""
"如果你编写了一个自定义过滤器，处理 :class:`~datetime.datetime` 对象，注册过滤"
"器时通常将 ``expects_localtime`` 标志置为 ``True``::"

msgid ""
"When this flag is set, if the first argument to your filter is a time zone "
"aware datetime, Django will convert it to the current time zone before "
"passing it to your filter when appropriate, according to :ref:`rules for "
"time zones conversions in templates <time-zones-in-templates>`."
msgstr ""
"设置该标志后，如果过滤器接收的第一个参数是一个时区敏感的 datetime，Django 在"
"将其传递给过滤器前的某个合适时间将其转换为当前时区的时间，依据 :ref:`模板中的"
"时区转换规则 <time-zones-in-templates>`。"

msgid "Writing custom template tags"
msgstr "编写自定义模板标签"

msgid ""
"Tags are more complex than filters, because tags can do anything. Django "
"provides a number of shortcuts that make writing most types of tags easier. "
"First we'll explore those shortcuts, then explain how to write a tag from "
"scratch for those cases when the shortcuts aren't powerful enough."
msgstr ""
"标签比过滤器更复杂，因为标签啥都能做。Django 提供了很多快捷方式，简化了编写绝"
"大多数类型的标签过程。我们先探索这些快捷方式，然后解释如何在快捷方式不够强大"
"的情况下从零编写标签。"

msgid "Simple tags"
msgstr "简单标签"

msgid ""
"Many template tags take a number of arguments -- strings or template "
"variables -- and return a result after doing some processing based solely on "
"the input arguments and some external information. For example, a "
"``current_time`` tag might accept a format string and return the time as a "
"string formatted accordingly."
msgstr ""
"许多模板标签接受多个参数——字符串或模板变量——并仅根据输入参数和一些额外信息进"
"行某种处理，并返回结果。例如， ``current_time`` 标签可能接受一个格式字符串，"
"并将时间按照字符串要求的格式返回。"

msgid ""
"To ease the creation of these types of tags, Django provides a helper "
"function, ``simple_tag``. This function, which is a method of ``django."
"template.Library``, takes a function that accepts any number of arguments, "
"wraps it in a ``render`` function and the other necessary bits mentioned "
"above and registers it with the template system."
msgstr ""
"为了简化创建标签类型的流程，Django 提供了一个助手函数， ``simple_tag``。该函"
"数实际是 ``django.template.Library`` 的一个方法，该函数接受任意个数的参数，将"
"其封装在一个 ``render`` 函数以及上述其它必要的位置，并用模板系统注册它。"

msgid "Our ``current_time`` function could thus be written like this::"
msgstr "我们的 ``current_time`` 函数因此能这样写::"

msgid "A few things to note about the ``simple_tag`` helper function:"
msgstr "关于 ``simple_tag`` 助手函数，有几点要注意："

msgid ""
"Checking for the required number of arguments, etc., has already been done "
"by the time our function is called, so we don't need to do that."
msgstr "检测要求参数的个数等在调用函数时就已完成，所以我们无需再做。"

msgid ""
"The quotes around the argument (if any) have already been stripped away, so "
"we just receive a plain string."
msgstr "包裹参数（如果有的话）的引号已被删除，所以我们只收到一个普通字符串。"

msgid ""
"If the argument was a template variable, our function is passed the current "
"value of the variable, not the variable itself."
msgstr "如果参数是一个模板变量，函数将传递变量值，而不是变量本身。"

msgid ""
"Unlike other tag utilities, ``simple_tag`` passes its output through :func:"
"`~django.utils.html.conditional_escape` if the template context is in "
"autoescape mode, to ensure correct HTML and protect you from XSS "
"vulnerabilities."
msgstr ""
"若模板上下文处于自动转义模式，不像其它标签实体， ``simple_tag`` 通过 :func:"
"`~django.utils.html.conditional_escape` 传递输出，为了确保输出正确的 HTML，避"
"免 XSS 漏洞的威胁。"

msgid ""
"If additional escaping is not desired, you will need to use :func:`~django."
"utils.safestring.mark_safe` if you are absolutely sure that your code does "
"not contain XSS vulnerabilities. For building small HTML snippets, use of :"
"func:`~django.utils.html.format_html` instead of ``mark_safe()`` is strongly "
"recommended."
msgstr ""
"如果不需要额外转义，你可能需要在万分确定您的代码不会引入任何 XSS 漏洞的情况下"
"使用 :func:`~django.utils.safestring.mark_safe`。如果只是构建小的 HTML 片段，"
"强烈建议使用 :func:`~django.utils.html.format_html`，而不是 ``mark_safe()``。"

msgid ""
"If your template tag needs to access the current context, you can use the "
"``takes_context`` argument when registering your tag::"
msgstr ""
"若您的模板标签需要访问当前上下文，你可以在注册标签时传入 ``takes_context`` 参"
"数::"

msgid "Note that the first argument *must* be called ``context``."
msgstr "注意，第一个参数必须是 ``context``。"

msgid ""
"For more information on how the ``takes_context`` option works, see the "
"section on :ref:`inclusion tags<howto-custom-template-tags-inclusion-tags>`."
msgstr ""
"更多关于 ``takes_context`` 选项如何工作的信息，参见章节 :ref:`包含标签 "
"<howto-custom-template-tags-inclusion-tags>`。"

msgid "If you need to rename your tag, you can provide a custom name for it::"
msgstr "若你需要重命名标签，你可以为其提供一个自定义名称::"

msgid ""
"``simple_tag`` functions may accept any number of positional or keyword "
"arguments. For example::"
msgstr "``simple_tag`` 函数可以接受任意数量的位置或关键字参数。例如::"

msgid ""
"Then in the template any number of arguments, separated by spaces, may be "
"passed to the template tag. Like in Python, the values for keyword arguments "
"are set using the equal sign (\"``=``\") and must be provided after the "
"positional arguments. For example:"
msgstr ""
"随后在模板中，任意数量的，以空格分隔的参数会被传递给模板标签。与 Python 中类"
"似，关键字参数的赋值使用等号（\"``=``\"），且必须在位置参数后提供。例子："

msgid ""
"It's possible to store the tag results in a template variable rather than "
"directly outputting it. This is done by using the ``as`` argument followed "
"by the variable name. Doing so enables you to output the content yourself "
"where you see fit:"
msgstr ""
"将标签结果存入一个模板变量而不是直接将其输出是可能的。这能通过使用 ``as`` 参"
"数，后跟变量名实现。这样做能让你在期望的位置输出内容："

msgid "Inclusion tags"
msgstr "包含标签"

msgid ""
"Another common type of template tag is the type that displays some data by "
"rendering *another* template. For example, Django's admin interface uses "
"custom template tags to display the buttons along the bottom of the \"add/"
"change\" form pages. Those buttons always look the same, but the link "
"targets change depending on the object being edited -- so they're a perfect "
"case for using a small template that is filled with details from the current "
"object. (In the admin's case, this is the ``submit_row`` tag.)"
msgstr ""
"另一种常见的模板标签会为 *另一个* 模板渲染数据。例如， Django 的后台利用自定"
"义模板标签在表单页的底部展示按钮。这些按钮看起来一样，但是连接目标根据被编辑"
"的对象不同而不同——所以，这是一个极好的例子，展示如何用当前对象的细节填充小模"
"板。（在后台例子中，即 ``submit_row`` 标签。）"

msgid "These sorts of tags are called \"inclusion tags\"."
msgstr "这种标签被称为“包含标签”。"

msgid ""
"Writing inclusion tags is probably best demonstrated by example. Let's write "
"a tag that outputs a list of choices for a given ``Poll`` object, such as "
"was created in the :ref:`tutorials <creating-models>`. We'll use the tag "
"like this:"
msgstr ""
"编写包含标签可能最好通过实例来展示。让我们编写一个标签，它会将指定 ``Poll`` "
"对象（就像 :ref:`教程 <creating-models>` 中创建的那样）的选项以列表输出。我们"
"像这样使用标签："

msgid "...and the output will be something like this:"
msgstr "输出看起来像这样："

msgid ""
"First, define the function that takes the argument and produces a dictionary "
"of data for the result. The important point here is we only need to return a "
"dictionary, not anything more complex. This will be used as a template "
"context for the template fragment. Example::"
msgstr ""
"首先，定义一个函数，接受参数，并返回一个字典。此处的要点是我们只需返回一个字"
"典，不是任何其它复杂的东西。这将作为一个模板上下文被模板碎片使用。例子::"

msgid ""
"Next, create the template used to render the tag's output. This template is "
"a fixed feature of the tag: the tag writer specifies it, not the template "
"designer. Following our example, the template is very simple:"
msgstr ""
"随后，创建用于渲染标签输出的模板。该模板是标签的一个固有特性：标签作者指定"
"它，而不是模板设计者。跟随我们的例子，模板非常简单："

msgid ""
"Now, create and register the inclusion tag by calling the "
"``inclusion_tag()`` method on a ``Library`` object. Following our example, "
"if the above template is in a file called ``results.html`` in a directory "
"that's searched by the template loader, we'd register the tag like this::"
msgstr ""
"现在，在 ``Library`` 对象上调用 ``inclusion_tag()`` 创建并注册该包含标签。如"
"果上述模板位于一个名为 ``results.html`` 的文件中，在模板加载器搜索的目录中，"
"我们像这样注册该标签::"

msgid ""
"Alternatively it is possible to register the inclusion tag using a :class:"
"`django.template.Template` instance::"
msgstr "或者，也能用 :class:`django.template.Template` 实例注册包含标签::"

msgid "...when first creating the function."
msgstr "在第一次创建该函数时。"

msgid ""
"Sometimes, your inclusion tags might require a large number of arguments, "
"making it a pain for template authors to pass in all the arguments and "
"remember their order. To solve this, Django provides a ``takes_context`` "
"option for inclusion tags. If you specify ``takes_context`` in creating a "
"template tag, the tag will have no required arguments, and the underlying "
"Python function will have one argument -- the template context as of when "
"the tag was called."
msgstr ""
"有时候，你的包含标签可能要求超多参数，模板作者不得不传入所有参数，并牢记它们"
"的顺序，非常痛苦。为了解决此问题， Django 为包含标签提供了一个 "
"``take_context`` 选项。如果在创建模板标签时指定了 ``takes_context``，该标签将"
"没有必要的参数，底层 Python 函数将只有一个参数——标签创建时的模板上下文。"

msgid ""
"For example, say you're writing an inclusion tag that will always be used in "
"a context that contains ``home_link`` and ``home_title`` variables that "
"point back to the main page. Here's what the Python function would look "
"like::"
msgstr ""
"举个例子，假设你编写了一个包含标签，总会在一个包含指向首页的 ``home_link`` "
"和 ``home_title`` 的上下文环境下使用。Python 函数看起来会像这样::"

msgid ""
"Note that the first parameter to the function *must* be called ``context``."
msgstr "注意，该函数的第一个参数 *必须* 是 ``context``。"

msgid ""
"In that ``register.inclusion_tag()`` line, we specified "
"``takes_context=True`` and the name of the template. Here's what the "
"template ``link.html`` might look like:"
msgstr ""
"在 ``register.inclusion_tag()`` 行，我们制定了模板名并设置 "
"``takes_context=True``。以下是模板 ``link.html`` 的样子："

msgid ""
"Then, any time you want to use that custom tag, load its library and call it "
"without any arguments, like so:"
msgstr ""
"后面，当你想用该自定义标签时，加载它的库，并不带任何参数的调用它，像这样："

msgid ""
"Note that when you're using ``takes_context=True``, there's no need to pass "
"arguments to the template tag. It automatically gets access to the context."
msgstr ""
"注意，只要使用了 ``takes_context=True``，就无需为模板标签传递参数。它自动从上"
"下文获取。"

msgid ""
"The ``takes_context`` parameter defaults to ``False``. When it's set to "
"``True``, the tag is passed the context object, as in this example. That's "
"the only difference between this case and the previous ``inclusion_tag`` "
"example."
msgstr ""
"``takes_context`` 参数默认为 ``False``。当其为 ``True``，标签会被传入上下文对"
"象，像本例展示的那样。这是本例和之前的 ``包含标签`` 实例的唯一不同之处。"

msgid ""
"``inclusion_tag`` functions may accept any number of positional or keyword "
"arguments. For example::"
msgstr "``包含标签`` 函数能接受任意个数的位置或关键字参数。例子::"

msgid "Advanced custom template tags"
msgstr "进阶自定义模板标签"

msgid ""
"Sometimes the basic features for custom template tag creation aren't enough. "
"Don't worry, Django gives you complete access to the internals required to "
"build a template tag from the ground up."
msgstr ""
"有时候，用于自定义模板标签的基础特性不够用。不要担心，Django 开放了从零开始构"
"建模板标签所需的所有内置机制。"

msgid "A quick overview"
msgstr "简介"

msgid ""
"The template system works in a two-step process: compiling and rendering. To "
"define a custom template tag, you specify how the compilation works and how "
"the rendering works."
msgstr ""
"模板系统工作只需两步：编译和渲染。为了定义自定义模板标签，你需指定如何编译和"
"渲染。"

msgid ""
"When Django compiles a template, it splits the raw template text into "
"''nodes''. Each node is an instance of ``django.template.Node`` and has a "
"``render()`` method. A compiled template is, simply, a list of ``Node`` "
"objects. When you call ``render()`` on a compiled template object, the "
"template calls ``render()`` on each ``Node`` in its node list, with the "
"given context. The results are all concatenated together to form the output "
"of the template."
msgstr ""
"Django 编译模板时，会将原始模板文本划为“节点”。每个节点都是一个 ``django."
"template.Node`` 实例，拥有一个 ``render()`` 方法。简单来说，编译完的模板就是"
"一个包含 ``节点`` 对象的列表。当你在已编译的模板上调用 ``render()``，该模板会"
"为节点列表中的每个 ``节点`` 携带指定上下文调用 ``render()`` 方法。结果会自动"
"连接，形成模板的输出。"

msgid ""
"Thus, to define a custom template tag, you specify how the raw template tag "
"is converted into a ``Node`` (the compilation function), and what the node's "
"``render()`` method does."
msgstr ""
"因此，要定义一个自定义模板标签，你要指定如何将原始模板标签转换为 ``节点`` "
"（编译函数），还要指定 ``render()`` 方法的操作。"

msgid "Writing the compilation function"
msgstr "编写编译函数"

msgid ""
"For each template tag the template parser encounters, it calls a Python "
"function with the tag contents and the parser object itself. This function "
"is responsible for returning a ``Node`` instance based on the contents of "
"the tag."
msgstr ""
"模板解析器遇到的每个模板标签，解析器都会调用一个 Python 函数，参数是标签内容"
"和解析器对象本身。该函数需要基于标签的内容返回一个 ``节点`` 实例。"

msgid ""
"For example, let's write a full implementation of our simple template tag, "
"``{% current_time %}``, that displays the current date/time, formatted "
"according to a parameter given in the tag, in :func:`~time.strftime` syntax. "
"It's a good idea to decide the tag syntax before anything else. In our case, "
"let's say the tag should be used like this:"
msgstr ""
"举个例子，让我们完整地实现简单模板标签 ``{% current_time %}``，该标签根据标签"
"中指定的参数，以 :func:`~time.strftime` 语法格式化当前时间或日期。先决定标签"
"语法是个不错的主意。在本例中，我们要这样使用标签："

msgid ""
"The parser for this function should grab the parameter and create a ``Node`` "
"object::"
msgstr "这个函数的解析器应用获取参数，并创建一个 ``节点`` 对象::"

msgid "Notes:"
msgstr "注意："

msgid ""
"``parser`` is the template parser object. We don't need it in this example."
msgstr "``parser`` 是模板解析器对象。本例中不需要。"

msgid ""
"``token.contents`` is a string of the raw contents of the tag. In our "
"example, it's ``'current_time \"%Y-%m-%d %I:%M %p\"'``."
msgstr ""
"``token.contents`` 是包含标签原始内容的字符串。本例中是 ``'current_time \"%Y-"
"%m-%d %I:%M %p\"'``。"

msgid ""
"The ``token.split_contents()`` method separates the arguments on spaces "
"while keeping quoted strings together. The more straightforward ``token."
"contents.split()`` wouldn't be as robust, as it would naively split on *all* "
"spaces, including those within quoted strings. It's a good idea to always "
"use ``token.split_contents()``."
msgstr ""
"``token.split_contents()`` 方法按空格分隔字符串，但不会分隔引号包裹的部分。二"
"愣子 ``token.contents.split()`` 就没那么健壮了，它直接在空格处分割字符串，不"
"论它们是否被引号包裹。推荐总是使用 ``token.split_contents()``。"

msgid ""
"This function is responsible for raising ``django.template."
"TemplateSyntaxError``, with helpful messages, for any syntax error."
msgstr ""
"该方法要在语法错误发生时抛出包含有用信息的 ``django.template."
"TemplateSyntaxError``。"

msgid ""
"The ``TemplateSyntaxError`` exceptions use the ``tag_name`` variable. Don't "
"hard-code the tag's name in your error messages, because that couples the "
"tag's name to your function. ``token.contents.split()[0]`` will ''always'' "
"be the name of your tag -- even when the tag has no arguments."
msgstr ""
"``TemplateSyntaxError`` 异常使用了 ``tag_name`` 变量。不要在错误消息中硬编码"
"标签名，因为这会使的标签名与函数耦合。 ``token.contents.split()[0]`` 总会返回"
"标签名——即便标签没有参数。"

msgid ""
"The function returns a ``CurrentTimeNode`` with everything the node needs to "
"know about this tag. In this case, it just passes the argument -- ``\"%Y-%m-"
"%d %I:%M %p\"``. The leading and trailing quotes from the template tag are "
"removed in ``format_string[1:-1]``."
msgstr ""
"该函数返回一个 ``CurrentTimeNode``，内含节点需要了解的标签的一切信息。在本例"
"中，仅传递了参数—— ``\"%Y-%m-%d %I:%M %p\"``。开头和结尾的引号由 "
"``format_string[1:-1]`` 删除。"

msgid ""
"The parsing is very low-level. The Django developers have experimented with "
"writing small frameworks on top of this parsing system, using techniques "
"such as EBNF grammars, but those experiments made the template engine too "
"slow. It's low-level because that's fastest."
msgstr ""
"这种解析是很低级的。Django 开发者已试着在该解析系统之上编写小型解析框架，使用"
"类似 EBNF 语法，但这些尝试使得模板引擎运行的很慢。低级意味着快。"

msgid "Writing the renderer"
msgstr "编写渲染器"

msgid ""
"The second step in writing custom tags is to define a ``Node`` subclass that "
"has a ``render()`` method."
msgstr ""
"编写自定义标签的第二步是定义一个 ``Node`` 子类，带有一个 ``render()`` 方法。"

msgid "Continuing the above example, we need to define ``CurrentTimeNode``::"
msgstr "承接上述例子，我们需要定义 ``CurrentTimeNode``::"

msgid ""
"``__init__()`` gets the ``format_string`` from ``do_current_time()``. Always "
"pass any options/parameters/arguments to a ``Node`` via its ``__init__()``."
msgstr ""
"``__init__()`` 从 ``do_current_time()`` 获取 ``format_string``。总是通过 ``节"
"点`` 的 ``__init__()`` 方法为其传入  options/parameters/arguments。"

msgid "The ``render()`` method is where the work actually happens."
msgstr "``render()`` 方法是实际干活的地方。"

msgid ""
"``render()`` should generally fail silently, particularly in a production "
"environment. In some cases however, particularly if ``context.template."
"engine.debug`` is ``True``, this method may raise an exception to make "
"debugging easier. For example, several core tags raise ``django.template."
"TemplateSyntaxError`` if they receive the wrong number or type of arguments."
msgstr ""
"``render()`` 应该无声失败，尤其是在生产环境。不过，某些场景下，尤其是 "
"``context.template.engine.debug`` 为 ``True`` 时，该方法可能抛出一个异常，简"
"化调式流程。例如，某些核心标签在接受个数不对的参数时抛出 ``django.template."
"TemplateSyntaxError``。"

msgid ""
"Ultimately, this decoupling of compilation and rendering results in an "
"efficient template system, because a template can render multiple contexts "
"without having to be parsed multiple times."
msgstr ""
"最终，这种对编译和渲染的解耦会产生一个高效的模板系统，因为一个模板无需多次解"
"析就能渲染多个上下文。"

msgid "Auto-escaping considerations"
msgstr "自动转义的注意事项"

msgid ""
"The output from template tags is **not** automatically run through the auto-"
"escaping filters (with the exception of :meth:`~django.template.Library."
"simple_tag` as described above). However, there are still a couple of things "
"you should keep in mind when writing a template tag."
msgstr ""
"模板标签的输出 **不会** 自动通过自动转义过滤器（除了上述的 :meth:`~django."
"template.Library.simple_tag` 之外）。不过，在编写模板标签时，你仍需牢记几点。"

msgid ""
"If the ``render()`` function of your template stores the result in a context "
"variable (rather than returning the result in a string), it should take care "
"to call ``mark_safe()`` if appropriate. When the variable is ultimately "
"rendered, it will be affected by the auto-escape setting in effect at the "
"time, so content that should be safe from further escaping needs to be "
"marked as such."
msgstr ""
"若模板的 ``render()`` 函数在上下文变量中存储结果（而不是以字符串返回结果），"
"它要小心地在合适的时机调用 ``mark_safe()``。当变量最后一次被渲染时，它会在这"
"个时候受到自动转义配置的影响，所以为了避免变量被进一步转义，需要如此配置。"

msgid ""
"Also, if your template tag creates a new context for performing some sub-"
"rendering, set the auto-escape attribute to the current context's value. The "
"``__init__`` method for the ``Context`` class takes a parameter called "
"``autoescape`` that you can use for this purpose. For example::"
msgstr ""
"同理，如果你的模板标签为某些子渲染进程创建了新的上下文，那么就需要将当前上下"
"文对应的自动转义属性传入。 ``Context`` 类的方法 ``__init__`` 的参数 "
"``autoescape`` 就是为此目的设计的。例如::"

msgid ""
"This is not a very common situation, but it's useful if you're rendering a "
"template yourself. For example::"
msgstr "该场景不常见，但在自助渲染模板时很有用。例如::"

msgid ""
"If we had neglected to pass in the current ``context.autoescape`` value to "
"our new ``Context`` in this example, the results would have *always* been "
"automatically escaped, which may not be the desired behavior if the template "
"tag is used inside a :ttag:`{% autoescape off %}<autoescape>` block."
msgstr ""
"在本例中，如果我们忽略了将当前的 ``context.autoescape`` 值传递给新 "
"``Context``，结果 *总会* 被自动转义，这可能与期望不同，尤其是模板标签被用于 :"
"ttag:`{% autoescape off %} <autoescape>` 块之内的时候。"

msgid "Thread-safety considerations"
msgstr "线程安全的注意事项"

msgid ""
"Once a node is parsed, its ``render`` method may be called any number of "
"times. Since Django is sometimes run in multi-threaded environments, a "
"single node may be simultaneously rendering with different contexts in "
"response to two separate requests. Therefore, it's important to make sure "
"your template tags are thread safe."
msgstr ""
"节点被解析后，其 ``render`` 方法可能被任意次地调用。由于 Django 有可能运行于"
"多线程环境，一个节点可能同时以不同的上下文进行渲染，以相应不同的请求。因此，"
"确保你的模板标签是线程安全就非常重要了。"

msgid ""
"To make sure your template tags are thread safe, you should never store "
"state information on the node itself. For example, Django provides a "
"builtin :ttag:`cycle` template tag that cycles among a list of given strings "
"each time it's rendered:"
msgstr ""
"为了确保你的模板标签是线程安全的，你应该永远不要在节点中存储状态信息。例如，"
"Django 提供了一个内置的 :ttag:`cycle` 模板标签，每次渲染时它都在一个给定字符"
"串列表间循环："

msgid ""
"A naive implementation of ``CycleNode`` might look something like this::"
msgstr "``CycleNode`` 的原生实现看起来可能像这样::"

msgid ""
"But, suppose we have two templates rendering the template snippet from above "
"at the same time:"
msgstr "但是，假设有两个模板渲染器同时渲染上述模板片段："

msgid ""
"Thread 1 performs its first loop iteration, ``CycleNode.render()`` returns "
"'row1'"
msgstr "线程 1 执行其第一次迭代， ``CycleNode.render()`` 返回 'row1'"

msgid ""
"Thread 2 performs its first loop iteration, ``CycleNode.render()`` returns "
"'row2'"
msgstr "线程 2 执行其第一次迭代， ``CycleNode.render()`` 返回 'row2'"

msgid ""
"Thread 1 performs its second loop iteration, ``CycleNode.render()`` returns "
"'row1'"
msgstr "线程 1 执行其第二次迭代， ``CycleNode.render()`` 返回 'row1'"

msgid ""
"Thread 2 performs its second loop iteration, ``CycleNode.render()`` returns "
"'row2'"
msgstr "线程 2 执行其第二次迭代， ``CycleNode.render()`` 返回 'row2'"

msgid ""
"The CycleNode is iterating, but it's iterating globally. As far as Thread 1 "
"and Thread 2 are concerned, it's always returning the same value. This is "
"obviously not what we want!"
msgstr ""
"CycleNode 正在被迭代，却是全局范围的。就像线程 1 和线程 2 担心的那样，它们总"
"是返回同样的值。这显然不是我们想要的。"

msgid ""
"To address this problem, Django provides a ``render_context`` that's "
"associated with the ``context`` of the template that is currently being "
"rendered. The ``render_context`` behaves like a Python dictionary, and "
"should be used to store ``Node`` state between invocations of the ``render`` "
"method."
msgstr ""
"为了定位此问题，Django 提供了一个 ``render_context``，关联至当前正在渲染的模"
"板的 ``context``。 ``render_context`` 表现的像一个 Python 字典，应该在其中保"
"存多次同时调用 ``render`` 方法时的 ``Node`` 状态。"

msgid ""
"Let's refactor our ``CycleNode`` implementation to use the "
"``render_context``::"
msgstr "让我们用 ``render_context`` 重构我们的 ``CycleNode`` 实现::"

msgid ""
"Note that it's perfectly safe to store global information that will not "
"change throughout the life of the ``Node`` as an attribute. In the case of "
"``CycleNode``, the ``cyclevars`` argument doesn't change after the ``Node`` "
"is instantiated, so we don't need to put it in the ``render_context``. But "
"state information that is specific to the template that is currently being "
"rendered, like the current iteration of the ``CycleNode``, should be stored "
"in the ``render_context``."
msgstr ""
"注意，将 ``Node`` 生命周期中都不会发生变化的全局信息保存为属性是非常安全的。"
"在 ``CycleNode`` 例中， ``cyclevars`` 参数在 ``Node`` 初始化后就不会变了，所"
"以无需将其放入 ``render_context``。但是当前正在渲染的模板的状态信息，类似 "
"``CycleNode`` 的当前迭代信息，就应该被保存在 ``render_context``。"

msgid ""
"Notice how we used ``self`` to scope the ``CycleNode`` specific information "
"within the ``render_context``. There may be multiple ``CycleNodes`` in a "
"given template, so we need to be careful not to clobber another node's state "
"information. The easiest way to do this is to always use ``self`` as the key "
"into ``render_context``. If you're keeping track of several state variables, "
"make ``render_context[self]`` a dictionary."
msgstr ""
"注意我们是如何利用 ``self`` 将 ``CycleNode`` 的特定参数装入 "
"``render_context`` 的。一个模板中可能有多个 ``CycleNodes``，所以我们要十分小"
"心，不要破坏其它节点的状态信息。最简单的方式就是一直将 ``self`` 作为键存入 "
"``render_context``。如果你同时追踪好几个状态变量，将 "
"``render_context[self]`` 做成一个字典。"

msgid "Registering the tag"
msgstr "注册该标签"

msgid ""
"Finally, register the tag with your module's ``Library`` instance, as "
"explained in :ref:`writing custom template filters<howto-writing-custom-"
"template-tags>` above. Example::"
msgstr ""
"最后，用模型的 ``Library`` 实例注册该标签，像上文 :ref:`编写自定义模板过滤器 "
"<howto-writing-custom-template-tags>` 介绍的那样。例子::"

msgid "The ``tag()`` method takes two arguments:"
msgstr "``tag`` 方法接收两个参数："

msgid ""
"The name of the template tag -- a string. If this is left out, the name of "
"the compilation function will be used."
msgstr "模板标签的名字——一个字符串。若为空，将会使用编译函数的名字。"

msgid ""
"As with filter registration, it is also possible to use this as a decorator::"
msgstr "就像过滤器注册一样，这里也能用装饰器::"

msgid ""
"If you leave off the ``name`` argument, as in the second example above, "
"Django will use the function's name as the tag name."
msgstr ""
"若未输入 ``name`` 参数，像上述第二个例子一样，Django 会将函数名作为标签名。"

msgid "Passing template variables to the tag"
msgstr "传递模板变量给标签"

msgid ""
"Although you can pass any number of arguments to a template tag using "
"``token.split_contents()``, the arguments are all unpacked as string "
"literals. A little more work is required in order to pass dynamic content (a "
"template variable) to a template tag as an argument."
msgstr ""
"虽然你能利用 ``token.split_contents()`` 将任意数量的变量传递给一个模板标签，"
"但是解包出来的参数均是字符串文本。要将一个动态内容（一个模板变量）作为参数传"
"递给模板标签需要额外工作。"

msgid ""
"While the previous examples have formatted the current time into a string "
"and returned the string, suppose you wanted to pass in a :class:`~django.db."
"models.DateTimeField` from an object and have the template tag format that "
"date-time:"
msgstr ""
"前文的例子已经成功将当前时间转为字符串并将之返回，假设你想传入一个 :class:"
"`~django.db.models.DateTimeField` 对象，并想用该模板标签格式化这个对象："

msgid "Initially, ``token.split_contents()`` will return three values:"
msgstr "首先，``token.split_contents()`` 会返回 3 个值："

msgid "The tag name ``format_time``."
msgstr "标签名 ``format_time``。"

msgid ""
"The string ``'blog_entry.date_updated'`` (without the surrounding quotes)."
msgstr "字符串 ``'blog_entry.date_updated'``（不包含引号）。"

msgid ""
"The formatting string ``'\"%Y-%m-%d %I:%M %p\"'``. The return value from "
"``split_contents()`` will include the leading and trailing quotes for string "
"literals like this."
msgstr ""
"格式化字符串 ``'\"%Y-%m-%d %I:%M %p\"'``。 ``split_contents()`` 的返回值会为"
"类似这样的字符串保留引号。"

msgid "Now your tag should begin to look like this::"
msgstr "现在，你的标签应该看起来像这样::"

msgid ""
"You also have to change the renderer to retrieve the actual contents of the "
"``date_updated`` property of the ``blog_entry`` object.  This can be "
"accomplished by using the ``Variable()`` class in ``django.template``."
msgstr ""
"你也需要修改 renderer，让其获取 ``blog_entry`` 对象的 ``date_updated`` 属性的"
"真实内容。这能通过在 ``django.template`` 中使用 ``Variable()`` 完成。"

msgid ""
"To use the ``Variable`` class, simply instantiate it with the name of the "
"variable to be resolved, and then call ``variable.resolve(context)``. So, "
"for example::"
msgstr ""
"要使用 ``Variable`` 类，简单地用变量名实例化它，并调用 ``variable."
"resolve(context)``。例子::"

msgid ""
"Variable resolution will throw a ``VariableDoesNotExist`` exception if it "
"cannot resolve the string passed to it in the current context of the page."
msgstr ""
"变量解决方案会在无法在当前页的上下文中找到指定字符串时抛出 "
"``VariableDoesNotExist`` 异常。"

msgid "Setting a variable in the context"
msgstr "在上下文中设置变量"

msgid ""
"The above examples simply output a value. Generally, it's more flexible if "
"your template tags set template variables instead of outputting values. That "
"way, template authors can reuse the values that your template tags create."
msgstr ""
"上述例子仅输出一个值。一般来说，如果你的模板标签设置模板变量，会比直接输出更"
"加灵活。这样，模板作者在你的模板标签创建时能复用这些值。"

msgid ""
"To set a variable in the context, just use dictionary assignment on the "
"context object in the ``render()`` method. Here's an updated version of "
"``CurrentTimeNode`` that sets a template variable ``current_time`` instead "
"of outputting it::"
msgstr ""
"要在上下文中设置变量，只需在 ``render()`` 方法中对其上下文使用字典赋值。新版"
"的 ``CurrentTimeNode`` 设置了一个模板变量 ``current_time``，而不是直接输出::"

msgid ""
"Note that ``render()`` returns the empty string. ``render()`` should always "
"return string output. If all the template tag does is set a variable, "
"``render()`` should return the empty string."
msgstr ""
"注意， ``render()`` 返回了空字符串。 ``render()`` 应该总是返回字符串。如果所"
"有的模板标签都设置了变量， ``render()`` 应该返回空字符串。"

msgid "Here's how you'd use this new version of the tag:"
msgstr "下面是如何使用新版标签的实例："

msgid "Variable scope in context"
msgstr "上下文中的变量作用域"

msgid ""
"Any variable set in the context will only be available in the same ``block`` "
"of the template in which it was assigned. This behavior is intentional; it "
"provides a scope for variables so that they don't conflict with context in "
"other blocks."
msgstr ""
"上下文内变量仅在模板中相同 ``block`` 内生效。这是故意的；提供有作用域的变量不"
"会与其它区块中的上下文发生冲突。"

msgid ""
"But, there's a problem with ``CurrentTimeNode2``: The variable name "
"``current_time`` is hard-coded. This means you'll need to make sure your "
"template doesn't use ``{{ current_time }}`` anywhere else, because the ``{% "
"current_time %}`` will blindly overwrite that variable's value. A cleaner "
"solution is to make the template tag specify the name of the output "
"variable, like so:"
msgstr ""
"但是， ``CurrentTimeNode2`` 有个问题：变量名 ``current_time`` 是硬编码的。这"
"意味着你需要确认模板未在其它地方使用 ``{{ current_time }}``，因为 ``{% "
"current_time %}`` 会绑定兵重写该变量的值。一个简洁的方法是让模板标签指定输出"
"变量的值，像这样："

msgid ""
"To do that, you'll need to refactor both the compilation function and "
"``Node`` class, like so::"
msgstr "为此，你需要重构编译函数和 ``Node`` 类，像这样::"

msgid ""
"The difference here is that ``do_current_time()`` grabs the format string "
"and the variable name, passing both to ``CurrentTimeNode3``."
msgstr ""
"此处的不同点是 ``do_current_time()`` 处理了格式化字符串和变量名，并将它们传递"
"给 ``CurrentTimeNode3``。"

msgid ""
"Finally, if you only need to have a simple syntax for your custom context-"
"updating template tag, consider using the :meth:`~django.template.Library."
"simple_tag` shortcut, which supports assigning the tag results to a template "
"variable."
msgstr ""
"最后，如果你的自定义上下文更新模板标签只需要简单的语法，考虑使用 :meth:"
"`~django.template.Library.simple_tag` 快捷方式，它支持将标签结果分配给模板变"
"量。"

msgid "Parsing until another block tag"
msgstr "解析直到碰到另一区块的标签"

msgid ""
"Template tags can work in tandem. For instance, the standard :ttag:`{% "
"comment %}<comment>` tag hides everything until ``{% endcomment %}``. To "
"create a template tag such as this, use ``parser.parse()`` in your "
"compilation function."
msgstr ""
"模板标签能串联工作。例如，标准标签 ttag:`{% comment %} <comment>` 隐藏任何东"
"西，直到碰到 ``{% endcomment %}``。要创建一个类似的标签，在编译函数中使用 "
"``parser.parse()``。"

msgid "Here's how a simplified ``{% comment %}`` tag might be implemented::"
msgstr "以下是如何实现一个简单的 ``{% comment %}`` 标签的介绍::"

msgid ""
"The actual implementation of :ttag:`{% comment %}<comment>` is slightly "
"different in that it allows broken template tags to appear between ``{% "
"comment %}`` and ``{% endcomment %}``. It does so by calling ``parser."
"skip_past('endcomment')`` instead of ``parser.parse(('endcomment',))`` "
"followed by ``parser.delete_first_token()``, thus avoiding the generation of "
"a node list."
msgstr ""
":ttag:`{% comment %} <comment>` 的实现略有不同，它允许 ``{% comment %}`` 和 "
"``{% endcomment %}`` 出现破损的标记。它通过调用 ``parser."
"skip_past('endcomment')`` （而不是 ``parser.parse(('endcomment',))``），后跟 "
"``parser.delete_first_token()``，从而避免生成节点列表。"

msgid ""
"``parser.parse()`` takes a tuple of names of block tags ''to parse until''. "
"It returns an instance of ``django.template.NodeList``, which is a list of "
"all ``Node`` objects that the parser encountered ''before'' it encountered "
"any of the tags named in the tuple."
msgstr ""
"``parser.parse()`` 接受一个包含 “解析直到” 区块标签的元组。它返回一个 "
"``django.template.NodeList`` 实例，它解析器遇到元组中的标签前解析的 ``Node`` "
"对象。"

msgid ""
"In ``\"nodelist = parser.parse(('endcomment',))\"`` in the above example, "
"``nodelist`` is a list of all nodes between the ``{% comment %}`` and ``{% "
"endcomment %}``, not counting ``{% comment %}`` and ``{% endcomment %}`` "
"themselves."
msgstr ""
"上文例子 ``\"nodelist = parser.parse(('endcomment',))\"`` 中， ``nodelist`` "
"是一个包含了 ``{% comment %}`` 和 ``{% endcomment %}`` 之间所有节点的列表，但"
"不包含 ``{% comment %}`` 和 ``{% endcomment %}`` 本身。"

msgid ""
"After ``parser.parse()`` is called, the parser hasn't yet \"consumed\" the "
"``{% endcomment %}`` tag, so the code needs to explicitly call ``parser."
"delete_first_token()``."
msgstr ""
"在调用 ``parser.parse()`` 后，解析还未 “消费掉” ``{% endcomment %}`` 标签，所"
"以代码需要显示地调用 ``parser.delete_first_token()``。"

msgid ""
"``CommentNode.render()`` simply returns an empty string. Anything between "
"``{% comment %}`` and ``{% endcomment %}`` is ignored."
msgstr ""
"``CommentNode.render()`` 简单地返回一个空字符串。 ``{% comment %}`` 和 ``{% "
"endcomment %}`` 之间的全部内容均被忽略。"

msgid "Parsing until another block tag, and saving contents"
msgstr "解析直到碰到另一区块标签，并保存内容。"

msgid ""
"In the previous example, ``do_comment()`` discarded everything between ``{% "
"comment %}`` and ``{% endcomment %}``. Instead of doing that, it's possible "
"to do something with the code between block tags."
msgstr ""
"在前文的例子中， ``do_comment`` 抛弃了 ``{% comment %}`` 和 ``{% endcomment "
"%}`` 之间的所有内容。现在我们不这么做，我们要对区块标签之间的东西做点什么。"

msgid ""
"For example, here's a custom template tag, ``{% upper %}``, that capitalizes "
"everything between itself and ``{% endupper %}``."
msgstr ""
"举个例子，这里有个模板标签， ``{% upper %}``，它将自己与 ``{% endupper %}`` "
"之间的内容全部大写。"

msgid "Usage:"
msgstr "用法："

msgid ""
"As in the previous example, we'll use ``parser.parse()``. But this time, we "
"pass the resulting ``nodelist`` to the ``Node``::"
msgstr ""
"与之前的例子一样，我们将使用 ``parser.parse()``。但这次，我们将生成的 "
"``nodelist`` 传递给 ``Node``::"

msgid ""
"The only new concept here is the ``self.nodelist.render(context)`` in "
"``UpperNode.render()``."
msgstr ""
"唯一的新概念是 ``UpperNode.render()`` 中的 ``self.nodelist."
"render(context)``。"

msgid ""
"For more examples of complex rendering, see the source code of :ttag:`{% for "
"%}<for>` in ``django/template/defaulttags.py`` and :ttag:`{% if %}<if>` in "
"``django/template/smartif.py``."
msgstr ""
"更多关于复杂渲染的例子，查看 ``django/template/defaulttags.py`` 中 :ttag:`{% "
"for %} <for>` 的源码，或 ``django/template/smartif.py`` 中 :ttag:`{% if %} "
"<if>` 的源码。"

msgid "Deployment checklist"
msgstr "部署清单"

msgid ""
"The Internet is a hostile environment. Before deploying your Django project, "
"you should take some time to review your settings, with security, "
"performance, and operations in mind."
msgstr ""
"互联网是一个恶劣的环境。在部署你的 Django 项目之前，你应该将安全、性能和操作"
"铭记于心，并花一些时间来检查你的配置。"

msgid ""
"Django includes many :doc:`security features </topics/security>`. Some are "
"built-in and always enabled. Others are optional because they aren't always "
"appropriate, or because they're inconvenient for development. For example, "
"forcing HTTPS may not be suitable for all websites, and it's impractical for "
"local development."
msgstr ""
"Django 包含了许多 :doc:`安全特性 </topics/security>`。一些是内置的并且总保持"
"激活状态，其他的则是可选的因为它们不总是恰当的，或者因为它们不便于之后的开"
"发。举个例子，强制的 HTTPS 并不一定适合所有网站，它对于本地开发就是不切实际"
"的。"

msgid ""
"Performance optimizations are another category of trade-offs with "
"convenience. For instance, caching is useful in production, less so for "
"local development. Error reporting needs are also widely different."
msgstr ""
"性能优化是另一项便利性权衡的主题。例如，缓存在生成环境很有用，但是对本地开发"
"就作用不大。错误报告的需求也大不相同。"

msgid "The following checklist includes settings that:"
msgstr "以下清单包括以下配置："

msgid ""
"must be set properly for Django to provide the expected level of security;"
msgstr "必须正确地设置 Django 以提供预期的安全级别；"

msgid "are expected to be different in each environment;"
msgstr "期望在每个环境中都是不同的；"

msgid "enable optional security features;"
msgstr "启用可选的安全功能；"

msgid "enable performance optimizations;"
msgstr "启用性能优化；"

msgid "provide error reporting."
msgstr "提供错误报告功能。"

msgid ""
"Many of these settings are sensitive and should be treated as confidential. "
"If you're releasing the source code for your project, a common practice is "
"to publish suitable settings for development, and to use a private settings "
"module for production."
msgstr ""
"许多配置项是敏感的，需要被当做机密对待。如果要发布项目源码，常见操作是为开发"
"开放合适的配置项，为生产环境配置私密设置模块。"

msgid "Run ``manage.py check --deploy``"
msgstr "运行 ``manage.py check --deploy``"

msgid ""
"Some of the checks described below can be automated using the :option:`check "
"--deploy` option. Be sure to run it against your production settings file as "
"described in the option's documentation."
msgstr ""
"下面介绍的某些检查项会自动使用 :option:`check --deploy` 选项。请确保根据选项"
"文档中描述的生产设置文件运行它。"

msgid "Critical settings"
msgstr "关键配置"

msgid ":setting:`SECRET_KEY`"
msgstr ":setting:`SECRET_KEY`"

msgid ""
"**The secret key must be a large random value and it must be kept secret.**"
msgstr "**密码必须是一个较长的随机值，且被妥善保存。**"

msgid ""
"Make sure that the key used in production isn't used anywhere else and avoid "
"committing it to source control. This reduces the number of vectors from "
"which an attacker may acquire the key."
msgstr ""
"确保生产环境使用的密码并未用于其它环境，且未被提交至版本控制系统。这将减少攻"
"击者获取密码的概率。"

msgid ""
"Instead of hardcoding the secret key in your settings module, consider "
"loading it from an environment variable::"
msgstr "逾期将安全密码硬编码在配置模块中，不然考虑从环境变量加载它::"

msgid "or from a file::"
msgstr "或者从一个文件::"

msgid ":setting:`DEBUG`"
msgstr ":setting:`DEBUG`"

msgid "**You must never enable debug in production.**"
msgstr "**永远不要在生产环境打开 debug 开关。**"

msgid ""
"You're certainly developing your project with :setting:`DEBUG = True "
"<DEBUG>`, since this enables handy features like full tracebacks in your "
"browser."
msgstr ""
"开发时，你当然要配置 :setting:`DEBUG = True <DEBUG>`，这将方便你在浏览器启用"
"完全回溯功能。"

msgid ""
"For a production environment, though, this is a really bad idea, because it "
"leaks lots of information about your project: excerpts of your source code, "
"local variables, settings, libraries used, etc."
msgstr ""
"不过，对于生产环境来说，这真是一个坏主意，因为这会泄露很多超出预期的信息：代"
"码摘要，本地变量，配置项，使用的库，等等。"

msgid "Environment-specific settings"
msgstr "特定于环境的配置"

msgid ":setting:`ALLOWED_HOSTS`"
msgstr ":setting:`ALLOWED_HOSTS`"

msgid ""
"When :setting:`DEBUG = False <DEBUG>`, Django doesn't work at all without a "
"suitable value for :setting:`ALLOWED_HOSTS`."
msgstr ""
":setting:`DEBUG = False <DEBUG>` 时，Django 在未正确配置 :setting:"
"`ALLOWED_HOSTS` 时无法工作。"

msgid ""
"This setting is required to protect your site against some CSRF attacks. If "
"you use a wildcard, you must perform your own validation of the ``Host`` "
"HTTP header, or otherwise ensure that you aren't vulnerable to this category "
"of attacks."
msgstr ""
"该配置避免你的站点遭受某些 CSRF 攻击。如果使用了通配符，你必须实现自定义的 "
"``Host`` HTTP 头，或者确保你不会很容易地遭受此种攻击。"

msgid ""
"You should also configure the Web server that sits in front of Django to "
"validate the host. It should respond with a static error page or ignore "
"requests for incorrect hosts instead of forwarding the request to Django. "
"This way you'll avoid spurious errors in your Django logs (or emails if you "
"have error reporting configured that way). For example, on nginx you might "
"setup a default server to return \"444 No Response\" on an unrecognized host:"
msgstr ""
"你也需要配置挡在 Django 之前的 Web 服务器，让它验证主机。它应该忽略来自错误主"
"机的请求，或返回静态错误页，而不是将请求重定向至 Django。这样做能避免 Django "
"日志中出现虚假错误（或在配置此种错误后，避免发送错误报告邮件）。例如，在 "
"nginx 上，你可能配置了一个默认主机，为未识别的主机返回 \"444 No Response\"："

msgid ":setting:`CACHES`"
msgstr ":setting:`CACHES`"

msgid ""
"If you're using a cache, connection parameters may be different in "
"development and in production. Django defaults to per-process :ref:`local-"
"memory caching <local-memory-caching>` which may not be desirable."
msgstr ""
"若使用了缓存，开发环境的连接参数和生产环境可能不同。Djano 默认为每个进程提"
"供 :ref:`本地内存缓存 <local-memory-caching>`，这可能与期望不同。"

msgid ""
"Cache servers often have weak authentication. Make sure they only accept "
"connections from your application servers."
msgstr "缓存服务器一般采用若验证。确保它们只接受来自你的应用服务器的连接。"

msgid ""
"If you're using Memcached, consider using :ref:`cached sessions <cached-"
"sessions-backend>` to improve performance."
msgstr ""
"若你使用了 Memcached，考虑用 :ref:`缓存会话 <cached-sessions-backend>` 来提高"
"性能。"

msgid ":setting:`DATABASES`"
msgstr ":setting:`DATABASES`"

msgid ""
"Database connection parameters are probably different in development and in "
"production."
msgstr "生产环境与开发环境的数据库连接参数可能是不同的。"

msgid ""
"Database passwords are very sensitive. You should protect them exactly like :"
"setting:`SECRET_KEY`."
msgstr "数据库密码是机密的。你应该像保护 :setting:`SECRET_KEY` 那样保护它们。"

msgid ""
"For maximum security, make sure database servers only accept connections "
"from your application servers."
msgstr "为了最大限度的安全，确保数据库只为来自你应用的连接提供服务。"

msgid "If you haven't set up backups for your database, do it right now!"
msgstr "如果你还未为数据库设置备份，现在就做！"

msgid ":setting:`EMAIL_BACKEND` and related settings"
msgstr ":setting:`EMAIL_BACKEND` 和关联配置"

msgid "If your site sends emails, these values need to be set correctly."
msgstr "如果你的站点发送邮件，以下值需要被正确地配置。"

msgid ""
"By default, Django sends email from webmaster@localhost and root@localhost. "
"However, some mail providers reject email from these addresses. To use "
"different sender addresses, modify the :setting:`DEFAULT_FROM_EMAIL` and :"
"setting:`SERVER_EMAIL` settings."
msgstr ""
"默认情况下，Django 从 webmaster@localhost 和 root@localhost 发送邮件。然而，"
"某些邮件服务商拒绝来自这些地址的邮件。为了使用不同的发件人地址，修改 :"
"setting:`DEFAULT_FROM_EMAIL` 和 :setting:`SERVER_EMAIL` 配置。"

msgid ":setting:`STATIC_ROOT` and :setting:`STATIC_URL`"
msgstr ":setting:`STATIC_ROOT` 和 :setting:`STATIC_URL`"

msgid ""
"Static files are automatically served by the development server. In "
"production, you must define a :setting:`STATIC_ROOT` directory where :"
"djadmin:`collectstatic` will copy them."
msgstr ""
"静态文件由开发服务器自动托管。但在生产环境，你必须定义配置 :setting:"
"`STATIC_ROOT` ， :djadmin:`collectstatic` 将会拷贝它们。"

msgid "See :doc:`/howto/static-files/index` for more information."
msgstr "查看 :doc:`/howto/static-files/index` 获得更多信息。"

msgid ":setting:`MEDIA_ROOT` and :setting:`MEDIA_URL`"
msgstr ":setting:`MEDIA_ROOT` 和 :setting:`MEDIA_URL`"

msgid ""
"Media files are uploaded by your users. They're untrusted! Make sure your "
"web server never attempts to interpret them. For instance, if a user uploads "
"a ``.php`` file, the web server shouldn't execute it."
msgstr ""
"媒体文件由用户上传。他们是不可信任的！确保 web 服务器从未尝试解析这些文件。例"
"如，若用户上传了一个 ``.php`` 文件，web 服务器应该永远不要运行它。"

msgid "Now is a good time to check your backup strategy for these files."
msgstr "现在是检查这些文件的备份策略的好时机。"

msgid ":setting:`FILE_UPLOAD_PERMISSIONS`"
msgstr ":setting:`FILE_UPLOAD_PERMISSIONS`"

msgid ""
"With the default file upload settings, files smaller than :setting:"
"`FILE_UPLOAD_MAX_MEMORY_SIZE` may be stored with a different mode than "
"larger files as described in :setting:`FILE_UPLOAD_PERMISSIONS`."
msgstr ""
"默认文件上传配置下，大小小于 :setting:`FILE_UPLOAD_MAX_MEMORY_SIZE` 的文件可"
"能与 :setting:`FILE_UPLOAD_PERMISSIONS` 中描述的大文件的存储模式不同。"

msgid ""
"Setting :setting:`FILE_UPLOAD_PERMISSIONS` ensures all files are uploaded "
"with the same permissions."
msgstr ""
"配置项 :setting:`FILE_UPLOAD_PERMISSIONS` 确保了所有的文件均已相同的权限上"
"传。"

msgid "HTTPS"
msgstr "HTTPS"

msgid ""
"Any website which allows users to log in should enforce site-wide HTTPS to "
"avoid transmitting access tokens in clear. In Django, access tokens include "
"the login/password, the session cookie, and password reset tokens. (You "
"can't do much to protect password reset tokens if you're sending them by "
"email.)"
msgstr ""
"允许用户登录的网站应该强制站点范围的 HTTPS，避免明文传输令牌。在 Django 中，"
"令牌包括账号/密码，会话 cookie 和重置密码的令牌。（如果你用邮件发送重置密码的"
"令牌，那就没什么办法能保护它们。）"

msgid ""
"Protecting sensitive areas such as the user account or the admin isn't "
"sufficient, because the same session cookie is used for HTTP and HTTPS. Your "
"web server must redirect all HTTP traffic to HTTPS, and only transmit HTTPS "
"requests to Django."
msgstr ""
"仅保护用户账号或后台等敏感区域是不够的，因为 HTTP 和 HTTPS 使用相同的会话 "
"cookie。Web 服务器必须将所有的 HTTP 重定向至 HTTPS，且只将 HTTPS 的请求转发"
"给 Django。"

msgid "Once you've set up HTTPS, enable the following settings."
msgstr "若你已经配置了 HTTPS，启用下列配置。"

msgid ":setting:`CSRF_COOKIE_SECURE`"
msgstr ":setting:`CSRF_COOKIE_SECURE`"

msgid ""
"Set this to ``True`` to avoid transmitting the CSRF cookie over HTTP "
"accidentally."
msgstr "将此设置为 ``True``，避免不甚用 HTTP 传输 CSRF cookie。"

msgid ":setting:`SESSION_COOKIE_SECURE`"
msgstr ":setting:`SESSION_COOKIE_SECURE`"

msgid ""
"Set this to ``True`` to avoid transmitting the session cookie over HTTP "
"accidentally."
msgstr "将此设置未 ``True``，避免不甚用 HTTP 传输会话 cookie。"

msgid "Performance optimizations"
msgstr "性能优化"

msgid ""
"Setting :setting:`DEBUG = False <DEBUG>` disables several features that are "
"only useful in development. In addition, you can tune the following settings."
msgstr ""
"配置 :setting:`DEBUG = False <DEBUG>` 会禁用几个仅在开发时有用的功能。另外，"
"你要调整下列配置。"

msgid ":setting:`CONN_MAX_AGE`"
msgstr ":setting:`CONN_MAX_AGE`"

msgid ""
"Enabling :ref:`persistent database connections <persistent-database-"
"connections>` can result in a nice speed-up when connecting to the database "
"accounts for a significant part of the request processing time."
msgstr ""
"开启 :ref:`持久数据库连接 <persistent-database-connections>` 会在连接数据库账"
"号耗费了请求处理时间的很大一部分的时候，大大提升速度。"

msgid "This helps a lot on virtualized hosts with limited network performance."
msgstr "这对带宽有限的虚拟主机帮助极大。"

msgid ":setting:`TEMPLATES`"
msgstr ":setting:`TEMPLATES`"

msgid ""
"Enabling the cached template loader often improves performance drastically, "
"as it avoids compiling each template every time it needs to be rendered. See "
"the :ref:`template loaders docs <template-loaders>` for more information."
msgstr ""
"启用缓存的模板加载器通常会极大地提升性能，因为它避免了每次渲染模板时都编译它"
"们。参考 :ref:`模板加载器文档 <template-loaders>` 获取更多信息。"

msgid "Error reporting"
msgstr "发送错误"

msgid ""
"By the time you push your code to production, it's hopefully robust, but you "
"can't rule out unexpected errors. Thankfully, Django can capture errors and "
"notify you accordingly."
msgstr ""
"在你将代码推送至生产环境后，你总是期望代码是健壮的，但你并不能控制意料之外的"
"错误。还好，Django 能捕获错误并通知你。"

msgid ":setting:`LOGGING`"
msgstr ":setting:`LOGGING`"

msgid ""
"Review your logging configuration before putting your website in production, "
"and check that it works as expected as soon as you have received some "
"traffic."
msgstr ""
"在将网站放入生产环境前，检查 logging 配置项。在你收到某些信息后，查看其是否按"
"预期运行。"

msgid "See :doc:`/topics/logging` for details on logging."
msgstr "查看 :doc:`/topics/logging` 了解 logging 的细节。"

msgid ":setting:`ADMINS` and :setting:`MANAGERS`"
msgstr ":setting:`ADMINS` 和 :setting:`MANAGERS`"

msgid ":setting:`ADMINS` will be notified of 500 errors by email."
msgstr "发生 500 错误时，会邮件通知 :setting:`ADMINS`。"

msgid ""
":setting:`MANAGERS` will be notified of 404 errors. :setting:"
"`IGNORABLE_404_URLS` can help filter out spurious reports."
msgstr ""
"404 错误会通知 :setting:`MANAGERS`。:setting:`IGNORABLE_404_URLS` 有助于过滤"
"误报。"

msgid ""
"See :doc:`/howto/error-reporting` for details on error reporting by email."
msgstr ""
"参考  :doc:`/howto/error-reporting` 了解邮件如何在发生错误时发送报告的细节。"

msgid "Error reporting by email doesn't scale very well"
msgstr "利用邮件报告错误的弹性并不好"

msgid ""
"Consider using an error monitoring system such as Sentry_ before your inbox "
"is flooded by reports. Sentry can also aggregate logs."
msgstr ""
"在收件箱被报告塞满前，考虑下使用错误监控系统，类似 Sentry_。Sentry 还可以聚合"
"日志。"

msgid "Customize the default error views"
msgstr "自定义默认错误视图"

msgid ""
"Django includes default views and templates for several HTTP error codes. "
"You may want to override the default templates by creating the following "
"templates in your root template directory: ``404.html``, ``500.html``, ``403."
"html``, and ``400.html``. The :ref:`default error views <error-views>` that "
"use these templates should suffice for 99% of Web applications, but you can :"
"ref:`customize them <customizing-error-views>` as well."
msgstr ""
"Django 为好几个 HTTP 错误代码提供了默认的视图和模板。你能通过在根模板目录创建"
"下列模板文件的方式重写默认模板： ``404.html``， ``500.html``， ``403.html`` "
"和 ``400.html``。 使用这些模板的 :ref:`默认错误视图 <error-views>` 能满足 "
"99% 的 Web 应用，不过你也能 :ref:`自定义它们 <customizing-error-views>`。"

msgid "Deploying Django"
msgstr "部署 Django"

msgid ""
"Django's chock-full of shortcuts to make Web developer's lives easier, but "
"all those tools are of no use if you can't easily deploy your sites. Since "
"Django's inception, ease of deployment has been a major goal."
msgstr ""
"Django 中简化 Web 开发的快捷函数俯拾皆是，但是如果不能轻松部署站点的话，所有"
"的工具都徒劳无益。Django 从最初就把方便部署当作一个主要目标。"

msgid ""
"If you're new to deploying Django and/or Python, we'd recommend you try :doc:"
"`mod_wsgi </howto/deployment/wsgi/modwsgi>` first. In most cases it'll be "
"the easiest, fastest, and most stable deployment choice."
msgstr ""
"如果你是初次接触 Django 或者 Python，我们推荐你先尝试阅读文档 :doc:`mod_wsgi "
"</howto/deployment/wsgi/modwsgi>`。在大多数情况，这种部署方式是最简单，最快和"
"最稳定的。"

msgid "Authenticating against Django's user database from Apache"
msgstr "Apache 利用 Django 的用户数据库进行验证"

msgid ""
"Since keeping multiple authentication databases in sync is a common problem "
"when dealing with Apache, you can configure Apache to authenticate against "
"Django's :doc:`authentication system </topics/auth/index>` directly. This "
"requires Apache version >= 2.2 and mod_wsgi >= 2.0. For example, you could:"
msgstr ""
"使用 Apache 时，保持多个身份认证数据同步是一个常见的问题，你可以让 Apache 直"
"接使用 Django 的 :doc:`验证系统 </topics/auth/index>`。这要求 Apache 版本 >= "
"2.2，且 mod_wsgi >= 2.0。例如这样："

msgid ""
"Serve static/media files directly from Apache only to authenticated users."
msgstr "仅为已授权的用户直接从 Apache 提供 static/media 文件。"

msgid ""
"Authenticate access to a Subversion_ repository against Django users with a "
"certain permission."
msgstr "仅为有特定权限的 Django 用户提供 Subversion 仓库访问。"

msgid "Allow certain users to connect to a WebDAV share created with mod_dav_."
msgstr "允许某些用户连接到 mod_dav_ 创建的 WebDAV 共享。"

msgid ""
"If you have installed a :ref:`custom user model <auth-custom-user>` and want "
"to use this default auth handler, it must support an ``is_active`` "
"attribute. If you want to use group based authorization, your custom user "
"must have a relation named 'groups', referring to a related object that has "
"a 'name' field. You can also specify your own custom mod_wsgi auth handler "
"if your custom cannot conform to these requirements."
msgstr ""
"若你已安装了一个 :ref:`自定义用户模型 <auth-custom-user>`，且想使用其默认认证"
"处理器，它必须要支持 ``is_active`` 属性。若你想使用用户组授权，自定义用户必须"
"有个关联名 'groups`，指向一个拥有 'name' 字段的关联对象。若自定义的无法满足上"
"述要求，你也可以指定自定义 mod_wsgi 认证处理器。"

msgid "Authentication with ``mod_wsgi``"
msgstr "用 ``mod_wsgi`` 进行授权认证"

msgid ""
"The use of ``WSGIApplicationGroup %{GLOBAL}`` in the configurations below "
"presumes that your Apache instance is running only one Django application. "
"If you are running more than one Django application, please refer to the "
"`Defining Application Groups`_ section of the mod_wsgi docs for more "
"information about this setting."
msgstr ""
"以下配置文件中的 ``WSGIApplicationGroup %{GLOBAL}`` 假定 Apache 实例仅运行了"
"一个 Django 应用。若你运行了不止一个 Django 应用，请参考 mod_wigi 文档的 `定"
"义应用集群`_ 章节获取更多配置信息。"

msgid ""
"Make sure that mod_wsgi is installed and activated and that you have "
"followed the steps to setup :doc:`Apache with mod_wsgi </howto/deployment/"
"wsgi/modwsgi>`."
msgstr ""
"确保你已按照 :doc:`Apache 配合 mod_wsgi </howto/deployment/wsgi/modwsgi>` 文"
"档正确安装并激活了 mod_wsgi。"

msgid ""
"Next, edit your Apache configuration to add a location that you want only "
"authenticated users to be able to view:"
msgstr "然后，编辑 Apache 配置，添加只允许授权用户查看的位置："

msgid ""
"The ``WSGIAuthUserScript`` directive tells mod_wsgi to execute the "
"``check_password`` function in specified wsgi script, passing the user name "
"and password that it receives from the prompt. In this example, the "
"``WSGIAuthUserScript`` is the same as the ``WSGIScriptAlias`` that defines "
"your application :doc:`that is created by django-admin startproject </howto/"
"deployment/wsgi/index>`."
msgstr ""
"``WSGIAuthUserScript`` 指令告诉 mod_wsgi 在指定 wsgi 脚本中执行 "
"``check_password`` 函数，并传递从提示符获取的用户名和密码。在本例中， "
"``WSGIAuthUserScript`` 与 ``WSGIScriptAlias`` 一样，后者 :doc:`由 django-"
"admin startproject 创建 </howto/deployment/wsgi/index>`，定义了应用。"

msgid "Using Apache 2.2 with authentication"
msgstr "使用带身份验证的 Apache 2.2 "

msgid "Make sure that ``mod_auth_basic`` and ``mod_authz_user`` are loaded."
msgstr "确认 ``mod_auth_basic`` 和 ``mod_authz_user`` 被加载了。"

msgid ""
"These might be compiled statically into Apache, or you might need to use "
"LoadModule to load them dynamically in your ``httpd.conf``:"
msgstr ""
"这些可能被静态编译进 Apache，或者用 LoadModule 在 ``httpd.conf`` 动态加载它"
"们："

msgid ""
"Finally, edit your WSGI script ``mysite.wsgi`` to tie Apache's "
"authentication to your site's authentication mechanisms by importing the "
"``check_password`` function::"
msgstr ""
"最后，编辑 WSGI 脚本 ``mysite.wsgi``，通过导入 ``check_password`` 函数，将 "
"Apache 的认证授权机制接续在你站点的授权机制之后::"

msgid ""
"Requests beginning with ``/secret/`` will now require a user to authenticate."
msgstr "以 ``/secret/`` 开头的请求现在会要求用户认证。"

msgid ""
"The mod_wsgi `access control mechanisms documentation`_ provides additional "
"details and information about alternative methods of authentication."
msgstr ""
"mod_wsgi `可达性控制机制文档`_ 提供了其它授权机制和方法的更多细节和信息。"

msgid "Authorization with ``mod_wsgi`` and Django groups"
msgstr "利用 ``mod_wsgi`` 和 Django 用户组(groups)进行授权"

msgid ""
"mod_wsgi also provides functionality to restrict a particular location to "
"members of a group."
msgstr "mod_wsgi 也提供了将组成员限制至特定路径的功能。"

msgid "In this case, the Apache configuration should look like this:"
msgstr "在本例中，Apache 配置应该看起来像这样："

msgid ""
"To support the ``WSGIAuthGroupScript`` directive, the same WSGI script "
"``mysite.wsgi`` must also import the ``groups_for_user`` function which "
"returns a list groups the given user belongs to."
msgstr ""
"要支持 ``WSGIAuthGroupScript`` 指令，同样的 WSGI 脚本 ``mysite.wsgi`` 必须也"
"导入 ``groups_for_user`` 函数，函数会返回用户所属用户组的列表。"

msgid ""
"Requests for ``/secret/`` will now also require user to be a member of the "
"\"secret-agents\" group."
msgstr ""
"对 ``/secret`` 的请求现在也会要求用户是 \"secret-agents\" 用户组的成员。"

msgid "How to use Django with Gunicorn"
msgstr "如何使用 Gunicorn 托管 Django"

msgid ""
"Gunicorn_ ('Green Unicorn') is a pure-Python WSGI server for UNIX. It has no "
"dependencies and is easy to install and use."
msgstr ""
"Gunicorn_ ('Green Unicorn') 是一个 UNIX 下的纯 Python WSGI 服务器。它没有其它"
"依赖，容易安装和使用。"

msgid "Installing Gunicorn"
msgstr "安装 Gunicorn"

msgid ""
"Installing gunicorn is as easy as ``pip install gunicorn``. For more "
"details, see the `gunicorn documentation`_."
msgstr ""
"安装 gunicorn 非常简单，只要执行 ``pip install gunicorn`` 即可。更多细节请参"
"考 `gunicorn documentation`_。"

msgid "Running Django in Gunicorn as a generic WSGI application"
msgstr "把 Django 当作普通 WSGI 应用在 Gunicorn 中运行"

msgid ""
"When Gunicorn is installed, a ``gunicorn`` command is available which starts "
"the Gunicorn server process. At its simplest, gunicorn just needs to be "
"called with the location of a module containing a WSGI application object "
"named `application`. So for a typical Django project, invoking gunicorn "
"would look like::"
msgstr ""
"安装 Gunicorn 之后，可以使用 ``gunicorn``  命令启动 Gunicorn 服务进程。最简模"
"式下，只需要把包含了 WSGI 应用对象的 `application` 模块位置告诉 gunicorn，就"
"可以启动了。因此对于典型的 Django 项目，像这样来调用 gunicorn::"

msgid ""
"This will start one process running one thread listening on "
"``127.0.0.1:8000``. It requires that your project be on the Python path; the "
"simplest way to ensure that is to run this command from the same directory "
"as your ``manage.py`` file."
msgstr ""
"这样会创建一个进程，包含了一个监听在 ``127.0.0.1:8000`` 的线程。前提是你的项"
"目在 Python path 中，要满足这个条件，最简单的方法是在 ``manage.py`` 文件所在"
"的目录中运行这条命令。"

msgid "See Gunicorn's `deployment documentation`_ for additional tips."
msgstr "更多技巧请参考 Gunicorn 的 `部署文档`_ 。"

msgid "How to deploy with WSGI"
msgstr "如何使用 WSGI 进行部署"

msgid ""
"Django's primary deployment platform is WSGI_, the Python standard for web "
"servers and applications."
msgstr ""
"Django 的主要部署平台是 WSGI_，它是 Web 服务器和 Web 应用的 Python 标准。"

msgid ""
"Django's :djadmin:`startproject` management command sets up a simple default "
"WSGI configuration for you, which you can tweak as needed for your project, "
"and direct any WSGI-compliant application server to use."
msgstr ""
"Django 的管理命令 :djadmin:`startproject`  生成了一个简单的默认 WSGI 配置，你"
"可以按照自己项目的需要去调整这个配置，任何兼容 WSGI 的应用服务器都可以直接使"
"用。"

msgid ""
"Django includes getting-started documentation for the following WSGI servers:"
msgstr "Django 提供了下面这些 WSGI 服务的入门文档："

msgid "The ``application`` object"
msgstr "``application`` 对象"

msgid ""
"The key concept of deploying with WSGI is the ``application`` callable which "
"the application server uses to communicate with your code. It's commonly "
"provided as an object named ``application`` in a Python module accessible to "
"the server."
msgstr ""
"用 WSGI 部署的关键是 ``application`` callable，应用服务器用它与你的代码交"
"互。 ``application`` callable 一般以一个位于 Python 模块中，名为 "
"``application`` 的对象的形式提供，且对服务器可见。"

msgid ""
"The :djadmin:`startproject` command creates a file :file:`<project_name>/"
"wsgi.py` that contains such an ``application`` callable."
msgstr ""
":djadmin:`startproject` 命令创建了文件 :file:`<project_name>/wsgi.py`，其中包"
"含了 ``application`` callable。"

msgid ""
"It's used both by Django's development server and in production WSGI "
"deployments."
msgstr "Django 开发服务器和生产环境的 WSGI 部署都用到了它。"

msgid ""
"WSGI servers obtain the path to the ``application`` callable from their "
"configuration. Django's built-in server, namely the :djadmin:`runserver` "
"command, reads it from the :setting:`WSGI_APPLICATION` setting. By default, "
"it's set to ``<project_name>.wsgi.application``, which points to the "
"``application`` callable in :file:`<project_name>/wsgi.py`."
msgstr ""
"WSGI 服务器从其配置中获取 ``application`` callable 的路径。Django 的默认服务"
"器（ :djadmin:`runserver` 命令），从配置项 :setting:`WSGI_APPLICATION` 中获"
"取。默认值是 ``<project_name>.wsgi.application``，指向 :file:`<project_name>/"
"wsgi.py` 中的 ``application`` callable。"

msgid "Configuring the settings module"
msgstr "配置 settings 模块"

msgid ""
"When the WSGI server loads your application, Django needs to import the "
"settings module — that's where your entire application is defined."
msgstr ""
"当 WSGI 服务器加载应用时，Django 需要导入配置模块——完整定义应用的地方。"

msgid ""
"Django uses the :envvar:`DJANGO_SETTINGS_MODULE` environment variable to "
"locate the appropriate settings module. It must contain the dotted path to "
"the settings module. You can use a different value for development and "
"production; it all depends on how you organize your settings."
msgstr ""
"Django 利用 :envvar:`DJANGO_SETTINGS_MODULE` 环境变量来定位合适的配置模块。它"
"必须包含到配置模块的点式路径。开发环境和生产环境可以配置不同值；这都取决于你"
"是如何组织配置的。"

msgid ""
"If this variable isn't set, the default :file:`wsgi.py` sets it to ``mysite."
"settings``, where ``mysite`` is the name of your project. That's how :"
"djadmin:`runserver` discovers the default settings file by default."
msgstr ""
"若未设置该变量， :file:`wsgi.py` 默认将其设置为 ``mysite.settings``， "
"``mysite`` 即工程名字。这就是 :djadmin:`runserver` 默认的发现默认配置行为。"

msgid ""
"Since environment variables are process-wide, this doesn't work when you run "
"multiple Django sites in the same process. This happens with mod_wsgi."
msgstr ""
"由于环境变量是进程级的，所以如果在同一进程运行多个 Django 站点将出错。这在使"
"用 mod_wsgi 时会出现。"

msgid ""
"To avoid this problem, use mod_wsgi's daemon mode with each site in its own "
"daemon process, or override the value from the environment by enforcing ``os."
"environ[\"DJANGO_SETTINGS_MODULE\"] = \"mysite.settings\"`` in your :file:"
"`wsgi.py`."
msgstr ""
"要避免此问题，为每个站点在后台进程使用 mod_wsgi 的后台模式，或者在 :file:"
"`wsgi.py` 中通过 ``os.environ[\"DJANGO_SETTINGS_MODULE\"] = \"mysite.settings"
"\"`` 重写来自环境变量的值。"

msgid "Applying WSGI middleware"
msgstr "应用 WSGI 中间件"

msgid ""
"To apply `WSGI middleware`_ you can simply wrap the application object. For "
"instance you could add these lines at the bottom of :file:`wsgi.py`::"
msgstr ""
"要应用 `WSGI 中间层`_，你只需简单包裹应用对象。举个例子，你可以在 :file:"
"`wsgi.py` 末尾添加以下代码::"

msgid ""
"You could also replace the Django WSGI application with a custom WSGI "
"application that later delegates to the Django WSGI application, if you want "
"to combine a Django application with a WSGI application of another framework."
msgstr ""
"如果你想将 Django 应用于一个 WSGI 应用或其它框架联合起来，可以用自定义 WSGI "
"应用替换 Django 的 WSGI 应用，前者会在稍晚时候将任务委托给 WSGI 应用。"

msgid "How to use Django with Apache and ``mod_wsgi``"
msgstr "如何使用 Apache 和 ``mod_wsgi`` 托管 Django"

msgid ""
"Deploying Django with Apache_ and `mod_wsgi`_ is a tried and tested way to "
"get Django into production."
msgstr "利用 Apache_ 和 `mod_wsgi`_ 在生产环境部署已经过充分测试。"

msgid ""
"mod_wsgi is an Apache module which can host any Python WSGI_ application, "
"including Django. Django will work with any version of Apache which supports "
"mod_wsgi."
msgstr ""
"mod_wsgi 是一个 Apache 模块，它可以管理任何 Python WSGI_ 应用，包括 Django。"
"Django 支持所有支持 mod_wsgi 的 Apache 版本。"

msgid ""
"The `official mod_wsgi documentation`_ is your source for all the details "
"about how to use mod_wsgi. You'll probably want to start with the "
"`installation and configuration documentation`_."
msgstr ""
"`官方 mod_wsgi 文档`_ 介绍了如何使用 mod_wsgi 的全部细节。你可能更喜欢从 `安"
"装和配置文档`_ 开始。"

msgid "Basic configuration"
msgstr "基础配置"

msgid ""
"Once you've got mod_wsgi installed and activated, edit your Apache server's "
"`httpd.conf`_ file and add the following. If you are using a version of "
"Apache older than 2.4, replace ``Require all granted`` with ``Allow from "
"all`` and also add the line ``Order deny,allow`` above it."
msgstr ""
"安装并激活 mod_wsgi 后，编辑 Apache 服务器的 `httpd.conf`_ 文件，并添加以下内"
"容。若你正在使用的 Apache 版本号早于 2.4，用 ``Allow from all`` 替换 "
"``Require all granted``，并在其上添加一行 ``Order deny,allow``。"

msgid ""
"The first bit in the ``WSGIScriptAlias`` line is the base URL path you want "
"to serve your application at (``/`` indicates the root url), and the second "
"is the location of a \"WSGI file\" -- see below -- on your system, usually "
"inside of your project package (``mysite`` in this example). This tells "
"Apache to serve any request below the given URL using the WSGI application "
"defined in that file."
msgstr ""
"``WSGIScriptAlias`` 行的第一项是你所期望的应用所在的基础 URL 路径（ ``/`` 根 "
"url），第二项是 \"WSGI 文件\" 的位置——一般位于项目包之内（本例中是 "
"``mysite``）。这告诉 Apache 用该文件中定义的 WSGI 应用响应指定 URL 下的请求。"

msgid ""
"If you install your project's Python dependencies inside a `virtualenv`_, "
"add the path to the virtualenv using ``WSGIPythonHome``. See the `mod_wsgi "
"virtualenv guide`_ for more details."
msgstr ""
"如果你在某个 `virtualenv`_ 内为应用安装项目的 Python 依赖，将该 virtualenv 的"
"路径添加至 ``WSGIPythonHome`` 。参考 `mod_wsgi virtualenv 指引`_ 获取更多细"
"节。"

msgid ""
"The ``WSGIPythonPath`` line ensures that your project package is available "
"for import on the Python path; in other words, that ``import mysite`` works."
msgstr ""
"``WSGIPythonPath`` 行确保你的项目包能从 Python path 导入；换句话说， "
"``import mysite`` 能正常工作。 "

msgid ""
"The ``<Directory>`` piece just ensures that Apache can access your :file:"
"`wsgi.py` file."
msgstr "``<Directory>`` 片段仅确保 Apache 能访问 :file:`wsgi.py` 文件。"

msgid ""
"Next we'll need to ensure this :file:`wsgi.py` with a WSGI application "
"object exists. As of Django version 1.4, :djadmin:`startproject` will have "
"created one for you; otherwise, you'll need to create it. See the :doc:`WSGI "
"overview documentation</howto/deployment/wsgi/index>` for the default "
"contents you should put in this file, and what else you can add to it."
msgstr ""
"下一步，我们需要确认 :file:`wsgi.py` 文件包含一个 WSGI 应用对象。从 Django "
"1.4 起， :djadmin:`startproject` 会自动创建；换而言之，你无需手动创建。查阅 :"
"doc:`WSGI 概述文档 </howto/deployment/wsgi/index>` 获取你需要配置的默认内容，"
"以及其它可配置项。"

msgid ""
"If multiple Django sites are run in a single mod_wsgi process, all of them "
"will use the settings of whichever one happens to run first. This can be "
"solved by changing::"
msgstr ""
"如果多个 Django 站点运行在同一 mod_wsgi 进程，它们会共用最先启动的站点配置。"
"能通过以下修改改变行为::"

msgid "in ``wsgi.py``, to::"
msgstr "``wsgi.py`` 中也这么改::"

msgid ""
"or by :ref:`using mod_wsgi daemon mode<daemon-mode>` and ensuring that each "
"site runs in its own daemon process."
msgstr ""
"或通过 :ref:`使用 mod_wsgi 的后台模式 <daemon-mode>` 确保每个站点都运行于独立"
"的后台进程。"

msgid "Fixing ``UnicodeEncodeError`` for file uploads"
msgstr "为文件上传修复 ``UnicodeEncodeError``"

msgid ""
"If you get a ``UnicodeEncodeError`` when uploading files with file names "
"that contain non-ASCII characters, make sure Apache is configured to accept "
"non-ASCII file names::"
msgstr ""
"上传名称包含非 ASCII 字符的文件时，若抛出 ``UnicodeEncodeError``，确认 "
"Apache 是否被正确配置，能接受非 ASCII 文件名::"

msgid ""
"A common location to put this configuration is ``/etc/apache2/envvars``."
msgstr "常见的配置文件路径是 ``/etc/apache2/envvars``。"

msgid ""
"See the :ref:`unicode-files` section of the Unicode reference guide for "
"details."
msgstr "参考 Unicode 参考指引的 :ref:`unicode-files` 章节获取细节信息。"

msgid "Using ``mod_wsgi`` daemon mode"
msgstr "使用 ``mod_wsgi`` 后台模式"

msgid ""
"\"Daemon mode\" is the recommended mode for running mod_wsgi (on non-Windows "
"platforms). To create the required daemon process group and delegate the "
"Django instance to run in it, you will need to add appropriate "
"``WSGIDaemonProcess`` and ``WSGIProcessGroup`` directives. A further change "
"required to the above configuration if you use daemon mode is that you can't "
"use ``WSGIPythonPath``; instead you should use the ``python-path`` option to "
"``WSGIDaemonProcess``, for example:"
msgstr ""
"\"Daemon mode\" 是运行 mod_wsgi 的推荐模式（在非 Windows 平台上）。为了创建必"
"要的后台进程组并在其中运行 Django 实例，你需要添加合适的 "
"``WSGIDaemonProcess`` 和 ``WSGIProcessGroup`` 指令。上述配置在你使用后台模式"
"时需要点小修改，即你不能使用 ``WSGIPythonPath``；作为替换，你要在 "
"``WSGIDaemonProcess`` 中添加 ``python-path`` 选项，例如："

msgid ""
"If you want to serve your project in a subdirectory (``https://example.com/"
"mysite`` in this example), you can add ``WSGIScriptAlias`` to the "
"configuration above:"
msgstr ""
"如果你想在子目录中开放你的项目（本例中 ``https://example.com/mysite``），你可"
"在上述配置中添加 ``WSGIScriptAlias``："

msgid ""
"See the official mod_wsgi documentation for `details on setting up daemon "
"mode`_."
msgstr "参考官方 mod_wsgi 文档获取 `配置后台模式的细节`_。"

msgid "Serving files"
msgstr "提供文件服务"

msgid ""
"Django doesn't serve files itself; it leaves that job to whichever Web "
"server you choose."
msgstr "Django 本身并不提供文件服务；他将这个职责交给了你选择的 Web 服务器。"

msgid ""
"We recommend using a separate Web server -- i.e., one that's not also "
"running Django -- for serving media. Here are some good choices:"
msgstr ""
"我们推荐使用一个独立的 Web 服务器，即其未运行 Django——仅用于媒体服务。以下是"
"一些不错的选项："

msgid "Nginx_"
msgstr "Nginx_"

msgid "A stripped-down version of Apache_"
msgstr "一个 Apache_ 的朴素版本"

msgid ""
"If, however, you have no option but to serve media files on the same Apache "
"``VirtualHost`` as Django, you can set up Apache to serve some URLs as "
"static media, and others using the mod_wsgi interface to Django."
msgstr ""
"然而，若你别无选择，只能在与 Django 相同的 Apache ``VirtualHost`` 上提供媒体"
"文件，你可以让 Apache 为一些 URL 提供静态媒体服务，其它的用 mod_wsgi 接口传递"
"给 Django。"

msgid ""
"This example sets up Django at the site root, but serves ``robots.txt``, "
"``favicon.ico``, and anything in the ``/static/`` and ``/media/`` URL space "
"as a static file. All other URLs will be served using mod_wsgi:"
msgstr ""
"本例在站点根目录配置 Django，但以静态文件的形式提供 ``robots.txt``， "
"``favicon.ico`` 以及 ``/static/`` 和 ``/media/`` 中的内容。其它所有 URL 以 "
"mod_wsgi 提供服务："

msgid ""
"If you are using a version of Apache older than 2.4, replace ``Require all "
"granted`` with ``Allow from all`` and also add the line ``Order deny,allow`` "
"above it."
msgstr ""
"若使用早于 2.4 的 Apache，将 ``Require all granted`` 替换为 ``Allow from "
"all`` ，并在其上添加 ``Order deny,allow``。"

msgid "Serving the admin files"
msgstr "服务后台文件"

msgid ""
"When :mod:`django.contrib.staticfiles` is in :setting:`INSTALLED_APPS`, the "
"Django development server automatically serves the static files of the admin "
"app (and any other installed apps). This is however not the case when you "
"use any other server arrangement. You're responsible for setting up Apache, "
"or whichever Web server you're using, to serve the admin files."
msgstr ""
":setting:`INSTALLED_APPS` 中包含 :mod:`django.contrib.staticfiles` 时，"
"Django 开发服务器自动为这些归属于后台应用（也包含其它已安装的应用）的静态文件"
"提供服务。这与你使用其它服务器时不太一样。你需要正确配置 Apache 或其它你使用"
"的 Web 服务器，另其正确的为后台文件提供服务。"

msgid ""
"The admin files live in (:file:`django/contrib/admin/static/admin`) of the "
"Django distribution."
msgstr ""
"后台文件位于 Django 发行版的 (:file:`django/contrib/admin/static/admin`) 中。"

msgid ""
"We **strongly** recommend using :mod:`django.contrib.staticfiles` to handle "
"the admin files (along with a Web server as outlined in the previous "
"section; this means using the :djadmin:`collectstatic` management command to "
"collect the static files in :setting:`STATIC_ROOT`, and then configuring "
"your Web server to serve :setting:`STATIC_ROOT` at :setting:`STATIC_URL`), "
"but here are three other approaches:"
msgstr ""
"我们 **强烈** 建议用 :mod:`django.contrib.staticfiles` 处理后台文件（连同上一"
"节所述的 Web 服务器；这意味着用 :djadmin:`collectstatic` 管理命令收集 :"
"setting:`STATIC_ROOT` 中的静态文件，然后配置 Web 服务器，使其在 :setting:"
"`STATIC_URL` 为 :setting:`STATIC_ROOT` 提供服务），不过，这还有几个方法："

msgid ""
"Create a symbolic link to the admin static files from within your document "
"root (this may require ``+FollowSymLinks`` in your Apache configuration)."
msgstr ""
"在文档根目录中创建一个指向后台静态文件的符号链接（Apache 配置中可能要添加 ``"
"+FollowSymLinks``）。"

msgid ""
"Use an ``Alias`` directive, as demonstrated above, to alias the appropriate "
"URL (probably :setting:`STATIC_URL` + ``admin/``) to the actual location of "
"the admin files."
msgstr ""
"使用前文介绍的 ``Alias`` 指令，为合适的 URL (可能是 :setting:`STATIC_URL` + "
"``admin/``) 取个别名，指向后台文件的实际位置。"

msgid ""
"Copy the admin static files so that they live within your Apache document "
"root."
msgstr "直接将后台静态文件拷贝至 Apache 的文档根目录。"

msgid ""
"Django provides a handler to allow Apache to authenticate users directly "
"against Django's authentication backends. See the :doc:`mod_wsgi "
"authentication documentation </howto/deployment/wsgi/apache-auth>`."
msgstr ""
"Django 提供了一个处理器，允许 Apache 直接用 Django 的认证授权后端认证用户。参"
"考文档 :doc:`mod_wsgi 认证授权文档 </howto/deployment/wsgi/apache-auth>`。"

msgid "How to use Django with uWSGI"
msgstr "如何用 uWSGI 托管 Django"

msgid ""
"uWSGI_ is a fast, self-healing and developer/sysadmin-friendly application "
"container server coded in pure C."
msgstr ""
"uWSGI_ 是一个快速的，自我驱动的，对开发者和系统管理员友好的应用容器服务器，完"
"全由 C 编写。"

msgid ""
"The uWSGI docs offer a `tutorial`_ covering Django, nginx, and uWSGI (one "
"possible deployment setup of many). The docs below are focused on how to "
"integrate Django with uWSGI."
msgstr ""
"uWSGI 文档提供了一个覆盖 Django，nginx，和 uWSGI（一个配置，多种适配）。以下"
"文档专注于如何用 uWSGI 集成 Django。"

msgid "Prerequisite: uWSGI"
msgstr "前置条件：uWSGI"

msgid ""
"The uWSGI wiki describes several `installation procedures`_. Using pip, the "
"Python package manager, you can install any uWSGI version with a single "
"command. For example:"
msgstr ""
"uWSGI 百科介绍了几种 `安装流程`_。Pip （Python 包管理器）能让你仅用一行代码就"
"安装任意版本的 uWSGI。例子："

msgid "uWSGI model"
msgstr "uWSGI 模块"

msgid ""
"uWSGI operates on a client-server model. Your Web server (e.g., nginx, "
"Apache) communicates with a `django-uwsgi` \"worker\" process to serve "
"dynamic content."
msgstr ""
"uWSGI 以客户端-服务端模式运行。Web 服务器（例如 nginx，Apache）与一个 "
"`django-uwsgi` \"worker\" 进程交互，提供动态内容。"

msgid "Configuring and starting the uWSGI server for Django"
msgstr "配置并启动用于 Django 的 uWSGI 服务器"

msgid ""
"uWSGI supports multiple ways to configure the process. See uWSGI's "
"`configuration documentation`_."
msgstr "uWSGI 支持多种配置进程的方式。参考 uWSGI 的 `配置文档`_。"

msgid "Here's an example command to start a uWSGI server::"
msgstr "以下是个示例命令，用于启动一个 uWSGI 服务器::"

msgid ""
"This assumes you have a top-level project package named ``mysite``, and "
"within it a module :file:`mysite/wsgi.py` that contains a WSGI "
"``application`` object. This is the layout you'll have if you ran ``django-"
"admin startproject mysite`` (using your own project name in place of "
"``mysite``) with a recent version of Django. If this file doesn't exist, "
"you'll need to create it. See the :doc:`/howto/deployment/wsgi/index` "
"documentation for the default contents you should put in this file and what "
"else you can add to it."
msgstr ""
"假设你有个叫做 ``mysite`` 的顶级项目包，期中包含一个模板 :file:`mysite/wsgi."
"py`，模块包含一个 WSGI ``application`` 对象。如果你使用的是较新的 Django，这"
"就是你运行 ``django-admin startproject mysite`` （使用你的项目名替换 "
"``mysite``）后得到的目录结构。若该文件不存在，你需要创建它。参考文档 :doc:`/"
"howto/deployment/wsgi/index` 看看你需要配置的默认内容，以及你还能添加什么。"

msgid "The Django-specific options here are:"
msgstr "Django 指定的参数如下："

msgid ""
"``chdir``: The path to the directory that needs to be on Python's import "
"path -- i.e., the directory containing the ``mysite`` package."
msgstr ""
"``chdir``：需要包含于 Python 的导入路径的目录的路径——例如，包含 ``mysite`` 包"
"的目录。"

msgid ""
"``module``: The WSGI module to use -- probably the ``mysite.wsgi`` module "
"that :djadmin:`startproject` creates."
msgstr ""
"``module``：要使用的 WSGI 模块——可能是 :djadmin:`startproject` 创建的 "
"``mysite.wsgi`` 的模块。"

msgid "``env``: Should probably contain at least ``DJANGO_SETTINGS_MODULE``."
msgstr "``env``：至少要包括 ``DJANGO_SETTINGS_MODULE``。"

msgid "``home``: Optional path to your project virtualenv."
msgstr "``home``: 可选的路径，指向你工程的 virtualenv。"

msgid "Example ini configuration file::"
msgstr "示例 ini 配置文件::"

msgid "Example ini configuration file usage::"
msgstr "示例 ini 配置文件语法::"

msgid ""
"If you get a ``UnicodeEncodeError`` when uploading files with file names "
"that contain non-ASCII characters, make sure uWSGI is configured to accept "
"non-ASCII file names by adding this to your ``uwsgi.ini``::"
msgstr ""
"如果上传的文件名包含非 ASCII 字符时，可能抛出 ``UnicodeEncodeError``，确保 "
"uWSGI 已正确配置，能接受非 ASCII 字符的文件名，通过在 ``uwsgi.ini`` 添加以下"
"内容::"

msgid ""
"See the uWSGI docs on `managing the uWSGI process`_ for information on "
"starting, stopping and reloading the uWSGI workers."
msgstr ""
"参考 uWSGI 文档 `管理 uWSGI 进程`_ 获取更多关于开启，关闭和重载 uWSGI "
"workers 的信息。"

msgid ""
"When you're running a public site you should always turn off the :setting:"
"`DEBUG` setting. That will make your server run much faster, and will also "
"prevent malicious users from seeing details of your application that can be "
"revealed by the error pages."
msgstr ""
"当您运行着公开的网页时，你应该把设置中的 :setting:`DEBUG` 选项设为关闭。 这将"
"使您的服务器运行得更快，并且还可以防止恶意用户在错误页面中看到应用的详细信"
"息。"

msgid ""
"However, running with :setting:`DEBUG` set to ``False`` means you'll never "
"see errors generated by your site -- everyone will just see your public "
"error pages. You need to keep track of errors that occur in deployed sites, "
"so Django can be configured to create reports with details about those "
"errors."
msgstr ""
"然而，把 :setting:`DEBUG` 设置为 `False`， 这意味着你永远不会在你的网站上看到"
"错误的细节，所有的人都只是看到你公开的错误页面。当你需要在部署的网页上追踪出"
"现的错误，Django 可以通过设置去报告错误的细节。"

msgid "Email reports"
msgstr "通过邮件方式报告"

msgid "Server errors"
msgstr "服务器错误"

msgid ""
"When :setting:`DEBUG` is ``False``, Django will email the users listed in "
"the :setting:`ADMINS` setting whenever your code raises an unhandled "
"exception and results in an internal server error (HTTP status code 500). "
"This gives the administrators immediate notification of any errors. The :"
"setting:`ADMINS` will get a description of the error, a complete Python "
"traceback, and details about the HTTP request that caused the error."
msgstr ""
":setting:`DEBUG` 为 ``False`` 时，Django 会在代码抛出的异常未被捕获或导致一个"
"内部的服务器错误（HTTP 状态码 500）时向 :setting:`ADMINS` 配置中列出的用户发"
"送邮件。这让管理员立刻收到错误通知。 :setting:`ADMINS` 会收到详细的错误描述，"
"完整的 Python 调用栈，引发此错误的 HTTP 请求的细节。"

msgid ""
"In order to send email, Django requires a few settings telling it how to "
"connect to your mail server. At the very least, you'll need to specify :"
"setting:`EMAIL_HOST` and possibly :setting:`EMAIL_HOST_USER` and :setting:"
"`EMAIL_HOST_PASSWORD`, though other settings may be also required depending "
"on your mail server's configuration. Consult :doc:`the Django settings "
"documentation </ref/settings>` for a full list of email-related settings."
msgstr ""
"要发送邮件，Django 要求一些配置项，告诉它如何连接至邮件服务器。最小配置下，你"
"需要指定 :setting:`EMAIL_HOST` 和 :setting:`EMAIL_HOST_USER` 和 :setting:"
"`EMAIL_HOST_PASSWORD`，可能还有其它配置，这取决于邮件服务器的配置。查阅 :doc:"
"`Django 配置文档 </ref/settings>` 获取邮件相关配置的完整列表。"

msgid ""
"By default, Django will send email from root@localhost. However, some mail "
"providers reject all email from this address. To use a different sender "
"address, modify the :setting:`SERVER_EMAIL` setting."
msgstr ""
"默认情况下，Django 会从 root@localhost 发送邮件。然而，某些邮件服务商拒绝来自"
"该地址的所有邮件。要使用不同的发件人地址，修改 :setting:`SERVER_EMAIL` 配置。"

msgid ""
"To activate this behavior, put the email addresses of the recipients in the :"
"setting:`ADMINS` setting."
msgstr "要启动该行为，将收件人的邮箱地址放入 :setting:`ADMINS`。"

msgid ""
"Server error emails are sent using the logging framework, so you can "
"customize this behavior by :doc:`customizing your logging configuration </"
"topics/logging>`."
msgstr ""
"服务器错误邮件由 logging 框架发出，所以你能通过 :doc:`自定义 logging 配置 </"
"topics/logging>` 自定义该行为。"

msgid "404 errors"
msgstr "404 错误"

msgid ""
"Django can also be configured to email errors about broken links (404 \"page "
"not found\" errors). Django sends emails about 404 errors when:"
msgstr ""
"Django 也能配置成为已失效的连接发送错误邮件（404 \"page not found\" 错误）。"
"Django 发送 404 错误邮件的条件："

msgid ":setting:`DEBUG` is ``False``;"
msgstr ":setting:`DEBUG` 为 ``False``；"

msgid ""
"Your :setting:`MIDDLEWARE` setting includes :class:`django.middleware.common."
"BrokenLinkEmailsMiddleware`."
msgstr ""
":setting:`MIDDLEWARE` 配置包括 :class:`django.middleware.common."
"BrokenLinkEmailsMiddleware`。"

msgid ""
"If those conditions are met, Django will email the users listed in the :"
"setting:`MANAGERS` setting whenever your code raises a 404 and the request "
"has a referer. It doesn't bother to email for 404s that don't have a referer "
"-- those are usually just people typing in broken URLs or broken Web bots. "
"It also ignores 404s when the referer is equal to the requested URL, since "
"this behavior is from broken Web bots too."
msgstr ""
"如以上条件均满足，Django 会在代码抛出 404 错误且请求有对应来源时向 :setting:"
"`MANAGERS` 配置项中的用户发送邮件。Django 并不会为没有来源的 404s 发送邮件——"
"这些通常是人们或失效的网络爬虫直接输入无效链接。Django 还忽略来源于所请求的 "
"URL 相同的 404s，因为这往往是失效的网络爬虫干的。"

msgid ""
":class:`~django.middleware.common.BrokenLinkEmailsMiddleware` must appear "
"before other middleware that intercepts 404 errors, such as :class:`~django."
"middleware.locale.LocaleMiddleware` or :class:`~django.contrib.flatpages."
"middleware.FlatpageFallbackMiddleware`. Put it towards the top of your :"
"setting:`MIDDLEWARE` setting."
msgstr ""
":class:`~django.middleware.common.BrokenLinkEmailsMiddleware` 必须出现在其它"
"拦截 404 错误的中间层之前，例如 :class:`~django.middleware.locale."
"LocaleMiddleware` 或 :class:`~django.contrib.flatpages.middleware."
"FlatpageFallbackMiddleware`。将其置于 :setting:`MIDDLEWARE` 配置项的顶部。"

msgid ""
"You can tell Django to stop reporting particular 404s by tweaking the :"
"setting:`IGNORABLE_404_URLS` setting. It should be a list of compiled "
"regular expression objects. For example::"
msgstr ""
"你可以通过调整配置项 :setting:`IGNORABLE_404_URLS` 让 Django 忽略某些 404s。"
"内容应该是已编译的正则表达式的列表。例子::"

msgid ""
"In this example, a 404 to any URL ending with ``.php`` or ``.cgi`` will "
"*not* be reported. Neither will any URL starting with ``/phpmyadmin/``."
msgstr ""
"在本例中，对以 ``.php`` 或 ``.cgi`` 结尾的 URL 的 404 错误将 *不会* 被报告。"
"以 ``phpmyadmin`` 开头的也不会被报告。"

msgid ""
"The following example shows how to exclude some conventional URLs that "
"browsers and crawlers often request::"
msgstr "下面的例子展示了如何排除一些浏览器和爬虫经常访问的传统 URL::"

msgid ""
"(Note that these are regular expressions, so we put a backslash in front of "
"periods to escape them.)"
msgstr "（注意，这些都是正则表达式，所以我们用反斜杠转义了点号。）"

msgid ""
"If you'd like to customize the behavior of :class:`django.middleware.common."
"BrokenLinkEmailsMiddleware` further (for example to ignore requests coming "
"from web crawlers), you should subclass it and override its methods."
msgstr ""
"若后续你想自定义 :class:`django.middleware.common."
"BrokenLinkEmailsMiddleware` 的行为（例如忽略来自网络爬虫的请求），你需要继承"
"该类，并重写方法。"

msgid ""
"404 errors are logged using the logging framework. By default, these log "
"records are ignored, but you can use them for error reporting by writing a "
"handler and :doc:`configuring logging </topics/logging>` appropriately."
msgstr ""
"404 错误由 logging 框架报告。默认情况下，这些日志记录被忽略了，但你能通过编写"
"一个处理器和 :doc:`配置 logging </topics/logging>` 让它们报告错误。"

msgid "Filtering error reports"
msgstr "过滤错误报告"

msgid ""
"Filtering sensitive data is a hard problem, and it's nearly impossible to "
"guarantee that sensitive data won't leak into an error report. Therefore, "
"error reports should only be available to trusted team members and you "
"should avoid transmitting error reports unencrypted over the Internet (such "
"as through email)."
msgstr ""
"过滤敏感数据是个极度困难的问题，且几乎不可能不将敏感数据泄露至错误报告。因"
"此，错误报告应该只对可信任的团队成员开放，并且，你应该避免直接通过明文传输错"
"误报告（例如通过邮件）。"

msgid "Filtering sensitive information"
msgstr "过滤敏感数据"

msgid ""
"Error reports are really helpful for debugging errors, so it is generally "
"useful to record as much relevant information about those errors as "
"possible. For example, by default Django records the `full traceback`_ for "
"the exception raised, each `traceback frame`_’s local variables, and the :"
"class:`~django.http.HttpRequest`’s :ref:`attributes<httprequest-attributes>`."
msgstr ""
"错误报告对于调试错误来说超级有用，所以通常尽可能多的记录关键信息。例如，"
"Django 默认记录了抛出异常的 `完整调用栈`_，每个 `调用栈层`_ 的局部变量，以"
"及 :class:`~django.http.HttpRequest` 的 :ref:`属性 <httprequest-"
"attributes>`。"

msgid ""
"However, sometimes certain types of information may be too sensitive and "
"thus may not be appropriate to be kept track of, for example a user's "
"password or credit card number. So in addition to filtering out settings "
"that appear to be sensitive as described in the :setting:`DEBUG` "
"documentation, Django offers a set of function decorators to help you "
"control which information should be filtered out of error reports in a "
"production environment (that is, where :setting:`DEBUG` is set to "
"``False``): :func:`sensitive_variables` and :func:"
"`sensitive_post_parameters`."
msgstr ""
"然而，有时候某些信息会涉及敏感内容，因此不适合写入调用栈。例如，用户的密码或"
"信用卡号。故此，为了过滤 :setting:`DEBUG` 文档中描述的敏感内容，Django 提供了"
"一系列的函数装饰器，帮你控制在生产环境（即 :setting:`DEBUG` 为 ``False``）下"
"应该从错误报告中过滤掉哪些信息：:func:`sensitive_variables` 和 :func:"
"`sensitive_post_parameters`。"

msgid ""
"If a function (either a view or any regular callback) in your code uses "
"local variables susceptible to contain sensitive information, you may "
"prevent the values of those variables from being included in error reports "
"using the ``sensitive_variables`` decorator::"
msgstr ""
"若代码中的一个函数（也可能是视图或定期回调）使用容易包含敏感信息的本地变量，"
"你可以用 ``sensitive_variables`` 装饰器阻止错误报告包含这些变量的值::"

msgid ""
"In the above example, the values for the ``user``, ``pw`` and ``cc`` "
"variables will be hidden and replaced with stars (`**********`) in the error "
"reports, whereas the value of the ``name`` variable will be disclosed."
msgstr ""
"上述例子中，错误报告中变量 ``user``， ``pw`` 和 ``cc`` 的值会被以星开头的字符"
"串(`**********`)替换 ，不过 ``name`` 变量的值不会被屏蔽。"

msgid ""
"To systematically hide all local variables of a function from error logs, do "
"not provide any argument to the ``sensitive_variables`` decorator::"
msgstr ""
"要在错误日志中系统的隐藏所有的局部变量，不要向 ``sensitive_variables`` 装饰器"
"传入任何参数::"

msgid "When using multiple decorators"
msgstr "同时使用多个装饰器时"

msgid ""
"If the variable you want to hide is also a function argument (e.g. "
"'``user``’ in the following example), and if the decorated function has "
"multiple decorators, then make sure to place ``@sensitive_variables`` at the "
"top of the decorator chain. This way it will also hide the function argument "
"as it gets passed through the other decorators::"
msgstr ""
"若你想隐藏的变量还是一个函数参数（下例中 '``user``’），且被装饰的函数已拥有好"
"几个装饰器，确保将 ``@sensitive_variables`` 置于最上面。这样，它就也能隐藏函"
"数参数了，因为它穿过其它装饰器::"

msgid ""
"If one of your views receives an :class:`~django.http.HttpRequest` object "
"with :attr:`POST parameters<django.http.HttpRequest.POST>` susceptible to "
"contain sensitive information, you may prevent the values of those "
"parameters from being included in the error reports using the "
"``sensitive_post_parameters`` decorator::"
msgstr ""
"若视图收到一个包含 :attr:`POST 参数 <django.http.HttpRequest.POST>` 的 :"
"class:`~django.http.HttpRequest` 对象，参数中极有可能内含敏感信息。你可以通"
"过 ``sensitive_post_parameters`` 装饰器避免这些参数的值被包括在错误报告中::"

msgid ""
"In the above example, the values for the ``pass_word`` and "
"``credit_card_number`` POST parameters will be hidden and replaced with "
"stars (`**********`) in the request's representation inside the error "
"reports, whereas the value of the ``name`` parameter will be disclosed."
msgstr ""
"上文例子中，POST 参数 ``pass_word`` 和 ``credit_card_number`` 的值会被隐藏，"
"通过在错误报告中展示请求信息的地方用星号开头的字符串 (`**********`) 替换，而"
"参数 ``name`` 的值不会被屏蔽。"

msgid ""
"To systematically hide all POST parameters of a request in error reports, do "
"not provide any argument to the ``sensitive_post_parameters`` decorator::"
msgstr ""
"要在错误报告中系统的屏蔽所有 POST 参数，不要给 ``sensitive_post_parameters`` "
"装饰器提供任何参数::"

msgid ""
"All POST parameters are systematically filtered out of error reports for "
"certain :mod:`django.contrib.auth.views` views (``login``, "
"``password_reset_confirm``, ``password_change``, and ``add_view`` and "
"``user_change_password`` in the ``auth`` admin) to prevent the leaking of "
"sensitive information such as user passwords."
msgstr ""
"为了避免敏感信息的泄露（例如账号密码）， 所有传入认证视图 :mod:`django."
"contrib.auth.views` （``login``， ``password_reset_confirm``， "
"``password_change``， and ``add_view`` 和 ``auth`` 后台中的 "
"``user_change_password``）的 POST 参数都在错误报告中经过系统过滤。"

msgid "Custom error reports"
msgstr "自定义错误报告"

msgid ""
"All :func:`sensitive_variables` and :func:`sensitive_post_parameters` do is, "
"respectively, annotate the decorated function with the names of sensitive "
"variables and annotate the ``HttpRequest`` object with the names of "
"sensitive POST parameters, so that this sensitive information can later be "
"filtered out of reports when an error occurs. The actual filtering is done "
"by Django's default error reporter filter: :class:`django.views.debug."
"SafeExceptionReporterFilter`. This filter uses the decorators' annotations "
"to replace the corresponding values with stars (`**********`) when the error "
"reports are produced. If you wish to override or customize this default "
"behavior for your entire site, you need to define your own filter class and "
"tell Django to use it via the :setting:`DEFAULT_EXCEPTION_REPORTER_FILTER` "
"setting::"
msgstr ""
":func:`sensitive_variables` 和 :func:`sensitive_post_parameters` 所做的全部工"
"作是，前者用敏感变量名注解被装饰的函数，后者用 POST 参数中的敏感变量名注解 "
"``HttpRequest`` 对象，所以敏感信息能在后续错误发生时从报告中过滤出去。这项过"
"滤操作者实际上是由 Django 的默认错误报告处理器： :class:`django.views.debug."
"SafeExceptionReporterFilter`。该过滤器在错误报告生成时，利用装饰器注解以星号 "
"(`**********`) 替换指定值。若你想在全站范围重写或自定义该默认行为，你需要定义"
"你的过滤器类，并通过配置项 :setting:`DEFAULT_EXCEPTION_REPORTER_FILTER` 告诉 "
"Django 启用它::"

msgid ""
"You may also control in a more granular way which filter to use within any "
"given view by setting the ``HttpRequest``’s ``exception_reporter_filter`` "
"attribute::"
msgstr ""
"你也能在任意视图内以一种更细碎的方式控制过滤器，通过设置 ``HttpRequest`` 的 "
"``exception_reporter_filter`` 属性::"

msgid ""
"Your custom filter class needs to inherit from :class:`django.views.debug."
"SafeExceptionReporterFilter` and may override the following methods:"
msgstr ""
"自定义过滤器类需要继承自 :class:`django.views.debug."
"SafeExceptionReporterFilter` 并重写以下方法："

msgid ""
"Returns ``True`` to activate the filtering operated in the other methods. By "
"default the filter is active if :setting:`DEBUG` is ``False``."
msgstr ""
"返回 ``True`` 将激活其它方法中的过滤操作。 :setting:`DEBUG` 为 ``False`` 时，"
"过滤器默认是激活的。"

msgid ""
"Returns the filtered dictionary of POST parameters. By default it replaces "
"the values of sensitive parameters with stars (`**********`)."
msgstr ""
"返回 POST 参数过滤后的字典。默认情况下，它将敏感参数的值替换成星号 "
"(`**********`)。"

msgid ""
"Returns the filtered dictionary of local variables for the given traceback "
"frame. By default it replaces the values of sensitive variables with stars "
"(`**********`)."
msgstr ""
"返回给定的调用栈层中的局部变量经过过滤后的字段。默认情况下，它将敏感参数的值"
"替换成星号 (`**********`)。"

msgid ""
"You can also set up custom error reporting by writing a custom piece of :ref:"
"`exception middleware <exception-middleware>`. If you do write custom error "
"handling, it's a good idea to emulate Django's built-in error handling and "
"only report/log errors if :setting:`DEBUG` is ``False``."
msgstr ""
"你也能够通过自定义一系列的 :ref:`异常中间层 <exception-middleware>` 定制错误"
"报告行为。若你已经编写了自定义错误处理器，模仿 Django 内置的错误处理器，并只"
"在 :setting:`DEBUG` 为 ``False`` 时报告或记录错误是个不错的主意。"

msgid "\"How-to\" guides"
msgstr "操作指南"

msgid ""
"Here you'll find short answers to \"How do I....?\" types of questions. "
"These how-to guides don't cover topics in depth -- you'll find that material "
"in the :doc:`/topics/index` and the :doc:`/ref/index`. However, these guides "
"will help you quickly accomplish common tasks."
msgstr ""
"你将在此找到大量回答形如“我该如何……”问题的简答。这些怎么做指南不会深入各个主"
"题——你可以在 :doc:`/topics/index` 和 :doc:`/ref/index` 找到深入的讲解。不过，"
"这些指引可以帮你快速完成常见的任务。"

msgid ""
"The `Django community aggregator`_, where we aggregate content from the "
"global Django community. Many writers in the aggregator write this sort of "
"how-to material."
msgstr ""
"`Django 聚合社区`_，我们将全球 Django 社区的内容聚合至此。聚合社区中的很多作"
"者编写了本快速指南文档。"

msgid "Providing initial data for models"
msgstr "为模型提供初始化的数据"

msgid ""
"It's sometimes useful to pre-populate your database with hard-coded data "
"when you're first setting up an app. You can provide initial data with "
"migrations or fixtures."
msgstr ""
"第一次配置应用时，用硬编码的数据预备数据库有时很很有用。你能通过迁移和固定内"
"容提供初始数据。"

msgid "Providing initial data with migrations"
msgstr "通过迁移提供初始数据"

msgid ""
"If you want to automatically load initial data for an app, create a :ref:"
"`data migration <data-migrations>`. Migrations are run when setting up the "
"test database, so the data will be available there, subject to :ref:`some "
"limitations <test-case-serialized-rollback>`."
msgstr ""
"若你想为应用自动载入初始数据，创建一个 :ref:`数据迁移 <data-migrations>`。创"
"建测试数据库时会运行迁移，所以可以用这里的数据， :ref:`一些限制 <test-case-"
"serialized-rollback>` 主题。"

msgid "Providing data with fixtures"
msgstr "通过固定内容提供数据"

msgid ""
"You can also provide data using fixtures, however, this data isn't loaded "
"automatically, except if you use :attr:`.TransactionTestCase.fixtures`."
msgstr ""
"你也能通过固定内容提供数据，不过，这些数据不会自动加载，除非你使用 :attr:`."
"TransactionTestCase.fixtures`。"

msgid ""
"A fixture is a collection of data that Django knows how to import into a "
"database. The most straightforward way of creating a fixture if you've "
"already got some data is to use the :djadmin:`manage.py dumpdata <dumpdata>` "
"command. Or, you can write fixtures by hand; fixtures can be written as "
"JSON, XML or YAML (with PyYAML_ installed) documents. The :doc:"
"`serialization documentation </topics/serialization>` has more details about "
"each of these supported :ref:`serialization formats <serialization-formats>`."
msgstr ""
"固定内容是一个 Django 知道如何导入数据库的集合。若你已有一些可用数据，最直接"
"的创建固定内容的方式是使用  :djadmin:`manage.py dumpdata <dumpdata>` 命令。或"
"者，你可以手写固定内容；固定数据能被写作 JSON，XML 或 YAML （要求已安装 "
"PyYAML_）文档。 :doc:`序列化文档 </topics/serialization>` 拥有更多这些支持"
"的 :ref:`序列化格式 <serialization-formats>` 的细节信息。"

msgid ""
"As an example, though, here's what a fixture for a simple ``Person`` model "
"might look like in JSON:"
msgstr ""
"例子，这有一个固定内容，描述了一个简单 ``Person`` 模型写成 JSON 后的样子："

msgid "And here's that same fixture as YAML:"
msgstr "以下是一样的固定内容，YAML 格式："

msgid "You'll store this data in a ``fixtures`` directory inside your app."
msgstr "你会将该数据存入应用中的 ``fixtures`` 字典。"

msgid ""
"Loading data is easy: just call :djadmin:`manage.py loaddata <loaddata>` "
"``<fixturename>``, where ``<fixturename>`` is the name of the fixture file "
"you've created. Each time you run :djadmin:`loaddata`, the data will be read "
"from the fixture and re-loaded into the database. Note this means that if "
"you change one of the rows created by a fixture and then run :djadmin:"
"`loaddata` again, you'll wipe out any changes you've made."
msgstr ""
"加载数据非常简单：只需调用 :djadmin:`manage.py loaddata <loaddata>` "
"``<fixturename>``， ``<fixturename>`` 是你刚创建的固定内容的文件名。每次你运"
"行 :djadmin:`loaddata`，数据都会从固定内容读出，重新装入数据库。这意味着若你"
"修改了某个固定内容创建的行，随后再次运行 :djadmin:`loaddata` ，你会丢掉所有的"
"修改。"

msgid "Where Django finds fixture files"
msgstr "Django 从哪里寻找固定内容文件"

msgid ""
"By default, Django looks in the ``fixtures`` directory inside each app for "
"fixtures. You can set the :setting:`FIXTURE_DIRS` setting to a list of "
"additional directories where Django should look."
msgstr ""
"默认情况下，Django 在每个应用的 ``fixtures`` 目录中查找固定内容。你可以将配置"
"项 :setting:`FIXTURE_DIRS` 设为一个 Django 需要额外寻找的目录列表。"

msgid ""
"When running :djadmin:`manage.py loaddata <loaddata>`, you can also specify "
"a path to a fixture file, which overrides searching the usual directories."
msgstr ""
":djadmin:`manage.py loaddata <loaddata>` 时，你也能指定一个到固定内容文件的路"
"径，这将会覆盖查找常规目录的行为。"

msgid ""
"Fixtures are also used by the :ref:`testing framework <topics-testing-"
"fixtures>` to help set up a consistent test environment."
msgstr ""
"固定内容通常备 :ref:`测试框架 <topics-testing-fixtures>` 用于创建永久的测试环"
"境。"

msgid "Django on Jython"
msgstr "基于 Jython 的 Django"

msgid ""
"Jython_ is an implementation of Python that runs on the Java platform (JVM)."
msgstr "Jython_ 是运行在 Java 平台(JVM) 的 Python 实现。"

msgid ""
"If you want to use Jython (which supports only Python 2.7 at the time of "
"this writing), you must use Django 1.11.x (the last series to support Python "
"2). Jython support may be readded to Django if a Python 3 compatible Jython "
"is released."
msgstr ""
"若你想使用 Jython（编写文本时，它只支持 Python 2.7），你必须使用 Django 1.11."
"x（支持 Python 2 的最终版本）。若兼容 Python 3 的 Jython 发布了，你可能能在这"
"里读到 Django 关于 Jython 支持的内容。"

msgid "Integrating Django with a legacy database"
msgstr "Django 使用旧有的数据库"

msgid ""
"While Django is best suited for developing new applications, it's quite "
"possible to integrate it into legacy databases. Django includes a couple of "
"utilities to automate as much of this process as possible."
msgstr ""
"虽然 Django 很适合开发新应用，但也能用它集成旧数据库。Django 包含了一整套套件"
"来尽可能自动处理类似的任务。"

msgid ""
"This document assumes you know the Django basics, as covered in the :doc:"
"`tutorial </intro/tutorial01>`."
msgstr ""
"本文假设你有 Django 基础，基础内容由 :doc:`教程 </intro/tutorial01>` 介绍。"

msgid ""
"Once you've got Django set up, you'll follow this general process to "
"integrate with an existing database."
msgstr "你配置完 Django 后，你就能跟着此常规操作去集成旧数据库了。"

msgid "Give Django your database parameters"
msgstr "将数据库参数告诉 Django"

msgid ""
"You'll need to tell Django what your database connection parameters are, and "
"what the name of the database is. Do that by editing the :setting:"
"`DATABASES` setting and assigning values to the following keys for the "
"``'default'`` connection:"
msgstr ""
"你需要告诉 Django 数据库连接参数和数据库名称。通过编写 :setting:`DATABASES` "
"配置项并为 ``'默认'`` 连接指定下列值："

msgid ":setting:`NAME`"
msgstr ":setting:`NAME`"

msgid ":setting:`ENGINE <DATABASE-ENGINE>`"
msgstr ":setting:`ENGINE <DATABASE-ENGINE>`"

msgid ":setting:`USER`"
msgstr ":setting:`USER`"

msgid ":setting:`PASSWORD`"
msgstr ":setting:`PASSWORD`"

msgid ":setting:`HOST`"
msgstr ":setting:`HOST`"

msgid ":setting:`PORT`"
msgstr ":setting:`PORT`"

msgid "Auto-generate the models"
msgstr "自动生成这些模型"

msgid ""
"Django comes with a utility called :djadmin:`inspectdb` that can create "
"models by introspecting an existing database. You can view the output by "
"running this command::"
msgstr ""
"Django 自带一个叫做 :djadmin:`inspectdb` 的工具，它可以通过内省已存在的数据库"
"创建对应模型。你能通过运行以下命令看到输出::"

msgid "Save this as a file by using standard Unix output redirection::"
msgstr "通过标准 Unix 输出重定向将其保存为文件::"

msgid ""
"This feature is meant as a shortcut, not as definitive model generation. See "
"the :djadmin:`documentation of inspectdb <inspectdb>` for more information."
msgstr ""
"该功能仅是一个快捷方式，不是最佳的创建模型的方法。参考 :djadmin:`inspectdb 文"
"档 <inspectdb>` 获取更多信息。"

msgid ""
"Once you've cleaned up your models, name the file ``models.py`` and put it "
"in the Python package that holds your app. Then add the app to your :setting:"
"`INSTALLED_APPS` setting."
msgstr ""
"只要你整理完这些模型，就可以将文件重命名为 ``models.py`` 并将其放入持有应用"
"的 Python 包中。随后，将应用添加至 :setting:`INSTALLED_APPS` 配置。"

msgid ""
"By default, :djadmin:`inspectdb` creates unmanaged models. That is, "
"``managed = False`` in the model's ``Meta`` class tells Django not to manage "
"each table's creation, modification, and deletion::"
msgstr ""
"默认情况下， :djadmin:`inspectdb` 创建未托管的模型。也就是说，模型的 `Meta`` "
"类中的 ``managed = False`` 告诉 Django 不要管理这些表的创建，修改和删除::"

msgid ""
"If you do want to allow Django to manage the table's lifecycle, you'll need "
"to change the :attr:`~django.db.models.Options.managed` option above to "
"``True`` (or simply remove it because ``True`` is its default value)."
msgstr ""
"若你的确想要允许 Django 管理这些表格的生命周期，你需要将上面的 :attr:"
"`~django.db.models.Options.managed` 选项的值改为 ``True`` （或者直接删掉它，"
"因为 ``True`` 是默认值）。"

msgid "Install the core Django tables"
msgstr "安装核心 Django 表"

msgid ""
"Next, run the :djadmin:`migrate` command to install any extra needed "
"database records such as admin permissions and content types::"
msgstr ""
"然后，运行 :djadmin:`migrate` 命令安装所有额外需要的数据库记录，像是后台权限"
"和内容类型::"

msgid "Test and tweak"
msgstr "测试和调整"

msgid ""
"Those are the basic steps -- from here you'll want to tweak the models "
"Django generated until they work the way you'd like. Try accessing your data "
"via the Django database API, and try editing objects via Django's admin "
"site, and edit the models file accordingly."
msgstr ""
"这些是基本步骤——这样，你就能调整 Django 生成的模型，直到他们达到你的要求。试"
"着通过 Django 数据库 API 访问数据，试着通过 Django 后台站点编辑数据，也可以直"
"接编辑模型文件。"

msgid "Outputting CSV with Django"
msgstr "利用 Django 输出 CSV"

msgid ""
"This document explains how to output CSV (Comma Separated Values) "
"dynamically using Django views. To do this, you can either use the Python "
"CSV library or the Django template system."
msgstr ""
"本文介绍如何用 Django 的视图动态输出 CSV (Comma Separated Values)。要达到目"
"的，你可以使用 Python 的 CSV 库或 Django 的模板系统。"

msgid "Using the Python CSV library"
msgstr "使用 Python 的 CSV 库"

msgid ""
"Python comes with a CSV library, :mod:`csv`. The key to using it with Django "
"is that the :mod:`csv` module's CSV-creation capability acts on file-like "
"objects, and Django's :class:`~django.http.HttpResponse` objects are file-"
"like objects."
msgstr ""
"Python 有用一个 CSV 库 :mod:`csv`。它配合 Django 使用的关键是 :mod:`csv` 模块"
"的 CSV 创建行为作用于类文件对象，而 Django 的 :class:`~django.http."
"HttpResponse` 对象也是类文件对象。"

msgid "Here's an example::"
msgstr "这有个例子::"

msgid ""
"The code and comments should be self-explanatory, but a few things deserve a "
"mention:"
msgstr "代码和注释应该是不言自明的，但是有几件事值得提一下："

msgid ""
"The response gets a special MIME type, :mimetype:`text/csv`. This tells "
"browsers that the document is a CSV file, rather than an HTML file. If you "
"leave this off, browsers will probably interpret the output as HTML, which "
"will result in ugly, scary gobbledygook in the browser window."
msgstr ""
"响应指定了特殊的 MIME 类型 :mimetype:`text/csv`。这告诉浏览器该文档是一个 "
"CSV 文件，而不是一个 HTML 文件。如果你没这么干，浏览器可能会将输出视作 HTML，"
"这会在浏览器窗口展示丑陋的，恐怖的官样文章。"

msgid ""
"The response gets an additional ``Content-Disposition`` header, which "
"contains the name of the CSV file. This filename is arbitrary; call it "
"whatever you want. It'll be used by browsers in the \"Save as...\" dialog, "
"etc."
msgstr ""
"相应还包括一个额外的 ``Content-Disposition`` 头，其中包含了 CSV 文件的名称。"
"文件名是任意的；随便你怎么叫。它会被浏览器在 \"保存为……\" 对话框中用到。"

msgid ""
"Hooking into the CSV-generation API is easy: Just pass ``response`` as the "
"first argument to ``csv.writer``. The ``csv.writer`` function expects a file-"
"like object, and :class:`~django.http.HttpResponse` objects fit the bill."
msgstr ""
"接入生成 CSV API 非常简单：仅需将 ``response`` 作为第一个参数传给 ``csv."
"writer``。 ``csv.writer`` 函数期望一个类文件对象，而 :class:`~django.http."
"HttpResponse` 对象满足该要求。"

msgid ""
"For each row in your CSV file, call ``writer.writerow``, passing it an :term:"
"`iterable`."
msgstr ""
"要按行输出 CSV 文件，调用 ``writer.writerrow``，传入一个 :term:`iterable` 参"
"数。"

msgid ""
"The CSV module takes care of quoting for you, so you don't have to worry "
"about escaping strings with quotes or commas in them. Just pass "
"``writerow()`` your raw strings, and it'll do the right thing."
msgstr ""
"CSV 模块为你处理了引号，所以你无需担心包含引号或逗号的字符串的转义问题。只需"
"为 ``writerow()`` 传入原始字符串，它为你处理好一切。"

msgid "Streaming large CSV files"
msgstr "输出超大 CSV 文件"

msgid ""
"When dealing with views that generate very large responses, you might want "
"to consider using Django's :class:`~django.http.StreamingHttpResponse` "
"instead. For example, by streaming a file that takes a long time to generate "
"you can avoid a load balancer dropping a connection that might have "
"otherwise timed out while the server was generating the response."
msgstr ""
"当处理生成很多回复的视图时，你可能要考虑使用 Django 的 :class:`~django.http."
"StreamingHttpResponse` 作为替代。例如，要进行耗时的输出文件流的操作，你可以避"
"免负载均衡器在服务器输出耗时相应时，可能由于超时抛弃改连接。"

msgid ""
"In this example, we make full use of Python generators to efficiently handle "
"the assembly and transmission of a large CSV file::"
msgstr ""
"在本例中，我们充分利用 Python 的生成器，高效地处理大型 CSV 文件的装配和输出任"
"务::"

msgid "Using the template system"
msgstr "使用模板系统"

msgid ""
"Alternatively, you can use the :doc:`Django template system </topics/"
"templates>` to generate CSV. This is lower-level than using the convenient "
"Python :mod:`csv` module, but the solution is presented here for "
"completeness."
msgstr ""
"或者，你也能用 :doc:`Djano 模板系统 </topics/templates>` 生成 CSV。这比使用方"
"便的 :mod:`csv` 模块级别低点，但是，解决方案就在这，你可以选。"

msgid ""
"The idea here is to pass a list of items to your template, and have the "
"template output the commas in a :ttag:`for` loop."
msgstr "办法就是将项目列表传给模板，让模板在 :ttag:`for` 循环中输出逗号。"

msgid "Here's an example, which generates the same CSV file as above::"
msgstr "以下例子输出与前文一样的 CSV 文件::"

msgid ""
"The only difference between this example and the previous example is that "
"this one uses template loading instead of the CSV module. The rest of the "
"code -- such as the ``content_type='text/csv'`` -- is the same."
msgstr ""
"本例与前例唯一的不同是本例使用模板加载，而不是 CSV 模块。剩下的代码都一样，例"
"如  ``content_type='text/csv'``。"

msgid ""
"Then, create the template ``my_template_name.txt``, with this template code:"
msgstr "然后，用模板代码创建模板 ``my_template_name.txt``。"

msgid ""
"This template is quite basic. It just iterates over the given data and "
"displays a line of CSV for each row. It uses the :tfilter:`addslashes` "
"template filter to ensure there aren't any problems with quotes."
msgstr ""
"本例非常基础。它仅仅遍历所给的数据，并为每行生成一个 CSV 行。它利用 :tfilter:"
"`addslashes` 模板过滤器确保引号不会引发任何问题。"

msgid "Other text-based formats"
msgstr "其它文本格式"

msgid ""
"Notice that there isn't very much specific to CSV here -- just the specific "
"output format. You can use either of these techniques to output any text-"
"based format you can dream of. You can also use a similar technique to "
"generate arbitrary binary data; see :doc:`/howto/outputting-pdf` for an "
"example."
msgstr ""
"注意，这里并没有太多特定于 CSV 的内容——仅是特定的输出格式。你可以使用其中任意"
"一种输出你能想到文本内容。你也能用类似的技术生成任意二进制数据；参考 :doc:`/"
"howto/outputting-pdf` 的例子。"

msgid "Outputting PDFs with Django"
msgstr "利用 Django 输出 PDF"

msgid ""
"This document explains how to output PDF files dynamically using Django "
"views. This is made possible by the excellent, open-source ReportLab_ Python "
"PDF library."
msgstr ""
"本文介绍如何用 Django 的视图动态输出 PDF 文件。该功能由绝佳的开源 ReportLab_ "
"Python  PDF 库提供。"

msgid ""
"The advantage of generating PDF files dynamically is that you can create "
"customized PDFs for different purposes -- say, for different users or "
"different pieces of content."
msgstr ""
"动态生成 PDF 文件的优点是你可以为不同的目的创建不同的自定义 PDF——例如，为不同"
"的用户或内容的不同片段生成 PDF。"

msgid ""
"For example, Django was used at kusports.com_ to generate customized, "
"printer-friendly NCAA tournament brackets, as PDF files, for people "
"participating in a March Madness contest."
msgstr ""
"例如，kusports.com_ 用 Django 将自定义的，打印友好的 NCAA 锦标赛树状图生成 "
"PDF 文件，发放给参加三月疯狂竞赛的人。"

msgid "Install ReportLab"
msgstr "安装 ReportLab"

msgid ""
"The ReportLab library is `available on PyPI`_. A `user guide`_ (not "
"coincidentally, a PDF file) is also available for download. You can install "
"ReportLab with ``pip``:"
msgstr ""
"ReportLab 库可从 `PyPI`_ 获取。也可以下载 `用户指南`_ （一份 PDF 文件，这不是"
"巧合）。你可以用 ``pip`` 安装 ReportLab："

msgid ""
"Test your installation by importing it in the Python interactive "
"interpreter::"
msgstr "在 Python 交互解释器中导入它，测试你的安装是否成功::"

msgid "If that command doesn't raise any errors, the installation worked."
msgstr "若该命令未抛出任何错误，安装成功。"

msgid "Write your view"
msgstr "编写视图"

msgid ""
"The key to generating PDFs dynamically with Django is that the ReportLab API "
"acts on file-like objects, and Django's :class:`~django.http.FileResponse` "
"objects accept file-like objects."
msgstr ""
"利用 Django 动态生成 PDF 的关键是 ReportLab API 作用于类文件对象，而 Django "
"的 :class:`~django.http.FileResponse` 对象接收类文件对象。"

msgid "Here's a \"Hello World\" example::"
msgstr "这有个 \"Hello World\" 示例::"

msgid ""
"The response will automatically set the MIME type :mimetype:`application/"
"pdf` based on the filename extension. This tells browsers that the document "
"is a PDF file, rather than an HTML file or a generic `application/octet-"
"stream` binary content."
msgstr ""
"响应会自动基于文件扩展名将 MIME 类型设置为 :mimetype:`application/pdf`。这告"
"诉浏览器该文档是个 PDF 文件，而不是 HTML 文件或普通的 `application/octet-"
"stream` 二进制内容。"

msgid ""
"When ``as_attachment=True`` is passed to ``FileResponse``, it sets the "
"appropriate ``Content-Disposition`` header and that tells Web browsers to "
"pop-up a dialog box prompting/confirming how to handle the document even if "
"a default is set on the machine. If the ``as_attachment`` parameter is "
"omitted, browsers will handle the PDF using whatever program/plugin they've "
"been configured to use for PDFs."
msgstr ""
"将 ``as_attachment=True`` 传递给 ``FileResponse`` 时，它会设置合适的 "
"``Content-Disposition`` 头，这将告诉 Web 浏览器弹出一个对话框，提示或确认如何"
"处理该文档，即便设备已配置默认行为。若省略了 ``as_attachment`` 参数，浏览器会"
"用已配置的用于处理 PDF 的程序或插件来处理该 PDF。"

msgid ""
"You can provide an arbitrary ``filename`` parameter. It'll be used by "
"browsers in the \"Save as...\" dialog."
msgstr "你也可以提供可选参数 ``filename``。浏览器的“另存为…”对话框会用到它。"

msgid ""
"Hooking into the ReportLab API is easy: The same buffer passed as the first "
"argument to ``canvas.Canvas`` can be fed to the :class:`~django.http."
"FileResponse` class."
msgstr ""
"使用 ReportLab API 非常简单：作为第一个参数传递给 ``canvas.Canvas`` 的缓冲区"
"也能传递给 :class:`~django.http.FileResponse` 类。"

msgid ""
"Note that all subsequent PDF-generation methods are called on the PDF object "
"(in this case, ``p``) -- not on ``buffer``."
msgstr ""
"注意，所有后续生成 PDF 的方法都是在 PDF 对象上调用的（本例中是 ``p``）——而不"
"是在 ``buffer`` 上调用。"

msgid ""
"Finally, it's important to call ``showPage()`` and ``save()`` on the PDF "
"file."
msgstr "最后，牢记在 PDF 文件上调用 ``showPage()`` 和 ``save()``。"

msgid ""
"ReportLab is not thread-safe. Some of our users have reported odd issues "
"with building PDF-generating Django views that are accessed by many people "
"at the same time."
msgstr ""
"ReportLab 不是线程安全的。某些用户已经报告了一些奇怪的 issue，在创建用于生成 "
"PDF 的 Django 视图时，这些视图被多个用户同时访问会出现问题。"

msgid "Other formats"
msgstr "其它格式"

msgid ""
"Notice that there isn't a lot in these examples that's PDF-specific -- just "
"the bits using ``reportlab``. You can use a similar technique to generate "
"any arbitrary format that you can find a Python library for. Also see :doc:`/"
"howto/outputting-csv` for another example and some techniques you can use "
"when generated text-based formats."
msgstr ""
"注意，这些例子中没有任何 PDF 特有的数据——只有使用 ``reportlab`` 的部分。你可"
"以用类似的技巧生成任意格式，只要你能找到对应的 Python 库。也请看看 :doc:`/"
"howto/outputting-csv`，看看另一个例子中，如何用一些技巧输出文本内容。"

msgid ""
"Django Packages provides a `comparison of packages <https://djangopackages."
"org/grids/g/pdf/>`_ that help generate PDF files from Django."
msgstr ""
"Django 包提供了一个 `包的比较 <https://djangopackages.org/grids/g/pdf/>`_ 有"
"助于用 Django 生成 PDF 文件。"

msgid "Overriding templates"
msgstr "复写模板"

msgid ""
"In your project, you might want to override a template in another Django "
"application, whether it be a third-party application or a contrib "
"application such as ``django.contrib.admin``. You can either put template "
"overrides in your project's templates directory or in an application's "
"templates directory."
msgstr ""
"在项目中，你可以想要在另一个 Django 应用中重写模板，不论它是第三方应用或 "
"contrib 应用，例如 ``django.contrib.admin``。你可以将重写的模板置于工程的模板"
"目录或应用的模板目录。"

msgid ""
"If you have app and project templates directories that both contain "
"overrides, the default Django template loader will try to load the template "
"from the project-level directory first. In other words, :setting:`DIRS "
"<TEMPLATES-DIRS>` is searched before :setting:`APP_DIRS <TEMPLATES-"
"APP_DIRS>`."
msgstr ""
"若应用和工程的模板模板都包含被重写的模板，默认的 Django 模板加载器会先尝试加"
"载工程目录下的模板。换句话说，先查找 :setting:`DIRS <TEMPLATES-DIRS>`，其次 :"
"setting:`APP_DIRS <TEMPLATES-APP_DIRS>`。"

msgid ""
"Read :ref:`overriding-built-in-widget-templates` if you're looking to do "
"that."
msgstr "阅读 :ref:`重写内置视图模板` 若你正在找相关资料。"

msgid "Overriding from the project's templates directory"
msgstr "重写来自工程目录的模板"

msgid ""
"First, we'll explore overriding templates by creating replacement templates "
"in your project's templates directory."
msgstr "首先，我们探索用在工程模板目录创建替代模板的方法。"

msgid ""
"Let's say you're trying to override the templates for a third-party "
"application called ``blog``, which provides the templates ``blog/post.html`` "
"and ``blog/list.html``. The relevant settings for your project would look "
"like::"
msgstr ""
"假设你正在重写第三方应用 ``blog`` 的模板，该应用提供了 ``blog/post.html`` 和 "
"``blog/list.html`` 模板。工程关键配置如下::"

msgid ""
"The :setting:`TEMPLATES` setting and ``BASE_DIR`` will already exist if you "
"created your project using the default project template. The setting that "
"needs to be modified is :setting:`DIRS<TEMPLATES-DIRS>`."
msgstr ""
"若用模板工程模板创建工程，则 :setting:`TEMPLATES` 和 ``BASE_DIR`` 早已存在。"
"需要修改的配置是 :setting:`DIRS <TEMPLATES-DIRS>`。"

msgid ""
"These settings assume you have a ``templates`` directory in the root of your "
"project. To override the templates for the ``blog`` app, create a folder in "
"the ``templates`` directory, and add the template files to that folder:"
msgstr ""
"这些配置假定在工程根目录下有个 ``templates`` 目录。要重写 ``blog`` 应用的模"
"板，在 ``templates`` 目录中创建一个文件夹，然后将以下模板文件添加至该目录："

msgid ""
"The template loader first looks for templates in the ``DIRS`` directory. "
"When the views in the ``blog`` app ask for the ``blog/post.html`` and ``blog/"
"list.html`` templates, the loader will return the files you just created."
msgstr ""
"模板加载器会先查找 ``DIRS`` 目录下的模板。当 ``blog`` 应用中的视图要求 "
"``blog/post.html`` 和 ``blog/list.html`` 模板，加载器会返回你刚创建的文件。"

msgid "Overriding from an app's template directory"
msgstr "重写来自应用模板目录的模板"

msgid ""
"Since you're overriding templates located outside of one of your project's "
"apps, it's more common to use the first method and put template overrides in "
"a project's templates folder. If you prefer, however, it's also possible to "
"put the overrides in an app's template directory."
msgstr ""
"由于重写的模板位于工程应用之外，更常见的做法是使用第一个方法，然后将重写的模"
"板置于工程模板目录。然而，如果你偏爱将重写的模板放入应用模板目录，也是可以"
"的。"

msgid ""
"First, make sure your template settings are checking inside app directories::"
msgstr "首先，确保模板配置会搜索应用模板目录::"

msgid ""
"If you want to put the template overrides in an app called ``myapp`` and the "
"templates to override are named ``blog/list.html`` and ``blog/post.html``, "
"then your directory structure will look like:"
msgstr ""
"若你想重写名为 ``blog/list.html`` 和 ``blog/post.html`` 的模板，并将它们置于"
"名为 ``myapp`` 的应用中，那么目录结构应该看起来像这样："

msgid ""
"With :setting:`APP_DIRS<TEMPLATES-APP_DIRS>` set to ``True``, the template "
"loader will look in the app's templates directory and find the templates."
msgstr ""
"当 :setting:`APP_DIRS <TEMPLATES-APP_DIRS>` 置为 ``True`` 时，模板加载器会深"
"入应用的模板目录查找模板。"

msgid "Deploying static files"
msgstr "部署静态文件"

msgid ""
"For an introduction to the use of :mod:`django.contrib.staticfiles`, see :"
"doc:`/howto/static-files/index`."
msgstr ""
"想要 :mod:`django.contrib.staticfiles` 的使用指南，请参考 :doc:`/howto/"
"static-files/index`。"

msgid "Serving static files in production"
msgstr "在生产环境提供静态文件服务"

msgid ""
"The basic outline of putting static files into production is simple: run "
"the :djadmin:`collectstatic` command when static files change, then arrange "
"for the collected static files directory (:setting:`STATIC_ROOT`) to be "
"moved to the static file server and served. Depending on :setting:"
"`STATICFILES_STORAGE`, files may need to be moved to a new location manually "
"or the :func:`post_process <django.contrib.staticfiles.storage."
"StaticFilesStorage.post_process>` method of the ``Storage`` class might take "
"care of that."
msgstr ""
"在生产环境部署静态文件的要点很简单：在静态文件变化时，运行 :djadmin:"
"`collectstatic`，然后将已收集的静态文件目录(:setting:`STATIC_ROOT`)移至静态文"
"件服务器并提供服务。 :setting:`STATICFILES_STORAGE` 可能会要求手动将文件移动"
"到新位置，不过 ``Storage`` 类的 :func:`post_process <django.contrib."
"staticfiles.storage.StaticFilesStorage.post_process>` 方法可能会处理它。"

msgid ""
"Of course, as with all deployment tasks, the devil's in the details. Every "
"production setup will be a bit different, so you'll need to adapt the basic "
"outline to fit your needs. Below are a few common patterns that might help."
msgstr ""
"当然，像所有的部署任务一样，细节决定成败。每个生成环境的配置可能都有点不同"
"个，所以，需要调整配置以满足你的需求。以下是常见模式，可能对你有所帮助。"

msgid "Serving the site and your static files from the same server"
msgstr "在同一服务器提供站点和静态文件服务"

msgid ""
"If you want to serve your static files from the same server that's already "
"serving your site, the process may look something like:"
msgstr ""
"如果你想在早已提供站点服务器服务器上同时提供静态文件服务，操作步骤类似这样："

msgid "Push your code up to the deployment server."
msgstr "将代码推送至部署服务器。"

msgid ""
"On the server, run :djadmin:`collectstatic` to copy all the static files "
"into :setting:`STATIC_ROOT`."
msgstr ""
"在服务器上运行 :djadmin:`collectstatic`，将所有的静态文件拷贝至 :setting:"
"`STATIC_ROOT`。"

msgid ""
"Configure your web server to serve the files in :setting:`STATIC_ROOT` under "
"the URL :setting:`STATIC_URL`. For example, here's :ref:`how to do this with "
"Apache and mod_wsgi <serving-files>`."
msgstr ""
"配置 Web 服务器，使其在 :setting:`STATIC_URL` 下为 :setting:`STATIC_ROOT` 目"
"录下的文件提供静态文件服务。例如， :ref:`这里是如何以 Apache 配合 mod_wsgi 开"
"始 <serving-files>`。"

msgid ""
"You'll probably want to automate this process, especially if you've got "
"multiple web servers."
msgstr "你可能期望将该流程自动化，特别是在你有好几个 web 服务器的时候。"

msgid "Serving static files from a dedicated server"
msgstr "专用服务器提供静态文件服务"

msgid ""
"Most larger Django sites use a separate Web server -- i.e., one that's not "
"also running Django -- for serving static files. This server often runs a "
"different type of web server -- faster but less full-featured. Some common "
"choices are:"
msgstr ""
"大多数大型 Django 站点使用一个独立的 Web 服务器——即，该服务器并未运行 "
"Django，值提供静态文件服务。这种服务器一般运行一种不同的 Web 服务器——更快，更"
"简单。常见选项如下："

msgid ""
"Configuring these servers is out of scope of this document; check each "
"server's respective documentation for instructions."
msgstr "如何配置这些服务器超出了本文范围；查阅这些服务器各自的文档获取介绍。"

msgid ""
"Since your static file server won't be running Django, you'll need to modify "
"the deployment strategy to look something like:"
msgstr "由于静态文件服务器并不运行 Django，你需要将部署策略改成这样："

msgid "When your static files change, run :djadmin:`collectstatic` locally."
msgstr "当静态文件改变时，本地运行 :djadmin:`collectstatic`。"

msgid ""
"Push your local :setting:`STATIC_ROOT` up to the static file server into the "
"directory that's being served. `rsync <https://rsync.samba.org/>`_ is a "
"common choice for this step since it only needs to transfer the bits of "
"static files that have changed."
msgstr ""
"将本地 :setting:`STATIC_ROOT` 推送到静态文件服务器提供服务的目录。 `rsync "
"<https://rsync.samba.org/>`_ 是一个常见选项，因为这种配置只会传输文件修改部分"
"的数据流。"

msgid "Serving static files from a cloud service or CDN"
msgstr "从云服务或 CDN 提供静态文件服务"

msgid ""
"Another common tactic is to serve static files from a cloud storage provider "
"like Amazon's S3 and/or a CDN (content delivery network). This lets you "
"ignore the problems of serving static files and can often make for faster-"
"loading Web pages (especially when using a CDN)."
msgstr ""
"另一种常见的策略是从类似亚马逊 S3 的云存储服务商或 CDN (content delivery "
"network) 提供静态文件服务。这能让你忽略提供静态文件服务可能出现的问题，提供 "
"Web 页面加载速度（尤其是在用 CDN 的时候）。"

msgid ""
"When using these services, the basic workflow would look a bit like the "
"above, except that instead of using ``rsync`` to transfer your static files "
"to the server you'd need to transfer the static files to the storage "
"provider or CDN."
msgstr ""
"使用这些服务时，基本的工作流程与上面类似，除了要将静态文件传输给存储服务商或 "
"CDN，而不是用 ``rsync`` 将静态文件传输给服务器。"

msgid ""
"There's any number of ways you might do this, but if the provider has an API "
"a :doc:`custom file storage backend </howto/custom-file-storage>` will make "
"the process incredibly simple. If you've written or are using a 3rd party "
"custom storage backend, you can tell :djadmin:`collectstatic` to use it by "
"setting :setting:`STATICFILES_STORAGE` to the storage engine."
msgstr ""
"有很多中方法可以实现目的，但是若服务商提供一个 API :doc:`自定义文件存储后端 "
"</howto/custom-file-storage>`，这将会使流程难以置信的简单。若你已编写或正在使"
"用第三方的自定义存储后端，你可以通过将 :setting:`STATICFILES_STORAGE` 指向该"
"存储引擎告诉 :djadmin:`collectstatic` 启用它。"

msgid ""
"For example, if you've written an S3 storage backend in ``myproject.storage."
"S3Storage`` you could use it with::"
msgstr ""
"例如，若你已在 ``myproject.storage.S3Storage`` 中写了一个 S3 存储后端，可以这"
"么用::"

msgid ""
"Once that's done, all you have to do is run :djadmin:`collectstatic` and "
"your static files would be pushed through your storage package up to S3. If "
"you later needed to switch to a different storage provider, it could be as "
"simple as changing your :setting:`STATICFILES_STORAGE` setting."
msgstr ""
"只要完成了上述流程，你就只需运行 :djadmin:`collectstatic`，静态文件将通过存储"
"包推送给 S3。如果稍后需要切换至另一个存储服务商，只需简单地修改 :setting:"
"`STATICFILES_STORAGE` 配置。"

msgid ""
"For details on how you'd write one of these backends, see :doc:`/howto/"
"custom-file-storage`. There are 3rd party apps available that provide "
"storage backends for many common file storage APIs. A good starting point is "
"the `overview at djangopackages.org <https://djangopackages.org/grids/g/"
"storage-backends/>`_."
msgstr ""
"关于如何编写这些后端的细节，参考 :doc:`/howto/custom-file-storage`。有很多可"
"用的第三方应用提供了针对常见文件存储 API 的存储后端。 `djangopackages.org 入"
"门 <https://djangopackages.org/grids/g/storage-backends/>`_ 是个不错的起点。"

msgid "Learn more"
msgstr "了解更多"

msgid ""
"For complete details on all the settings, commands, template tags, and other "
"pieces included in :mod:`django.contrib.staticfiles`, see :doc:`the "
"staticfiles reference </ref/contrib/staticfiles>`."
msgstr ""
"想要了解所有配置项，命令，模板标签和 :mod:`django.contrib.staticfiles` 包含的"
"其它零碎的完整细节，参考 :doc:`staticfiles 参考 </ref/contrib/staticfiles>`。"

msgid "Managing static files (e.g. images, JavaScript, CSS)"
msgstr "管理静态文件（比如图片、JavaScript、CSS）"

msgid ""
"Websites generally need to serve additional files such as images, "
"JavaScript, or CSS. In Django, we refer to these files as \"static files\".  "
"Django provides :mod:`django.contrib.staticfiles` to help you manage them."
msgstr ""
"网站通常需要提供类似图片，JavaScript 或 CSS 的额外文件服务。在 Django 中，我"
"们将这些文件称为“静态文件”。Django 提供了 :mod:`django.contrib.staticfiles` "
"帮你管理它们。"

msgid "This page describes how you can serve these static files."
msgstr "本页介绍如何为这些静态文件提供服务。"

msgid "Configuring static files"
msgstr "配置静态文件"

msgid ""
"Make sure that ``django.contrib.staticfiles`` is included in your :setting:"
"`INSTALLED_APPS`."
msgstr "确保 :setting:`INSTALLED_APPS` 包含了 ``django.contrib.staticfiles``。"

msgid "In your settings file, define :setting:`STATIC_URL`, for example::"
msgstr "在配置文件中，定义 :setting:`STATIC_URL`，例子::"

msgid ""
"In your templates, use the :ttag:`static` template tag to build the URL for "
"the given relative path using the configured :setting:`STATICFILES_STORAGE`."
msgstr ""
"在模板中，用 :ttag:`static` 模板标签基于配置 :setting:`STATICFILES_STORAGE` "
"位给定的相对路径构建 URL。"

msgid ""
"Store your static files in a folder called ``static`` in your app. For "
"example ``my_app/static/my_app/example.jpg``."
msgstr ""
"将你的静态文件保存至程序中名为 ``static`` 的目录中。例如 ``my_app/static/"
"my_app/example.jpg``。"

msgid "Serving the files"
msgstr "为这些文件提供服务"

msgid ""
"In addition to these configuration steps, you'll also need to actually serve "
"the static files."
msgstr "除了这些配置步骤外，你还需要实际地为这些文件提供服务。"

msgid ""
"During development, if you use :mod:`django.contrib.staticfiles`, this will "
"be done automatically by :djadmin:`runserver` when :setting:`DEBUG` is set "
"to ``True`` (see :func:`django.contrib.staticfiles.views.serve`)."
msgstr ""
"开发时，使用 :mod:`django.contrib.staticfiles`，这一般会在 :setting:`DEBUG` "
"is set to ``True`` 情况下由 :djadmin:`runserver` 自动完成（参考 :func:"
"`django.contrib.staticfiles.views.serve`）。"

msgid ""
"This method is **grossly inefficient** and probably **insecure**, so it is "
"**unsuitable for production**."
msgstr "该方法 **极度低效** 且 **不怎么安全**，所以这 **不适合生产环境**。"

msgid ""
"See :doc:`/howto/static-files/deployment` for proper strategies to serve "
"static files in production environments."
msgstr ""
"参考 :doc:`/howto/static-files/deployment` 了解如何正确地在生产环境提供静态文"
"件服务的策略。"

msgid ""
"Your project will probably also have static assets that aren't tied to a "
"particular app. In addition to using a ``static/`` directory inside your "
"apps, you can define a list of directories (:setting:`STATICFILES_DIRS`) in "
"your settings file where Django will also look for static files. For "
"example::"
msgstr ""
"你的工程可能包含未与任何应用绑定的静态资源。除了在 apps 中使用 ``static/`` 目"
"录，你可以在配置文件中定义一个目录列表 (:setting:`STATICFILES_DIRS`) ，"
"Django 会从中寻找静态文件。例子::"

msgid ""
"See the documentation for the :setting:`STATICFILES_FINDERS` setting for "
"details on how ``staticfiles`` finds your files."
msgstr ""
"参考 :setting:`STATICFILES_FINDERS` 配置的文档了解 ``staticfiles`` 是如何找到"
"你的文件的细节。"

msgid "Static file namespacing"
msgstr "静态文件命名空间"

msgid ""
"Now we *might* be able to get away with putting our static files directly in "
"``my_app/static/`` (rather than creating another ``my_app`` subdirectory), "
"but it would actually be a bad idea. Django will use the first static file "
"it finds whose name matches, and if you had a static file with the same name "
"in a *different* application, Django would be unable to distinguish between "
"them. We need to be able to point Django at the right one, and the easiest "
"way to ensure this is by *namespacing* them. That is, by putting those "
"static files inside *another* directory named for the application itself."
msgstr ""
"现在，我们 *也许* 能直接将静态文件放入 ``my_app/static/`` 目录（而不是创建另"
"一个 ``my_app`` 子目录），不过这实际上是个坏主意。Django 会使用第一个名字匹配"
"的静态文件，若你在 *不同的* 应用中有一个同名静态文件，Django 无力区分它们。我"
"们需要为 Django 指出正确的那个，而最简单的方式就是使用 *命名空间*。也就是说，"
"将这些静态文件放在 *另一个* 以应用名本身命名的目录下。"

msgid "Serving static files during development"
msgstr "开发时提供静态文件服务"

msgid ""
"If you use :mod:`django.contrib.staticfiles` as explained above, :djadmin:"
"`runserver` will do this automatically when :setting:`DEBUG` is set to "
"``True``. If you don't have ``django.contrib.staticfiles`` in :setting:"
"`INSTALLED_APPS`, you can still manually serve static files using the :func:"
"`django.views.static.serve` view."
msgstr ""
"若你使用了前文所述的 :mod:`django.contrib.staticfiles`， :djadmin:"
"`runserver` 会在 :setting:`DEBUG` 为 ``True`` 时自动处理。若你未在 :setting:"
"`INSTALLED_APPS` 中包含 ``django.contrib.staticfiles``，你仍能手动通过 :func:"
"`django.views.static.serve` 为静态文件提供服务。"

msgid ""
"This is not suitable for production use! For some common deployment "
"strategies, see :doc:`/howto/static-files/deployment`."
msgstr ""
"这不适合生产环境！常见的部署策略请参考 :doc:`/howto/static-files/"
"deployment`。"

msgid ""
"For example, if your :setting:`STATIC_URL` is defined as ``/static/``, you "
"can do this by adding the following snippet to your urls.py::"
msgstr ""
"例如，若 :setting:`STATIC_URL` 为 ``/static/``，你能通过添加以下代码片段至 "
"urls.py 完成目的::"

msgid ""
"This helper function works only in debug mode and only if the given prefix "
"is local (e.g. ``/static/``) and not a URL (e.g. ``http://static.example.com/"
"``)."
msgstr ""
"该助手函数只能在 debug 模式下生效，且要求前缀是本地的（例如 ``/static/``），"
"不是一个 URL (例如 ``http://static.example.com/``)。"

msgid ""
"Also this helper function only serves the actual :setting:`STATIC_ROOT` "
"folder; it doesn't perform static files discovery like :mod:`django.contrib."
"staticfiles`."
msgstr ""
"当然，助手函数只为实际的 :setting:`STATIC_ROOT` 目录提供服务；它不会像 :mod:"
"`django.contrib.staticfiles` 一样搜索静态文件。"

msgid "Serving files uploaded by a user during development"
msgstr "开发期间保存用户上传的文件"

msgid ""
"During development, you can serve user-uploaded media files from :setting:"
"`MEDIA_ROOT` using the :func:`django.views.static.serve` view."
msgstr ""
"开发期间，你能用 :func:`django.views.static.serve` 视图为用户上传的媒体文件提"
"供服务。"

msgid ""
"For example, if your :setting:`MEDIA_URL` is defined as ``/media/``, you can "
"do this by adding the following snippet to your urls.py::"
msgstr ""
"例如，若 :setting:`MEDIA_URL` 定义为 ``/media/``，你可以通过将以下代码片段加"
"入 urls.py 实现目的::"

msgid ""
"This helper function works only in debug mode and only if the given prefix "
"is local (e.g. ``/media/``) and not a URL (e.g. ``http://media.example.com/"
"``)."
msgstr ""
"该助手函数只能在 debug 模式下生效，且要求前缀是本地的（例如 ``/static/``），"
"不是一个 URL (例如 ``http://media.example.com/``)。"

msgid ""
"When running tests that use actual HTTP requests instead of the built-in "
"testing client (i.e. when using the built-in :class:`LiveServerTestCase "
"<django.test.LiveServerTestCase>`) the static assets need to be served along "
"the rest of the content so the test environment reproduces the real one as "
"faithfully as possible, but ``LiveServerTestCase`` has only very basic "
"static file-serving functionality: It doesn't know about the finders feature "
"of the ``staticfiles`` application and assumes the static content has "
"already been collected under :setting:`STATIC_ROOT`."
msgstr ""
"运行使用真实 HTTP 请求（而不是内置的测试客户端，即内置的 :class:"
"`LiveServerTestCase <django.test.LiveServerTestCase>`）的测试用例时，静态资源"
"要与剩余内容分别提供服务，这样，测试环境才能尽量重现真实的问题。但 "
"``LiveServerTestCase`` 只拥有非常基本的为静态文件提供服务的能力：它并不知道 "
"``staticfiles`` 应用的查找功能，且总是假设静态内容已被收集至 :setting:"
"`STATIC_ROOT` 目录下。"

msgid ""
"Because of this, ``staticfiles`` ships its own :class:`django.contrib."
"staticfiles.testing.StaticLiveServerTestCase`, a subclass of the built-in "
"one that has the ability to transparently serve all the assets during "
"execution of these tests in a way very similar to what we get at development "
"time with ``DEBUG = True``, i.e. without having to collect them using :"
"djadmin:`collectstatic` first."
msgstr ""
"因此， ``staticfiles`` 自带了 :class:`django.contrib.staticfiles.testing."
"StaticLiveServerTestCase`，这是一个内置子类，能够透明地以类似我们在开发阶段 "
"``DEBUG = True`` 时获得的方式为所有静态资源在测试期间提供服务。即无需先用 :"
"djadmin:`collectstatic` 收集它们。"

msgid "Deployment"
msgstr "部署"

msgid ""
":mod:`django.contrib.staticfiles` provides a convenience management command "
"for gathering static files in a single directory so you can serve them "
"easily."
msgstr ""
":mod:`django.contrib.staticfiles` 提供了一个便利的管理命令，用于将静态文件收"
"集至独立目录，方便你为它们提供服务。"

msgid ""
"Set the :setting:`STATIC_ROOT` setting to the directory from which you'd "
"like to serve these files, for example::"
msgstr ""
"将 :setting:`STATIC_ROOT` 配置成你喜欢的目录，在这个目录提供服务，例如::"

msgid "Run the :djadmin:`collectstatic` management command::"
msgstr "运行 :djadmin:`collectstatic` 管理命令::"

msgid ""
"This will copy all files from your static folders into the :setting:"
"`STATIC_ROOT` directory."
msgstr "这将会把静态目录下的所有文件拷贝至 :setting:`STATIC_ROOT` 目录。"

msgid ""
"Use a web server of your choice to serve the files. :doc:`/howto/static-"
"files/deployment` covers some common deployment strategies for static files."
msgstr ""
"选一个 Web 服务器为这些文件提供服务。 文档 :doc:`/howto/static-files/"
"deployment` 介绍了静态文件的常见部署策略。"

msgid ""
"This document has covered the basics and some common usage patterns. For "
"complete details on all the settings, commands, template tags, and other "
"pieces included in :mod:`django.contrib.staticfiles`, see :doc:`the "
"staticfiles reference </ref/contrib/staticfiles>`."
msgstr ""
"本文档已覆盖基础和常见模式。对于所有配置项，命令，模板标签和其他包含在 :mod:"
"`django.contrib.staticfiles` 碎片的全部细节，参考 :doc:`静态文件参考 </ref/"
"contrib/staticfiles>`。"

msgid "Upgrading Django to a newer version"
msgstr "升级 Django 到最新的版本"

msgid ""
"While it can be a complex process at times, upgrading to the latest Django "
"version has several benefits:"
msgstr "虽然有时是个复杂的过程，将 Django 升级到最新版有以下好处："

msgid "New features and improvements are added."
msgstr "新功能和优化"

msgid "Bugs are fixed."
msgstr "已修复的 bug。"

msgid ""
"Older version of Django will eventually no longer receive security updates. "
"(see :ref:`supported-versions-policy`)."
msgstr ""
"旧版 Django 最终将不再收到安全更新。（参考 :ref:`supported-versions-policy`）"

msgid ""
"Upgrading as each new Django release is available makes future upgrades less "
"painful by keeping your code base up to date."
msgstr ""
"随着每个新 Django 发行版的发布而升级，可以使您的代码库保持最新，从而减少将来"
"升级带来的痛苦。"

msgid ""
"Here are some things to consider to help make your upgrade process as smooth "
"as possible."
msgstr "有些事情需要你考虑，这有助于使升级流程尽可能顺滑。"

msgid "Required Reading"
msgstr "必读内容"

msgid ""
"If it's your first time doing an upgrade, it is useful to read the :doc:"
"`guide on the different release processes </internals/release-process>`."
msgstr ""
"若这是你第一次进行升级操作，那么阅读 :doc:`不同发行进程的指南 </internals/"
"release-process>` 就非常有用。"

msgid ""
"Afterwards, you should familiarize yourself with the changes that were made "
"in the new Django version(s):"
msgstr "随后，你要自主熟悉 Django 新版本的修改："

msgid ""
"Read the :doc:`release notes </releases/index>` for each 'final' release "
"from the one after your current Django version, up to and including the "
"version to which you plan to upgrade."
msgstr ""
"阅读当前版本之后的每个“最终”版本的 :doc:`发行说明 </releases/index>` ，包括计"
"划升级的版本。"

msgid ""
"Look at the :doc:`deprecation timeline</internals/deprecation>` for the "
"relevant versions."
msgstr "阅读 :doc:`过期时间表 </internals/deprecation>` 获取相关版本信息。"

msgid ""
"Pay particular attention to backwards incompatible changes to get a clear "
"idea of what will be needed for a successful upgrade."
msgstr "特别注意向前兼容修改，清楚了解成功的升级需要做什么。"

msgid ""
"If you're upgrading through more than one feature version (e.g. A.B to A.B"
"+2), it's usually easier to upgrade through each feature release "
"incrementally (A.B to A.B+1 to A.B+2) rather than to make all the changes "
"for each feature release at once. For each feature release, use the latest "
"patch release (A.B.C)."
msgstr ""
"若你更新的版本跨度超过两个（例如 A.B 更新至 A.B+2），通常增量更新（A.B 到 A.B"
"+1 再到 A.B+2）每个版本会比一次性更新更简单。对于每个发布特性，使用最新的补丁"
"版本（A.B.C）。"

msgid ""
"The same incremental upgrade approach is recommended when upgrading from one "
"LTS to the next."
msgstr ""
"从一个长期支持（LTS）版本更新至下一个长期更新版本时，特别推荐同样的增量更新方"
"法。"

msgid "Dependencies"
msgstr "依赖"

msgid ""
"In most cases it will be necessary to upgrade to the latest version of your "
"Django-related dependencies as well. If the Django version was recently "
"released or if some of your dependencies are not well-maintained, some of "
"your dependencies may not yet support the new Django version. In these cases "
"you may have to wait until new versions of your dependencies are released."
msgstr ""
"大多数情况下，将 Django 的依赖升至最新版本是必要的。若 Django 版本是最近发布"
"的，但某些依赖没有很好适配，这些依赖可能无法支持最新版的 Django。这种情况下，"
"你只能等新版本的依赖发布。"

msgid "Resolving deprecation warnings"
msgstr "处理过期警告"

msgid ""
"Before upgrading, it's a good idea to resolve any deprecation warnings "
"raised by your project while using your current version of Django. Fixing "
"these warnings before upgrading ensures that you're informed about areas of "
"the code that need altering."
msgstr ""
"在升级前，将使用当前 Django 版本引发的过期警告解决掉是个不错的注意。在升级前"
"修复这些警告能确保你了解代码中哪些部分需要修改。"

msgid ""
"In Python, deprecation warnings are silenced by default. You must turn them "
"on using the ``-Wa`` Python command line option or the :envvar:"
"`PYTHONWARNINGS` environment variable. For example, to show warnings while "
"running tests:"
msgstr ""
"在 Python 中，过期警告默认是静默的。你必须用 Python 的命令行选项 ``-Wa`` 或 :"
"envvar:`PYTHONWARNINGS` 环境变量将其打开。例如，在运行测试时显示警告："

msgid ""
"If you're not using the Django test runner, you may need to also ensure that "
"any console output is not captured which would hide deprecation warnings. "
"For example, if you use `py.test`:"
msgstr ""
"若你未使用 Django 的 test runner，你可能还需要确认没有终端输出被截胡，这可能"
"会影藏过期警告。例如，若你使用 `py.test`："

msgid ""
"Resolve any deprecation warnings with your current version of Django before "
"continuing the upgrade process."
msgstr "在继续升级流程前处理当前 Django 版本报告的所有过期警告。"

msgid ""
"Third party applications might use deprecated APIs in order to support "
"multiple versions of Django, so deprecation warnings in packages you've "
"installed don't necessarily indicate a problem. If a package doesn't support "
"the latest version of Django, consider raising an issue or sending a pull "
"request for it."
msgstr ""
"第三方应用可能会出于兼容多版本 Django 目的使用过期 APIs，所以你安装的应用报告"
"的过期警告可能并不是问题。若某个包不支持最新版的 Django，考虑为其创建一个 "
"issue 或发起一个 pull request。"

msgid "Installation"
msgstr "安装"

msgid ""
"Once you're ready, it is time to :doc:`install the new Django version </"
"topics/install>`. If you are using virtualenv_ and it is a major upgrade, "
"you might want to set up a new environment with all the dependencies first."
msgstr ""
"准备好后，就是 :doc:`安装新版 Django </topics/install>` 的时候。若你正使用 "
"virtualenv_ ，且这是一次关键性升级，你可能想要先配置一个包含所有依赖的环境。"

msgid ""
"If you installed Django with pip_, you can use the ``--upgrade`` or ``-U`` "
"flag:"
msgstr "若你用 pip_ 安装 Django，你可以使用 ``--upgrade`` 或 ``-U`` 标志："

msgid ""
"When the new environment is set up, :doc:`run the full test suite </topics/"
"testing/overview>` for your application. Again, it's useful to turn on "
"deprecation warnings on so they're shown in the test output (you can also "
"use the flag if you test your app manually using ``manage.py runserver``):"
msgstr ""
"当环境准备好后，先为应用 :doc:`运行完整的测试套件 </topics/testing/"
"overview>`。再说一次，将过期警告开关打开很有用，这样就能在测试输出中看到过期"
"警告（若你用 ``manage.py runserver`` 手动测试，也能有该标志）："

msgid ""
"After you have run the tests, fix any failures. While you have the release "
"notes fresh in your mind, it may also be a good time to take advantage of "
"new features in Django by refactoring your code to eliminate any deprecation "
"warnings."
msgstr ""
"在你运行测试，并修复所有问题后。由于你刚看了发布说明，可能现在也是重构代码，"
"消除所有过期警告，尝尝 Django 最新功能特性的好时机。"

msgid ""
"When you are sufficiently confident your app works with the new version of "
"Django, you're ready to go ahead and :doc:`deploy </howto/deployment/index>` "
"your upgraded Django project."
msgstr ""
"当你十分确信你的应用能兼容新版 Django 时，你就准备好去往下一步， :doc:`部署 "
"</howto/deployment/index>` 升级后的 Django 工程。"

msgid ""
"If you are using caching provided by Django, you should consider clearing "
"your cache after upgrading. Otherwise you may run into problems, for "
"example, if you are caching pickled objects as these objects are not "
"guaranteed to be pickle-compatible across Django versions. A past instance "
"of incompatibility was caching pickled :class:`~django.http.HttpResponse` "
"objects, either directly or indirectly via the :func:`~django.views."
"decorators.cache.cache_page` decorator."
msgstr ""
"若你使用 Django 提供的缓存，你需要考虑在升级后清空缓存。否则，你可能会卷入麻"
"烦中，举个例子，若你缓存了 pickled 对象，而这些对象并不能确保跨版本 pickle 兼"
"容。一个过期兼容性例子是缓存 pickled :class:`~django.http.HttpResponse` 对"
"象，不论是直接或间接由 :func:`~django.views.decorators.cache.cache_page` 装饰"
"器创建。"

msgid "How to install Django on Windows"
msgstr "如何在 Windows 上安装 Django"

msgid ""
"This document will guide you through installing Python 3.5 and Django on "
"Windows. It also provides instructions for installing `virtualenv`_ and "
"`virtualenvwrapper`_, which make it easier to work on Python projects. This "
"is meant as a beginner's guide for users working on Django projects and does "
"not reflect how Django should be installed when developing patches for "
"Django itself."
msgstr ""
"本文会通过安装在 Windows 上安装 Python 3.5 和 Django 指导你。同时也提供了关于"
"安装 `virtualenv`_ 和 `virtualenvwrapper` 的介绍，它们使得编写 Python 工程变"
"的非常简单。这是为从事 Django 项目的用户提供的入门指南，而介绍为 Django 本身"
"开发补丁时该如何安装 Django。"

msgid ""
"The steps in this guide have been tested with Windows 7, 8, and 10. In other "
"versions, the steps would be similar. You will need to be familiar with "
"using the Windows command prompt."
msgstr ""
"下列步骤已在 Windows 7, 8 和 10 上测试通过。其它版本上，步骤类似。你需要熟悉"
"如何使用 Windows 的命令提示符。"

msgid "Install Python"
msgstr "安装Python"

msgid ""
"Django is a Python web framework, thus requiring Python to be installed on "
"your machine. At the time of writing, Python 3.5 is the latest version."
msgstr ""
"Django 是一个 Python Web 框架，因此需要在您的机器上安装 Python。在本文撰写"
"时，Python 最新的版本是 3.5。"

msgid ""
"To install Python on your machine go to https://python.org/downloads/. The "
"website should offer you a download button for the latest Python version. "
"Download the executable installer and run it. Check the box next to ``Add "
"Python 3.5 to PATH`` and then click ``Install Now``."
msgstr ""
"为了把 Python 安装到你的机器上，请打开https://python.org/downloads/。这个网站"
"应该为你提供了一个最新的 Python 版本的下载按钮。下载可执行安装包并且运行它。"
"运行后，选择把 ``Python 3.5 添加到环境变量`` ，然后点击``马上安装``。"

msgid ""
"After installation, open the command prompt and check that the Python "
"version matches the version you installed by executing::"
msgstr "安装后，打开命令提示符，检查 Python 版本是否与你装的一致，通过运行::"

msgid "About ``pip``"
msgstr "关于 ``pip``"

msgid ""
"`pip`_ is a package manage for Python. It makes installing and uninstalling "
"Python packages (such as Django!) very easy. For the rest of the "
"installation, we'll use ``pip`` to install Python packages from the command "
"line."
msgstr ""
"`pip`_ 是 Python 的包管理器。它使得 Python 包（例如 Django）的安装和卸载变的"
"非常简单。剩下的安装流程中，我们会用 ``pip`` 从命令行安装 Python 包。"

msgid ""
"To install pip on your machine, go to https://pip.pypa.io/en/latest/"
"installing/, and follow the ``Installing with get-pip.py`` instructions."
msgstr ""
"想要在您的机器上安装 pip，请转至 https://pip.pypa.io/en/latest/installing/，"
"并按照 ``通过 get-pip.py 安装`` 说明进行操作。"

msgid "Install ``virtualenv`` and ``virtualenvwrapper``"
msgstr "安装 ``virtualenv`` 和 ``virtualenvwrapper``"

msgid ""
"`virtualenv`_ and `virtualenvwrapper`_ provide a dedicated environment for "
"each Django project you create. While not mandatory, this is considered a "
"best practice and will save you time in the future when you're ready to "
"deploy your project. Simply type::"
msgstr ""
"`virtualenv`_ 和 `virtualenvwrapper`_ 为每个 Django 项目提供独立环境。虽然不"
"是必要的，但这是个不错的主意，会在你准备部署项目时节约时间。仅需输入::"

msgid "Then create a virtual environment for your project::"
msgstr "然后为您的项目创建一个虚拟环境::"

msgid ""
"The virtual environment will be activated automatically and you'll see "
"\"(myproject)\" next to the command prompt to designate that. If you start a "
"new command prompt, you'll need to activate the environment again using::"
msgstr ""
"虚拟环境会自动激活，你能在命令提示符旁边看到 \"(myproject)\" 指向该环境。若你"
"打开了新的命令提示符，你需要用以下代码再次激活它::"

msgid "Install Django"
msgstr "安装 Django"

msgid ""
"Django can be installed easily using ``pip`` within your virtual environment."
msgstr "Django 可以轻松地在你的虚拟环境中使用 ``pip`` 安装。"

msgid ""
"In the command prompt, ensure your virtual environment is active, and "
"execute the following command::"
msgstr "在命令提示行中，确认虚拟环境是激活的，然后运行以下命令::"

msgid "This will download and install the latest Django release."
msgstr "这将下载并安装最新的 Django 发布版本。"

msgid ""
"After the installation has completed, you can verify your Django "
"installation by executing ``django-admin --version`` in the command prompt."
msgstr ""
"安装完成后，你可以在命令提示符运行 ``django-admin --version`` 验证你安装的 "
"Django。"

msgid ""
"See :ref:`database-installation` for information on database installation "
"with Django."
msgstr "参考 :ref:`数据库安装` 了解如何通过 Django 安装数据库。"

msgid "Common pitfalls"
msgstr "常见失误"

msgid ""
"If ``django-admin`` only displays the help text no matter what arguments it "
"is given, there is probably a problem with the file association in Windows. "
"Check if there is more than one environment variable set for running Python "
"scripts in ``PATH``. This usually occurs when there is more than one Python "
"version installed."
msgstr ""
"若 ``django-admin`` 无论输入啥参数都只显示帮助信息，这可能是一个 Windos 的文"
"件关联问题。检查 ``PATH`` 中是否不止一个用于运行 Python 脚本的环境变量。该问"
"题通常在安装了多个 Python 版本时出现。"

msgid ""
"If you are connecting to the internet behind a proxy, there might be problem "
"in running the command ``pip install django``. Set the environment variables "
"for proxy configuration in the command prompt as follows::"
msgstr ""
"若你通过代理连接互联网，运行命令 ``pip install django`` 时可能会有问题。在命"
"令提示符中为代理配置如下环境变量::"

msgid "Writing database migrations"
msgstr "编写数据库迁移语句"

msgid ""
"This document explains how to structure and write database migrations for "
"different scenarios you might encounter. For introductory material on "
"migrations, see :doc:`the topic guide </topics/migrations>`."
msgstr ""
"本文介绍了如何为可能遇到的不同场景组织和编写数据库迁移。关于迁移的介绍性资"
"料，参考 :doc:`专题指南</topics/migrations>`。"

msgid "Data migrations and multiple databases"
msgstr "数据迁移和多种数据库"

msgid ""
"When using multiple databases, you may need to figure out whether or not to "
"run a migration against a particular database. For example, you may want to "
"**only** run a migration on a particular database."
msgstr ""
"使用多种数据库时，你可能需要指定是否为特定数据库运行迁移。例如，你可能 **只想"
"** 为特定数据库运行迁移。"

msgid ""
"In order to do that you can check the database connection's alias inside a "
"``RunPython`` operation by looking at the ``schema_editor.connection.alias`` "
"attribute::"
msgstr ""
"为此，你可以在 ``RunPython`` 操作中检查数据库连接别名，通过查看 "
"``schema_editor.connection.alias`` 属性::"

msgid ""
"You can also provide hints that will be passed to the :meth:"
"`allow_migrate()` method of database routers as ``**hints``:"
msgstr ""
"你也能提供会以 ``**hints`` 传递给数据库路由器的 :meth:`allow_migrate()` 方法"
"的提示："

msgid "myapp/dbrouters.py"
msgstr "myapp/dbrouters.py"

msgid "Then, to leverage this in your migrations, do the following::"
msgstr "然后，要将其在迁移中生效，像下面这样做::"

msgid ""
"If your ``RunPython`` or ``RunSQL`` operation only affects one model, it's "
"good practice to pass ``model_name`` as a hint to make it as transparent as "
"possible to the router. This is especially important for reusable and third-"
"party apps."
msgstr ""
"若你的 ``RunPython`` 或 ``RunSQL`` 操作只影响了一个模型，为其传入 "
"``model_name`` 作为提示，使其对路由器更加透明。这对可复用的和第三方应用特别重"
"要。"

msgid "Migrations that add unique fields"
msgstr "添加独一无二字段的迁移"

msgid ""
"Applying a \"plain\" migration that adds a unique non-nullable field to a "
"table with existing rows will raise an error because the value used to "
"populate existing rows is generated only once, thus breaking the unique "
"constraint."
msgstr ""
"应用 “普通” 迁移，将新的唯一非空的字段添加到已拥有一些行的表格会抛出一个错"
"误，因为用于填充现有行的值只生成一次，从而打破了唯一约束。唯一非空字段即所有"
"行的该字段都不能为空，且值唯一，不能重复。"

msgid ""
"Therefore, the following steps should be taken. In this example, we'll add a "
"non-nullable :class:`~django.db.models.UUIDField` with a default value. "
"Modify the respective field according to your needs."
msgstr ""
"因此，需要做以下步骤。在本例中，我们将添加一个带默认值的非空 :class:`~django."
"db.models.UUIDField`。根据你的需要修改对应字段。"

msgid ""
"Add the field on your model with ``default=uuid.uuid4`` and ``unique=True`` "
"arguments (choose an appropriate default for the type of the field you're "
"adding)."
msgstr ""
"在模型中以 ``default=uuid.uuid4`` 和 ``unique=True`` 参数添加该字段（根据字段"
"类型，为其选择一个合适的默认值）。"

msgid ""
"Run the :djadmin:`makemigrations` command. This should generate a migration "
"with an ``AddField`` operation."
msgstr ""
"运行 :djadmin:`makemigrations` 命令。这将生成一个 ``AddField`` 操作的迁移。"

msgid ""
"Generate two empty migration files for the same app by running "
"``makemigrations myapp --empty`` twice. We've renamed the migration files to "
"give them meaningful names in the examples below."
msgstr ""
"通过运行 ``makemigrations myapp --empty`` 两次为同一应用生成两个相同的空迁移"
"文件。我们已在以下例子中将迁移文件重命名成有意义的名字。"

msgid ""
"Copy the ``AddField`` operation from the auto-generated migration (the first "
"of the three new files) to the last migration, change ``AddField`` to "
"``AlterField``, and add imports of ``uuid`` and ``models``. For example:"
msgstr ""
"从自动生成的迁移（3个新文件中的第一个）中将 ``AddField`` 操作拷贝至上一个迁"
"移，将 ``AddField`` 改为 ``AlterField``，添加 ``uuid`` 和 ``models`` 的导入。"
"例子："

msgid "0006_remove_uuid_null.py"
msgstr "0006_remove_uuid_null.py"

msgid ""
"Edit the first migration file. The generated migration class should look "
"similar to this:"
msgstr "编辑第一个迁移文件。生成的迁移类应该看起来像这样："

msgid "0004_add_uuid_field.py"
msgstr "0004_add_uuid_field.py"

msgid ""
"Change ``unique=True`` to ``null=True`` -- this will create the intermediary "
"null field and defer creating the unique constraint until we've populated "
"unique values on all the rows."
msgstr ""
"将 ``unique=True`` 改为 ``null=True``——这将创建中间 null 字段，并延迟创建唯一"
"性约束，直到我们已为所以行填充了唯一值。"

msgid ""
"In the first empty migration file, add a :class:`~django.db.migrations."
"operations.RunPython` or :class:`~django.db.migrations.operations.RunSQL` "
"operation to generate a unique value (UUID in the example) for each existing "
"row. Also add an import of ``uuid``. For example:"
msgstr ""
"在第一个空的迁移文件中，添加一个 :class:`~django.db.migrations.operations."
"RunPython` 或 :class:`~django.db.migrations.operations.RunSQL` 操作，为每个已"
"存在的行创建一个唯一值（本例中 UUID）。同时添加 ``uuid`` 的导入。例子："

msgid "0005_populate_uuid_values.py"
msgstr "0005_populate_uuid_values.py"

msgid ""
"Now you can apply the migrations as usual with the :djadmin:`migrate` "
"command."
msgstr "现在你能像往常一样用 :djadmin:`migrate` 应用迁移了。"

msgid ""
"Note there is a race condition if you allow objects to be created while this "
"migration is running. Objects created after the ``AddField`` and before "
"``RunPython`` will have their original ``uuid``’s overwritten."
msgstr ""
"注意，若你允许运行迁移时创建对象可能会造成竞争。 ``AddField`` 后和 "
"``RunPython`` 前创建的对象保留原先重写的 ``uuid`` 值。"

msgid "Non-atomic migrations"
msgstr "非原子性迁移"

msgid ""
"On databases that support DDL transactions (SQLite and PostgreSQL), "
"migrations will run inside a transaction by default. For use cases such as "
"performing data migrations on large tables, you may want to prevent a "
"migration from running in a transaction by setting the ``atomic`` attribute "
"to ``False``::"
msgstr ""
"对于支持 DDL 事务的数据库 (SQLite and PostgreSQL)，迁移默认运行在事务内。对于"
"类似在大数据表上运行数据迁移的场景，你可以通过将 ``atomic`` 属性置为 "
"``False`` 避免在事务中运行迁移::"

msgid ""
"Within such a migration, all operations are run without a transaction. It's "
"possible to execute parts of the migration inside a transaction using :func:"
"`~django.db.transaction.atomic()` or by passing ``atomic=True`` to "
"``RunPython``."
msgstr ""
"在这样的迁移种，所有的操作运行时都不含事务。通过使用 :func:`~django.db."
"transaction.atomic()` 或为 ``RunPython`` 传入 ``atomic=True`` 能将部分迁移置"
"于事务之中。"

msgid ""
"Here's an example of a non-atomic data migration that updates a large table "
"in smaller batches::"
msgstr ""
"这是一个例子，关于非原子性数据迁移操作，将更新大数据表的操作分为数个小批次::"

msgid ""
"The ``atomic`` attribute doesn't have an effect on databases that don't "
"support DDL transactions (e.g. MySQL, Oracle). (MySQL's `atomic DDL "
"statement support <https://dev.mysql.com/doc/refman/en/atomic-ddl.html>`_ "
"refers to individual statements rather than multiple statements wrapped in a "
"transaction that can be rolled back.)"
msgstr ""
"``atomic`` 属性对不支持 DDL 事务的数据库没有影响（例如 MySQL，Oracle）。"
"（MySQL 的 `原子性 DDL 语句支持 <https://dev.mysql.com/doc/refman/en/atomic-"
"ddl.html>`_ 指向独立的语句，而不是封装在能回滚的事务中的多句语句。）"

msgid "Controlling the order of migrations"
msgstr "控制迁移顺序"

msgid ""
"Django determines the order in which migrations should be applied not by the "
"filename of each migration, but by building a graph using two properties on "
"the ``Migration`` class: ``dependencies`` and ``run_before``."
msgstr ""
"Django 不是通过迁移的名字决定迁移执行顺序，而是通过在 ``迁移`` 类上使用两个属"
"性：  ``dependencies`` 和 ``run_before``。"

msgid ""
"If you've used the :djadmin:`makemigrations` command you've probably already "
"seen ``dependencies`` in action because auto-created migrations have this "
"defined as part of their creation process."
msgstr ""
"若你用过 :djadmin:`makemigrations` 命令，你可能早已在运行时见过 "
"``dependencies``，因为自动创建的迁移将此定义为其创建过程的一部分。"

msgid "The ``dependencies`` property is declared like this::"
msgstr "``依赖`` 属性像这样申明::"

msgid ""
"Usually this will be enough, but from time to time you may need to ensure "
"that your migration runs *before* other migrations. This is useful, for "
"example, to make third-party apps' migrations run *after* your :setting:"
"`AUTH_USER_MODEL` replacement."
msgstr ""
"通常这就够用了，但是有很多次，你总是需要确认你的迁移运行在其它迁移 *之前*。例"
"如，这对于让第三方应用的迁移运行在替换 :setting:`AUTH_USER_MODEL` 之后就很有"
"用。"

msgid ""
"To achieve this, place all migrations that should depend on yours in the "
"``run_before`` attribute on your ``Migration`` class::"
msgstr ""
"要实现此目的，将所有需要先运行的迁移置于你的 ``Migration`` 类的 "
"``run_before`` 属性::"

msgid ""
"Prefer using ``dependencies`` over ``run_before`` when possible. You should "
"only use ``run_before`` if it is undesirable or impractical to specify "
"``dependencies`` in the migration which you want to run after the one you "
"are writing."
msgstr ""
"尽可能使用 ``dependencies``，而不是 ``run_before``。只有在在特定迁移中添加 "
"``dependencies`` 使其运行于你编写的迁移之后是没希望的和不切实际的情况下，你才"
"能使用 ``run_before``。"

msgid "Migrating data between third-party apps"
msgstr "在第三方应用程序中迁移数据"

msgid ""
"You can use a data migration to move data from one third-party application "
"to another."
msgstr "你可以使用数据迁移把数据从一个第三方应用程序中转移到另一个。"

msgid ""
"If you plan to remove the old app later, you'll need to set the "
"``dependencies`` property based on whether or not the old app is installed. "
"Otherwise, you'll have missing dependencies once you uninstall the old app. "
"Similarly, you'll need to catch :exc:`LookupError` in the ``apps."
"get_model()`` call that retrieves models from the old app. This approach "
"allows you to deploy your project anywhere without first installing and then "
"uninstalling the old app."
msgstr ""
"如果你计划要移除旧应用程序，则需要根据是否安装旧应用程序来设置 ``依赖`` 属"
"性。否则，一旦你卸载旧应用程序，就会缺失依赖项。同样，你需要在调用 ``app."
"get_model()`` 时捕获 :exc:`LookupError`，前者在旧应用程序中检索模型。这种方法"
"允许你在任何地方部署项目，而无需先安装并且卸载旧应用程序。"

msgid "Here's a sample migration:"
msgstr "这是一个迁移示例："

msgid "myapp/migrations/0124_move_old_app_to_new_app.py"
msgstr "myapp/migrations/0124_move_old_app_to_new_app.py"

msgid ""
"Also consider what you want to happen when the migration is unapplied. You "
"could either do nothing (as in the example above) or remove some or all of "
"the data from the new application. Adjust the second argument of the :mod:"
"`~django.db.migrations.operations.RunPython` operation accordingly."
msgstr ""
"另外在迁移未执行时，请考虑好什么是你想要发生的。你可以什么都不做（就像上面的"
"示例）或者从新应用中移除一些或全部的数据。相应的调整 :mod:`~django.db."
"migrations.operations.RunPython` 操作的第二个参数。"

msgid "Changing an unmanaged model to managed"
msgstr "将非托管模型变为托管的"

msgid ""
"If you want to change an unmanaged model (:attr:`managed=False <django.db."
"models.Options.managed>`) to managed, you must remove ``managed=False`` and "
"generate a migration before making other schema-related changes to the "
"model, since schema changes that appear in the migration that contains the "
"operation to change ``Meta.managed`` may not be applied."
msgstr ""
"如果你想要将非托管模型 (:attr:`managed=False <django.db.models.Options."
"managed>`) 变为托管的，你必须移除 ``managed=False`` 并且在对此模型做其他模式"
"相关的改变前生成一次迁移，因为如果迁移中出现模式改变，对 ``Meta.managed`` 的"
"修改操作不会被执行。"
