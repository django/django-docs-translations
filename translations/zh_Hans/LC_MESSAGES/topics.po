# SOME DESCRIPTIVE TITLE.
# Copyright (C) Django Software Foundation and contributors
# This file is distributed under the same license as the Django package.
#
# Translators:
# Aris Chow <arischow@gmail.com>, 2018
# Arthur Wu <dandelionstill@gmail.com>, 2018
# b1c58ea15303be9e49500f6966759e5d, 2018
# HuanCheng Bai白宦成 <xiqingongzi@gmail.com>, 2018-2019
# BAKEZQ <zhongquan789@126.com>, 2018
# belitex, 2018
# belitex, 2018
# Blg Mengde <kid.blg@gmail.com>, 2019-2020
# 杜文昊 <i@bobdu.cc>, 2018
# Brian Wang <singeeking@gmail.com>, 2018
# cjc7373 <niuchangcun@163.com>, 2020
# FSSlc <fsslc235@gmail.com>, 2020
# charloai <charlo@charlo.xin>, 2018
# charloai <charlo@charlo.xin>, 2018
# Claude Paroz <claude@2xlibre.net>, 2020
# Cy <ll_faw@hotmail.com>, 2018
# Danfi Tao <tdanfi@gmail.com>, 2018
# Danfi Tao <tdanfi@gmail.com>, 2018
# Dogify <595572594@qq.com>, 2019
# flypopo <flypopo.reg@qq.com>, 2018
# fuxiuyin <woshifuxiuyin@gmail.com>, 2019
# fuxiuyin <woshifuxiuyin@gmail.com>, 2019
# Hongjie Tian <tianhongjie07@gmail.com>, 2017
# HuanCheng Bai白宦成 <xiqingongzi@gmail.com>, 2019
# Jahoo Yang <jahoo@pku.edu.cn>, 2021
# ausaki <www.ljm969087551@qq.com>, 2018
# JINGMING DAI <d664216@gmail.com>, 2018
# jinwen wu <toono@qq.com>, 2018
# df2dc1c92e792f7ae8417c51df43db8f_594d92a <0f49be28017426edb1db1a2ab6e67088_717605>, 2018
# Junyu Li <junyu-li@outlook.com>, 2021
# Kai Song <songkaiape@gmail.com>, 2017
# Kevin Sze <leiarix@gmail.com>, 2014
# Kevin Sze <leiarix@gmail.com>, 2014
# lanbla <lanlinwen@buaa.edu.cn>, 2021
# Liping Wang <lynn.config@gmail.com>, 2016
# Liuwt, 2019
# Lu <lu2github@gmail.com>, 2022
# marcus ma <freebird0221@gmail.com>, 2018
# Fnanshan <634635262@qq.com>, 2019
# Noirey <862151891@qq.com>, 2020
# Veoco <one@nomox.cn>, 2020
# paisins Ji <1355871637@qq.com>, 2018
# qiang wu <wuqiangroy@live.com>, 2018
# Robot Robert <justamanm@gmail.com>, 2021
# Ronald White <tkliuxing@me.com>, 2019
# Rui Deng <vipdengrui@vip.qq.com>, 2018
# Lucas Song <mr.songxr@gmail.com>, 2018
# Shellbye bai <shellbye.com@gmail.com>, 2018
# shouheng lei <zz5432@qq.com>, 2018
# 思源曹 <seeran@outlook.com>, 2018
# Todd Kasaki <2524737581@qq.com>, 2020
# Veoco <one@nomox.cn>, 2020-2022
# Vincent <Intelligent.vincent@gmail.com>, 2018
# Liping Wang <lynn.config@gmail.com>, 2016
# 汪心禾 <wangxinhe06@gmail.com>, 2018
# WayneCher <aaazwg@msn.cn>, 2019
# Wei Liu <2407802064@qq.com>, 2020-2021
# zwwhdls <zwwhdls@hotmail.com>, 2018
# woodenrobot <woodenrobot1993@gmail.com>, 2020
# XingFive <haoxingwu@hotmail.com>, 2018
# XingFive <haoxingwu@hotmail.com>, 2018
# Xin Qi <georgechii@outlook.com>, 2021
# xy zhou <kevinzhou412183845@outlook.com>, 2021
# dykai <yingkaidang@gmail.com>, 2019
# yhliyr <lokidri@outlook.com>, 2018
# Zhengyang Wang <sufforest@gmail.com>, 2018
# Zhibo Zhang <805960083@qq.com>, 2019
# BAKEZQ <zhongquan789@126.com>, 2018
# zwwhdls <zwwhdls@hotmail.com>, 2018
# 吴彬 <xiake21x@qq.com>, 2016
# 小明 王 <qing_chun_dou@126.com>, 2018
# 开宇 冯 <loveress01@outlook.com>, 2019
# 得鑫 李 <lidexin911@126.com>, 2018
# 思源曹 <seeran@outlook.com>, 2018
# 摸象 虾子 <86447840@qq.com>, 2019
# 杜文昊 <i@bobdu.cc>, 2018
# 文隆 胡 <xcluas@gmail.com>, 2018
# 景隆 王 <Arsenal591@126.com>, 2018
# blacklin <chinalinzhijie@gmail.com>, 2020
# 郝逸先(Henry) <haoyixian1994@hotmail.com>, 2019
# 阿西 <davidxu5945@qq.com>, 2018
# Dogify <595572594@qq.com>, 2019
# b1c58ea15303be9e49500f6966759e5d, 2018
msgid ""
msgstr ""
"Project-Id-Version: django-docs\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-02-21 01:06-0600\n"
"PO-Revision-Date: 2022-02-12 21:16+0000\n"
"Last-Translator: Transifex Bot <>\n"
"Language-Team: Chinese (China) (http://www.transifex.com/django/django-docs/"
"language/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

msgid "Asynchronous support"
msgstr "异步支持"

msgid ""
"Django has support for writing asynchronous (\"async\") views, along with an "
"entirely async-enabled request stack if you are running under :doc:`ASGI </"
"howto/deployment/asgi/index>`. Async views will still work under WSGI, but "
"with performance penalties, and without the ability to have efficient long-"
"running requests."
msgstr ""
"Django 支持编写异步（“async”）视图，如果在 :doc:`ASGI </howto/deployment/"
"asgi/index>` 下运行，还支持完全异步的请求堆栈。异步视图仍然可以在 WSGI 下运"
"行，但会有性能损失，并且不能有高效的长时间运行的请求。"

msgid ""
"We're still working on async support for the ORM and other parts of Django. "
"You can expect to see this in future releases. For now, you can use the :"
"func:`sync_to_async` adapter to interact with the sync parts of Django. "
"There is also a whole range of async-native Python libraries that you can "
"integrate with."
msgstr ""
"我们仍然在为 ORM 和 Django 的其他部分提供异步支持。你可以期待在未来的版本中看"
"到这个功能。目前，你可以使用 :func:`sync_to_async` 适配器来和 Django 的同步部"
"分进行交互。你还可以集成一系列的原生异步 Python 库。"

msgid "Async views"
msgstr "异步视图"

msgid ""
"Any view can be declared async by making the callable part of it return a "
"coroutine - commonly, this is done using ``async def``. For a function-based "
"view, this means declaring the whole view using ``async def``. For a class-"
"based view, this means making its ``__call__()`` method an ``async def`` "
"(not its ``__init__()`` or ``as_view()``)."
msgstr ""
"任何视图可以通过使它的可调用部分返回一个协程来声明为异步——通常，这是使用 "
"``async def`` 完成的。对于基于函数的视图，需要使用 ``async def`` 来声明所有视"
"图。对于基于类的视图，需要将它的 ``__call__()`` 方法作为 ``async def`` （而不"
"是 ``__init__()`` 或 ``as_view()`` ）。"

msgid ""
"Django uses ``asyncio.iscoroutinefunction`` to test if your view is "
"asynchronous or not. If you implement your own method of returning a "
"coroutine, ensure you set the ``_is_coroutine`` attribute of the view to "
"``asyncio.coroutines._is_coroutine`` so this function returns ``True``."
msgstr ""
"Django 使用 ``asyncio.iscoroutinefunction`` 来测试视图是否为异步。如果你实现"
"了自己的方法来返回协同程序，请确保你把视图的 ``_is_coroutine`` 属性设置为 "
"``asyncio.coroutines._is_coroutine`` ，这样函数将返回 ``True``。"

msgid ""
"Under a WSGI server, async views will run in their own, one-off event loop. "
"This means you can use async features, like concurrent async HTTP requests, "
"without any issues, but you will not get the benefits of an async stack."
msgstr ""
"WSGI 服务器下，异步视图将在其自有的一次性事件循环中运行。这意味着你可以放心使"
"用异步特性（例如并发异步 HTTP 请求），但是你不会获得异步堆栈的好处。"

msgid ""
"The main benefits are the ability to service hundreds of connections without "
"using Python threads. This allows you to use slow streaming, long-polling, "
"and other exciting response types."
msgstr ""
"主要优点是无需使用 Python 线程就能服务数百个连接。这就允许你使用慢流（slow "
"streaming）、长轮询和其他响应类型。"

msgid ""
"If you want to use these, you will need to deploy Django using :doc:`ASGI </"
"howto/deployment/asgi/index>` instead."
msgstr ""
"如果你想使用这些特性，需要使用 :doc:`ASGI </howto/deployment/asgi/index>` 来"
"部署 Django。"

msgid ""
"You will only get the benefits of a fully-asynchronous request stack if you "
"have *no synchronous middleware* loaded into your site. If there is a piece "
"of synchronous middleware, then Django must use a thread per request to "
"safely emulate a synchronous environment for it."
msgstr ""
"如果你的站点中没有 *非同步中间件*，那么你将得到完全异步请求栈的好处。如果有一"
"个同步中间件，那么 Django 必须在每个请求中使用一个线程来安全地为它模拟一个同"
"步环境。"

msgid ""
"Middleware can be built to support :ref:`both sync and async <async-"
"middleware>` contexts. Some of Django's middleware is built like this, but "
"not all. To see what middleware Django has to adapt, you can turn on debug "
"logging for the ``django.request`` logger and look for log messages about *"
"\"Synchronous middleware ... adapted\"*."
msgstr ""
"可以构建中间件来支持 :ref:`同步和异步 <async-middleware>` 上下文。一些 "
"Django 中间件是这么构建的，但不是所有都这样。要查看 Django 能够支持哪些中间"
"件，你可以为 ``django.request`` 记录器打开调试日志，而且要查看有关 *"
"\"Synchronous middleware ... adapted\"* 的日志消息。"

msgid ""
"In both ASGI and WSGI mode, you can still safely use asynchronous support to "
"run code concurrently rather than serially. This is especially handy when "
"dealing with external APIs or data stores."
msgstr ""
"在 ASGI 和 WSGI 模式里，你可以始终安全地使用异步支持来并发运行代码而不是串"
"行。这在处理外部 API 或数据存储时特别方便。"

msgid ""
"If you want to call a part of Django that is still synchronous, like the "
"ORM, you will need to wrap it in a :func:`sync_to_async` call. For example::"
msgstr ""
"如果你想调用仍处于同步的 Django 部分（比如 ORM），则需要用 :func:"
"`sync_to_async` 调用来包装它。例如："

msgid ""
"You may find it easier to move any ORM code into its own function and call "
"that entire function using :func:`sync_to_async`. For example::"
msgstr ""
"你可能发现，移动任何 ORM 代码到它自己的函数中并使用 :func:`sync_to_async` 来"
"调用整个函数会更容易。例如："

msgid ""
"If you accidentally try to call a part of Django that is still synchronous-"
"only from an async view, you will trigger Django's :ref:`asynchronous safety "
"protection <async-safety>` to protect your data from corruption."
msgstr ""
"如果你不小心从异步视图中调用一个仍然处于同步状态的 Django 部分，那么你将触发 "
"Django 的 :ref:`异步安全保护 <async-safety>` 来保护你的数据不被破坏。"

msgid "Performance"
msgstr "性能"

msgid ""
"When running in a mode that does not match the view (e.g. an async view "
"under WSGI, or a traditional sync view under ASGI), Django must emulate the "
"other call style to allow your code to run. This context-switch causes a "
"small performance penalty of around a millisecond."
msgstr ""
"在与视图不匹配的模式里运行时（比如在 WSGI 下的异步视图，在 ASGI 下的传统同步"
"视图），Django 必须模拟其他调用方式来运行你的代码。这个上下文切换回导致大约 "
"1 毫秒的小性能损失。"

msgid ""
"This is also true of middleware. Django will attempt to minimize the number "
"of context-switches between sync and async. If you have an ASGI server, but "
"all your middleware and views are synchronous, it will switch just once, "
"before it enters the middleware stack."
msgstr ""
"这对中间件也是如此。Django 将尝试最小化同步和异步之间上下文切换的次数。如果你"
"有一个 ASGI 服务器，但所有中间件和视图是同步的，那么在进入中间件堆栈之前，它"
"将仅切换一次。"

msgid ""
"However, if you put synchronous middleware between an ASGI server and an "
"asynchronous view, it will have to switch into sync mode for the middleware "
"and then back to async mode for the view. Django will also hold the sync "
"thread open for middleware exception propagation. This may not be noticeable "
"at first, but adding this penalty of one thread per request can remove any "
"async performance advantage."
msgstr ""
"但是，如果你把同步的中间件放在 ASGI 服务器和异步的视图之间，就必须为中间件切"
"换到同步模式，然后再回到视图的异步模式。Django 还将保持同步线程的开放，以便中"
"间件的异常传播。这可能在一开始并不明显，但增加每个请求一个线程的惩罚可以消除"
"任何异步性能的优势。"

msgid ""
"You should do your own performance testing to see what effect ASGI versus "
"WSGI has on your code. In some cases, there may be a performance increase "
"even for a purely synchronous codebase under ASGI because the request-"
"handling code is still all running asynchronously. In general you will only "
"want to enable ASGI mode if you have asynchronous code in your project."
msgstr ""
"你应该执行性能测试来观察 ASGI 和 WSGI 对你的代码有什么影响。在一些案例中，即"
"使对于 ASGI 下的纯同步代码库，性能也可能会有所提高，因为请求处理代码仍然全部"
"异步执行。通常，只有当项目有异步代码时，才需要开启 ASGI 模式。"

msgid "Async safety"
msgstr "异步安全"

msgid ""
"Certain key parts of Django are not able to operate safely in an async "
"environment, as they have global state that is not coroutine-aware. These "
"parts of Django are classified as \"async-unsafe\", and are protected from "
"execution in an async environment. The ORM is the main example, but there "
"are other parts that are also protected in this way."
msgstr ""
"Django 的一些关键部分不能在异步环境中安全运行，因为它们的全局状态不支持协同状"
"态。这些部分被归类为\"异步不安全\"，并且受到保护，不能在异步环境中执行。ORM是"
"主要的例子，但这里也有其他部分以这种方式受到保护。"

msgid ""
"If you try to run any of these parts from a thread where there is a *running "
"event loop*, you will get a :exc:`~django.core.exceptions."
"SynchronousOnlyOperation` error. Note that you don't have to be inside an "
"async function directly to have this error occur. If you have called a sync "
"function directly from an async function, without using :func:"
"`sync_to_async` or similar, then it can also occur. This is because your "
"code is still running in a thread with an active event loop, even though it "
"may not be declared as async code."
msgstr ""
"如果你试着从有运行事件循环的线程中运行这部分中的任何一个，你会得到一个 :exc:"
"`~django.core.exceptions.SynchronousOnlyOperation` 错误。注意，不用在异步函数"
"内部就会得到这个错误。如果你从异步函数中调用一个同步函数，而没有使用 :func:"
"`sync_to_async` 或类似方法，也会出现这个问题。这是因为你的代码仍然在具有活动"
"事件循环的线程中运行，即使它可能没有被声明为异步代码。"

msgid ""
"If you encounter this error, you should fix your code to not call the "
"offending code from an async context. Instead, write your code that talks to "
"async-unsafe functions in its own, sync function, and call that using :func:"
"`asgiref.sync.sync_to_async` (or any other way of running sync code in its "
"own thread)."
msgstr ""
"如果遇到这个错误，你应该修改你的代码，以免从异步上下文中调用有问题的代码。相"
"反，你可以编写代码在同步函数中与不安全异步交流，并使用 :func:`asgiref.sync."
"sync_to_async` 调用（或在自己的线程中运行同步代码的任何其他方式）。"

msgid ""
"The async context can be imposed upon you by the environment in which you "
"are running your Django code. For example, Jupyter_ notebooks and IPython_ "
"interactive shells both transparently provide an active event loop so that "
"it is easier to interact with asynchronous APIs."
msgstr ""
"在运行你的 Django 代码环境中你可以使用异步上下文语境。例如， Jupyter_ 笔记本"
"和 IPython_ 互动环境都是明显地提供了一种激活事件循环，所以与异步 APIs 互动更"
"容易。"

msgid ""
"If you're using an IPython shell, you can disable this event loop by "
"running::"
msgstr ""
"如果你正在使用 IPython 环境，你可以通过运行如下命令来禁用这种事件循环::"

msgid ""
"as a command at the IPython prompt. This will allow you to run synchronous "
"code without generating :exc:`~django.core.exceptions."
"SynchronousOnlyOperation` errors; however, you also won't be able to "
"``await`` asynchronous APIs. To turn the event loop back on, run::"
msgstr ""
"作为IPython终端的命令。这会使你得以运行同步代码而不产生:exc:`~django.core."
"exceptions.SynchronousOnlyOperation` 错误。然而，你无法等候异步API。重新打开"
"事件循环，请运行::"

msgid ""
"If you're in an environment other than IPython (or you can't turn off "
"``autoawait`` in IPython for some reason), you are *certain* there is no "
"chance of your code being run concurrently, and you *absolutely* need to run "
"your sync code from an async context, then you can disable the warning by "
"setting the :envvar:`DJANGO_ALLOW_ASYNC_UNSAFE` environment variable to any "
"value."
msgstr ""

msgid ""
"If you enable this option and there is concurrent access to the async-unsafe "
"parts of Django, you may suffer data loss or corruption. Be very careful and "
"do not use this in production environments."
msgstr ""
"如果启用了这个选项，并且同时访问 Django 的异步不安全 (async-unsafe) 部分，你"
"会遇到数据丢失或损坏，所以一定要非常小心，并且不要再生产环境里这样使用。"

msgid ""
"If you need to do this from within Python, do that with ``os.environ``::"
msgstr "如果你需要在 Python 中执行此操作，请使用 ``os.environ`` ："

msgid "Async adapter functions"
msgstr "异步适配函数"

msgid ""
"It is necessary to adapt the calling style when calling sync code from an "
"async context, or vice-versa. For this there are two adapter functions, from "
"the ``asgiref.sync`` module: :func:`async_to_sync` and :func:"
"`sync_to_async`. They are used to transition between the calling styles "
"while preserving compatibility."
msgstr ""
"当从异步的上下文中调用同步的代码时，有必要适配调用风格，反之亦然。为此，有两"
"个适配器功能，可从 ``asgiref.sync`` 模块中获取：:func:`async_to_sync` 和 :"
"func:`sync_to_async` 。它们用于调用样式之间转换，同时保持兼容性。"

msgid ""
"These adapter functions are widely used in Django. The `asgiref`_ package "
"itself is part of the Django project, and it is automatically installed as a "
"dependency when you install Django with ``pip``."
msgstr ""
"这些适配函数广泛应用于 Django。`asgiref`_ 包本身就是 Django 项目的部分，并且"
"它在当你用 ``pip`` 方式安装 Django 时，会作为依赖项目自动安装。"

msgid "``async_to_sync()``"
msgstr "``async_to_sync()``"

msgid ""
"Takes an async function and returns a sync function that wraps it. Can be "
"used as either a direct wrapper or a decorator::"
msgstr "使用异步函数并返回包装它的同步函数。可用作直接包装器或装饰器："

msgid ""
"The async function is run in the event loop for the current thread, if one "
"is present. If there is no current event loop, a new event loop is spun up "
"specifically for the single async invocation and shut down again once it "
"completes. In either situation, the async function will execute on a "
"different thread to the calling code."
msgstr ""
"如果存在异步函数，那么它会在当前线程的事件循环中运行。如果没有当前事件循环，"
"则会为单独异步调用专门启动一个新的事件循环，并且会在它完成后再次关闭。无论哪"
"种情况，异步函数会在调用代码的不同线程上执行。"

msgid ""
"Threadlocals and contextvars values are preserved across the boundary in "
"both directions."
msgstr "Threadlocals 和 contextvars 值在两个方向的边界上都保持不变。"

msgid ""
":func:`async_to_sync` is essentially a more powerful version of the :py:func:"
"`asyncio.run` function in Python's standard library. As well as ensuring "
"threadlocals work, it also enables the ``thread_sensitive`` mode of :func:"
"`sync_to_async` when that wrapper is used below it."
msgstr ""
":func:`async_to_sync` 本质上是 Python 标准库中 :py:func:`asyncio.run` 函数更"
"强大的版本。在确保 threadlocals 工作之外，当在它下面使用包装时，它也会启用 :"
"func:`sync_to_async` 的 ``thread_sensitive`` 模式。"

msgid "``sync_to_async()``"
msgstr "``sync_to_async()``"

msgid ""
"Takes a sync function and returns an async function that wraps it. Can be "
"used as either a direct wrapper or a decorator::"
msgstr "使用同步函数并返回包装它的异步函数。可用作直接包装器或装饰器："

msgid ""
"Sync functions tend to be written assuming they all run in the main thread, "
"so :func:`sync_to_async` has two threading modes:"
msgstr ""
"假设所有同步功能都在主线程中运行时，则倾向于编写同步功能，因此 :func:"
"`sync_to_async` 有两个线程模式："

msgid ""
"``thread_sensitive=True`` (the default): the sync function will run in the "
"same thread as all other ``thread_sensitive`` functions. This will be the "
"main thread, if the main thread is synchronous and you are using the :func:"
"`async_to_sync` wrapper."
msgstr ""
"``thread_sensitive=True`` （默认使用）：同步函数将与所有其它 "
"``thread_sensitive`` 函数在相同线程里运行。如果主线程是同步的并且你正在使用 :"
"func:`async_to_sync` 装饰器，则该同步函数将成为主线程。"

msgid ""
"``thread_sensitive=False``: the sync function will run in a brand new thread "
"which is then closed once the invocation completes."
msgstr ""
"``thread_sensitive=False``：同步函数将在一个全新的线程中运行，该线程一旦完"
"成，将会关闭。"

msgid ""
"``asgiref`` version 3.3.0 changed the default value of the "
"``thread_sensitive`` parameter to ``True``. This is a safer default, and in "
"many cases interacting with Django the correct value, but be sure to "
"evaluate uses of ``sync_to_async()`` if updating ``asgiref`` from a prior "
"version."
msgstr ""
"``asgiref`` 3.3.0版本将 ``thread_sensitive`` 的默认值改为了 ``True`` 。这是一"
"个更加安全的默认项，并且在许多情况下与Django交互能得到正确的值。但是在使用 "
"``asgiref`` 的旧版本在升级前请评估 ``sync_to_async()`` 的使用情况。"

msgid ""
"Thread-sensitive mode is quite special, and does a lot of work to run all "
"functions in the same thread. Note, though, that it *relies on usage of* :"
"func:`async_to_sync` *above it in the stack* to correctly run things on the "
"main thread. If you use ``asyncio.run()`` or similar, it will fall back to "
"running thread-sensitive functions in a single, shared thread, but this will "
"not be the main thread."
msgstr ""
"Thread-sensitive(线程敏感)模式非常特殊，在同一个线程中运行所有函数需要做很多"
"工作。但是请注意，它依赖于堆栈中它上面的 :func:`async_to_sync` 的使用，以便在"
"主线程上正确运行。如果你使用 ``asyncio.run()`` 或类似，它将退回到单独共享线程"
"（但不是主线程）中运行 thread-sensitive 函数。"

msgid ""
"The reason this is needed in Django is that many libraries, specifically "
"database adapters, require that they are accessed in the same thread that "
"they were created in. Also a lot of existing Django code assumes it all runs "
"in the same thread, e.g. middleware adding things to a request for later use "
"in views."
msgstr ""
"在 Django 中需要这么做的原因是许多库，特别是数据库适配器，要求它们在创建时所"
"在的同一个线程里对其进行访问。许多现有的 Django 代码也假设它都在同一进程中运"
"行（比如中间件将内容添加到请求中以供稍后在视图中使用）。"

msgid ""
"Rather than introduce potential compatibility issues with this code, we "
"instead opted to add this mode so that all existing Django sync code runs in "
"the same thread and thus is fully compatible with async mode. Note that sync "
"code will always be in a *different* thread to any async code that is "
"calling it, so you should avoid passing raw database handles or other thread-"
"sensitive references around."
msgstr ""
"我们没有引入代码潜在的兼容性问题，而是选择了添加这种模式，以便所有现有的 "
"Django 同步代码都在同一个线程中运行，从而完全兼容异步模式。注意，同步代码始终"
"要与调用它的异步代码保持在不同线程中，所以你应该避免传递原始数据库句柄"
"(handles)或者其他 thread-sensitive 引用。"

msgid "Customizing authentication in Django"
msgstr "Django 中的自定义验证"

msgid ""
"The authentication that comes with Django is good enough for most common "
"cases, but you may have needs not met by the out-of-the-box defaults. "
"Customizing authentication in your projects requires understanding what "
"points of the provided system are extensible or replaceable. This document "
"provides details about how the auth system can be customized."
msgstr ""
"Django 自带的身份验证已经足够满足大多数常见的情况，但你可能有一些需求没有被开"
"箱即用的默认值所满足。在你的项目中定制身份验证需要了解所提供系统的哪些点是可"
"扩展或可替换的。本文档详细介绍了如何定制认证系统。"

msgid ""
":ref:`Authentication backends <authentication-backends>` provide an "
"extensible system for when a username and password stored with the user "
"model need to be authenticated against a different service than Django's "
"default."
msgstr ""
"当用户模型中存储的用户名和密码需要对一个不同于 Django 默认服务验证时，:ref:`"
"认证后端 <authentication-backends>` 提供了一个可扩展的系统。"

msgid ""
"You can give your models :ref:`custom permissions <custom-permissions>` that "
"can be checked through Django's authorization system."
msgstr ""
"你可以给你的模型 :ref:`自定义权限 <custom-permissions>` 并且可以通过 Django "
"的授权系统检查。"

msgid ""
"You can :ref:`extend <extending-user>` the default ``User`` model, or :ref:"
"`substitute <auth-custom-user>` a completely customized model."
msgstr ""
"你可以 :ref:`扩展 <extending-user>` 默认的 ``User`` 模型，或者完全自定义一个"
"模型进行 :ref:`替换 <auth-custom-user>` "

msgid "Other authentication sources"
msgstr "其它认证资源"

msgid ""
"There may be times you have the need to hook into another authentication "
"source -- that is, another source of usernames and passwords or "
"authentication methods."
msgstr "有时候你需要连接到其他认证源——一个包含用户名及密码的源或者认证方法。"

msgid ""
"For example, your company may already have an LDAP setup that stores a "
"username and password for every employee. It'd be a hassle for both the "
"network administrator and the users themselves if users had separate "
"accounts in LDAP and the Django-based applications."
msgstr ""
"例如，你的公司可能已经有了一个 LDAP 配置，为每个员工存储了一个用户名和密码。"
"如果用户在 LDAP 和基于 Django 的应用程序中分别有不同的账户，那么对于网络管理"
"员和用户本身来说都是一件很麻烦的事情。"

msgid ""
"So, to handle situations like this, the Django authentication system lets "
"you plug in other authentication sources. You can override Django's default "
"database-based scheme, or you can use the default system in tandem with "
"other systems."
msgstr ""
"所以，为了处理这样的情况，Django 认证系统让你可以插入其他认证源。你可以覆盖 "
"Django 默认的基于数据库的方案，也可以将默认系统与其他系统串联使用。"

msgid ""
"See the :ref:`authentication backend reference <authentication-backends-"
"reference>` for information on the authentication backends included with "
"Django."
msgstr ""
"参见 :ref:`认证后端参考 <authentication-backends-reference>`，了解 Django 所"
"包含的认证后端的信息。"

msgid "Specifying authentication backends"
msgstr "指定认证后端"

msgid ""
"Behind the scenes, Django maintains a list of \"authentication backends\" "
"that it checks for authentication. When somebody calls :func:`django.contrib."
"auth.authenticate()` -- as described in :ref:`How to log a user in <how-to-"
"log-a-user-in>` -- Django tries authenticating across all of its "
"authentication backends. If the first authentication method fails, Django "
"tries the second one, and so on, until all backends have been attempted."
msgstr ""
"在幕后，Django 维护了一个 “认证后端” 列表，用于检查认证。当有人调用 :func:"
"`django.contrib.auth.authenticate()` ——就像 :ref:`如何登录用户 <how-to-log-a-"
"user-in>` 中描述的那样——Django 会尝试对所有的认证后端进行认证。如果第一个认证"
"方法失败，Django 就尝试第二个，以此类推，直到所有后端都尝试过。"

msgid ""
"The list of authentication backends to use is specified in the :setting:"
"`AUTHENTICATION_BACKENDS` setting. This should be a list of Python path "
"names that point to Python classes that know how to authenticate. These "
"classes can be anywhere on your Python path."
msgstr ""
"要使用的认证后端列表在 :setting:`AUTHENTICATION_BACKENDS` 配置中指定。这应该"
"是一个指向知道如何验证的 Python 类的 Python 路径名列表。这些类可以是 Python "
"路径上的任何地方。"

msgid "By default, :setting:`AUTHENTICATION_BACKENDS` is set to::"
msgstr "默认情况下，:setting:`AUTHENTICATION_BACKENDS` 配置为："

msgid ""
"That's the basic authentication backend that checks the Django users "
"database and queries the built-in permissions. It does not provide "
"protection against brute force attacks via any rate limiting mechanism. You "
"may either implement your own rate limiting mechanism in a custom auth "
"backend, or use the mechanisms provided by most web servers."
msgstr ""

msgid ""
"The order of :setting:`AUTHENTICATION_BACKENDS` matters, so if the same "
"username and password is valid in multiple backends, Django will stop "
"processing at the first positive match."
msgstr ""
":setting:`AUTHENTICATION_BACKENDS` 的顺序很重要，所以如果同一个用户名和密码在"
"多个后端都有效，Django 会在第一个正向匹配时停止处理。"

msgid ""
"If a backend raises a :class:`~django.core.exceptions.PermissionDenied` "
"exception, authentication will immediately fail. Django won't check the "
"backends that follow."
msgstr ""
"如果一个后端抛出 :class:`~django.core.exceptions.PermissionDenied` 异常，则验"
"证流程立马终止，Django 不会继续检查其后的后端。"

msgid ""
"Once a user has authenticated, Django stores which backend was used to "
"authenticate the user in the user's session, and re-uses the same backend "
"for the duration of that session whenever access to the currently "
"authenticated user is needed. This effectively means that authentication "
"sources are cached on a per-session basis, so if you change :setting:"
"`AUTHENTICATION_BACKENDS`, you'll need to clear out session data if you need "
"to force users to re-authenticate using different methods. A simple way to "
"do that is to execute ``Session.objects.all().delete()``."
msgstr ""
"一旦用户进行了身份认证，Django 就会在用户的会话中存储哪个后端对用户进行了身份"
"验证，并在该会话期间，每当需要访问当前已身份认证的用户时，就会重新使用同一个"
"后端。这实际上意味着认证源是以每个会话为基础进行缓存的，所以如果你改变了 :"
"setting:`AUTHENTICATION_BACKENDS`，如果你需要强制用户使用不同的方法重新认证，"
"你就需要清除会话数据。一个简单的方法就是执行 ``Session.objects.all()."
"delete()``。"

msgid "Writing an authentication backend"
msgstr "编写一个认证后端"

msgid ""
"An authentication backend is a class that implements two required methods: "
"``get_user(user_id)`` and ``authenticate(request, **credentials)``, as well "
"as a set of optional permission related :ref:`authorization methods "
"<authorization_methods>`."
msgstr ""
"认证后端是一个类，它实现了两个必要的方法：``get_user(user_id)`` 和 "
"``authenticate(request, **credentials)``，以及一组可选的与权限相关的 :ref:`认"
"证方法 <authorization_methods>`。"

msgid ""
"The ``get_user`` method takes a ``user_id`` -- which could be a username, "
"database ID or whatever, but has to be the primary key of your user object "
"-- and returns a user object or ``None``."
msgstr ""
"``get_user`` 方法接收一个 ``user_id`` ——可以是用户名、数据库 ID 或其他什么，"
"但必须是用户对象的主键——然后返回一个用户对象或 ``None``。"

msgid ""
"The ``authenticate`` method takes a ``request`` argument and credentials as "
"keyword arguments. Most of the time, it'll look like this::"
msgstr ""
"``authenticate`` 方法采用 ``request`` 参数和证书作为关键字参数。大多数情况"
"下，它看起来像这样："

msgid "But it could also authenticate a token, like so::"
msgstr "但它也可以认证一个令牌，比如："

msgid ""
"Either way, ``authenticate()`` should check the credentials it gets and "
"return a user object that matches those credentials if the credentials are "
"valid. If they're not valid, it should return ``None``."
msgstr ""
"无论哪种方式，``authenticate()`` 应该检查它所得到的凭证，如果凭证有效，则返回"
"一个与这些凭证相匹配的用户对象。如果无效，则应返回 ``None``。"

msgid ""
"``request`` is an :class:`~django.http.HttpRequest` and may be ``None`` if "
"it wasn't provided to :func:`~django.contrib.auth.authenticate` (which "
"passes it on to the backend)."
msgstr ""
"``request`` 是一个 :class:`~django.http.HttpRequest`，如果没有提供给 :func:"
"`~django.contrib.auth.authenticate` （将其传递给后端），则可能是 ``None``。"

msgid ""
"The Django admin is tightly coupled to the Django :ref:`User object <user-"
"objects>`. The best way to deal with this is to create a Django ``User`` "
"object for each user that exists for your backend (e.g., in your LDAP "
"directory, your external SQL database, etc.) You can either write a script "
"to do this in advance, or your ``authenticate`` method can do it the first "
"time a user logs in."
msgstr ""
"Django admin 与 Django :ref:`User 对象 <user-objects>` 紧密耦合。处理这个问题"
"的最好方法是为每个存在于后台的用户创建一个 Django ``User`` 对象（例如，在你"
"的 LDAP 目录中，你的外部 SQL 数据库中，等等），你可以提前写一个脚本来完成这个"
"任务，或者你的 ``authenticate`` 方法可以在用户第一次登录时完成。"

msgid ""
"Here's an example backend that authenticates against a username and password "
"variable defined in your ``settings.py`` file and creates a Django ``User`` "
"object the first time a user authenticates::"
msgstr ""
"下面是一个后端实例，它可以根据 ``settings.py`` 文件中定义的用户名和密码变量进"
"行验证，并在用户第一次验证时创建一个 Django ``User`` 对象："

msgid "Handling authorization in custom backends"
msgstr "在自定义后端处理认证"

msgid "Custom auth backends can provide their own permissions."
msgstr "自定义的认证后端可以提供他们自己的权限。"

msgid ""
"The user model and its manager will delegate permission lookup functions (:"
"meth:`~django.contrib.auth.models.User.get_user_permissions()`, :meth:"
"`~django.contrib.auth.models.User.get_group_permissions()`, :meth:`~django."
"contrib.auth.models.User.get_all_permissions()`, :meth:`~django.contrib.auth."
"models.User.has_perm()`, :meth:`~django.contrib.auth.models.User."
"has_module_perms()`, and :meth:`~django.contrib.auth.models.UserManager."
"with_perm()`) to any authentication backend that implements these functions."
msgstr ""
"用户模型和它的管理器会把权限查找函数（:meth:`~django.contrib.auth.models."
"User.get_user_permissions()`、:meth:`~django.contrib.auth.models.User."
"get_group_permissions()`、:meth:`~django.contrib.auth.models.User."
"get_all_permissions()`、:meth:`~django.contrib.auth.models.User."
"has_perm()`、:meth:`~django.contrib.auth.models.User.has_module_perms()` 和 :"
"meth:`~django.contrib.auth.models.UserManager.with_perm()`）委托给任何实现了"
"这些函数的认证后端。"

msgid ""
"The permissions given to the user will be the superset of all permissions "
"returned by all backends. That is, Django grants a permission to a user that "
"any one backend grants."
msgstr ""
"用户所拥有的权限将是所有验证后端返回的所有权限的一个超集。也就是说，如果任何"
"后端之一将一个权限赋予了用户，那么 Django 最终也将该权限赋予这个用户。"

msgid ""
"If a backend raises a :class:`~django.core.exceptions.PermissionDenied` "
"exception in :meth:`~django.contrib.auth.models.User.has_perm()` or :meth:"
"`~django.contrib.auth.models.User.has_module_perms()`, the authorization "
"will immediately fail and Django won't check the backends that follow."
msgstr ""
"如果后端在 :meth:`~django.contrib.auth.models.User.has_perm()` 或 :meth:"
"`~django.contrib.auth.models.User.has_module_perms()` 中引发 :class:`~django."
"core.exceptions.PermissionDenied` 异常，认证就会立即失败，Django 也不会检查后"
"面的后端。"

msgid "A backend could implement permissions for the magic admin like this::"
msgstr "后端可以像这样为管理员实现权限："

msgid ""
"This gives full permissions to the user granted access in the above example. "
"Notice that in addition to the same arguments given to the associated :class:"
"`django.contrib.auth.models.User` functions, the backend auth functions all "
"take the user object, which may be an anonymous user, as an argument."
msgstr ""
"这就给了上例中授予访问权限的用户全部权限。请注意，除了给相关的 :class:"
"`django.contrib.auth.models.User` 函数提供相同的参数外，后台的认证函数都以用"
"户对象（可能是一个匿名用户）作为参数。"

msgid ""
"A full authorization implementation can be found in the ``ModelBackend`` "
"class in :source:`django/contrib/auth/backends.py`, which is the default "
"backend and queries the ``auth_permission`` table most of the time."
msgstr ""
"一个完整的鉴权实现可以在 :source:`django/contrib/auth/backends.py` 的 "
"``ModelBackend`` 里找到，这是默认的后端，并且在大多数时候会查询 "
"``auth_permission`` 表。"

msgid "Authorization for anonymous users"
msgstr "匿名用户的授权"

msgid ""
"An anonymous user is one that is not authenticated i.e. they have provided "
"no valid authentication details. However, that does not necessarily mean "
"they are not authorized to do anything. At the most basic level, most "
"websites authorize anonymous users to browse most of the site, and many "
"allow anonymous posting of comments etc."
msgstr ""
"匿名用户是指那些没有验证过的用户，也就是说，他们没有提供任何有效的验证信息。"
"然而，这并不一定意味着他们就无权做任何事。在最基本的层面上，大多数站点允许匿"
"名用户浏览大部分页面，而且很多站点也允许匿名评论。"

msgid ""
"Django's permission framework does not have a place to store permissions for "
"anonymous users. However, the user object passed to an authentication "
"backend may be an :class:`django.contrib.auth.models.AnonymousUser` object, "
"allowing the backend to specify custom authorization behavior for anonymous "
"users. This is especially useful for the authors of re-usable apps, who can "
"delegate all questions of authorization to the auth backend, rather than "
"needing settings, for example, to control anonymous access."
msgstr ""
"Django 的权限框架没有一个地方可以存储匿名用户的权限。但是，传递给认证后台的用"
"户对象可以是一个 :class:`django.contrib.uth.models.AnonymousUser` 对象，允许"
"后台为匿名用户指定自定义的授权行为。这对于可重用应用的作者来说特别有用，他们"
"可以将所有的授权问题委托给认证后端，而不是需要配置，例如，控制匿名访问。"

msgid "Authorization for inactive users"
msgstr "非激活用户认证"

msgid ""
"An inactive user is one that has its :attr:`~django.contrib.auth.models.User."
"is_active` field set to ``False``. The :class:`~django.contrib.auth.backends."
"ModelBackend` and :class:`~django.contrib.auth.backends.RemoteUserBackend` "
"authentication backends prohibits these users from authenticating. If a "
"custom user model doesn't have an :attr:`~django.contrib.auth.models."
"CustomUser.is_active` field, all users will be allowed to authenticate."
msgstr ""
"非激活用户是指 :attr:`~django.contrib.auth.models.User.is_active` 字段设置为 "
"``False`` 的用户。:class:`~django.contrib.auth.backends.ModelBackend` 和 :"
"class:`~django.contrib.auth.backends.RemoteUserBackend` 认证后端禁止这些用户"
"进行认证。如果一个自定义用户模型没有 :attr:`~django.contrib.auth.models."
"CustomUser.is_active` 字段，那么所有用户都将被允许认证。"

msgid ""
"You can use :class:`~django.contrib.auth.backends.AllowAllUsersModelBackend` "
"or :class:`~django.contrib.auth.backends.AllowAllUsersRemoteUserBackend` if "
"you want to allow inactive users to authenticate."
msgstr ""
"如果你想让非激活用户进行身份认证，可以使用 :class:`~django.contrib.auth."
"backends.AllowAllUsersModelBackend` 或 :class:`~django.contrib.auth.backends."
"AllowAllUsersRemoteUserBackend`。"

msgid ""
"The support for anonymous users in the permission system allows for a "
"scenario where anonymous users have permissions to do something while "
"inactive authenticated users do not."
msgstr ""
"权限系统中对匿名用户的支持，可以实现匿名用户有权限做某事，而非激活的认证用户"
"没有权限的场景。"

msgid ""
"Do not forget to test for the ``is_active`` attribute of the user in your "
"own backend permission methods."
msgstr "不要忘记在自己的后端权限方法中测试用户的 ``is_active`` 属性。"

msgid "Handling object permissions"
msgstr "处理对象权限"

msgid ""
"Django's permission framework has a foundation for object permissions, "
"though there is no implementation for it in the core. That means that "
"checking for object permissions will always return ``False`` or an empty "
"list (depending on the check performed). An authentication backend will "
"receive the keyword parameters ``obj`` and ``user_obj`` for each object "
"related authorization method and can return the object level permission as "
"appropriate."
msgstr ""
"Django 的权限框架有一个对象权限的基础，尽管在核心中没有实现。这意味着对对象权"
"限的检查总是返回 ``False`` 或一个空列表（取决于所执行的检查）。认证后端将为每"
"个与对象相关的授权方法接收关键字参数 ``obj`` 和 ``user_obj``，并可以适当返回"
"对象级别的权限。"

msgid "Custom permissions"
msgstr "自定义权限"

msgid ""
"To create custom permissions for a given model object, use the "
"``permissions`` :ref:`model Meta attribute <meta-options>`."
msgstr ""
"要为给定的模型对象创建自定义权限，使用 ``permissions`` :ref:`模型 Meta 属性 "
"<meta-options>`。"

msgid ""
"This example ``Task`` model creates two custom permissions, i.e., actions "
"users can or cannot do with ``Task`` instances, specific to your "
"application::"
msgstr ""
"这个 ``Task`` 模型创建了两个自定义权限，即用户可以或不可以对 ``Task`` 实例进"
"行的操作，具体到你的应用程序："

msgid ""
"The only thing this does is create those extra permissions when you run :"
"djadmin:`manage.py migrate <migrate>` (the function that creates permissions "
"is connected to the :data:`~django.db.models.signals.post_migrate` signal). "
"Your code is in charge of checking the value of these permissions when a "
"user is trying to access the functionality provided by the application "
"(changing the status of tasks or closing tasks.) Continuing the above "
"example, the following checks if a user may close tasks::"
msgstr ""
"这样做的唯一作用就是当你运行 :djadmin:`manage.py migrate <migrate>` 时，创建"
"这些额外的权限（创建权限的函数连接到 :data:`~django.db.models.signals."
"post_migrate` 信号）。你的代码负责在用户试图访问应用程序提供的功能（改变任务"
"状态或关闭任务）时检查这些权限的值。 继续上面的例子，下面检查用户是否可以关闭"
"任务："

msgid "Extending the existing ``User`` model"
msgstr "扩展现有的 ``User`` 模型"

msgid ""
"There are two ways to extend the default :class:`~django.contrib.auth.models."
"User` model without substituting your own model. If the changes you need are "
"purely behavioral, and don't require any change to what is stored in the "
"database, you can create a :ref:`proxy model <proxy-models>` based on :class:"
"`~django.contrib.auth.models.User`. This allows for any of the features "
"offered by proxy models including default ordering, custom managers, or "
"custom model methods."
msgstr ""
"有两种方法可以扩展默认的 :class:`~django.contrib.auth.models.User` 模型，而不"
"用替换自己的模型。如果你需要的是纯粹的行为改变，而不需要改变数据库中存储的内"
"容，你可以基于 :class:`~django.contrib.auth.models.User` 创建一个 :ref:`代理"
"模型 <proxy-models>`。这允许代理模型提供的任何功能，包括默认排序、自定义管理"
"器或自定义模型方法。"

msgid ""
"If you wish to store information related to ``User``, you can use a :class:"
"`~django.db.models.OneToOneField` to a model containing the fields for "
"additional information. This one-to-one model is often called a profile "
"model, as it might store non-auth related information about a site user. For "
"example you might create an Employee model::"
msgstr ""
"如果你希望存储与 ``User`` 相关的信息，你可以使用一个 :class:`~django.db."
"models.OneToOneField` 到一个包含字段的模型，以获得额外的信息。这种一对一的模"
"型通常被称为 profile 模型，因为它可能会存储一个站点用户的非认证相关信息。例"
"如，你可以创建一个 Employee 模型："

msgid ""
"Assuming an existing Employee Fred Smith who has both a User and Employee "
"model, you can access the related information using Django's standard "
"related model conventions::"
msgstr ""
"假设现有的雇员 Fred Smith 同时拥有 User 和 Employee 模型，可以使用 Django 的"
"标准关联模型约束来访问相关信息："

msgid ""
"To add a profile model's fields to the user page in the admin, define an :"
"class:`~django.contrib.admin.InlineModelAdmin` (for this example, we'll use "
"a :class:`~django.contrib.admin.StackedInline`) in your app's ``admin.py`` "
"and add it to a ``UserAdmin`` class which is registered with the :class:"
"`~django.contrib.auth.models.User` class::"
msgstr ""
"要将配置文件模型的字段添加到管理员的用户页面中，在你的应用程序的 ``admin."
"py`` 中定义一个 :class:`~django.contrib.admin.InlineModelAdmin` （在这个例子"
"中，我们将使用一个 :class:`~django.contrib.admin.StackedInline`），并将其添加"
"到一个 ``UserAdmin`` 类中，该类用 :class:`~django.contrib.auth.models.User`` "
"类注册："

msgid ""
"These profile models are not special in any way - they are just Django "
"models that happen to have a one-to-one link with a user model. As such, "
"they aren't auto created when a user is created, but a :attr:`django.db."
"models.signals.post_save` could be used to create or update related models "
"as appropriate."
msgstr ""
"这些 profile 模型并没有任何特殊之处——它们只是 Django 模型，恰好与用户模型有一"
"对一的联系。因此，当用户被创建时，它们并不会自动创建，但可以用一个 :attr:"
"`django.db.models.signals.post_save` 来适当地创建或更新相关模型。"

msgid ""
"Using related models results in additional queries or joins to retrieve the "
"related data. Depending on your needs, a custom user model that includes the "
"related fields may be your better option, however, existing relations to the "
"default user model within your project's apps may justify the extra database "
"load."
msgstr ""
"使用相关模型会导致额外的查询或连接来检索相关数据。根据你的需求，包含相关字段"
"的自定义用户模型可能是你更好的选择，然而，在你的项目应用程序中与默认用户模型"
"的现有关系可能会证明额外的数据库负载是合理的。"

msgid "Substituting a custom ``User`` model"
msgstr "替换一个自定义的 ``User`` 模型。"

msgid ""
"Some kinds of projects may have authentication requirements for which "
"Django's built-in :class:`~django.contrib.auth.models.User` model is not "
"always appropriate. For instance, on some sites it makes more sense to use "
"an email address as your identification token instead of a username."
msgstr ""
"有些项目可能会有认证需求，而 Django 内置的 :class:`~django.contrib.auth."
"models.User` 模型并不总是合适。例如，在一些网站上，使用电子邮件地址作为你的身"
"份识别标记比使用用户名更有意义。"

msgid ""
"Django allows you to override the default user model by providing a value "
"for the :setting:`AUTH_USER_MODEL` setting that references a custom model::"
msgstr ""
"Django 允许你通过为 :setting:`AUTH_USER_MODEL` 配置提供一个引用自定义模型的值"
"来覆盖默认的用户模型："

msgid ""
"This dotted pair describes the :attr:`~django.apps.AppConfig.label` of the "
"Django app (which must be in your :setting:`INSTALLED_APPS`), and the name "
"of the Django model that you wish to use as your user model."
msgstr ""

msgid "Using a custom user model when starting a project"
msgstr "启动项目时使用自定义用户模型"

msgid ""
"If you're starting a new project, it's highly recommended to set up a custom "
"user model, even if the default :class:`~django.contrib.auth.models.User` "
"model is sufficient for you. This model behaves identically to the default "
"user model, but you'll be able to customize it in the future if the need "
"arises::"
msgstr ""
"如果你准备启动一个新的项目，强烈推荐你设置一个自定义的用户模型，即使默认的用"
"户模型对你来说已经足够了。这个模型的行为与默认用户模型相通，但是你能在未来需"
"要的时候自定义它："

msgid ""
"Don't forget to point :setting:`AUTH_USER_MODEL` to it. Do this before "
"creating any migrations or running ``manage.py migrate`` for the first time."
msgstr ""
"不要忘记将 :setting:`AUTH_USER_MODEL` 指向它。在创建任何迁移或者首次运行 "
"``manage.py migrate`` 之前执行这个操作。"

msgid "Also, register the model in the app's ``admin.py``::"
msgstr "同样的，在 app 中的 ``admin.py`` 中注册模型。"

msgid "Changing to a custom user model mid-project"
msgstr "在项目中更改为自定义用户模型。"

msgid ""
"Changing :setting:`AUTH_USER_MODEL` after you've created database tables is "
"significantly more difficult since it affects foreign keys and many-to-many "
"relationships, for example."
msgstr ""
"在你已经建立数据库表之后再去修改 :setting:`AUTH_USER_MODEL` 要困难的多，因为"
"它会影响外键和多对多关系。"

msgid ""
"This change can't be done automatically and requires manually fixing your "
"schema, moving your data from the old user table, and possibly manually "
"reapplying some migrations. See :ticket:`25313` for an outline of the steps."
msgstr ""
"这个改动并不能自动完成，需要手动修复你的架构，将数据从旧的用户表移出，并有可"
"能需要手动执行一些迁移操作。查看步骤概述，请查看 :ticket:`25313`。"

msgid ""
"Due to limitations of Django's dynamic dependency feature for swappable "
"models, the model referenced by :setting:`AUTH_USER_MODEL` must be created "
"in the first migration of its app (usually called ``0001_initial``); "
"otherwise, you'll have dependency issues."
msgstr ""
"由于 Django 对可交换模型的动态依赖特性的限制，:setting:`AUTH_USER_MODEL` 所引"
"用的模型必须在其应用的第一次迁移中创建（通常称为 ``0001_initial``）；否则，你"
"会出现依赖问题。"

msgid ""
"In addition, you may run into a ``CircularDependencyError`` when running "
"your migrations as Django won't be able to automatically break the "
"dependency loop due to the dynamic dependency. If you see this error, you "
"should break the loop by moving the models depended on by your user model "
"into a second migration. (You can try making two normal models that have a "
"``ForeignKey`` to each other and seeing how ``makemigrations`` resolves that "
"circular dependency if you want to see how it's usually done.)"
msgstr ""
"此外，当你运行迁移时，你可能会遇到一个 ``CircularDependencyError``，因为 "
"Django 不会因为动态依赖而自动打破依赖循环。如果你看到这个错误，你应该通过将你"
"的用户模型所依赖的模型移动到第二个迁移中来打破这个循环。（如果你想看看通常是"
"怎么做的，你可以尝试做两个正常的模型，它们之间有一个 ``ForeignKey``，看看 "
"``makemigrations`` 是如何解决这个循环依赖的。）"

msgid "Reusable apps and ``AUTH_USER_MODEL``"
msgstr "可重用应用和 ``AUTH_USER_MODEL``"

msgid ""
"Reusable apps shouldn't implement a custom user model. A project may use "
"many apps, and two reusable apps that implemented a custom user model "
"couldn't be used together. If you need to store per user information in your "
"app, use a :class:`~django.db.models.ForeignKey` or :class:`~django.db."
"models.OneToOneField` to ``settings.AUTH_USER_MODEL`` as described below."
msgstr ""
"可重用应用不应该实现自定义用户模型。一个项目可能会使用很多应用，两个实现了自"
"定义用户模型的可重用应用不能一起使用。如果你需要在你的应用中存储每个用户的信"
"息，可以使用一个 :class:`~django.db.models.ForeignKey` 或 :class:`~django.db."
"models.OneToOneField` 到 `settings.AUTH_USER_MODEL`，如下所述。"

msgid "Referencing the ``User`` model"
msgstr "引用 ``User`` 模型"

msgid ""
"If you reference :class:`~django.contrib.auth.models.User` directly (for "
"example, by referring to it in a foreign key), your code will not work in "
"projects where the :setting:`AUTH_USER_MODEL` setting has been changed to a "
"different user model."
msgstr ""
"如果你直接引用 :class:`~django.contrib.auth.models.User` （例如，通过在一个外"
"键中引用它），你的代码将无法在 :setting:`AUTH_USER_MODEL` 配置已被更改为不同"
"用户模型的项目中工作。"

msgid ""
"Instead of referring to :class:`~django.contrib.auth.models.User` directly, "
"you should reference the user model using ``django.contrib.auth."
"get_user_model()``. This method will return the currently active user model "
"-- the custom user model if one is specified, or :class:`~django.contrib."
"auth.models.User` otherwise."
msgstr ""
"与其直接引用 :class:`~django.contrib.auth.models.User`，不如使用 ``django."
"contrib.auth.get_user_model()`` 引用用户模型。这个方法将返回当前活动的用户模"
"型——如果指定了自定义用户模型，则返回自定义用户模型，否则返回 :class:`~django."
"contrib.auth.models.User`。"

msgid ""
"When you define a foreign key or many-to-many relations to the user model, "
"you should specify the custom model using the :setting:`AUTH_USER_MODEL` "
"setting. For example::"
msgstr ""
"在定义用户模型的外键或多对多关系时，应使用 :setting:`AUTH_USER_MODEL` 配置指"
"定自定义模型。例如："

msgid ""
"When connecting to signals sent by the user model, you should specify the "
"custom model using the :setting:`AUTH_USER_MODEL` setting. For example::"
msgstr ""
"连接用户模型发送的信号时，应使用 :setting:`AUTH_USER_MODEL` 配置指定自定义模"
"型。例如："

msgid ""
"Generally speaking, it's easiest to refer to the user model with the :"
"setting:`AUTH_USER_MODEL` setting in code that's executed at import time, "
"however, it's also possible to call ``get_user_model()`` while Django is "
"importing models, so you could use ``models."
"ForeignKey(get_user_model(), ...)``."
msgstr ""
"一般来说，在导入时执行的代码中，用 :setting:`AUTH_USER_MODEL` 配置来引用用户"
"模型是最简单的，不过，也可以在 Django 导入模型时调用 ``get_user_model()``，所"
"以可以使用 ``models.ForeignKey(get_user_model()，...)``。"

msgid ""
"If your app is tested with multiple user models, using "
"``@override_settings(AUTH_USER_MODEL=...)`` for example, and you cache the "
"result of ``get_user_model()`` in a module-level variable, you may need to "
"listen to the  :data:`~django.test.signals.setting_changed` signal to clear "
"the cache. For example::"
msgstr ""
"例如，如果你的应用是用多个用户模型进行测试的，使用 "
"``@override_settings(AUTH_USER_MODEL=...)``，并且你把 ``get_user_model()`` 的"
"结果缓存在模块级变量中，你可能需要监听 :data:`~django.test.signals."
"setting_changed` 信号来清除缓存。例如："

msgid "Specifying a custom user model"
msgstr "指定自定义用户模型"

msgid ""
"When you start your project with a custom user model, stop to consider if "
"this is the right choice for your project."
msgstr ""
"当你用自定义用户模型开始你的项目时，请停下来考虑一下这是否是你项目的正确选"
"择。"

msgid ""
"Keeping all user related information in one model removes the need for "
"additional or more complex database queries to retrieve related models. On "
"the other hand, it may be more suitable to store app-specific user "
"information in a model that has a relation with your custom user model. That "
"allows each app to specify its own user data requirements without "
"potentially conflicting or breaking assumptions by other apps. It also means "
"that you would keep your user model as simple as possible, focused on "
"authentication, and following the minimum requirements Django expects custom "
"user models to meet."
msgstr ""
"将所有用户相关信息保存在一个模型中，就不需要额外的或更复杂的数据库查询来检索"
"相关模型。另一方面，在一个与你的自定义用户模型有关系的模型中存储特定应用的用"
"户信息可能更合适。这允许每个应用程序指定自己的用户数据需求，而不会有潜在的冲"
"突或破坏其他应用程序的假设。这也意味着，你会让你的用户模型尽可能的简单，专注"
"于认证，并遵循 Django 期望自定义用户模型满足的最低要求。"

msgid ""
"If you use the default authentication backend, then your model must have a "
"single unique field that can be used for identification purposes. This can "
"be a username, an email address, or any other unique attribute. A non-unique "
"username field is allowed if you use a custom authentication backend that "
"can support it."
msgstr ""
"如果你使用默认的认证后端，那么你的模型必须有一个可用于识别目的的唯一字段。这"
"可以是一个用户名，一个电子邮件地址，或任何其他独特的属性。如果你使用可以支持"
"的自定义认证后端，则允许使用非唯一的用户名字段。"

msgid ""
"The easiest way to construct a compliant custom user model is to inherit "
"from :class:`~django.contrib.auth.models.AbstractBaseUser`. :class:`~django."
"contrib.auth.models.AbstractBaseUser` provides the core implementation of a "
"user model, including hashed passwords and tokenized password resets. You "
"must then provide some key implementation details:"
msgstr ""
"最简单的方法是继承 :class:`~django.contrib.auth.models.AbstractBaseUser`。 :"
"class:`~django.contrib.auth.models.AbstractBaseUser` 提供了用户模型的核心实"
"现，包括哈希密码和令牌化密码重置。然后你必须提供一些关键的实现细节。"

msgid ""
"A string describing the name of the field on the user model that is used as "
"the unique identifier. This will usually be a username of some kind, but it "
"can also be an email address, or any other unique identifier. The field "
"*must* be unique (i.e., have ``unique=True`` set in its definition), unless "
"you use a custom authentication backend that can support non-unique "
"usernames."
msgstr ""
"描述用户模型上用作唯一标识符的字段名称的字符串。这通常是某种用户名，但也可以"
"是电子邮件地址，或任何其他独特的标识符。该字段 *必须* 是唯一的（即在其定义中"
"设置了 ``unique=True``），除非你使用的自定义认证后端可以支持非唯一的用户名。"

msgid ""
"In the following example, the field ``identifier`` is used as the "
"identifying field::"
msgstr "接下来的样例中，``identifier`` 字段将被用作识别字段："

msgid ""
"A string describing the name of the email field on the ``User`` model. This "
"value is returned by :meth:`~models.AbstractBaseUser.get_email_field_name`."
msgstr ""
"用来描述用户模型中的邮件字段，该值通过 :meth:`~models.AbstractBaseUser."
"get_email_field_name` 返回。"

msgid ""
"A list of the field names that will be prompted for when creating a user via "
"the :djadmin:`createsuperuser` management command. The user will be prompted "
"to supply a value for each of these fields. It must include any field for "
"which :attr:`~django.db.models.Field.blank` is ``False`` or undefined and "
"may include additional fields you want prompted for when a user is created "
"interactively. ``REQUIRED_FIELDS`` has no effect in other parts of Django, "
"like creating a user in the admin."
msgstr ""
"在通过 :djadmin:`createsuperuser` 管理命令创建用户时，将提示用户输入的字段名"
"称列表。用户将被提示为每个字段提供一个值。它必须包括 :attr:`~django.db."
"models.Field.blank` 为 ``False`` 或未定义的任何字段，并可能包括你希望在交互式"
"创建用户时提示的其他字段。``REQUIRED_FIELDS`` 在 Django 的其他部分没有效果，"
"比如在管理中创建用户。"

msgid ""
"For example, here is the partial definition for a user model that defines "
"two required fields - a date of birth and height::"
msgstr ""
"例如，这里是一个用户模型的部分定义，它定义了两个必填字段——出生日期和身高："

msgid ""
"``REQUIRED_FIELDS`` must contain all required fields on your user model, but "
"should *not* contain the ``USERNAME_FIELD`` or ``password`` as these fields "
"will always be prompted for."
msgstr ""
"``REQUIRED_FIELDS`` 必须包含用户模型上的所有必填字段，但 *不应* 包含 "
"``USERNAME_FIELD`` 或 ``password``，因为这些字段总是会被提示。"

msgid ""
"A boolean attribute that indicates whether the user is considered \"active"
"\".  This attribute is provided as an attribute on ``AbstractBaseUser`` "
"defaulting to ``True``. How you choose to implement it will depend on the "
"details of your chosen auth backends. See the documentation of the :attr:"
"`is_active attribute on the built-in user model <django.contrib.auth.models."
"User.is_active>` for details."
msgstr ""
"一个布尔属性，表示用户是否被认为是 “激活的”。 这个属性作为 "
"``AbstractBaseUser`` 的属性，默认为 ``True``。你如何选择实现它将取决于你所选"
"择的认证后端的细节。详情请参考内置用户模型的 :attr:`is_active 属性的文档 "
"<django.contrib.auth.models.User.is_active>`。"

msgid ""
"Optional. A longer formal identifier for the user such as their full name. "
"If implemented, this appears alongside the username in an object's history "
"in :mod:`django.contrib.admin`."
msgstr ""
"可选项。用户的较长身份标识符，比如用户的全名。如果已经设置，则会与用户名一起"
"出现在 :mod:`django.contrib.admin` 中。"

msgid ""
"Optional. A short, informal identifier for the user such as their first "
"name. If implemented, this replaces the username in the greeting to the user "
"in the header of :mod:`django.contrib.admin`."
msgstr ""
"可选项。用户较短的身份标识符，比如用户的名。如果已经设置，它会在 :mod:"
"`django.contrib.admin` 页面头部的欢迎词中替换用户名。"

msgid "Importing ``AbstractBaseUser``"
msgstr "导入 ``AbstractBaseUser``"

msgid ""
"``AbstractBaseUser`` and ``BaseUserManager`` are importable from ``django."
"contrib.auth.base_user`` so that they can be imported without including "
"``django.contrib.auth`` in :setting:`INSTALLED_APPS`."
msgstr ""
"``AbstractBaseUser`` and ``BaseUserManager`` 可以从 ``django.contrib.auth."
"base_user`` 中导入，所以你无需在 :setting:`INSTALLED_APPS` 添加 ``django."
"contrib.auth`` 就能导入它们。"

msgid ""
"The following attributes and methods are available on any subclass of :class:"
"`~django.contrib.auth.models.AbstractBaseUser`:"
msgstr ""
":class:`~django.contrib.auth.models.AbstractBaseUser` 的任何子类都可以使用下"
"面的属性和方法："

msgid "Returns the value of the field nominated by ``USERNAME_FIELD``."
msgstr "返回 ``USERNAME_FIELD`` 指定的字段的值。"

msgid ""
"Normalizes the username by calling :meth:`normalize_username`. If you "
"override this method, be sure to call ``super()`` to retain the "
"normalization."
msgstr ""
"通过调用 :meth:`normalize_username` 来规范化用户名。 如果重写此方法，必须调"
"用 ``super()`` 来保持规范化。"

msgid ""
"Returns the name of the email field specified by the :attr:`~models."
"CustomUser.EMAIL_FIELD` attribute. Defaults to ``'email'`` if "
"``EMAIL_FIELD`` isn't specified."
msgstr ""
"返回由 :attr:`~models.CustomUser.EMAIL_FIELD` 属性指定的电子邮件字段的名称。 "
"如果未指定 ``EMAIL_FIELD`` ，则默认为 ``'email'`` 。"

msgid ""
"Applies NFKC Unicode normalization to usernames so that visually identical "
"characters with different Unicode code points are considered identical."
msgstr ""
"应用 NFKC Unicode 规范化用户名，使得不同 Unicode 码位视觉相同字符视为相同。"

msgid ""
"Read-only attribute which is always ``True`` (as opposed to ``AnonymousUser."
"is_authenticated`` which is always ``False``). This is a way to tell if the "
"user has been authenticated. This does not imply any permissions and doesn't "
"check if the user is active or has a valid session. Even though normally you "
"will check this attribute on ``request.user`` to find out whether it has "
"been populated by the :class:`~django.contrib.auth.middleware."
"AuthenticationMiddleware` (representing the currently logged-in user), you "
"should know this attribute is ``True`` for any :class:`~models.User` "
"instance."
msgstr ""
"只读属性，始终返回 ``True`` （匿名用户 ``AnonymousUser.is_authenticated``  始"
"终返回 ``False`` ）。这是一种判断用户是否已通过身份验证的方法。这并不意味着任"
"何权限，也不会检查用户是否处于活动状态或是否具有有效会话。即使通常您会根据 "
"``request.user`` 检查这个属性，以确定它是否被 :class:`~django.contrib.auth."
"middleware.AuthenticationMiddleware` 填充（表示当前登录的用户），但是你应该知"
"道该属性对于任何 :class:`~models.User` 实例都返回 ``True``。"

msgid ""
"Read-only attribute which is always ``False``. This is a way of "
"differentiating :class:`~models.User` and :class:`~models.AnonymousUser` "
"objects. Generally, you should prefer using :attr:`~models.User."
"is_authenticated` to this attribute."
msgstr ""
"只读属性总是 ``False``。这个属性用于区分 :class:`~models.User` 和 :class:"
"`~models.AnonymousUser` 对象。通常情况下， :attr:`~models.User."
"is_authenticated` 应该置于只读。"

msgid ""
"Sets the user's password to the given raw string, taking care of the "
"password hashing. Doesn't save the :class:`~django.contrib.auth.models."
"AbstractBaseUser` object."
msgstr ""
"设置用户密码，谨慎保存密码哈希。不可保存 :class:`~django.contrib.auth.models."
"AbstractBaseUser` 的对象。"

msgid ""
"When the raw_password is ``None``, the password will be set to an unusable "
"password, as if :meth:`~django.contrib.auth.models.AbstractBaseUser."
"set_unusable_password()` were used."
msgstr ""
"当 raw_password 为 ``None`` 时，密码将被设置为不可用的密码，就像 :meth:"
"`~django.contrib.auth.models.AbstractBaseUser.set_unusable_password()` 一样。"

msgid ""
"Returns ``True`` if the given raw string is the correct password for the "
"user. (This takes care of the password hashing in making the comparison.)"
msgstr ""
"如果给定的原始字符串是用户的正确密码，返回 ``True``。（在进行比较时，这将处理"
"密码散列。）"

msgid ""
"Marks the user as having no password set.  This isn't the same as having a "
"blank string for a password. :meth:`~django.contrib.auth.models."
"AbstractBaseUser.check_password()` for this user will never return ``True``. "
"Doesn't save the :class:`~django.contrib.auth.models.AbstractBaseUser` "
"object."
msgstr ""
"将该用户标记为没有设置密码。 :meth:`~django.contrib.auth.models."
"AbstractBaseUser.check_password()` 对这个用户的检查永远不会返回 ``True``。不"
"保存 :class:`~django.contrib.auth.models.AbstractBaseUser` 对象。"

msgid ""
"You may need this if authentication for your application takes place against "
"an existing external source such as an LDAP directory."
msgstr ""
"如果你的应用程序的身份验证是针对现有的外部源（如 LDAP 目录）进行的，你可能需"
"要这个功能。"

msgid ""
"Returns ``False`` if :meth:`~django.contrib.auth.models.AbstractBaseUser."
"set_unusable_password()` has been called for this user."
msgstr ""
"如果 :meth:`~django.contrib.auth.models.AbstractBaseUser."
"set_unusable_password()` 被调用，返回 ``False``。"

msgid ""
"Returns an HMAC of the password field. Used for :ref:`session-invalidation-"
"on-password-change`."
msgstr ""
"返回密码字段的 HMAC。用于 :ref:`session-invalidation-onpassword-change`。"

msgid ""
":class:`~models.AbstractUser` subclasses :class:`~models.AbstractBaseUser`:"
msgstr ""
":class:`~models.AbstractUser` 是 :class:`~models.AbstractBaseUser` 的子类。"

msgid ""
"Normalizes the email by calling :meth:`.BaseUserManager.normalize_email`. If "
"you override this method, be sure to call ``super()`` to retain the "
"normalization."
msgstr ""
"通过调用 :meth:`.BaseUserManager.normalize_email` 来规范化邮件。如果你覆盖了"
"这个方法，一定要调用 ``super()`` 来保留规范化。"

msgid "Writing a manager for a custom user model"
msgstr "为自定义的用户模型编写一个管理器"

msgid ""
"You should also define a custom manager for your user model. If your user "
"model defines ``username``, ``email``, ``is_staff``, ``is_active``, "
"``is_superuser``, ``last_login``, and ``date_joined`` fields the same as "
"Django's default user, you can install Django's :class:`~django.contrib.auth."
"models.UserManager`; however, if your user model defines different fields, "
"you'll need to define a custom manager that extends :class:`~django.contrib."
"auth.models.BaseUserManager` providing two additional methods:"
msgstr ""
"你也该为你的用户模型定义一个自定义管理器。如果你的用户模型定义了和默认用户相"
"同的 ``username``, ``email``, ``is_staff``, ``is_active``, ``is_superuser``, "
"``last_login``, 和 ``date_joined`等字段，你可以安装 :class:`~django.contrib."
"auth.models.UserManager` ；但是，如果你的用户模型还定义了其他字段，那么就需要"
"定义一个自定义管理器，它扩展了 :class:`~django.contrib.auth.models."
"BaseUserManager` ，提供了两个额外的方法："

msgid ""
"The prototype of ``create_user()`` should accept the username field, plus "
"all required fields as arguments. For example, if your user model uses "
"``email`` as the username field, and has ``date_of_birth`` as a required "
"field, then ``create_user`` should be defined as::"
msgstr ""
"``create_user()`` 的原型应该接受username字段，加上其他所有必须的字段作为参"
"数。举例，如果你的用户模型使用 ``email`` 作为用户名字段，``date_of_birth``  "
"字段作为必填字段，那么 ``create_user`` 应该如下定义："

msgid ""
"The prototype of ``create_superuser()`` should accept the username field, "
"plus all required fields as arguments. For example, if your user model uses "
"``email`` as the username field, and has ``date_of_birth`` as a required "
"field, then ``create_superuser`` should be defined as::"
msgstr ""
"``create_superuser()`` 的原型应该接受username字段，加上其他所有必须的字段作为"
"参数。举例，如果你的用户模型使用 ``email`` 作为用户名字段，``date_of_birth`` "
"字段作为必填字段，那么 ``create_superuser`` 应该如下定义："

msgid ""
"For a :class:`~.ForeignKey` in :attr:`.USERNAME_FIELD` or :attr:`."
"REQUIRED_FIELDS`, these methods receive the value of the :attr:`~.ForeignKey."
"to_field` (the :attr:`~django.db.models.Field.primary_key` by default) of an "
"existing instance."
msgstr ""
"对于 :attr:`.USERNAME_FIELD` 或 :attr:`.REQUIRED_FIELDS` 中的 :class:`~."
"ForeignKey` ，这些方法接收现有实例的:attr:`~.ForeignKey.to_field` （默认为 :"
"attr:`~django.db.models.Field.primary_key` ）的值。"

msgid ""
":class:`~django.contrib.auth.models.BaseUserManager` provides the following "
"utility methods:"
msgstr ""
":class:`~django.contrib.auth.models.BaseUserManager` 提供以下实用方法："

msgid ""
"Normalizes email addresses by lowercasing the domain portion of the email "
"address."
msgstr "通过降低电子邮件地址的域部分来规范化电子邮件地址。"

msgid ""
"Retrieves a user instance using the contents of the field nominated by "
"``USERNAME_FIELD``."
msgstr "使用 ``USERNAME_FIELD`` 指定的字段的内容检索用户实例。"

msgid ""
"Returns a random password with the given length and given string of allowed "
"characters. Note that the default value of ``allowed_chars`` doesn't contain "
"letters that can cause user confusion, including:"
msgstr ""
"返回具有给定长度和给定字符串的随机密码。请注意， ``allowed_chars``  的默认值"
"不包含可能导致用户混淆的字母，包括："

msgid ""
"``i``, ``l``, ``I``, and ``1`` (lowercase letter i, lowercase letter L, "
"uppercase letter i, and the number one)"
msgstr "``i``, ``l``, ``I``, 和 ``1`` (小写i, 小写L, 大写i和数字1)"

msgid ""
"``o``, ``O``, and ``0`` (lowercase letter o, uppercase letter o, and zero)"
msgstr "``o``, ``O``, 和 ``0`` (小写 o, 大写 o, 和数字0 )"

msgid "Extending Django's default ``User``"
msgstr "扩展Django的默认用户模型"

msgid ""
"If you're entirely happy with Django's :class:`~django.contrib.auth.models."
"User` model, but you want to add some additional profile information, you "
"could subclass :class:`django.contrib.auth.models.AbstractUser` and add your "
"custom profile fields, although we'd recommend a separate model as described "
"in the \"Model design considerations\" note of :ref:`specifying-custom-user-"
"model`. ``AbstractUser`` provides the full implementation of the default :"
"class:`~django.contrib.auth.models.User` as an :ref:`abstract model "
"<abstract-base-classes>`."
msgstr ""
"如果你对Django自带的用户模型完全满意，而你又想添加一些其他信息，你可以继承 :"
"class:`django.contrib.auth.models.AbstractUser`  并添加你的自定义字段，不过我"
"们建议使用在“模型设计考虑因素”中描述 :ref:`specifying-custom-user-model` 那样"
"的单独的模型。  ``AbstractUser`` 提供默认 :class:`~django.contrib.auth."
"models.User` 的完整实现作为 :ref:`abstract model ` 。"

msgid "Custom users and the built-in auth forms"
msgstr "自定义用户和内建的auth表单"

msgid ""
"Django's built-in :ref:`forms <built-in-auth-forms>` and :ref:`views <built-"
"in-auth-views>` make certain assumptions about the user model that they are "
"working with."
msgstr ""
"Django的内置 :ref:`forms ` 和 :ref:`views ` 对他们正在使用的用户模型做了一些"
"假设。"

msgid ""
"The following forms are compatible with any subclass of :class:`~django."
"contrib.auth.models.AbstractBaseUser`:"
msgstr ""
"以下表单与 :class:`~django.contrib.auth.models.AbstractBaseUser` 的任何子类兼"
"容："

msgid ""
":class:`~django.contrib.auth.forms.AuthenticationForm`: Uses the username "
"field specified by :attr:`~models.CustomUser.USERNAME_FIELD`."
msgstr ""
":class:`~django.contrib.auth.forms.AuthenticationForm`:  使用 :attr:`~models."
"CustomUser.USERNAME_FIELD` 指定的username字段。"

msgid ":class:`~django.contrib.auth.forms.SetPasswordForm`"
msgstr ":class:`~django.contrib.auth.forms.SetPasswordForm`"

msgid ":class:`~django.contrib.auth.forms.PasswordChangeForm`"
msgstr ":class:`~django.contrib.auth.forms.PasswordChangeForm`"

msgid ":class:`~django.contrib.auth.forms.AdminPasswordChangeForm`"
msgstr ":class:`~django.contrib.auth.forms.AdminPasswordChangeForm`"

msgid ""
"The following forms make assumptions about the user model and can be used as-"
"is if those assumptions are met:"
msgstr "以下表单对用户模型进行了假设，如果满足这些假设，则可以按原样使用:"

msgid ""
":class:`~django.contrib.auth.forms.PasswordResetForm`: Assumes that the user "
"model has a field that stores the user's email address with the name "
"returned by :meth:`~models.AbstractBaseUser.get_email_field_name` (``email`` "
"by default) that can be used to identify the user and a boolean field named "
"``is_active`` to prevent password resets for inactive users."
msgstr ""
":class:`~django.contrib.auth.forms.PasswordResetForm` ：假设用户模型有一个字"
"段存储用户的电子邮件地址，其名称由 :meth:`~models.AbstractBaseUser."
"get_email_field_name` 返回（默认为电子邮件），这个方法用来标识用户，以及名为"
"``is_active``的布尔字段，防止非活动用户重置密码。"

msgid ""
"Finally, the following forms are tied to :class:`~django.contrib.auth.models."
"User` and need to be rewritten or extended to work with a custom user model:"
msgstr ""
"最后，下面的表单和 :class:`~django.contrib.auth.models.User` 绑定，如果需要和"
"自定义的用户模型一起使用，则需要重写或者扩展。"

msgid ":class:`~django.contrib.auth.forms.UserCreationForm`"
msgstr ":class:`~django.contrib.auth.forms.UserCreationForm`"

msgid ":class:`~django.contrib.auth.forms.UserChangeForm`"
msgstr ":class:`~django.contrib.auth.forms.UserChangeForm`"

msgid ""
"If your custom user model is a subclass of ``AbstractUser``, then you can "
"extend these forms in this manner::"
msgstr ""
"如果自定义的用户模型是 ``AbstractUser`` 的子类，则可以使用下面的方式来扩展表"
"单："

msgid "Custom users and :mod:`django.contrib.admin`"
msgstr "自定义用户和 :mod:`django.contrib.admin`"

msgid ""
"If you want your custom user model to also work with the admin, your user "
"model must define some additional attributes and methods. These methods "
"allow the admin to control access of the user to admin content:"
msgstr ""
"如果你希望自定义的用户模型也与管理后台一起使用，那么你的用户模型必须定义一些"
"额外的属性和方法。这些方法允许管理员控制用户对管理后台内容的访问："

msgid ""
"Returns ``True`` if the user is allowed to have access to the admin site."
msgstr "如果允许用户有访问 admin 页面就返回 ``True``。"

msgid "Returns ``True`` if the user account is currently active."
msgstr "返回``True``，如果该用户的账号当前是激活状态"

msgid ""
"Returns ``True`` if the user has the named permission. If ``obj`` is "
"provided, the permission needs to be checked against a specific object "
"instance."
msgstr ""
"如果用户有指定的权限，则返回 ``True`` 。如果提供了参数 ``obj``  ，则需要对指"
"定的对象实例进行权限检查。"

msgid ""
"Returns ``True`` if the user has permission to access models in the given "
"app."
msgstr "如果用户有权限访问指定 app 里的模型，那么返回 ``True`` 。"

msgid ""
"You will also need to register your custom user model with the admin. If "
"your custom user model extends ``django.contrib.auth.models.AbstractUser``, "
"you can use Django's existing ``django.contrib.auth.admin.UserAdmin`` class. "
"However, if your user model extends :class:`~django.contrib.auth.models."
"AbstractBaseUser`, you'll need to define a custom ``ModelAdmin`` class. It "
"may be possible to subclass the default ``django.contrib.auth.admin."
"UserAdmin``; however, you'll need to override any of the definitions that "
"refer to fields on ``django.contrib.auth.models.AbstractUser`` that aren't "
"on your custom user class."
msgstr ""
"你也需要在 admin 文件里注册自定义的用户模型。如果自定义的用户模型扩展了  "
"``django.contrib.auth.models.AbstractUser`` ，你可以直接使用Django已有的类 "
"``django.contrib.auth.admin.UserAdmin`` 。如果你的用户模型扩展了 :class:"
"`~django.contrib.auth.models.AbstractBaseUser` ，你将需要定义一个自定义的类 "
"``ModelAdmin`` 。不管怎样，你都将需要重写任何引用 ``django.contrib.auth."
"models.AbstractUser`` 上的字段的定义，这些字段不在你自定义的用户类中。"

msgid ""
"If you are using a custom ``ModelAdmin`` which is a subclass of ``django."
"contrib.auth.admin.UserAdmin``, then you need to add your custom fields to "
"``fieldsets`` (for fields to be used in editing users) and to "
"``add_fieldsets`` (for fields to be used when creating a user). For example::"
msgstr ""
"如果正在使用自定义的 ``ModelAdmin`` 是 ``django.contrib.auth.admin."
"UserAdmin`` 的子类，那么你需要添加自定义字段到 ``fieldsets`` （用于在编辑用户"
"中使用）和 ``add_fieldsets`` （用于在创建用户时使用）。比如"

msgid ""
"See :ref:`a full example <custom-users-admin-full-example>` for more details."
msgstr ""
"查看 :ref:`a full example <custom-users-admin-full-example>` 来了解更多细节。"

msgid "Custom users and permissions"
msgstr "自定义用户和权限。"

msgid ""
"To make it easy to include Django's permission framework into your own user "
"class, Django provides :class:`~django.contrib.auth.models."
"PermissionsMixin`. This is an abstract model you can include in the class "
"hierarchy for your user model, giving you all the methods and database "
"fields necessary to support Django's permission model."
msgstr ""
"为了便于将Django的权限框架引入到你自己的用户类中，Django提供了 :class:"
"`~django.contrib.auth.models.PermissionsMixin` 。这是一个抽象模型，可以包含在"
"用户模型的类层次结构中，为你提供支持Django权限模型所需的所有方法和数据库字"
"段。"

msgid ""
":class:`~django.contrib.auth.models.PermissionsMixin` provides the following "
"methods and attributes:"
msgstr ""
":class:`~django.contrib.auth.models.PermissionsMixin` 提供下列方法和属性："

msgid ""
"Boolean. Designates that this user has all permissions without explicitly "
"assigning them."
msgstr "布尔值。指定该用户拥有所有权限，而不用一个个开启权限。"

msgid "Returns a set of permission strings that the user has directly."
msgstr "返回用户本身就自带的权限字符串集合。"

msgid ""
"If ``obj`` is passed in, only returns the user permissions for this specific "
"object."
msgstr "如果传入了 ``obj`` ，则只返回指定对象的用户权限。"

msgid ""
"Returns a set of permission strings that the user has, through their groups."
msgstr "返回用户拥有权限的字符串集合，从用户所属组的权限中获取。"

msgid ""
"If ``obj`` is passed in, only returns the group permissions for this "
"specific object."
msgstr "如果传入 ``obj`` 参数，则只返回指定对象所属组的权限。"

msgid ""
"Returns a set of permission strings that the user has, both through group "
"and user permissions."
msgstr ""
"返回用户拥有权限的字符串集合，同时从用户所属组及用户本身的权限中获取。 "

msgid ""
"If ``obj`` is passed in, only returns the permissions for this specific "
"object."
msgstr "如果传入 ``obj``参数，则只返回指定对象和所属组的权限。"

msgid ""
"Returns ``True`` if the user has the specified permission, where ``perm`` is "
"in the format ``\"<app label>.<permission codename>\"`` (see :ref:"
"`permissions <topic-authorization>`). If :attr:`.User.is_active` and :attr:"
"`~.User.is_superuser` are both ``True``, this method always returns ``True``."
msgstr ""
"如果用户具有指定的权限，则返回 ``True`` ，其中 ``perm`` 的格式为 ``\"<app "
"label>.<permission codename>\"`` (see :ref:`permissions <topic-"
"authorization>`)。如果 :attr:`.User.is_active` 和 :attr:`~.User."
"is_superuser` 都为 ``True``，则这个方法一直返回 ``True`` 。"

msgid ""
"If ``obj`` is passed in, this method won't check for a permission for the "
"model, but for this specific object."
msgstr ""
"如果传入 ``obj`` 参数，则这个方法不会检查该模型权限，而只会检查这个出传入对象"
"的权限。"

msgid ""
"Returns ``True`` if the user has each of the specified permissions, where "
"each perm is in the format ``\"<app label>.<permission codename>\"``. If :"
"attr:`.User.is_active` and :attr:`~.User.is_superuser` are both ``True``, "
"this method always returns ``True``."
msgstr ""
"如果用户具有指定权限列表里的每个权限，则返回 ``True`` ，其中perm的格式为 ``"
"\"<app label>.<permission codename>\"`` 。如果 :attr:`.User.is_active` 和 :"
"attr:`~.User.is_superuser` 都返回 ``True`` ，则这个方法一直返回 ``True`` 。"

msgid ""
"If ``obj`` is passed in, this method won't check for permissions for the "
"model, but for the specific object."
msgstr ""
"如果传入参数  ``obj``  ，则这个方法不会检查指定的权限列表，只检查指定对象的权"
"限。"

msgid ""
"Returns ``True`` if the user has any permissions in the given package (the "
"Django app label). If :attr:`.User.is_active` and :attr:`~.User."
"is_superuser` are both ``True``, this method always returns ``True``."
msgstr ""
"如果用户拥有所给的 Django app 标签 (the Django app label) 里的任何权限，则会"
"返回 ``True`` 。如果 :attr:`.User.is_active` 和 :attr:`~.User.is_superuser` "
"都为 ``True`` ，则该方法一直返回 ``True`` 。"

msgid "``PermissionsMixin`` and ``ModelBackend``"
msgstr "``PermissionsMixin``  和  ``ModelBackend``"

msgid ""
"If you don't include the :class:`~django.contrib.auth.models."
"PermissionsMixin`, you must ensure you don't invoke the permissions methods "
"on ``ModelBackend``. ``ModelBackend`` assumes that certain fields are "
"available on your user model. If your user model doesn't provide  those "
"fields, you'll receive database errors when you check permissions."
msgstr ""
"如果你没有引入 :class:`~django.contrib.auth.models.PermissionsMixin` ，必须确"
"保没有调用 ``ModelBackend`` 的权限方法。``ModelBackend`` 假定你的用户模型某些"
"字段可用。如果你的用户模型没有提供这些字段，则当你检查权限的时候，会收到数据"
"库错误提示。"

msgid "Custom users and proxy models"
msgstr "自定义用户和代理模型"

msgid ""
"One limitation of custom user models is that installing a custom user model "
"will break any proxy model extending :class:`~django.contrib.auth.models."
"User`. Proxy models must be based on a concrete base class; by defining a "
"custom user model, you remove the ability of Django to reliably identify the "
"base class."
msgstr ""
"自定义用户模型的一个限制是安装自定义用户模型将破坏任何扩展  :class:`~django."
"contrib.auth.models.User` 的代理模型。代理模型必须基于具体的基类；通过定义自"
"定义用户模型，你就移除了Django可靠地识别基类的功能。"

msgid ""
"If your project uses proxy models, you must either modify the proxy to "
"extend the user model that's in use in your project, or merge your proxy's "
"behavior into your :class:`~django.contrib.auth.models.User` subclass."
msgstr ""
"如果你的项目正在使用代理模型，你必须修改扩展用户模型的代理，或者把代理的行为"
"都合并到 :class:`~django.contrib.auth.models.User` 子类里去。"

msgid "A full example"
msgstr "一个完整的例子"

msgid ""
"Here is an example of an admin-compliant custom user app. This user model "
"uses an email address as the username, and has a required date of birth; it "
"provides no permission checking beyond an ``admin`` flag on the user "
"account. This model would be compatible with all the built-in auth forms and "
"views, except for the user creation forms. This example illustrates how most "
"of the components work together, but is not intended to be copied directly "
"into projects for production use."
msgstr ""
"这里是一个兼容admin的自定义的用户app的例子。这个用户模型使用 email 地址作为"
"username，并且生日是必填字段；除了用户账户上的 ``admin`` flag之外，它本身不提"
"供权限检查。除用户创建的表单外，此模型和所有内置的身份验证表单和视图兼容。此"
"例只是说明了大多数组件如何协同工作，不要直接复制到生产环境里。"

msgid ""
"This code would all live in a ``models.py`` file for a custom authentication "
"app::"
msgstr "这段代码将一直存在于 ``models.py`` 文件中，用于自定义身份验证 app::"

msgid ""
"Then, to register this custom user model with Django's admin, the following "
"code would be required in the app's ``admin.py`` file::"
msgstr ""
"然后，在 Django 管理后台里注册这个用户模型，下面这些代码必须在 app 的 "
"``admin.py`` 文件里："

msgid ""
"Finally, specify the custom model as the default user model for your project "
"using the :setting:`AUTH_USER_MODEL` setting in your ``settings.py``::"
msgstr ""
"最后，在项目配置文件中的 :setting:`AUTH_USER_MODEL` 里指定自定义的用户模型为"
"默认的用户模型。"

msgid ""
"In older versions, ``ReadOnlyPasswordHashField`` is not :attr:`~django.forms."
"Field.disabled` by default and ``UserChangeForm.clean_password()`` is "
"required to return the initial value, whatever the user provides."
msgstr ""
"在旧版本中，``ReadOnlyPasswordHashField`` 默认不是 :attr:`~django.forms."
"Field.disabled`，``UserChangeForm.clean_password()`` 需要返回初始值，不管用户"
"提供什么。"

msgid "Using the Django authentication system"
msgstr "使用 Django 的验证系统"

msgid ""
"This document explains the usage of Django's authentication system in its "
"default configuration. This configuration has evolved to serve the most "
"common project needs, handling a reasonably wide range of tasks, and has a "
"careful implementation of passwords and permissions. For projects where "
"authentication needs differ from the default, Django supports extensive :doc:"
"`extension and customization </topics/auth/customizing>` of authentication."
msgstr ""
"本文档介绍了 Django 验证系统在默认配置下的使用方法。默认配置满足最常见的项目"
"需求，可以处理相当多的任务，还有一个安全的密码和权限实现。对于验证需求与默认"
"配置不同的项目，Django 支持对身份验证进行扩展和定制。"

msgid ""
"Django authentication provides both authentication and authorization "
"together and is generally referred to as the authentication system, as these "
"features are somewhat coupled."
msgstr ""
"Django 验证同时提供身份验证和授权，通常称为身份验证系统，因为这些功能在某种程"
"度上是耦合的。"

msgid "``User`` objects"
msgstr "``User`` 对象"

msgid ""
":class:`~django.contrib.auth.models.User` objects are the core of the "
"authentication system. They typically represent the people interacting with "
"your site and are used to enable things like restricting access, registering "
"user profiles, associating content with creators etc. Only one class of user "
"exists in Django's authentication framework, i.e., :attr:`'superusers' "
"<django.contrib.auth.models.User.is_superuser>` or admin :attr:`'staff' "
"<django.contrib.auth.models.User.is_staff>` users are just user objects with "
"special attributes set, not different classes of user objects."
msgstr ""
"用户对象是认证系统的核心。它通常代表了与你的站点交互的人员，并用于允许诸如限"
"制访问、注册用户配置文件、将内容与创建者关联等功能。Django 的认证框架中用户只"
"有一个类，例如 “超级管理员”或“普通管理员”只是具有特殊属性集的用户对象，而不是"
"用户对象的不同类。"

msgid "The primary attributes of the default user are:"
msgstr "默认用户的主要属性是："

msgid ":attr:`~django.contrib.auth.models.User.username`"
msgstr ":attr:`~django.contrib.auth.models.User.username`"

msgid ":attr:`~django.contrib.auth.models.User.password`"
msgstr ":attr:`~django.contrib.auth.models.User.password`"

msgid ":attr:`~django.contrib.auth.models.User.email`"
msgstr ":attr:`~django.contrib.auth.models.User.email`"

msgid ":attr:`~django.contrib.auth.models.User.first_name`"
msgstr ":attr:`~django.contrib.auth.models.User.first_name`"

msgid ":attr:`~django.contrib.auth.models.User.last_name`"
msgstr ":attr:`~django.contrib.auth.models.User.last_name`"

msgid ""
"See the :class:`full API documentation <django.contrib.auth.models.User>` "
"for full reference, the documentation that follows is more task oriented."
msgstr ""
"请参阅完整的API文档 :class:`full API documentation <django.contrib.auth."
"models.User>` 以获得完整的参考，下面的文档主要以任务为导向。"

msgid "Creating users"
msgstr "创建用户"

msgid ""
"The most direct way to create users is to use the included :meth:`~django."
"contrib.auth.models.UserManager.create_user` helper function::"
msgstr ""
"创建用户最直接的方法是使用包含 :meth:`~django.contrib.auth.models."
"UserManager.create_user` 的函数："

msgid ""
"If you have the Django admin installed, you can also :ref:`create users "
"interactively <auth-admin>`."
msgstr ""
"如果你已经安装了 Django admin 管理后台，你也可以在 admin 管理后台交互式地创建"
"用户:ref:`create users interactively <auth-admin>` 。 "

msgid "Creating superusers"
msgstr "创建超级用户"

msgid "Create superusers using the :djadmin:`createsuperuser` command::"
msgstr "通过命令行 :djadmin:`createsuperuser` 创建超级管理员："

msgid ""
"You will be prompted for a password. After you enter one, the user will be "
"created immediately. If you leave off the :option:`--username "
"<createsuperuser --username>` or :option:`--email <createsuperuser --email>` "
"options, it will prompt you for those values."
msgstr ""
"你将会被提示输入密码，完成之后，超级管理员就被创建成功了。如果你没有填写参"
"数 :option:`--username <createsuperuser --username> ` or :option:`--email "
"<createsuperuser --email>` ，也将会被提示输入这些值。"

msgid "Changing passwords"
msgstr "更改密码"

msgid ""
"Django does not store raw (clear text) passwords on the user model, but only "
"a hash (see :doc:`documentation of how passwords are managed </topics/auth/"
"passwords>` for full details). Because of this, do not attempt to manipulate "
"the password attribute of the user directly. This is why a helper function "
"is used when creating a user."
msgstr ""
"Django 不会在用户模型里保存原始(明文)密码，而只会存储哈希值(请参阅文档 `如何"
"管理密码`  :doc:`documentation of how passwords are managed </topics/auth/"
"passwords>` ) 。因此，请不要试图直接操作用户的密码，这就是创建用户需要辅助函"
"数的原因。"

msgid "To change a user's password, you have several options:"
msgstr "更改一个用户的密码，你有几个选择："

msgid ""
":djadmin:`manage.py changepassword *username* <changepassword>` offers a "
"method of changing a user's password from the command line. It prompts you "
"to change the password of a given user which you must enter twice. If they "
"both match, the new password will be changed immediately. If you do not "
"supply a user, the command will attempt to change the password whose "
"username matches the current system user."
msgstr ""
":djadmin:`manage.py changepassword *username* <changepassword>` 提供了在命令"
"行修改用户密码的方法。它会提示你输入两次新密码，如果操作成功，新密码就立刻生"
"效。如果你没有提供参数 username ，那么将会尝试修改当前系统用户的密码。"

msgid ""
"You can also change a password programmatically, using :meth:`~django."
"contrib.auth.models.User.set_password()`:"
msgstr ""
"你也可以在代码里修改密码，使用 :meth:`~django.contrib.auth.models.User."
"set_password()`:"

msgid ""
"If you have the Django admin installed, you can also change user's passwords "
"on the :ref:`authentication system's admin pages <auth-admin>`."
msgstr ""
"如果你已经按照了 Django admin 管理后台，你也可以在管理后台页面修改密码（请参"
"阅 :ref:`authentication system's admin pages ` ）。"

msgid ""
"Django also provides :ref:`views <built-in-auth-views>` and :ref:`forms "
"<built-in-auth-forms>` that may be used to allow users to change their own "
"passwords."
msgstr ""
"Django 还提供了允许用户自行修改密码的 :ref:`views ` 和 :ref:`forms ` 。"

msgid ""
"Changing a user's password will log out all their sessions. See :ref:"
"`session-invalidation-on-password-change` for details."
msgstr ""
"修改密码将会注销用户的所有会话。查看详情请参阅 :ref:`session-invalidation-on-"
"password-change` 。"

msgid "Authenticating users"
msgstr "验证用户"

msgid ""
"Use :func:`~django.contrib.auth.authenticate()` to verify a set of "
"credentials. It takes credentials as keyword arguments, ``username`` and "
"``password`` for the default case, checks them against each :ref:"
"`authentication backend <authentication-backends>`, and returns a :class:"
"`~django.contrib.auth.models.User` object if the credentials are valid for a "
"backend. If the credentials aren't valid for any backend or if a backend "
"raises :class:`~django.core.exceptions.PermissionDenied`, it returns "
"``None``. For example::"
msgstr ""
"使用 :func:`~django.contrib.auth.authenticate()` 来验证用户。它使用 "
"``username`` 和 ``password`` 作为参数来验证，对每个身份验证后端( :ref:"
"`authentication backend ` )进行检查。如果后端验证有效，则返回一个 :class:"
"`~django.contrib.auth.models.User` 对象。如果后端引发 :class:`~django.core."
"exceptions.PermissionDenied` 错误，将返回 ``None``。举例："

msgid ""
"``request`` is an optional :class:`~django.http.HttpRequest` which is passed "
"on the ``authenticate()`` method of the authentication backends."
msgstr ""
"``request`` 是可选的 :class:`~django.http.HttpRequest` ，它在身份验证后端上"
"的 ``authenticate()`` 方法来传递。"

msgid ""
"This is a low level way to authenticate a set of credentials; for example, "
"it's used by the :class:`~django.contrib.auth.middleware."
"RemoteUserMiddleware`. Unless you are writing your own authentication "
"system, you probably won't use this. Rather if you're looking for a way to "
"login a user, use the :class:`~django.contrib.auth.views.LoginView`."
msgstr ""
"这个一个很底层的验证方法。比如，可以通过 :class:`~django.contrib.auth."
"middleware.RemoteUserMiddleware` 来验证。除非你在编写自己的身份验证系统，否则"
"你可能不会用到它。如果你正在寻找用户登录的方法，请参阅 :class:`~django."
"contrib.auth.views.LoginView` 。"

msgid "Permissions and Authorization"
msgstr "权限和认证"

msgid ""
"Django comes with a built-in permissions system. It provides a way to assign "
"permissions to specific users and groups of users."
msgstr ""
"Django 内置了一个权限系统。它提供了为指定的用户和用户组分配权限的方法。"

msgid ""
"It's used by the Django admin site, but you're welcome to use it in your own "
"code."
msgstr "它在 Django 管理后台界面里使用，但你也可以在自己的代码中使用它。"

msgid "The Django admin site uses permissions as follows:"
msgstr "Django 的 admin 页面使用了如下权限："

msgid ""
"Access to view objects is limited to users with the \"view\" or \"change\" "
"permission for that type of object."
msgstr "访问查看的对象仅限于具有该类型对象的“查看”或“更改”权限的用户。"

msgid ""
"Access to view the \"add\" form and add an object is limited to users with "
"the \"add\" permission for that type of object."
msgstr "访问“添加”表单和添加对象仅限于具有该类型对象的“添加”权限的用户。"

msgid ""
"Access to view the change list, view the \"change\" form and change an "
"object is limited to users with the \"change\" permission for that type of "
"object."
msgstr ""
"访问修改列表、查看“修改”表单和修改对象仅限于对该类型对象的“修改”权限的用户。"

msgid ""
"Access to delete an object is limited to users with the \"delete\" "
"permission for that type of object."
msgstr "访问删除对象仅限于对该类型对象的“删除”权限的用户。"

msgid ""
"Permissions can be set not only per type of object, but also per specific "
"object instance. By using the :meth:`~django.contrib.admin.ModelAdmin."
"has_view_permission`, :meth:`~django.contrib.admin.ModelAdmin."
"has_add_permission`, :meth:`~django.contrib.admin.ModelAdmin."
"has_change_permission` and :meth:`~django.contrib.admin.ModelAdmin."
"has_delete_permission` methods provided by the :class:`~django.contrib.admin."
"ModelAdmin` class, it is possible to customize permissions for different "
"object instances of the same type."
msgstr ""
"不仅可以为每个对象类型设置权限，还可以为每个指定对象实例设置权限。通过使用 :"
"class:`~django.contrib.admin.ModelAdmin` 类提供的 :meth:`~django.contrib."
"admin.ModelAdmin.has_view_permission`, :meth:`~django.contrib.admin."
"ModelAdmin.has_add_permission`, :meth:`~django.contrib.admin.ModelAdmin."
"has_change_permission` 和 :meth:`~django.contrib.admin.ModelAdmin."
"has_delete_permission` 方法，可以为同一类型的不同实例定制权限。"

msgid ""
":class:`~django.contrib.auth.models.User` objects have two many-to-many "
"fields: ``groups`` and ``user_permissions``. :class:`~django.contrib.auth."
"models.User` objects can access their related objects in the same way as any "
"other :doc:`Django model </topics/db/models>`::"
msgstr ""
":class:`~django.contrib.auth.models.User` 对象有两个多对多字段:``groups`` 和 "
"``user_permissions``。 :class:`~django.contrib.auth.models.User` 对象可以像访"
"问其他 :doc:`Django model `: 一样访问他们的相关对象。"

msgid "Default permissions"
msgstr "默认权限"

msgid ""
"When ``django.contrib.auth`` is listed in your :setting:`INSTALLED_APPS` "
"setting, it will ensure that four default permissions -- add, change, "
"delete, and view -- are created for each Django model defined in one of your "
"installed applications."
msgstr ""
"当 :setting:`INSTALLED_APPS` 设置了 ``django.contrib.auth`` 时，它将确保你的"
"每个 Django 模型被创建时有四个默认权限：添加、修改、删除和查看。"

msgid ""
"These permissions will be created when you run :djadmin:`manage.py migrate "
"<migrate>`; the first time you run ``migrate`` after adding ``django.contrib."
"auth`` to :setting:`INSTALLED_APPS`, the default permissions will be created "
"for all previously-installed models, as well as for any new models being "
"installed at that time. Afterward, it will create default permissions for "
"new models each time you run :djadmin:`manage.py migrate <migrate>` (the "
"function that creates permissions is connected to the :data:`~django.db."
"models.signals.post_migrate` signal)."
msgstr ""
"运行 :djadmin:`manage.py migrate <migrate>` 时将创建这些权限。当你添加 "
"``django.contrib.auth`` 到 :setting:`INSTALLED_APPS` 后第一次运行 ``迁移`` ，"
"将会为所有只去已经安装过的模型以及现在正在安装的模型创建这些默认的权限。之"
"后，每次你运行 :djadmin:`manage.py migrate <migrate>` 都会为新模型创建默认权"
"限 (创建权限的函数连接 :data:`~django.db.models.signals.post_migrate` 信号)。"

msgid ""
"Assuming you have an application with an :attr:`~django.db.models.Options."
"app_label` ``foo`` and a model named ``Bar``, to test for basic permissions "
"you should use:"
msgstr ""
"假设你有一个名为 ``foo`` 应用程序和一个名为 ``Bar`` 的模型，要测试基础权限，"
"你应该使用："

msgid "add: ``user.has_perm('foo.add_bar')``"
msgstr "添加：``user.has_perm('foo.add_bar')``"

msgid "change: ``user.has_perm('foo.change_bar')``"
msgstr "修改：``user.has_perm('foo.change_bar')``"

msgid "delete: ``user.has_perm('foo.delete_bar')``"
msgstr "删除：``user.has_perm('foo.delete_bar')``"

msgid "view: ``user.has_perm('foo.view_bar')``"
msgstr "查看：``user.has_perm('foo.view_bar')``"

msgid ""
"The :class:`~django.contrib.auth.models.Permission` model is rarely accessed "
"directly."
msgstr "权限模型很少会被直接访问。"

msgid "Groups"
msgstr "组"

msgid ""
":class:`django.contrib.auth.models.Group` models are a generic way of "
"categorizing users so you can apply permissions, or some other label, to "
"those users. A user can belong to any number of groups."
msgstr ""
":class:`django.contrib.auth.models.Group` 模型是对用户进行分类的通用方法，因"
"此您可以将权限或其他标签应用于这些用户。用户可以属于任意数量的组。"

msgid ""
"A user in a group automatically has the permissions granted to that group. "
"For example, if the group ``Site editors`` has the permission "
"``can_edit_home_page``, any user in that group will have that permission."
msgstr ""
"组里的用户会自动拥有该组的权限。举例，如果 ``Site editors`` 组有修改网站首页"
"的权限，那么该组的任何成员都有这个权限。"

msgid ""
"Beyond permissions, groups are a convenient way to categorize users to give "
"them some label, or extended functionality. For example, you could create a "
"group ``'Special users'``, and you could write code that could, say, give "
"them access to a members-only portion of your site, or send them members-"
"only email messages."
msgstr ""
"除权限外，组是一个方便的途径，可以给用户分类，为其提供一些标签或扩展功能。例"
"如，你可以创建一个组 ``'Special users'``，并在编写的代码里让该组成员访问网站"
"仅限会员部分的内容，或者对该组成员发送仅限会员查看的电子邮件。"

msgid "Programmatically creating permissions"
msgstr "以编程方式创建权限"

msgid ""
"While :ref:`custom permissions <custom-permissions>` can be defined within a "
"model's ``Meta`` class, you can also create permissions directly. For "
"example, you can create the ``can_publish`` permission for a ``BlogPost`` "
"model in ``myapp``::"
msgstr ""
"虽然可以在模型的  ``Meta`` 类中定义 :ref:`custom permissions <custom-"
"permissions>` ，你也可以直接创建权限。例如，你可以为 ``BlogPost`` 模型创建 "
"``can_publish`` 权限。"

msgid ""
"The permission can then be assigned to a :class:`~django.contrib.auth.models."
"User` via its ``user_permissions`` attribute or to a :class:`~django.contrib."
"auth.models.Group` via its ``permissions`` attribute."
msgstr ""
"然后，可以通过 ``user_permissions`` 属性将权限分配给 :class:`~django.contrib."
"auth.models.User` ，或通过 ``permissions`` 属性分配给 :class:`~django."
"contrib.auth.models.Group`  。"

msgid "Proxy models need their own content type"
msgstr "代理模型需要自己的内容类型"

msgid ""
"If you want to create :ref:`permissions for a proxy model <proxy-models-"
"permissions-topic>`, pass ``for_concrete_model=False`` to :meth:`."
"ContentTypeManager.get_for_model` to get the appropriate ``ContentType``::"
msgstr ""
"如果你想创建 :ref:`permissions for a proxy model <proxy-models-permissions-"
"topic>` ，传递 ``for_concrete_model=False`` 到 :meth:`.ContentTypeManager."
"get_for_model` 来获取合适的 ``ContentType`` ："

msgid "Permission caching"
msgstr "权限缓存"

msgid ""
"The :class:`~django.contrib.auth.backends.ModelBackend` caches permissions "
"on the user object after the first time they need to be fetched for a "
"permissions check. This is typically fine for the request-response cycle "
"since permissions aren't typically checked immediately after they are added "
"(in the admin, for example). If you are adding permissions and checking them "
"immediately afterward, in a test or view for example, the easiest solution "
"is to re-fetch the user from the database. For example::"
msgstr ""
"在第一次需要获取用户对象的权限检查时， :class:`~django.contrib.auth.backends."
"ModelBackend` 才会缓存它们的权限。对于请求-响应周期来说，这通常是很好的，因为"
"权限通常不会在添加的时候立刻检查（例如，在 admin 中）。如果你打算在测试或视图"
"中添加权限，并随后检查他们，最简单的解决方案就是从数据库中重新获取用户。例"
"如："

msgid "Proxy models"
msgstr "代理模型"

msgid ""
"Proxy models work exactly the same way as concrete models. Permissions are "
"created using the own content type of the proxy model. Proxy models don't "
"inherit the permissions of the concrete model they subclass::"
msgstr ""
"代理模型的工作方式和具体模型完全相同。代理模型使用自己的内容类型创建权限。代"
"理模型不会继承其子类的具体模型权限。"

msgid "Authentication in web requests"
msgstr ""

msgid ""
"Django uses :doc:`sessions </topics/http/sessions>` and middleware to hook "
"the authentication system into :class:`request objects <django.http."
"HttpRequest>`."
msgstr ""
"Django 使用 :doc:`sessions </topics/http/sessions>` 和中间件将身份验证系统挂"
"接到请求对象中。"

msgid ""
"These provide a :attr:`request.user <django.http.HttpRequest.user>`  "
"attribute on every request which represents the current user. If the current "
"user has not logged in, this attribute will be set to an instance of :class:"
"`~django.contrib.auth.models.AnonymousUser`, otherwise it will be an "
"instance of :class:`~django.contrib.auth.models.User`."
msgstr ""
"它们在每次请求中都会提供 :attr:`request.user <django.http.HttpRequest.user>` "
"属性。如果当前没有用户登录，这个属性将会被设置为 :class:`~django.contrib."
"auth.models.AnonymousUser` ，否则将会被设置为 :class:`~django.contrib.auth."
"models.User` 实例。"

msgid ""
"You can tell them apart with :attr:`~django.contrib.auth.models.User."
"is_authenticated`, like so::"
msgstr ""
"你可以使用 :attr:`~django.contrib.auth.models.User.is_authenticated` 区分两"
"者，例如："

msgid "How to log a user in"
msgstr "用户如何登陆"

msgid ""
"If you have an authenticated user you want to attach to the current session "
"- this is done with a :func:`~django.contrib.auth.login` function."
msgstr ""
"如果有一个已验证的用户想附加到当前会话(session)中，将通过 :func:`~django."
"contrib.auth.login`  函数完成。"

msgid ""
"To log a user in, from a view, use :func:`~django.contrib.auth.login()`. It "
"takes an :class:`~django.http.HttpRequest` object and a :class:`~django."
"contrib.auth.models.User` object. :func:`~django.contrib.auth.login()` saves "
"the user's ID in the session, using Django's session framework."
msgstr ""
"要在视图中让用户登录，使用 :func:`~django.contrib.auth.login()`  。它需要 :"
"class:`~django.http.HttpRequest` 对象和 :class:`~django.contrib.auth.models."
"User` 对象。通过 Django 的 session 框架， :func:`~django.contrib.auth."
"login()` 会在 session 中保存用户的ID。"

msgid ""
"Note that any data set during the anonymous session is retained in the "
"session after a user logs in."
msgstr "注意，在匿名会话期间设置的任何数据都会在用户登录后保留在会话中。"

msgid ""
"This example shows how you might use both :func:`~django.contrib.auth."
"authenticate()` and :func:`~django.contrib.auth.login()`::"
msgstr ""
"这个例子展示了如何使用 :func:`~django.contrib.auth.authenticate()` 和 :func:"
"`~django.contrib.auth.login()`: ："

msgid "Selecting the authentication backend"
msgstr "选择验证后端"

msgid ""
"When a user logs in, the user's ID and the backend that was used for "
"authentication are saved in the user's session. This allows the same :ref:"
"`authentication backend <authentication-backends>` to fetch the user's "
"details on a future request. The authentication backend to save in the "
"session is selected as follows:"
msgstr ""
"当用户登录时，用户 ID 和用于身份验证的后端会被保存在用户会话中。允许相同的 :"
"ref:`authentication backend <authentication-backends>` 在未来的请求中获取用户"
"详情。选择要在会话中保存的验证后端如下："

msgid "Use the value of the optional ``backend`` argument, if provided."
msgstr "使用提供了的可选 ``backend`` 参数值。"

msgid ""
"Use the value of the ``user.backend`` attribute, if present. This allows "
"pairing :func:`~django.contrib.auth.authenticate()` and :func:`~django."
"contrib.auth.login()`: :func:`~django.contrib.auth.authenticate()` sets the "
"``user.backend`` attribute on the user object it returns."
msgstr ""
"使用 ``user.backend``  的值。允许配对 :func:`~django.contrib.auth."
"authenticate()`  和 :func:`~django.contrib.auth.login()` ：当返回用户对象时 :"
"func:`~django.contrib.auth.authenticate()`  设置 ``user.backend`` 属性。"

msgid ""
"Use the ``backend`` in :setting:`AUTHENTICATION_BACKENDS`, if there is only "
"one."
msgstr "使用 :setting:`AUTHENTICATION_BACKENDS` 存在的 ``backend`` 。"

msgid "Otherwise, raise an exception."
msgstr "否则，抛出一个异常。"

msgid ""
"In cases 1 and 2, the value of the ``backend`` argument or the ``user."
"backend`` attribute should be a dotted import path string (like that found "
"in :setting:`AUTHENTICATION_BACKENDS`), not the actual backend class."
msgstr ""
"在1和2中，``backend`` 参数和 ``user.backend`` 属性应该是完整的导入路径（像 :"
"setting:`AUTHENTICATION_BACKENDS` 里的路径一样），而不是真实的后端类。"

msgid "How to log a user out"
msgstr "用户如何登出"

msgid ""
"To log out a user who has been logged in via :func:`django.contrib.auth."
"login()`, use :func:`django.contrib.auth.logout()` within your view. It "
"takes an :class:`~django.http.HttpRequest` object and has no return value. "
"Example::"
msgstr ""
"如果已经通过 :func:`django.contrib.auth.login()` 登录的用户想退出登录，可以在"
"视图中使用 :func:`django.contrib.auth.logout()` 。需要传入 :class:`~django."
"http.HttpRequest` 对象，并且该函数不会返回值。例如："

msgid ""
"Note that :func:`~django.contrib.auth.logout()` doesn't throw any errors if "
"the user wasn't logged in."
msgstr "注意，如果用户未登录，:func:`~django.contrib.auth.logout()` 不会报错。"

msgid ""
"When you call :func:`~django.contrib.auth.logout()`, the session data for "
"the current request is completely cleaned out. All existing data is removed. "
"This is to prevent another person from using the same web browser to log in "
"and have access to the previous user's session data. If you want to put "
"anything into the session that will be available to the user immediately "
"after logging out, do that *after* calling :func:`django.contrib.auth."
"logout()`."
msgstr ""

msgid "Limiting access to logged-in users"
msgstr "限制对未登录用户的访问"

msgid "The raw way"
msgstr "原始方式"

msgid ""
"The raw way to limit access to pages is to check :attr:`request.user."
"is_authenticated <django.contrib.auth.models.User.is_authenticated>` and "
"either redirect to a login page::"
msgstr ""
"限制访问页面最原始的办法就是检查 :attr:`request.user.is_authenticated "
"<django.contrib.auth.models.User.is_authenticated>` 并重定向到登录页面。"

msgid "...or display an error message::"
msgstr "或者显示一个错误信息："

msgid "The ``login_required`` decorator"
msgstr "``login_required`` 装饰器"

msgid ""
"As a shortcut, you can use the convenient :func:`~django.contrib.auth."
"decorators.login_required` decorator::"
msgstr ""
"作为快捷方式，你可以使用 :func:`~django.contrib.auth.decorators."
"login_required` 装饰器:"

msgid ""
":func:`~django.contrib.auth.decorators.login_required` does the following:"
msgstr ""
":func:`~django.contrib.auth.decorators.login_required` 会执行以下操作："

msgid ""
"If the user isn't logged in, redirect to :setting:`settings.LOGIN_URL "
"<LOGIN_URL>`, passing the current absolute path in the query string. "
"Example: ``/accounts/login/?next=/polls/3/``."
msgstr ""
"如果用户没有登录，会重定向到  :setting:`settings.LOGIN_URL <LOGIN_URL>` ，并"
"传递绝对路径到查询字符串中。例如： ``/accounts/login/?next=/polls/3/`` 。"

msgid ""
"If the user is logged in, execute the view normally. The view code is free "
"to assume the user is logged in."
msgstr "如果用户已经登录，则正常执行视图。视图里的代码可以假设用户已经登录了。"

msgid ""
"By default, the path that the user should be redirected to upon successful "
"authentication is stored in a query string parameter called ``\"next\"``. If "
"you would prefer to use a different name for this parameter, :func:`~django."
"contrib.auth.decorators.login_required` takes an optional "
"``redirect_field_name`` parameter::"
msgstr ""
"默认情况下，成功验证时用户跳转的路径保存在名为 ``\"next\"`` 的查询字符串参数"
"中。如果你希望这个参数使用不同名称，请在 :func:`~django.contrib.auth."
"decorators.login_required` 中传递可选参数 ``redirect_field_name`` ："

msgid ""
"Note that if you provide a value to ``redirect_field_name``, you will most "
"likely need to customize your login template as well, since the template "
"context variable which stores the redirect path will use the value of "
"``redirect_field_name`` as its key rather than ``\"next\"`` (the default)."
msgstr ""
"注意，如果你提供了 ``redirect_field_name`` 值，则很可能也需要自定义登录模板，"
"因为存储重定向路径的模板上下文变量使用的是 ``redirect_field_name`` 值，而不"
"是 ``\"next\"`` （默认情况下）。"

msgid ""
":func:`~django.contrib.auth.decorators.login_required` also takes an "
"optional ``login_url`` parameter. Example::"
msgstr ""
":func:`~django.contrib.auth.decorators.login_required` 也有可选参数 "
"``login_url`` 。例如："

msgid ""
"Note that if you don't specify the ``login_url`` parameter, you'll need to "
"ensure that the :setting:`settings.LOGIN_URL <LOGIN_URL>` and your login "
"view are properly associated. For example, using the defaults, add the "
"following lines to your URLconf::"
msgstr ""
"注意，如果你没有指定参数 ``login_url`` ，你需要确认 :setting:`settings."
"LOGIN_URL <LOGIN_URL>`  和登录视图是正确关联的。例如，使用默认方式，在 URL 配"
"置文件里添加下面这行："

msgid ""
"The :setting:`settings.LOGIN_URL <LOGIN_URL>` also accepts view function "
"names and :ref:`named URL patterns <naming-url-patterns>`. This allows you "
"to freely remap your login view within your URLconf without having to update "
"the setting."
msgstr ""
":setting:`settings.LOGIN_URL <LOGIN_URL>` 也接受视图方法名和 :ref:`named URL "
"patterns <naming-url-patterns>` 。这样你可以在 URLconf 里自由地重新映射你的登"
"录视图，而不需更新配置文件。"

msgid ""
"The ``login_required`` decorator does NOT check the ``is_active`` flag on a "
"user, but the default :setting:`AUTHENTICATION_BACKENDS` reject inactive "
"users."
msgstr ""
"``login_required`` 装饰器不会检查用户的 ``is_active`` 标识状态，但默认的 :"
"setting:`AUTHENTICATION_BACKENDS` 会拒绝非正常用户。"

msgid ""
"If you are writing custom views for Django's admin (or need the same "
"authorization check that the built-in views use), you may find the :func:"
"`django.contrib.admin.views.decorators.staff_member_required` decorator a "
"useful alternative to ``login_required()``."
msgstr ""
"如果你打算编写自定义的 Django 管理模块视图（或需要与内置视图使用同样的权限检"
"查），你将会发现 :func:`django.contrib.admin.views.decorators."
"staff_member_required` 装饰器是 ``login_required()`` 的一个有用的替代方法。"

msgid "The ``LoginRequired`` mixin"
msgstr "``LoginRequired`` Mixin"

msgid ""
"When using :doc:`class-based views </topics/class-based-views/index>`, you "
"can achieve the same behavior as with ``login_required`` by using the "
"``LoginRequiredMixin``. This mixin should be at the leftmost position in the "
"inheritance list."
msgstr ""
"使用基于类的视图时，可以使用 ``LoginRequiredMixin`` 实现和 "
"``login_required`` 相同的行为。这个 Mixin 应该在继承列表中最左侧的位置。"

msgid ""
"If a view is using this mixin, all requests by non-authenticated users will "
"be redirected to the login page or shown an HTTP 403 Forbidden error, "
"depending on the :attr:`~django.contrib.auth.mixins.AccessMixin."
"raise_exception` parameter."
msgstr ""
"如果一个视图使用 Mixin ，那么未经验证用户的所有请求都会被重定向到登录页面或者"
"显示 HTTP 403 Forbidden 错误，这取决于 :attr:`~django.contrib.auth.mixins."
"AccessMixin.raise_exception` 参数。"

msgid ""
"You can set any of the parameters of :class:`~django.contrib.auth.mixins."
"AccessMixin` to customize the handling of unauthorized users::"
msgstr ""
"你可以设置 :class:`~django.contrib.auth.mixins.AccessMixin` 的任何参数来自定"
"义未验证用户的处理："

msgid ""
"Just as the ``login_required`` decorator, this mixin does NOT check the "
"``is_active`` flag on a user, but the default :setting:"
"`AUTHENTICATION_BACKENDS` reject inactive users."
msgstr ""
"同 ``login_required`` 装饰器一样，Mixin 不会检查用户的 ``is_active`` 标识状"
"态，但默认的 :setting:`AUTHENTICATION_BACKENDS` 会拒绝非正常用户。"

msgid "Limiting access to logged-in users that pass a test"
msgstr "限制对通过测试的登录用户的访问"

msgid ""
"To limit access based on certain permissions or some other test, you'd do "
"essentially the same thing as described in the previous section."
msgstr ""
"根据某些权限或者其他测试来限制访问，你基本上可以执行和上一节所述同样的操作。"

msgid ""
"You can run your test on :attr:`request.user <django.http.HttpRequest.user>` "
"in the view directly. For example, this view checks to make sure the user "
"has an email in the desired domain and if not, redirects to the login page::"
msgstr ""
"可以在视图里直接对 :attr:`request.user <django.http.HttpRequest.user>` 进行测"
"试。举例，这个视图检查用户是否拥有特定域名的邮箱，否则会重定向到登录页："

msgid ""
"As a shortcut, you can use the convenient ``user_passes_test`` decorator "
"which performs a redirect when the callable returns ``False``::"
msgstr ""
"作为快捷方式，你可以方便的调用 ``user_passes_test`` 装饰器，当调用返回 "
"``False`` 时会执行重定向。"

msgid ""
":func:`~django.contrib.auth.decorators.user_passes_test` takes a required "
"argument: a callable that takes a :class:`~django.contrib.auth.models.User` "
"object and returns ``True`` if the user is allowed to view the page. Note "
"that :func:`~django.contrib.auth.decorators.user_passes_test` does not "
"automatically check that the :class:`~django.contrib.auth.models.User` is "
"not anonymous."
msgstr ""
":func:`~django.contrib.auth.decorators.user_passes_test` 接受一个必要的参数："
"一个带有:class:`~django.contrib.auth.models.User` 对象的调用，如果允许用户访"
"问这个页面，则返回 ``True`` 。注意，:func:`~django.contrib.auth.decorators."
"user_passes_test` 不会自动检查用户是否匿名。"

msgid ""
":func:`~django.contrib.auth.decorators.user_passes_test` takes two optional "
"arguments:"
msgstr ""
":func:`~django.contrib.auth.decorators.user_passes_test` 可以传递两个可选参"
"数："

msgid "``login_url``"
msgstr "``login_url``"

msgid ""
"Lets you specify the URL that users who don't pass the test will be "
"redirected to. It may be a login page and defaults to :setting:`settings."
"LOGIN_URL <LOGIN_URL>` if you don't specify one."
msgstr ""
"允许你指定用户没有通过测试时跳转的地址。它可能是一个登录页面，如果你没指定，"
"默认是 :setting:`settings.LOGIN_URL <LOGIN_URL>` 。"

msgid "``redirect_field_name``"
msgstr "``redirect_field_name``"

msgid ""
"Same as for :func:`~django.contrib.auth.decorators.login_required`. Setting "
"it to ``None`` removes it from the URL, which you may want to do if you are "
"redirecting users that don't pass the test to a non-login page where there's "
"no \"next page\"."
msgstr ""
"与 :func:`~django.contrib.auth.decorators.login_required` 相同。如果你想把没"
"通过检查的用户重定向到没有 \"next page\" 的非登录页面时，把它设置为 "
"``None`` ，这样它会在 URL 中移除。"

msgid "For example::"
msgstr "例如："

msgid ""
"When using :doc:`class-based views </topics/class-based-views/index>`, you "
"can use the ``UserPassesTestMixin`` to do this."
msgstr "使用基于类的视图时，可以使用 ``UserPassesTestMixin`` 执行此操作。"

msgid ""
"You have to override the ``test_func()`` method of the class to provide the "
"test that is performed. Furthermore, you can set any of the parameters of :"
"class:`~django.contrib.auth.mixins.AccessMixin` to customize the handling of "
"unauthorized users::"
msgstr ""
"你必须覆盖类方法 ``test_func()`` 以提供执行的测试。此外，还可以设置 :class:"
"`~django.contrib.auth.mixins.AccessMixin` 的任何参数来自定义处理未授权用户："

msgid ""
"You can also override the ``get_test_func()`` method to have the mixin use a "
"differently named function for its checks (instead of :meth:`test_func`)."
msgstr ""
"你也可以覆盖 ``get_test_func()`` 方法，以使 mixin 对其检查使用不同名称的函数"
"（而不是 :meth:`test_func` ）。"

msgid "Stacking ``UserPassesTestMixin``"
msgstr "集成 ``UserPassesTestMixin``"

msgid ""
"Due to the way ``UserPassesTestMixin`` is implemented, you cannot stack them "
"in your inheritance list. The following does NOT work::"
msgstr ""
"由于实现了 ``UserPassesTestMixin`` 方式，不能在继承列表中集成它们。下述方式将"
"不能工作："

msgid ""
"If ``TestMixin1`` would call ``super()`` and take that result into account, "
"``TestMixin1`` wouldn't work standalone anymore."
msgstr ""
"如果 ``TestMixin1`` 调用 ``super()`` 并把结果考虑在内，``TestMixin1`` 将不能"
"独立运行。"

msgid "The ``permission_required`` decorator"
msgstr "``permission_required`` 装饰器"

msgid ""
"It's a relatively common task to check whether a user has a particular "
"permission. For that reason, Django provides a shortcut for that case: the :"
"func:`~django.contrib.auth.decorators.permission_required()` decorator.::"
msgstr ""
"检查用户是否拥有特定的权限是一个相对常见的任务。出于这个原因，Django 提供了一"
"个快捷方式：:func:`~django.contrib.auth.decorators.permission_required()` 装"
"饰器："

msgid ""
"Just like the :meth:`~django.contrib.auth.models.User.has_perm` method, "
"permission names take the form ``\"<app label>.<permission codename>\"`` (i."
"e. ``polls.add_choice`` for a permission on a model in the ``polls`` "
"application)."
msgstr ""
"就像 :meth:`~django.contrib.auth.models.User.has_perm` 方法一样，权限名称采"
"用 ``\"<app label>.<permission codename>\"`` 形式（比如 ``polls.polls."
"add_choice`` 就是 ``polls`` 应用程序下的模型的权限）。"

msgid ""
"The decorator may also take an iterable of permissions, in which case the "
"user must have all of the permissions in order to access the view."
msgstr ""
"装饰器也可以接受可迭代权限，在这种情况下，用户必须拥有所有权限才能访问视图。"

msgid ""
"Note that :func:`~django.contrib.auth.decorators.permission_required()` also "
"takes an optional ``login_url`` parameter::"
msgstr ""
"注意， :func:`~django.contrib.auth.decorators.permission_required()` 也可以接"
"受可选的 ``login_url`` 参数："

msgid ""
"As in the :func:`~django.contrib.auth.decorators.login_required` decorator, "
"``login_url`` defaults to :setting:`settings.LOGIN_URL <LOGIN_URL>`."
msgstr ""
"和 :func:`~django.contrib.auth.decorators.login_required` 装饰器一样， "
"``login_url`` 默认是:setting:`settings.LOGIN_URL <LOGIN_URL>`。"

msgid ""
"If the ``raise_exception`` parameter is given, the decorator will raise :exc:"
"`~django.core.exceptions.PermissionDenied`, prompting :ref:`the 403 (HTTP "
"Forbidden) view<http_forbidden_view>` instead of redirecting to the login "
"page."
msgstr ""
"如果有 ``raise_exception`` 参数，那么装饰器将引发 :exc:`~django.core."
"exceptions.PermissionDenied` 错误，提示 :ref:`the 403 (HTTP Forbidden) "
"view<http_forbidden_view>` 而不是跳转到登录页面。"

msgid ""
"If you want to use ``raise_exception`` but also give your users a chance to "
"login first, you can add the :func:`~django.contrib.auth.decorators."
"login_required` decorator::"
msgstr ""
"如果你想使用 ``raise_exception`` 但也想给用户登录的机会，那需要添加 :func:"
"`~django.contrib.auth.decorators.login_required` 装饰器："

msgid ""
"This also avoids a redirect loop when :class:`.LoginView`'s "
"``redirect_authenticated_user=True`` and the logged-in user doesn't have all "
"of the required permissions."
msgstr ""
"当 :class:`.LoginView` 的 ``redirect_authenticated_user=True`` 并且已登录用户"
"没有所有必须的权限时，这避免了重定向循环。"

msgid "The ``PermissionRequiredMixin`` mixin"
msgstr "``PermissionRequiredMixin`` Mixin"

msgid ""
"To apply permission checks to :doc:`class-based views </ref/class-based-"
"views/index>`, you can use the ``PermissionRequiredMixin``:"
msgstr ""
"在 :doc:`class-based views </ref/class-based-views/index>` 中应用权限检查，你"
"可以使用 ``PermissionRequiredMixin`` ："

msgid ""
"This mixin, just like the ``permission_required`` decorator, checks whether "
"the user accessing a view has all given permissions. You should specify the "
"permission (or an iterable of permissions) using the ``permission_required`` "
"parameter::"
msgstr ""
"和 ``permission_required`` 装饰器一样，Mixin 检查用户访问的视图是否拥有全部的"
"权限。你应该使用 ``permission_required`` 指定权限（或者可迭代权限）："

msgid ""
"You can set any of the parameters of :class:`~django.contrib.auth.mixins."
"AccessMixin` to customize the handling of unauthorized users."
msgstr ""
"你可以设置 :class:`~django.contrib.auth.mixins.AccessMixin` 的任意参数来自定"
"义处理没有权限的用户。"

msgid "You may also override these methods:"
msgstr "你可能同样需要重写这些方法："

msgid ""
"Returns an iterable of permission names used by the mixin. Defaults to the "
"``permission_required`` attribute, converted to a tuple if necessary."
msgstr ""
"返回 Mixin 使用的可迭代权限的名称。默认为 ``permission_required`` 属性，如果"
"需要可以转化为元组。"

msgid ""
"Returns a boolean denoting whether the current user has permission to "
"execute the decorated view. By default, this returns the result of calling :"
"meth:`~django.contrib.auth.models.User.has_perms()` with the list of "
"permissions returned by :meth:`get_permission_required()`."
msgstr ""
"返回布尔值，表示当前用户是否拥有权限执行装饰器视图。默认情况下，这将返回调"
"用 :meth:`~django.contrib.auth.models.User.has_perms()` 的结果，其中包括返"
"回 :meth:`get_permission_required()` 的权限列表。"

msgid "Redirecting unauthorized requests in class-based views"
msgstr "在基于类的视图中重定向未通过验证的请求"

msgid ""
"To ease the handling of access restrictions in :doc:`class-based views </ref/"
"class-based-views/index>`, the ``AccessMixin`` can be used to configure the "
"behavior of a view when access is denied. Authenticated users are denied "
"access with an HTTP 403 Forbidden response. Anonymous users are redirected "
"to the login page or shown an HTTP 403 Forbidden response, depending on the :"
"attr:`~django.contrib.auth.mixins.AccessMixin.raise_exception` attribute."
msgstr ""
"为了简化基于类的视图限制访问的处理方式，``AccessMixin`` 被用来配置当访问被拒"
"绝时的视图行为。"

msgid ""
"Default return value for :meth:`get_login_url`.  Defaults to ``None`` in "
"which case :meth:`get_login_url` falls back to :setting:`settings.LOGIN_URL "
"<LOGIN_URL>`."
msgstr ""
":meth:`get_login_url` 的缺省返回值。默认是 ``None`` ，在这种情况下， :meth:"
"`get_login_url` 会回退至 :setting:`settings.LOGIN_URL <LOGIN_URL>`。"

msgid ""
"Default return value for :meth:`get_permission_denied_message`. Defaults to "
"an empty string."
msgstr ":meth:`get_permission_denied_message` 的缺省返回值。默认是空字符串。"

msgid ""
"Default return value for :meth:`get_redirect_field_name`. Defaults to ``"
"\"next\"``."
msgstr ":meth:`get_redirect_field_name` 的缺省返回值。默认是 ``\"next\"`` 。"

msgid ""
"If this attribute is set to ``True``, a :class:`~django.core.exceptions."
"PermissionDenied` exception is raised when the conditions are not met.  When "
"``False`` (the default), anonymous users are redirected to the login page."
msgstr ""
"如果这个属性被设置为 ``True`` ，当条件不被满足的时候会引发 :class:`~django."
"core.exceptions.PermissionDenied` 异常。如果是 ``False`` （默认），匿名用户会"
"被重定向至登录页面。"

msgid ""
"Returns the URL that users who don't pass the test will be redirected to. "
"Returns :attr:`login_url` if set, or :setting:`settings.LOGIN_URL "
"<LOGIN_URL>` otherwise."
msgstr ""
"返回当用户没有通过测试时将被重定向的网址。如果已设置，将返回 :attr:"
"`login_url` ，否则返回 :setting:`settings.LOGIN_URL <LOGIN_URL>` 。"

msgid ""
"When :attr:`raise_exception` is ``True``, this method can be used to control "
"the error message passed to the error handler for display to the user. "
"Returns the :attr:`permission_denied_message` attribute by default."
msgstr ""
"当 :attr:`raise_exception` 为 ``True`` 时，这个方法可以控制传递给错误处理程序"
"的错误信息，以便显示给用户。默认返回 :attr:`permission_denied_message` 属性。"

msgid ""
"Returns the name of the query parameter that will contain the URL the user "
"should be redirected to after a successful login. If you set this to "
"``None``, a query parameter won't be added. Returns the :attr:"
"`redirect_field_name` attribute by default."
msgstr ""
"返回查询参数名，包含用户登录成功后重定向的 URL 。如果这个值设置为 ``None`` ，"
"将不会添加查询参数。默认返回 :attr:`redirect_field_name` 属性。"

msgid ""
"Depending on the value of ``raise_exception``, the method either raises a :"
"exc:`~django.core.exceptions.PermissionDenied` exception or redirects the "
"user to the ``login_url``, optionally including the ``redirect_field_name`` "
"if it is set."
msgstr ""
"根据 ``raise_exception`` 的值，这个方法将会引发 :exc:`~django.core."
"exceptions.PermissionDenied` 异常或重定向用户至 ``login_url`` ，如果已设置，"
"则可选地包含 ``redirect_field_name`` 。"

msgid "Session invalidation on password change"
msgstr "密码更改时会话失效"

msgid ""
"If your :setting:`AUTH_USER_MODEL` inherits from :class:`~django.contrib."
"auth.models.AbstractBaseUser` or implements its own :meth:`~django.contrib."
"auth.models.AbstractBaseUser.get_session_auth_hash()` method, authenticated "
"sessions will include the hash returned by this function. In the :class:"
"`~django.contrib.auth.models.AbstractBaseUser` case, this is an HMAC of the "
"password field. Django verifies that the hash in the session for each "
"request matches the one that's computed during the request. This allows a "
"user to log out all of their sessions by changing their password."
msgstr ""
"如果 :setting:`AUTH_USER_MODEL` 继承自 :class:`~django.contrib.auth.models."
"AbstractBaseUser` 或实现了自己的 :meth:`~django.contrib.auth.models."
"AbstractBaseUser.get_session_auth_hash()` 方法，已验证的会话将包含这个函数返"
"回的哈希值。在 :class:`~django.contrib.auth.models.AbstractBaseUser` 的情况"
"下，这是密码字段的 HMAC 。Django 验证每个请求的会话中的哈希是否与请求期间计算"
"的哈希相匹配。这允许用户修改密码来注销所有会话。"

msgid ""
"The default password change views included with Django, :class:`~django."
"contrib.auth.views.PasswordChangeView` and the ``user_change_password`` view "
"in the :mod:`django.contrib.auth` admin, update the session with the new "
"password hash so that a user changing their own password won't log "
"themselves out. If you have a custom password change view and wish to have "
"similar behavior, use the :func:`update_session_auth_hash` function."
msgstr ""
"Django 包含默认的密码修改视图，:class:`~django.contrib.auth.views."
"PasswordChangeView` 和 ``user_change_password`` 视图在 :mod:`django.contrib."
"auth` admin 中，将使用新密码的哈希更新会话，因此用户修改密码后不会被注销。如"
"果你有自定义的密码修改视图，并期望有同样的行为，可以使用 :func:"
"`update_session_auth_hash` 函数。"

msgid ""
"This function takes the current request and the updated user object from "
"which the new session hash will be derived and updates the session hash "
"appropriately. It also rotates the session key so that a stolen session "
"cookie will be invalidated."
msgstr ""
"这个函数接受当前请求和从新会话哈希派生时更新的用户对象，并会更新哈希值。它也"
"会替换哈希值因此被盗用的会话cookie会无效。"

msgid "Example usage::"
msgstr "用法示例："

msgid ""
"Since :meth:`~django.contrib.auth.models.AbstractBaseUser."
"get_session_auth_hash()` is based on :setting:`SECRET_KEY`, updating your "
"site to use a new secret will invalidate all existing sessions."
msgstr ""
"因为 :meth:`~django.contrib.auth.models.AbstractBaseUser."
"get_session_auth_hash()` 是基于 :setting:`SECRET_KEY` 的，因此更新站点以使用"
"密钥将会导致所有存在的会话失效。"

msgid "Authentication Views"
msgstr "验证视图"

msgid ""
"Django provides several views that you can use for handling login, logout, "
"and password management. These make use of the :ref:`stock auth forms <built-"
"in-auth-forms>` but you can pass in your own forms as well."
msgstr ""
"Django 提供许多可以用来处理登录、注销和密码管理的视图。这些利用了  :ref:"
"`stock auth forms <built-in-auth-forms>` ，但你也可以使用自己的表单。"

msgid ""
"Django provides no default template for the authentication views. You should "
"create your own templates for the views you want to use. The template "
"context is documented in each view, see :ref:`all-authentication-views`."
msgstr ""
"Django 没有为验证视图提供默认模板。你可以为你打算使用的视图创建自己的模板。每"
"个视图都记录了模板上下文，详情查看 :ref:`all-authentication-views` 。"

msgid "Using the views"
msgstr "使用视图"

msgid ""
"There are different methods to implement these views in your project. The "
"easiest way is to include the provided URLconf in ``django.contrib.auth."
"urls`` in your own URLconf, for example::"
msgstr ""
"在项目中可以使用不同方法来实现这些视图。最简单的方法就是在 URLconf 中包含  "
"``django.contrib.auth.urls`` 提供的 URLconf 。举例："

msgid "This will include the following URL patterns::"
msgstr "这将包含以下 URL 模式："

msgid ""
"The views provide a URL name for easier reference. See :doc:`the URL "
"documentation </topics/http/urls>` for details on using named URL patterns."
msgstr ""
"视图提供 URL 名称以便参考。有关使用命名 URL 模式的使用详情参考 :doc:`the URL "
"documentation </topics/http/urls>` 。"

msgid ""
"If you want more control over your URLs, you can reference a specific view "
"in your URLconf::"
msgstr "如果你想更好的控制 URL ，你可以在你的 URLconf 中引用特定的视图："

msgid ""
"The views have optional arguments you can use to alter the behavior of the "
"view. For example, if you want to change the template name a view uses, you "
"can provide the ``template_name`` argument. A way to do this is to provide "
"keyword arguments in the URLconf, these will be passed on to the view. For "
"example::"
msgstr ""
"这个视图具有更改视图行为的可选参数。例如，如果你想改变视图使用的模板名称，你"
"可以提供 ``template_name`` 参数。在 URLconf 中提供关键字参数，这些参数将被传"
"递给视图。举例："

msgid ""
"All views are :doc:`class-based </topics/class-based-views/index>`, which "
"allows you to easily customize them by subclassing."
msgstr "所有视图都是基于类的，这就允许你通过子类去方便地自定义它们。"

msgid "All authentication views"
msgstr "所有的验证视图"

msgid ""
"This is a list with all the views ``django.contrib.auth`` provides. For "
"implementation details see :ref:`using-the-views`."
msgstr ""
"这是一个 ``django.contrib.auth`` 提供的所有视图列表。有关实现细节可参考 :ref:"
"`using-the-views` 。"

msgid "**URL name:** ``login``"
msgstr "**URL name:** ``login``"

msgid ""
"See :doc:`the URL documentation </topics/http/urls>` for details on using "
"named URL patterns."
msgstr ""
"有关使用命名 URL 模式的细节可参考 :doc:`the URL documentation </topics/http/"
"urls>` 。"

msgid "**Methods and Attributes**"
msgstr "**方法和属性*"

msgid ""
"The name of a template to display for the view used to log the user in. "
"Defaults to :file:`registration/login.html`."
msgstr ""

msgid ""
"The URL to redirect to after login. Defaults to :setting:"
"`LOGIN_REDIRECT_URL`."
msgstr ""

msgid ""
"The name of a ``GET`` field containing the URL to redirect to after login. "
"Defaults to ``next``. Overrides the :meth:`get_default_redirect_url` URL if "
"the given ``GET`` parameter is passed."
msgstr ""

msgid ""
"A callable (typically a form class) to use for authentication. Defaults to :"
"class:`~django.contrib.auth.forms.AuthenticationForm`."
msgstr ""

msgid ""
"A dictionary of context data that will be added to the default context data "
"passed to the template."
msgstr ""

msgid ""
"A boolean that controls whether or not authenticated users accessing the "
"login page will be redirected as if they had just successfully logged in. "
"Defaults to ``False``."
msgstr ""

msgid ""
"If you enable ``redirect_authenticated_user``, other websites will be able "
"to determine if their visitors are authenticated on your site by requesting "
"redirect URLs to image files on your website. To avoid this \"`social media "
"fingerprinting <https://robinlinus.github.io/socialmedia-leak/>`_\" "
"information leakage, host all images and your favicon on a separate domain."
msgstr ""
"如果你启用了 ``redirect_authenticated_user`` ，其他网站通过重定向请求你的网站"
"的图片文件的方式来确定他们的访客是否是你网站的已验证用户。为了避免这个 "
"\"`social media fingerprinting <https://robinlinus.github.io/socialmedia-"
"leak/>`_\" 信息泄露，请将所有图片和 favicon 都托管在单独的域名中。"

msgid ""
"Enabling ``redirect_authenticated_user`` can also result in a redirect loop "
"when using the :func:`.permission_required` decorator unless the "
"``raise_exception`` parameter is used."
msgstr ""
"启用 ``redirect_authenticated_user`` 也会在使用 :func:`.permission_required` "
"装饰器的时候，导致重定向循环，除非 ``raise_exception`` 参数被使用。"

msgid ""
"A :class:`set` of hosts, in addition to :meth:`request.get_host() <django."
"http.HttpRequest.get_host>`, that are safe for redirecting after login. "
"Defaults to an empty :class:`set`."
msgstr ""

msgid ""
"Returns the URL to redirect to after login. The default implementation "
"resolves and returns :attr:`next_page` if set, or :setting:"
"`LOGIN_REDIRECT_URL` otherwise."
msgstr ""

msgid "Here's what ``LoginView`` does:"
msgstr "``LoginView`` 能做什么："

msgid ""
"If called via ``GET``, it displays a login form that POSTs to the same URL. "
"More on this in a bit."
msgstr ""
"如果通过 ``GET`` 调用，它将显示 POST 到同一 URL 地址的登录表单。稍后会详细介"
"绍。"

msgid ""
"If called via ``POST`` with user submitted credentials, it tries to log the "
"user in. If login is successful, the view redirects to the URL specified in "
"``next``. If ``next`` isn't provided, it redirects to :setting:`settings."
"LOGIN_REDIRECT_URL <LOGIN_REDIRECT_URL>` (which defaults to ``/accounts/"
"profile/``). If login isn't successful, it redisplays the login form."
msgstr ""
"如果用户提交的数据通过 ``POST`` 调用，那它将试着让用户登录。如果登录成功，那"
"么视图将重定向到 ``next`` 指定的 URL 。如果没有提供 ``next`` ，它将重定向到 :"
"setting:`settings.LOGIN_REDIRECT_URL <LOGIN_REDIRECT_URL>` （默认 ``/"
"accounts/profile/`` ）。如果登录没有成功，它将重新显示登录表单。"

msgid ""
"It's your responsibility to provide the html for the login template , called "
"``registration/login.html`` by default. This template gets passed four "
"template context variables:"
msgstr ""
"你需要提供登录模板，默认调用 ``registration/login.html`` 。这个模板传递四个模"
"板上下文变量："

msgid ""
"``form``: A :class:`~django.forms.Form` object representing the :class:"
"`~django.contrib.auth.forms.AuthenticationForm`."
msgstr ""
"``form`` ：一个代表 :class:`~django.contrib.auth.forms.AuthenticationForm` "
"的 :class:`~django.forms.Form` 对象。"

msgid ""
"``next``: The URL to redirect to after successful login. This may contain a "
"query string, too."
msgstr "``next`` ：登录成功后跳转的网址。这可能包含查询字段。"

msgid ""
"``site``: The current :class:`~django.contrib.sites.models.Site`, according "
"to the :setting:`SITE_ID` setting. If you don't have the site framework "
"installed, this will be set to an instance of :class:`~django.contrib.sites."
"requests.RequestSite`, which derives the site name and domain from the "
"current :class:`~django.http.HttpRequest`."
msgstr ""
"``site`` ：根据 :setting:`SITE_ID` 设置的当前站点。如果你还没有安装站点框架，"
"会将其设置为 :class:`~django.contrib.sites.requests.RequestSite` 实例，该实例"
"从当前 :class:`~django.http.HttpRequest` 中派生出站点名和域名。"

msgid ""
"``site_name``: An alias for ``site.name``. If you don't have the site "
"framework installed, this will be set to the value of :attr:`request."
"META['SERVER_NAME'] <django.http.HttpRequest.META>`. For more on sites, see :"
"doc:`/ref/contrib/sites`."
msgstr ""
"``site_name`` ：``site.name`` 的别名。如果你还没有按照站点框架，它将设置为 :"
"attr:`request.META['SERVER_NAME'] <django.http.HttpRequest.META>` 的值。更多"
"关于站点信息，请参考 :doc:`/ref/contrib/sites` 。"

msgid ""
"If you'd prefer not to call the template :file:`registration/login.html`, "
"you can pass the ``template_name`` parameter via the extra arguments to the "
"``as_view`` method in your URLconf. For example, this URLconf line would "
"use :file:`myapp/login.html` instead::"
msgstr ""
"如果你不愿意调用模板 :file:`registration/login.html` ，你可以通过附加参数的形"
"式传递 ``template_name`` 参数给你的 URLconf 中的 ``as_view`` 方法。比如，这"
"行 URLconf 将使用 :file:`myapp/login.html` 代替："

msgid ""
"You can also specify the name of the ``GET`` field which contains the URL to "
"redirect to after login using ``redirect_field_name``. By default, the field "
"is called ``next``."
msgstr ""
"你也可以使用 ``redirect_field_name`` 指定 ``GET`` 字段的名称，这个字段包含登"
"陆后跳转的 URL 地址。默认情况下，这个字段为 ``next`` 。"

msgid ""
"Here's a sample :file:`registration/login.html` template you can use as a "
"starting point. It assumes you have a :file:`base.html` template that "
"defines a ``content`` block:"
msgstr ""
"下面是一个简单的 :file:`registration/login.html` 模板。它假设你有 :file:"
"`base.html` 模板，并且已经定义了 ``content`` 块："

msgid ""
"If you have customized authentication (see :doc:`Customizing Authentication "
"</topics/auth/customizing>`) you can use a custom authentication form by "
"setting the ``authentication_form`` attribute. This form must accept a "
"``request`` keyword argument in its ``__init__()`` method and provide a "
"``get_user()`` method which returns the authenticated user object (this "
"method is only ever called after successful form validation)."
msgstr ""
"如果你具有自定义身份验证（查看 :doc:`Customizing Authentication </topics/"
"auth/customizing>` ），可以通过设置 ``authentication_form`` 属性来使用自定义"
"的验证码模板。此表单必须在它的 ``__init__()`` 方法中接受 ``request`` 关键字参"
"数，并且提供一个返回已验证用户对象的 ``get_user()`` 方法（这个方法只会在表单"
"成功验证后调用）。"

msgid "Logs a user out."
msgstr "注销用户"

msgid "**URL name:** ``logout``"
msgstr "**URL name:** ``logout``"

msgid "**Attributes:**"
msgstr "属性："

msgid ""
"The URL to redirect to after logout. Defaults to :setting:"
"`LOGOUT_REDIRECT_URL`."
msgstr ""

msgid ""
"The full name of a template to display after logging the user out. Defaults "
"to :file:`registration/logged_out.html`."
msgstr ""

msgid ""
"The name of a ``GET`` field containing the URL to redirect to after log out. "
"Defaults to ``'next'``. Overrides the :attr:`next_page` URL if the given "
"``GET`` parameter is passed."
msgstr ""

msgid ""
"A :class:`set` of hosts, in addition to :meth:`request.get_host() <django."
"http.HttpRequest.get_host>`, that are safe for redirecting after logout. "
"Defaults to an empty :class:`set`."
msgstr ""

msgid "**Template context:**"
msgstr "**Template context:**"

msgid "``title``: The string \"Logged out\", localized."
msgstr "``title`` ：字符串 \"已注销\"，已本地化。"

msgid "Logs a user out, then redirects to the login page."
msgstr "用户注销，然后重定向到登录页面。"

msgid "**URL name:** No default URL provided"
msgstr "**URL name:** 没有提供默认的 URL "

msgid "**Optional arguments:**"
msgstr "可选参数："

msgid ""
"``login_url``: The URL of the login page to redirect to. Defaults to :"
"setting:`settings.LOGIN_URL <LOGIN_URL>` if not supplied."
msgstr ""
"``login_url`` ：要重定向到登录页面的 URL 。如果没有提供，默认是 :setting:"
"`settings.LOGIN_URL <LOGIN_URL>` 。"

msgid "**URL name:** ``password_change``"
msgstr "**URL name:** ``password_change``"

msgid "Allows a user to change their password."
msgstr "允许用户修改密码。"

msgid ""
"The full name of a template to use for displaying the password change form. "
"Defaults to :file:`registration/password_change_form.html` if not supplied."
msgstr ""

msgid ""
"The URL to redirect to after a successful password change. Defaults to "
"``'password_change_done'``."
msgstr ""

msgid ""
"A custom \"change password\" form which must accept a ``user`` keyword "
"argument. The form is responsible for actually changing the user's password. "
"Defaults to :class:`~django.contrib.auth.forms.PasswordChangeForm`."
msgstr ""

msgid "``form``: The password change form (see ``form_class`` above)."
msgstr "``form`` ：密码修改表单（参考上面的 ``form_class`` ）"

msgid "**URL name:** ``password_change_done``"
msgstr "**URL name:** ``password_change_done``"

msgid "The page shown after a user has changed their password."
msgstr "用户修改密码之后显示的页面。"

msgid ""
"The full name of a template to use. Defaults to :file:`registration/"
"password_change_done.html` if not supplied."
msgstr ""

msgid "**URL name:** ``password_reset``"
msgstr "**URL name:** ``password_reset``"

msgid ""
"Allows a user to reset their password by generating a one-time use link that "
"can be used to reset the password, and sending that link to the user's "
"registered email address."
msgstr ""
"允许用户通过生成的一次性链接来重置密码，并把一次性链接发到用户注册邮箱中。"

msgid "This view will send an email if the following conditions are met:"
msgstr ""

msgid "The email address provided exists in the system."
msgstr ""

msgid "The requested user is active (``User.is_active`` is ``True``)."
msgstr ""

msgid ""
"The requested user has a usable password. Users flagged with an unusable "
"password (see :meth:`~django.contrib.auth.models.User."
"set_unusable_password`) aren't allowed to request a password reset to "
"prevent misuse when using an external authentication source like LDAP."
msgstr ""

msgid ""
"If any of these conditions are *not* met, no email will be sent, but the "
"user won't receive any error message either. This prevents information "
"leaking to potential attackers. If you want to provide an error message in "
"this case, you can subclass :class:`~django.contrib.auth.forms."
"PasswordResetForm` and use the ``form_class`` attribute."
msgstr ""

msgid ""
"Be aware that sending an email costs extra time, hence you may be vulnerable "
"to an email address enumeration timing attack due to a difference between "
"the duration of a reset request for an existing email address and the "
"duration of a reset request for a nonexistent email address. To reduce the "
"overhead, you can use a 3rd party package that allows to send emails "
"asynchronously, e.g. `django-mailer <https://pypi.org/project/django-mailer/"
">`_."
msgstr ""
"注意，发送邮件需要花费额外时间，因此，由于对现有电子邮件地址的重置请求的持续"
"时间与对不存在的电子邮件地址的重置请求的持续时间不同，你可能容易受到电子邮件"
"地址枚举定时攻击。为了降低开销，你可以使用第三方插件来允许异步发送邮件，例如 "
"`django-mailer <https://pypi.org/project/django-mailer/>`_"

msgid ""
"The full name of a template to use for displaying the password reset form. "
"Defaults to :file:`registration/password_reset_form.html` if not supplied."
msgstr ""

msgid ""
"Form that will be used to get the email of the user to reset the password "
"for. Defaults to :class:`~django.contrib.auth.forms.PasswordResetForm`."
msgstr ""

msgid ""
"The full name of a template to use for generating the email with the reset "
"password link. Defaults to :file:`registration/password_reset_email.html` if "
"not supplied."
msgstr ""

msgid ""
"The full name of a template to use for the subject of the email with the "
"reset password link. Defaults to :file:`registration/password_reset_subject."
"txt` if not supplied."
msgstr ""

msgid ""
"Instance of the class to check the one time link. This will default to "
"``default_token_generator``, it's an instance of ``django.contrib.auth."
"tokens.PasswordResetTokenGenerator``."
msgstr ""

msgid ""
"The URL to redirect to after a successful password reset request. Defaults "
"to ``'password_reset_done'``."
msgstr ""

msgid ""
"A valid email address. By default Django uses the :setting:"
"`DEFAULT_FROM_EMAIL`."
msgstr ""

msgid ""
"The full name of a template to use for generating a :mimetype:`text/html` "
"multipart email with the password reset link. By default, HTML email is not "
"sent."
msgstr ""

msgid ""
"A dictionary of context data that will be available in the email template. "
"It can be used to override default template context values listed below e.g. "
"``domain``."
msgstr ""

msgid ""
"``form``: The form (see ``form_class`` above) for resetting the user's "
"password."
msgstr "``form`` ：重置用户密码的表单（可参考上面的 ``form_class`` ）。"

msgid "**Email template context:**"
msgstr "**电子邮件模板上下文:**"

msgid "``email``: An alias for ``user.email``"
msgstr "``email`` ：``user.email`` 的别名。"

msgid ""
"``user``: The current :class:`~django.contrib.auth.models.User`, according "
"to the ``email`` form field. Only active users are able to reset their "
"passwords (``User.is_active is True``)."
msgstr ""
"``user`` ：根据电子邮件表单字段指定的当前用户。只有活动用户才可以重置密码"
"（ ``User.is_active 为 True`` ）。"

msgid ""
"``domain``: An alias for ``site.domain``. If you don't have the site "
"framework installed, this will be set to the value of ``request.get_host()``."
msgstr ""
"``domain`` ：``site.domain`` 的别名。如果你还没有安装网站框架，它会被设置为 "
"``request.get_host()`` 的值。"

msgid "``protocol``: http or https"
msgstr "``protocol`` ：http 或 https"

msgid "``uid``: The user's primary key encoded in base 64."
msgstr "``uid`` ：使用 Base64 编码过的用户主键。"

msgid "``token``: Token to check that the reset link is valid."
msgstr "``token`` ：检测重置密码链接是否有效的 Token 。"

msgid ""
"Sample ``registration/password_reset_email.html`` (email body template):"
msgstr "``registration/password_reset_email.html`` 例子（电子邮件内容模板）"

msgid ""
"The same template context is used for subject template. Subject must be "
"single line plain text string."
msgstr "相同的模板上下文用于主题模板。主题必须是单行纯文本字符串。"

msgid "**URL name:** ``password_reset_done``"
msgstr "**URL name:** ``password_reset_done``"

msgid ""
"The page shown after a user has been emailed a link to reset their password. "
"This view is called by default if the :class:`PasswordResetView` doesn't "
"have an explicit ``success_url`` URL set."
msgstr ""
"发送重置密码邮件后显示的页面。如果 :class:`PasswordResetView` 没有明确设置 "
"``success_url`` ，那么默认将该视图调用。"

msgid ""
"If the email address provided does not exist in the system, the user is "
"inactive, or has an unusable password, the user will still be redirected to "
"this view but no email will be sent."
msgstr ""
"如果提供的电子邮件地址在系统内并不存在，那么用户可能是非活动用户，或者密码不"
"可被更改。用户仍然会重定向到这个视图，但不会发送邮件。"

msgid ""
"The full name of a template to use. Defaults to :file:`registration/"
"password_reset_done.html` if not supplied."
msgstr ""

msgid "**URL name:** ``password_reset_confirm``"
msgstr "**URL name:** ``password_reset_confirm``"

msgid "Presents a form for entering a new password."
msgstr "提供输入新密码的表单。"

msgid "**Keyword arguments from the URL:**"
msgstr "URL 的关键参数"

msgid "``uidb64``: The user's id encoded in base 64."
msgstr "``uidb64`` ：被Base64编码过的用户 id。"

msgid "``token``: Token to check that the password is valid."
msgstr "``token`` ：检查密码是否有效的 Token。"

msgid ""
"The full name of a template to display the confirm password view. Default "
"value is :file:`registration/password_reset_confirm.html`."
msgstr ""

msgid ""
"Instance of the class to check the password. This will default to "
"``default_token_generator``, it's an instance of ``django.contrib.auth."
"tokens.PasswordResetTokenGenerator``."
msgstr ""

msgid ""
"A boolean indicating if the user should be automatically authenticated after "
"a successful password reset. Defaults to ``False``."
msgstr ""

msgid ""
"A dotted path to the authentication backend to use when authenticating a "
"user if ``post_reset_login`` is ``True``. Required only if you have "
"multiple :setting:`AUTHENTICATION_BACKENDS` configured. Defaults to ``None``."
msgstr ""

msgid ""
"Form that will be used to set the password. Defaults to :class:`~django."
"contrib.auth.forms.SetPasswordForm`."
msgstr ""

msgid ""
"URL to redirect after the password reset done. Defaults to "
"``'password_reset_complete'``."
msgstr ""

msgid ""
"Token parameter displayed as a component of password reset URLs. Defaults to "
"``'set-password'``."
msgstr ""

msgid ""
"``form``: The form (see ``form_class`` above) for setting the new user's "
"password."
msgstr "``form`` ：用来设置用户新密码的表单（查看上面的 ``form_class`` ）。"

msgid ""
"``validlink``: Boolean, True if the link (combination of ``uidb64`` and "
"``token``) is valid or unused yet."
msgstr ""
"``validlink`` ：布尔值，如果链接（``uidb64`` 和 ``token`` 的组合）有效且合"
"法，则返回 True 。"

msgid "**URL name:** ``password_reset_complete``"
msgstr "**URL name:** ``password_reset_complete``"

msgid ""
"Presents a view which informs the user that the password has been "
"successfully changed."
msgstr "当密码已经被修改成功后通知用户的视图。"

msgid ""
"The full name of a template to display the view. Defaults to :file:"
"`registration/password_reset_complete.html`."
msgstr ""

msgid "Helper functions"
msgstr "辅助函数"

msgid ""
"Redirects to the login page, and then back to another URL after a successful "
"login."
msgstr "重定向到登录页面，登陆成功后跳转到其他 URL 。"

msgid "**Required arguments:**"
msgstr "**必要参数**"

msgid "``next``: The URL to redirect to after a successful login."
msgstr "``next`` ：成功登陆后跳转的 URL。"

msgid ""
"``redirect_field_name``: The name of a ``GET`` field containing the URL to "
"redirect to after log out. Overrides ``next`` if the given ``GET`` parameter "
"is passed."
msgstr ""
"``redirect_field_name`` ：注销后跳转的 URL 所包含的 ``GET`` 字段名称。如果已"
"传递给定的 ``GET`` 参数，则覆盖 ``next`` 。"

msgid "Built-in forms"
msgstr "内置表单"

msgid ""
"If you don't want to use the built-in views, but want the convenience of not "
"having to write forms for this functionality, the authentication system "
"provides several built-in forms located in :mod:`django.contrib.auth.forms`:"
msgstr ""
"如果你不想使用内置视图，但希望不必为此功能编写表单，验证系统提供很多在 :mod:"
"`django.contrib.auth.forms` 中的内置表单。"

msgid ""
"The built-in authentication forms make certain assumptions about the user "
"model that they are working with. If you're using a :ref:`custom user model "
"<auth-custom-user>`, it may be necessary to define your own forms for the "
"authentication system. For more information, refer to the documentation "
"about :ref:`using the built-in authentication forms with custom user models "
"<custom-users-and-the-built-in-auth-forms>`."
msgstr ""
"内置验证表单对用户正在使用的的用户模型做了某些假设。如果你正在使用 :ref:"
"`custom user model ` ，它可能需要为验证系统定义你自己的表单。如需了解更多信"
"息，参考文档 :ref:`using the built-in authentication forms with custom user "
"models <custom-users-and-the-built-in-auth-forms>` 。"

msgid "A form used in the admin interface to change a user's password."
msgstr "在管理界面修改用户密码所使用的表单。"

msgid "Takes the ``user`` as the first positional argument."
msgstr "将 ``user`` 作为第一个参数。"

msgid "A form for logging a user in."
msgstr "用户登录的表单。"

msgid ""
"Takes ``request`` as its first positional argument, which is stored on the "
"form instance for use by sub-classes."
msgstr "将 ``request`` 作为第一个参数，该参数存储在表单实例上，供子类使用。"

msgid ""
"By default, ``AuthenticationForm`` rejects users whose ``is_active`` flag is "
"set to ``False``. You may override this behavior with a custom policy to "
"determine which users can log in. Do this with a custom form that subclasses "
"``AuthenticationForm`` and overrides the ``confirm_login_allowed()`` method. "
"This method should raise a :exc:`~django.core.exceptions.ValidationError` if "
"the given user may not log in."
msgstr ""
"默认情况下，``AuthenticationForm`` 拒绝  ``is_active`` 标识为 ``False`` 的用"
"户。你可以通过自定义策略来覆盖这个行为来决定哪个用户可以登录。通过"
"``AuthenticationForm`` 子类的自定义表单来执行这个操作，并覆盖 "
"``confirm_login_allowed()`` 方法。如果给定的用户无法登录，这个方法应该引发 :"
"exc:`~django.core.exceptions.ValidationError` 错误。"

msgid ""
"For example, to allow all users to log in regardless of \"active\" status::"
msgstr "举例，允许所有用户登录而不管 \"active\" 状态："

msgid ""
"(In this case, you'll also need to use an authentication backend that allows "
"inactive users, such as :class:`~django.contrib.auth.backends."
"AllowAllUsersModelBackend`.)"
msgstr ""
"（在这个例子中，你将需要使用一个允许非活动用户的验证后端，比如 :class:"
"`~django.contrib.auth.backends.AllowAllUsersModelBackend` 。）"

msgid "Or to allow only some active users to log in::"
msgstr "或者只允许一些活动用户登录："

msgid "A form for allowing a user to change their password."
msgstr "允许用户修改密码的表单:"

msgid ""
"A form for generating and emailing a one-time use link to reset a user's "
"password."
msgstr "生成和邮件发送一次性重置密码链接的表单。"

msgid ""
"Uses the arguments to send an ``EmailMultiAlternatives``. Can be overridden "
"to customize how the email is sent to the user."
msgstr ""
"使用参数发送 ``EmailMultiAlternatives``。可以重写自定义邮件发送给用户的方式。"

msgid "Parameters"
msgstr "参数"

msgid "the template for the subject."
msgstr "主题模板"

msgid "the template for the email body."
msgstr "邮件主体模板"

msgid ""
"context passed to the ``subject_template``, ``email_template``, and "
"``html_email_template`` (if it is not ``None``)."
msgstr ""
"上下文传递至 ``subject_template``, ``email_template``, 和 "
"``html_email_template`` （如果它非空）。"

msgid "the sender's email."
msgstr "发送方的邮箱地址。"

msgid "the email of the requester."
msgstr "接收方的邮箱地址。"

msgid ""
"the template for the HTML body; defaults to ``None``, in which case a plain "
"text email is sent."
msgstr "HTML 正文模板；默认是 ``None``，在这种情况下发送纯文本邮件。"

msgid ""
"By default, ``save()`` populates the ``context`` with the same variables "
"that :class:`~django.contrib.auth.views.PasswordResetView` passes to its "
"email context."
msgstr ""
"默认情况下，``save()`` 使用 :class:`~django.contrib.auth.views."
"PasswordResetView` 传递给其电子邮件上下文的相同变量填充上下文。"

msgid ""
"A form that lets a user change their password without entering the old "
"password."
msgstr "让用户不输入旧密码就能改变它们密码的表单。"

msgid ""
"A form used in the admin interface to change a user's information and "
"permissions."
msgstr "在管理界面修改用户信息和权限的表单。"

msgid "A :class:`~django.forms.ModelForm` for creating a new user."
msgstr "建立新用户的 :class:`~django.forms.ModelForm` 。"

msgid ""
"It has three fields: ``username`` (from the user model), ``password1``, and "
"``password2``. It verifies that ``password1`` and ``password2`` match, "
"validates the password using :func:`~django.contrib.auth.password_validation."
"validate_password`, and sets the user's password using :meth:`~django."
"contrib.auth.models.User.set_password()`."
msgstr ""
"它有三个字段： ``username`` （来自用户模型），``password1`` ，和 "
"``password2`` 。它检查 ``password1`` 和 ``password2`` 是否匹配，使用 :func:"
"`~django.contrib.auth.password_validation.validate_password` 验证密码，并且使"
"用 :meth:`~django.contrib.auth.models.User.set_password()` 来设置用户密码。"

msgid "Authentication data in templates"
msgstr "模板内验证数据"

msgid ""
"The currently logged-in user and their permissions are made available in "
"the :doc:`template context </ref/templates/api>` when you use :class:"
"`~django.template.RequestContext`."
msgstr ""
"当你使用 :class:`~django.template.RequestContext` 时，当前已登录用户和他们的"
"权限在 :doc:`template context ` 中是可用的。"

msgid "Technicality"
msgstr "技术细节"

msgid ""
"Technically, these variables are only made available in the template context "
"if you use :class:`~django.template.RequestContext` and the ``'django."
"contrib.auth.context_processors.auth'`` context processor is enabled. It is "
"in the default generated settings file. For more, see the :ref:"
"`RequestContext docs <subclassing-context-requestcontext>`."
msgstr ""
"从技术上讲，如果你使用 :class:`~django.template.RequestContext` ，这些变量只"
"在模板上下文中可用，并且已启用 ``'django.contrib.auth.context_processors."
"auth'`` 处理机。它默认产生配置文件。了解更多，可以查看 :ref:`RequestContext "
"docs <subclassing-context-requestcontext>` 。"

msgid "Users"
msgstr "用户"

msgid ""
"When rendering a template :class:`~django.template.RequestContext`, the "
"currently logged-in user, either a  :class:`~django.contrib.auth.models."
"User` instance or an :class:`~django.contrib.auth.models.AnonymousUser` "
"instance, is stored in the template variable ``{{ user }}``:"
msgstr ""
"当渲染模板 :class:`~django.template.RequestContext` ，当前登录用户（:class:"
"`~django.contrib.auth.models.User` 实例或 :class:`~django.contrib.auth."
"models.AnonymousUser` 实例）被保存在模板变量 ``{{ user }}`` 中："

msgid ""
"This template context variable is not available if a ``RequestContext`` is "
"not being used."
msgstr "如果没有使用 ``RequestContext`` ，那么这个模板上下文变量将不可用。"

msgid "Permissions"
msgstr "权限"

msgid ""
"The currently logged-in user's permissions are stored in the template "
"variable ``{{ perms }}``. This is an instance of ``django.contrib.auth."
"context_processors.PermWrapper``, which is a template-friendly proxy of "
"permissions."
msgstr ""
"当前登录用户的权限保存在模板变量 ``{{ perms }}`` 中。这是 ``django.contrib."
"auth.context_processors.PermWrapper`` 的一个实例，它是一个对模板友好的权限代"
"理。"

msgid ""
"Evaluating a single-attribute lookup of ``{{ perms }}`` as a boolean is a "
"proxy to :meth:`User.has_module_perms() <django.contrib.auth.models.User."
"has_module_perms>`. For example, to check if the logged-in user has any "
"permissions in the ``foo`` app::"
msgstr ""
"将 ``{{ perms }}`` 的单属性查找作为布尔值为 :meth:`User.has_module_perms() "
"<django.contrib.auth.models.User.has_module_perms>` 的代理。比如，检测登录用"
"户是否拥有一些权限："

msgid ""
"Evaluating a two-level-attribute lookup as a boolean is a proxy to :meth:"
"`User.has_perm() <django.contrib.auth.models.User.has_perm>`. For example, "
"to check if the logged-in user has the permission ``foo.add_vote``::"
msgstr ""
"将两层属性查找作为布尔值是 :meth:`User.has_perm() <django.contrib.auth."
"models.User.has_perm>` 的代理。比如，检测登录用户是否拥有  ``foo.add_vote`` "
"权限："

msgid "Here's a more complete example of checking permissions in a template:"
msgstr "以下是一个在模板中检查权限的更完整的示例："

msgid ""
"It is possible to also look permissions up by ``{% if in %}`` statements. "
"For example:"
msgstr "也可以通过 ``{% if in %}`` 语句来查找权限。比如："

msgid "Managing users in the admin"
msgstr "在管理界面中管理用户"

msgid ""
"When you have both ``django.contrib.admin`` and ``django.contrib.auth`` "
"installed, the admin provides a convenient way to view and manage users, "
"groups, and permissions. Users can be created and deleted like any Django "
"model. Groups can be created, and permissions can be assigned to users or "
"groups. A log of user edits to models made within the admin is also stored "
"and displayed."
msgstr ""
"当安装了 ``django.contrib.admin`` 和 ``django.contrib.auth``，管理后台提供了"
"方便的方法来查看和管理用户、组和权限。用户可以增加和删除任何 Django 模型。可"
"以创建组，也可以为用户和组分配权限。用户操作模型的日志也会在管理后台中保存和"
"显示。"

msgid ""
"You should see a link to \"Users\" in the \"Auth\" section of the main admin "
"index page. The \"Add user\" admin page is different than standard admin "
"pages in that it requires you to choose a username and password before "
"allowing you to edit the rest of the user's fields."
msgstr ""
"你可以在管理后台主页的 “认证和权限” 部分看到 “用户” 链接。“增加用户”的管理界"
"面和其他标准的管理后台不同的是：你需要先输入一个新用户名和新密码，然后才能编"
"辑新用户的剩余字段。"

msgid ""
"Also note: if you want a user account to be able to create users using the "
"Django admin site, you'll need to give them permission to add users *and* "
"change users (i.e., the \"Add user\" and \"Change user\" permissions). If an "
"account has permission to add users but not to change them, that account "
"won't be able to add users. Why? Because if you have permission to add "
"users, you have the power to create superusers, which can then, in turn, "
"change other users. So Django requires add *and* change permissions as a "
"slight security measure."
msgstr ""
"注意：如果你希望某个用户账号可以在 Django 管理后台创建用户，你将需要给用户“创"
"建”和“修改”权限。如果账号只有“创建”权限但没有“修改”权限，那么这个账号将不能增"
"加用户。为什么？因为你有权限添加用户，那么你就拥有添加超级管理员的权利，而超"
"级管理员就可以修改其他用户。因此，Django 需要添加和修改权限作为安全措施。"

msgid ""
"Be thoughtful about how you allow users to manage permissions. If you give a "
"non-superuser the ability to edit users, this is ultimately the same as "
"giving them superuser status because they will be able to elevate "
"permissions of users including themselves!"
msgstr ""
"要考虑如何允许用户去管理权限。如果你允许普通管理员编辑用户，这和给他们超级管"
"理员权限一样。因为他们有权利提升用户权限，包括他们自己。"

msgid ""
"User passwords are not displayed in the admin (nor stored in the database), "
"but the :doc:`password storage details </topics/auth/passwords>` are "
"displayed. Included in the display of this information is a link to a "
"password change form that allows admins to change user passwords."
msgstr ""
"用户密码不显示在管理界面中（也不在数据库中保存），但会显示 :doc:`password "
"storage details </topics/auth/passwords>` 。这个信息中包含一个指向密码修改表"
"单的链接，该表单允许管理员修改用户密码。"

msgid "User authentication in Django"
msgstr "Django中的用户认证"

msgid ""
"Django comes with a user authentication system. It handles user accounts, "
"groups, permissions and cookie-based user sessions. This section of the "
"documentation explains how the default implementation works out of the box, "
"as well as how to :doc:`extend and customize </topics/auth/customizing>` it "
"to suit your project's needs."
msgstr ""
"Django 自带一个用户验证系统。它负责处理用户账号、组、权限和基于cookie的用户会"
"话。文档的这部分解释了默认的实现如何开箱即用，以及如何扩展和自定义以满足你的"
"项目需求。"

msgid "Overview"
msgstr "概况"

msgid ""
"The Django authentication system handles both authentication and "
"authorization. Briefly, authentication verifies a user is who they claim to "
"be, and authorization determines what an authenticated user is allowed to "
"do. Here the term authentication is used to refer to both tasks."
msgstr ""
"Django 验证系统处理验证和授权。简单来说，验证检验用户是否是他们的用户，授权决"
"定已验证用户能做什么。这里的术语验证用于指代这两个任务。"

msgid "The auth system consists of:"
msgstr "认证系统由以下部分组成："

msgid ""
"Permissions: Binary (yes/no) flags designating whether a user may perform a "
"certain task."
msgstr "权限：二进制（是/否）标识指定用户是否可以执行特定任务。"

msgid ""
"Groups: A generic way of applying labels and permissions to more than one "
"user."
msgstr "组：将标签和权限应用于多个用户的一般方法。"

msgid "A configurable password hashing system"
msgstr "可配置的密码哈希化系统"

msgid "Forms and view tools for logging in users, or restricting content"
msgstr "为登录用户或限制内容提供表单和视图工具"

msgid "A pluggable backend system"
msgstr "可插拔的后端系统"

msgid ""
"The authentication system in Django aims to be very generic and doesn't "
"provide some features commonly found in web authentication systems. "
"Solutions for some of these common problems have been implemented in third-"
"party packages:"
msgstr ""
"Django 里的验证系统旨在通用化，不提供一些常见的 web 验证系统的特性。其中一些"
"常见问题的解决方案已在第三方包中实现。"

msgid "Password strength checking"
msgstr "密码强度检查"

msgid "Throttling of login attempts"
msgstr "限制登录尝试"

msgid "Authentication against third-parties (OAuth, for example)"
msgstr "针对第三方的身份验证（例如OAuth）"

msgid "Object-level permissions"
msgstr "对象级权限"

msgid "Installation"
msgstr "安装"

msgid ""
"Authentication support is bundled as a Django contrib module in ``django."
"contrib.auth``. By default, the required configuration is already included "
"in the :file:`settings.py` generated by :djadmin:`django-admin startproject "
"<startproject>`, these consist of two items listed in your :setting:"
"`INSTALLED_APPS` setting:"
msgstr ""
"验证系统被捆绑为 ``django.contrib.auth`` 的 Django contrib 模块。默认情况下，"
"所需的配置以及包含在 :djadmin:`django-admin startproject <startproject>` 生成"
"的 :file:`settings.py` 中，在 :setting:`INSTALLED_APPS` 配置列出了以下两个条"
"目："

msgid ""
"``'django.contrib.auth'`` contains the core of the authentication framework, "
"and its default models."
msgstr "``'django.contrib.auth'`` 包含了验证框架的内核和它的默认模型。"

msgid ""
"``'django.contrib.contenttypes'`` is the Django :doc:`content type system </"
"ref/contrib/contenttypes>`, which allows permissions to be associated with "
"models you create."
msgstr ""
"``'django.contrib.contenttypes'`` 是 Django :doc:`content type system </ref/"
"contrib/contenttypes>` ，允许你创建的模型和权限相关联。"

msgid "and these items in your :setting:`MIDDLEWARE` setting:"
msgstr "这些条目在你的 :setting:`MIDDLEWARE` 设置中："

msgid ""
":class:`~django.contrib.sessions.middleware.SessionMiddleware` manages :doc:"
"`sessions </topics/http/sessions>` across requests."
msgstr ""
":class:`~django.contrib.sessions.middleware.SessionMiddleware` 通过请求管理 :"
"doc:`sessions </topics/http/sessions>` 。"

msgid ""
":class:`~django.contrib.auth.middleware.AuthenticationMiddleware` associates "
"users with requests using sessions."
msgstr ""
":class:`~django.contrib.auth.middleware.AuthenticationMiddleware` 使用会话将"
"用户和请求关联。"

msgid ""
"With these settings in place, running the command ``manage.py migrate`` "
"creates the necessary database tables for auth related models and "
"permissions for any models defined in your installed apps."
msgstr ""
"有了这些设置，运行命令 ``manage.py migrate`` 为auth相关模型创建必要的数据表，"
"并为已安装应用中定义的任何模型创建许可。"

msgid "Usage"
msgstr "用法"

msgid ":doc:`Using Django's default implementation <default>`"
msgstr ":doc:`使用 Django 的默认实现 <default>`"

msgid ":ref:`Working with User objects <user-objects>`"
msgstr ":ref:`使用 User 对象 <user-objects>`"

msgid ":ref:`Permissions and authorization <topic-authorization>`"
msgstr ":ref:`权限和认证 <topic-authorization>`"

msgid ":ref:`Authentication in web requests <auth-web-requests>`"
msgstr ":ref:`请求中的认证 <auth-web-requests>`"

msgid ":ref:`Managing users in the admin <auth-admin>`"
msgstr ":ref:`在管理系统中管理用户 <auth-admin>`"

msgid ":doc:`API reference for the default implementation </ref/contrib/auth>`"
msgstr ":doc:`默认实现的 API 参考 </ref/contrib/auth>`"

msgid ":doc:`Customizing Users and authentication <customizing>`"
msgstr ":doc:`自定义 Users 和认证 <customizing>`"

msgid ":doc:`Password management in Django <passwords>`"
msgstr ":doc:`Django 中的密码管理 <passwords>`"

msgid "Password management in Django"
msgstr "Django中的密码管理"

msgid ""
"Password management is something that should generally not be reinvented "
"unnecessarily, and Django endeavors to provide a secure and flexible set of "
"tools for managing user passwords. This document describes how Django stores "
"passwords, how the storage hashing can be configured, and some utilities to "
"work with hashed passwords."
msgstr ""
"密码管理通常不应该被重新再设计，Django 努力提供了一个安全且灵活的管理用户密码"
"的工具。这篇文档描述了 Django 如何存储密码，如何配置存储哈希，和一些使用哈希"
"密码的工具。"

msgid ""
"Even though users may use strong passwords, attackers might be able to "
"eavesdrop on their connections. Use :ref:`HTTPS <security-recommendation-"
"ssl>` to avoid sending passwords (or any other sensitive data) over plain "
"HTTP connections because they will be vulnerable to password sniffing."
msgstr ""
"即使用户使用了很强壮的密码，攻击者还是可以窃听他们的网络链接。用户使用 :ref:"
"`HTTPS <security-recommendation-ssl>` 可以避免通过纯 HTTP 链接发送密码（或其"
"他一些敏感数据），因为它们很容易被密码嗅探。"

msgid "How Django stores passwords"
msgstr "Django 如何存储密码"

msgid ""
"Django provides a flexible password storage system and uses PBKDF2 by "
"default."
msgstr "Django 提供灵活的密码存储系统，默认使用 PBKDF2。"

msgid ""
"The :attr:`~django.contrib.auth.models.User.password` attribute of a :class:"
"`~django.contrib.auth.models.User` object is a string in this format::"
msgstr ""
":class:`~django.contrib.auth.models.User` 对象的 :attr:`~django.contrib.auth."
"models.User.password` 属性是如下这种格式："

msgid ""
"Those are the components used for storing a User's password, separated by "
"the dollar-sign character and consist of: the hashing algorithm, the number "
"of algorithm iterations (work factor), the random salt, and the resulting "
"password hash.  The algorithm is one of a number of one-way hashing or "
"password storage algorithms Django can use; see below. Iterations describe "
"the number of times the algorithm is run over the hash. Salt is the random "
"seed used and the hash is the result of the one-way function."
msgstr ""
"这些是用来存储用户密码的插件，以美元符号分隔，包括：哈希算法，算法迭代次数"
"（工作因子），随机 Salt 和最终的密码哈希值。该算法是 Django 可以使用的单向哈"
"希或密码存储算法中的一种；见下文。迭代描述了算法在哈希上运行的次数。Salt 是所"
"使用的随机种子，哈希是单向函数的结果。"

msgid ""
"By default, Django uses the PBKDF2_ algorithm with a SHA256 hash, a password "
"stretching mechanism recommended by NIST_. This should be sufficient for "
"most users: it's quite secure, requiring massive amounts of computing time "
"to break."
msgstr ""
"默认情况下，Django 使用带有 SHA256 哈希的 PBKDF2_ 算法，它是 NIST 推荐的密码"
"延展机制。它足够安全，需要大量的运算时间才能破解，这对大部分用户来说足够了。"

msgid ""
"However, depending on your requirements, you may choose a different "
"algorithm, or even use a custom algorithm to match your specific security "
"situation. Again, most users shouldn't need to do this -- if you're not "
"sure, you probably don't.  If you do, please read on:"
msgstr ""
"但是，根据你的需求，你可以选择不同的算法，甚至使用自定义的算法来匹配特定的安"
"全场景。再次强调，大部分用户没必要这么做，如果你不确定的话，很可能并不需要。"
"如果你坚持要做，请继续阅读："

msgid ""
"Django chooses the algorithm to use by consulting the :setting:"
"`PASSWORD_HASHERS` setting. This is a list of hashing algorithm classes that "
"this Django installation supports. The first entry in this list (that is, "
"``settings.PASSWORD_HASHERS[0]``) will be used to store passwords, and all "
"the other entries are valid hashers that can be used to check existing "
"passwords.  This means that if you want to use a different algorithm, you'll "
"need to modify :setting:`PASSWORD_HASHERS` to list your preferred algorithm "
"first in the list."
msgstr ""
"Django 通过查阅 :setting:`PASSWORD_HASHERS` 的设置来选择算法。这是一个 "
"Django 支持的哈希算法类列表，第一个条目（ ``settings.PASSWORD_HASHERS[0]`` ）"
"将被用来存储密码，其他条目都是有效的哈希函数，可用来检测已存密码。这意味着如"
"果你想使用不同算法，你需要修改 :setting:`PASSWORD_HASHERS` ，在列表中首选列出"
"你的算法。"

msgid "The default for :setting:`PASSWORD_HASHERS` is::"
msgstr ":setting:`PASSWORD_HASHERS` 的默认值是："

msgid ""
"This means that Django will use PBKDF2_ to store all passwords but will "
"support checking passwords stored with PBKDF2SHA1, argon2_, and bcrypt_."
msgstr ""
"这意味着 Django 除了使用 PBKDF2 来存储所有密码，也支持使用 PBKDF2SHA1 、"
"argon2 和 bcrypt 来检测已存储的密码。"

msgid ""
"The next few sections describe a couple of common ways advanced users may "
"want to modify this setting."
msgstr "接下来的部分描述了高级用户修改这个配置的几个常见方法。"

msgid "Using Argon2 with Django"
msgstr "在 Django 中使用 Argon2"

msgid ""
"Argon2_ is the winner of the 2015 `Password Hashing Competition`_, a "
"community organized open competition to select a next generation hashing "
"algorithm. It's designed not to be easier to compute on custom hardware than "
"it is to compute on an ordinary CPU."
msgstr ""
"Argon2 是2015年哈希密码竞赛的获胜者，这是一个社区为选择下一代哈希算法而主办的"
"公开竞赛。它被设计成在定制硬件上计算不比在普通CPU上计算更容易。"

msgid ""
"Argon2_ is not the default for Django because it requires a third-party "
"library. The Password Hashing Competition panel, however, recommends "
"immediate use of Argon2 rather than the other algorithms supported by Django."
msgstr ""
"Argon2 并不是 Django 的默认首选，因为它依赖第三方库。尽管哈希密码竞赛主办方建"
"议立即使用 Argon2 ，而不是 Django 提供的其他算法。"

msgid "To use Argon2 as your default storage algorithm, do the following:"
msgstr "使用 Argon2 作为你的默认存储算法，需要以下步骤："

msgid ""
"Install the `argon2-cffi library`_.  This can be done by running ``python -m "
"pip install django[argon2]``, which is equivalent to ``python -m pip install "
"argon2-cffi`` (along with any version requirement from Django's ``setup."
"cfg``)."
msgstr ""
"安装 `argon2-cffi library`_ 库，可通过  ``python -m pip install "
"django[argon2]`` 安装，相当于 ``python -m pip install argon2-cffi`` （以及 "
"Django 的 ``setup.cfg`` 的任何版本要求）。"

msgid ""
"Modify :setting:`PASSWORD_HASHERS` to list ``Argon2PasswordHasher`` first. "
"That is, in your settings file, you'd put::"
msgstr ""
"修改 :setting:`PASSWORD_HASHERS` 配置，把 ``Argon2PasswordHasher`` 放在首位。"
"如下："

msgid ""
"Keep and/or add any entries in this list if you need Django to :ref:`upgrade "
"passwords <password-upgrades>`."
msgstr ""
"如果你需要 Django 升级密码（ :ref:`upgrade passwords <password-"
"upgrades>` ），请保留或添加这个列表中的任何条目。"

msgid "Using ``bcrypt`` with Django"
msgstr "在 Django 中使用 ``bcrypt`` "

msgid ""
"Bcrypt_ is a popular password storage algorithm that's specifically designed "
"for long-term password storage. It's not the default used by Django since it "
"requires the use of third-party libraries, but since many people may want to "
"use it Django supports bcrypt with minimal effort."
msgstr ""
"Bcrypt 是一个非常流行的密码存储算法，尤其是为长期密码存储设计。Django 默认不"
"使用它，因为它需要使用第三方库，但由于很多人想使用它，Django 只需要很少的努力"
"就能支持 bcrypt 。"

msgid "To use Bcrypt as your default storage algorithm, do the following:"
msgstr "使用 Bcrypt 作为你的默认存储算法，需要以下步骤："

msgid ""
"Install the `bcrypt library`_. This can be done by running ``python -m pip "
"install django[bcrypt]``, which is equivalent to ``python -m pip install "
"bcrypt`` (along with any version requirement from Django's ``setup.cfg``)."
msgstr ""
"安装 `bcrypt library`_ 库。通过 ``python -m pip install django[bcrypt]`` 安"
"装，相当于 ``python -m pip install bcrypt`` （以及 Django 的 ``setup.cfg`` 的"
"任何版本要求）。"

msgid ""
"Modify :setting:`PASSWORD_HASHERS` to list ``BCryptSHA256PasswordHasher`` "
"first. That is, in your settings file, you'd put::"
msgstr ""
"修改 :setting:`PASSWORD_HASHERS` 配置，把 ``BCryptSHA256PasswordHasher`` 放在"
"首位。如下："

msgid ""
"That's it -- now your Django install will use Bcrypt as the default storage "
"algorithm."
msgstr "现在 Django 将使用 Bcrypt 作为默认存储算法。"

msgid "Using ``scrypt`` with Django"
msgstr ""

msgid ""
"scrypt_ is similar to PBKDF2 and bcrypt in utilizing a set number of "
"iterations to slow down brute-force attacks. However, because PBKDF2 and "
"bcrypt do not require a lot of memory, attackers with sufficient resources "
"can launch large-scale parallel attacks in order to speed up the attacking "
"process. scrypt_ is specifically designed to use more memory compared to "
"other password-based key derivation functions in order to limit the amount "
"of parallelism an attacker can use, see :rfc:`7914` for more details."
msgstr ""

msgid "To use scrypt_ as your default storage algorithm, do the following:"
msgstr ""

msgid ""
"Modify :setting:`PASSWORD_HASHERS` to list ``ScryptPasswordHasher`` first. "
"That is, in your settings file::"
msgstr ""

msgid "``scrypt`` requires OpenSSL 1.1+."
msgstr ""

msgid "Increasing the salt entropy"
msgstr "增加盐的熵值"

msgid ""
"Most password hashes include a salt along with their password hash in order "
"to protect against rainbow table attacks. The salt itself is a random value "
"which increases the size and thus the cost of the rainbow table and is "
"currently set at 128 bits with the ``salt_entropy`` value in the "
"``BasePasswordHasher``. As computing and storage costs decrease this value "
"should be raised. When implementing your own password hasher you are free to "
"override this value in order to use a desired entropy level for your "
"password hashes. ``salt_entropy`` is measured in bits."
msgstr ""
"大多数密码哈希值包括一个盐，与他们的密码哈希值一起，以防止彩虹表攻击。盐本身"
"是一个随机值，它增加了彩虹表的大小和成本，目前在 ``BasePasswordHasher`` 中的 "
"``salt_entropy`` 值设置为 128 比特。随着计算和存储成本的降低，这个值应该被提"
"高。当实现你自己的密码散列器时，你可以自由地覆盖这个值，以便为你的密码散列器"
"使用一个理想的熵值。``salt_entropy`` 是以比特为单位。"

msgid "Implementation detail"
msgstr "实现细节"

msgid ""
"Due to the method in which salt values are stored the ``salt_entropy`` value "
"is effectively a minimum value. For instance a value of 128 would provide a "
"salt which would actually contain 131 bits of entropy."
msgstr ""
"由于盐值的存储方法，``salt_entropy`` 值实际上是一个最小值。例如，一个 128 的"
"值将提供一个实际包含 131 位熵的盐。"

msgid "Increasing the work factor"
msgstr "增加工作因子"

msgid "PBKDF2 and bcrypt"
msgstr "PBKDF2 和 bcrypt"

msgid ""
"The PBKDF2 and bcrypt algorithms use a number of iterations or rounds of "
"hashing. This deliberately slows down attackers, making attacks against "
"hashed passwords harder. However, as computing power increases, the number "
"of iterations needs to be increased. We've chosen a reasonable default (and "
"will increase it with each release of Django), but you may wish to tune it "
"up or down, depending on your security needs and available processing power. "
"To do so, you'll subclass the appropriate algorithm and override the "
"``iterations`` parameter (use the ``rounds`` parameter when subclassing a "
"bcrypt hasher). For example, to increase the number of iterations used by "
"the default PBKDF2 algorithm:"
msgstr ""

msgid ""
"Create a subclass of ``django.contrib.auth.hashers.PBKDF2PasswordHasher``::"
msgstr "创建 ``django.contrib.auth.hashers.PBKDF2PasswordHasher`` 的子类："

msgid ""
"Save this somewhere in your project. For example, you might put this in a "
"file like ``myproject/hashers.py``."
msgstr ""
"在你的项目某些位置中保存。比如，你可以放在类似 ``myproject/hashers.py`` 里。"

msgid "Add your new hasher as the first entry in :setting:`PASSWORD_HASHERS`::"
msgstr "在 :setting:`PASSWORD_HASHERS` 中把新哈希放在首位："

msgid ""
"That's it -- now your Django install will use more iterations when it stores "
"passwords using PBKDF2."
msgstr "现在 Django 使用 PBKDF2 存储密码时将会多次迭代。"

msgid ""
"bcrypt ``rounds`` is a logarithmic work factor, e.g. 12 rounds means ``2 ** "
"12`` iterations."
msgstr ""

msgid "Argon2"
msgstr "Argon2"

msgid "Argon2 has three attributes that can be customized:"
msgstr "Argon2 有三个可以自定义的属性："

msgid "``time_cost`` controls the number of iterations within the hash."
msgstr "``time_cost`` 控制哈希的次数。"

msgid ""
"``memory_cost`` controls the size of memory that must be used during the "
"computation of the hash."
msgstr "``memory_cost`` 控制被用来计算哈希时的内存大小。"

msgid ""
"``parallelism`` controls how many CPUs the computation of the hash can be "
"parallelized on."
msgstr "``parallelism`` 控制并行计算哈希的 CPU 数量。"

msgid ""
"The default values of these attributes are probably fine for you. If you "
"determine that the password hash is too fast or too slow, you can tweak it "
"as follows:"
msgstr ""
"这三个属性的默认值足够适合你。如果你确定密码哈希过快或过慢，可以按如下方式调"
"整它："

msgid ""
"Choose ``parallelism`` to be the number of threads you can spare computing "
"the hash."
msgstr "选择 ``parallelism`` 你可以节省计算哈希的线程数。"

msgid "Choose ``memory_cost`` to be the KiB of memory you can spare."
msgstr "选择 ``memory_cost`` 你可以节省内存的 KiB 。"

msgid ""
"Adjust ``time_cost`` and measure the time hashing a password takes. Pick a "
"``time_cost`` that takes an acceptable time for you. If ``time_cost`` set to "
"1 is unacceptably slow, lower ``memory_cost``."
msgstr ""
"调整 ``time_cost`` 和估计哈希一个密码所需的时间。挑选出你可以接受的 "
"``time_cost`` 。如果设置为1的  ``time_cost`` 慢的无法接受，则调低 "
"``memory_cost`` 。"

msgid "``memory_cost`` interpretation"
msgstr "``memory_cost`` 说明"

msgid ""
"The argon2 command-line utility and some other libraries interpret the "
"``memory_cost`` parameter differently from the value that Django uses. The "
"conversion is given by ``memory_cost == 2 ** memory_cost_commandline``."
msgstr ""
"argon2 命令行工具和一些其他的库解释了 ``memory_cost`` 参数不同于 Django 使用"
"的值。换算公式是``memory_cost == 2 ** memory_cost_commandline`` 。"

msgid "``scrypt``"
msgstr ""

msgid "scrypt_ has four attributes that can be customized:"
msgstr ""

msgid "``work_factor`` controls the number of iterations within the hash."
msgstr ""

msgid "``block_size``"
msgstr ""

msgid "``parallelism`` controls how many threads will run in parallel."
msgstr ""

msgid ""
"``maxmem`` limits the maximum size of memory that can be used during the "
"computation of the hash. Defaults to ``0``, which means the default "
"limitation from the OpenSSL library."
msgstr ""

msgid ""
"We've chosen reasonable defaults, but you may wish to tune it up or down, "
"depending on your security needs and available processing power."
msgstr ""

msgid "Estimating memory usage"
msgstr ""

msgid "The minimum memory requirement of scrypt_ is::"
msgstr ""

msgid ""
"so you may need to tweak ``maxmem`` when changing the ``work_factor`` or "
"``block_size`` values."
msgstr ""

msgid "Password upgrading"
msgstr "密码升级"

msgid ""
"When users log in, if their passwords are stored with anything other than "
"the preferred algorithm, Django will automatically upgrade the algorithm to "
"the preferred one. This means that old installs of Django will get "
"automatically more secure as users log in, and it also means that you can "
"switch to new (and better) storage algorithms as they get invented."
msgstr ""
"当用户登录时，如果用户的密码使用首选算法以外的算法保存，Django 会自动升级这个"
"算法成为首选算法。这意味着旧的 Django 安装会在用户登录时自动得到更多的安全，"
"并且当它们创建时你可以切换到新的更好的存储算法。"

msgid ""
"However, Django can only upgrade passwords that use algorithms mentioned in :"
"setting:`PASSWORD_HASHERS`, so as you upgrade to new systems you should make "
"sure never to *remove* entries from this list. If you do, users using "
"unmentioned algorithms won't be able to upgrade. Hashed passwords will be "
"updated when increasing (or decreasing) the number of PBKDF2 iterations, "
"bcrypt rounds, or argon2 attributes."
msgstr ""
"然而，Django 只会使用 :setting:`PASSWORD_HASHERS` 提到的算法升级密码，因此当"
"你升级到新系统时你要确保你从没有删除过这个列表的条目。如果你删除过，那么使用"
"的没有列出的算法的用户将不会升级。当增加（或减少） PBKDF2 迭代的次数、bcrypt "
"的轮次或者 argon2 属性，哈希过的密码将被更新。"

msgid ""
"Be aware that if all the passwords in your database aren't encoded in the "
"default hasher's algorithm, you may be vulnerable to a user enumeration "
"timing attack due to a difference between the duration of a login request "
"for a user with a password encoded in a non-default algorithm and the "
"duration of a login request for a nonexistent user (which runs the default "
"hasher). You may be able to mitigate this by :ref:`upgrading older password "
"hashes <wrapping-password-hashers>`."
msgstr ""
"注意，如果数据库内的所有密码没有在默认哈希算法里编码，则由于非默认算法的密码"
"编码的用户登录请求持续时间和不存在用户（运行过默认哈希）的登录请求持续时间的"
"不同，你可能会受到用户枚举时间攻击。你可以使用升级旧密码的哈希值来缓解此问"
"题。"

msgid "Password upgrading without requiring a login"
msgstr "无需登录的密码升级"

msgid ""
"If you have an existing database with an older, weak hash such as MD5 or "
"SHA1, you might want to upgrade those hashes yourself instead of waiting for "
"the upgrade to happen when a user logs in (which may never happen if a user "
"doesn't return to your site). In this case, you can use a \"wrapped\" "
"password hasher."
msgstr ""
"如果数据库拥有老旧低效的哈希算法，比如 MD5 或 SHA1，那么你也许希望自己升级哈"
"希而不是等待用户登录后升级（如果一个用户不再登录站点，密码就不会升级了）。在"
"这里，你可以包装一下密码哈希。"

msgid ""
"For this example, we'll migrate a collection of SHA1 hashes to use "
"PBKDF2(SHA1(password)) and add the corresponding password hasher for "
"checking if a user entered the correct password on login. We assume we're "
"using the built-in ``User`` model and that our project has an ``accounts`` "
"app. You can modify the pattern to work with any algorithm or with a custom "
"user model."
msgstr ""
"比如，你想迁移一个 SHA1 哈希集合来使用 PBKDF2(SHA1(password)) ，并添加相应的"
"密码哈希来检查用户在登陆时是否输入了正确的密码。我们假设我们正在使用内建的 "
"``User`` 模型，并有一个 ``accounts`` app 。你可以修改模式以使用任何算法或自定"
"义的模型。"

msgid "First, we'll add the custom hasher:"
msgstr "首先，我们添加一个自定义的哈希："

msgid "accounts/hashers.py"
msgstr "accounts/hashers.py"

msgid "The data migration might look something like:"
msgstr "数据迁移可能类似于这样："

msgid "accounts/migrations/0002_migrate_sha1_passwords.py"
msgstr "accounts/migrations/0002_migrate_sha1_passwords.py"

msgid ""
"Be aware that this migration will take on the order of several minutes for "
"several thousand users, depending on the speed of your hardware."
msgstr "注意，迁移将对上千名用户花费大约数十分钟，这取决于你的硬件速度。"

msgid "Finally, we'll add a :setting:`PASSWORD_HASHERS` setting:"
msgstr "最后，我们在 :setting:`PASSWORD_HASHERS` 中添加配置："

msgid "mysite/settings.py"
msgstr "mysite/settings.py"

msgid "Include any other hashers that your site uses in this list."
msgstr "包含你的站点使用的此列表中的其他算法。"

msgid "Included hashers"
msgstr "已包含的哈希"

msgid "The full list of hashers included in Django is::"
msgstr "在 Django 中的所有列出的哈希是："

msgid "The corresponding algorithm names are:"
msgstr "相应的算法名是："

msgid "``pbkdf2_sha256``"
msgstr "``pbkdf2_sha256``"

msgid "``pbkdf2_sha1``"
msgstr "``pbkdf2_sha1``"

msgid "``argon2``"
msgstr "``argon2``"

msgid "``bcrypt_sha256``"
msgstr "``bcrypt_sha256``"

msgid "``bcrypt``"
msgstr "``bcrypt``"

msgid "``sha1``"
msgstr "``sha1``"

msgid "``md5``"
msgstr "``md5``"

msgid "``unsalted_sha1``"
msgstr "``unsalted_sha1``"

msgid "``unsalted_md5``"
msgstr "``unsalted_md5``"

msgid "``crypt``"
msgstr "``crypt``"

msgid "Writing your own hasher"
msgstr "编写你自己的哈希"

msgid ""
"If you write your own password hasher that contains a work factor such as a "
"number of iterations, you should implement a ``harden_runtime(self, "
"password, encoded)`` method to bridge the runtime gap between the work "
"factor supplied in the ``encoded`` password and the default work factor of "
"the hasher. This prevents a user enumeration timing attack due to  "
"difference between a login request for a user with a password encoded in an "
"older number of iterations and a nonexistent user (which runs the default "
"hasher's default number of iterations)."
msgstr ""
"如果你编写自己的密码哈希包含工作因子，比如迭代数量。你应该实现一个 "
"``harden_runtime(self, password, encoded)`` 方法来消除编码密码时提供的工作因"
"子和默认的哈希工作因子之间的运行时间差。这样可以防止用户枚举时间攻击，因为旧"
"的迭代次数中对密码编码的用户与不存在的用户（运行默认哈希的默认迭代次数）在登"
"录时存在差异。"

msgid ""
"Taking PBKDF2 as example, if ``encoded`` contains 20,000 iterations and the "
"hasher's default ``iterations`` is 30,000, the method should run "
"``password`` through another 10,000 iterations of PBKDF2."
msgstr ""
"以 PDKDF2 为例，如果编码包含20000次迭代，并且默认哈希迭代是30000，那么该方法"
"应该通过另外的10000次迭代的 PBKDF2 运行密码。"

msgid ""
"If your hasher doesn't have a work factor, implement the method as a no-op "
"(``pass``)."
msgstr "如果你的哈希没有工作因子，可以将该方法实现为 no-op (pass) 。"

msgid "Manually managing a user's password"
msgstr "手动管理用户的密码"

msgid ""
"The :mod:`django.contrib.auth.hashers` module provides a set of functions to "
"create and validate hashed passwords. You can use them independently from "
"the ``User`` model."
msgstr ""
" :mod:`django.contrib.auth.hashers` 模块提供一个函数集来创建和验证哈希密码。"
"你可以独立于 ``User``  模型来使用它们。"

msgid ""
"If you'd like to manually authenticate a user by comparing a plain-text "
"password to the hashed password in the database, use the convenience "
"function :func:`check_password`. It takes two arguments: the plain-text "
"password to check, and the full value of a user's ``password`` field in the "
"database to check against, and returns ``True`` if they match, ``False`` "
"otherwise."
msgstr ""
"如果你想通过对比纯文本密码和数据库中的哈希密码来验证用户，可以使用  :func:"
"`check_password` 快捷函数。它需要2个参数：要检查的纯文本密码和要检查的数据库"
"中用户密码字段的值。如果匹配成功，返回 ``True`` ，否则返回 ``False`` 。"

msgid ""
"Creates a hashed password in the format used by this application. It takes "
"one mandatory argument: the password in plain-text (string or bytes). "
"Optionally, you can provide a salt and a hashing algorithm to use, if you "
"don't want to use the defaults (first entry of ``PASSWORD_HASHERS`` "
"setting). See :ref:`auth-included-hashers` for the algorithm name of each "
"hasher. If the password argument is ``None``, an unusable password is "
"returned (one that will never be accepted by :func:`check_password`)."
msgstr ""
"通过此应用的格式创建一个哈希密码。它需要一个必需的参数：纯文本密码（字符串或"
"字节）。或者，如果你不想使用默认配置（ ``PASSWORD_HASHERS`` 配置的首个条"
"目 ），那么可以提供 salt 和 使用的哈希算法。有关每个哈希的算法名，可查看 :"
"ref:`auth-included-hashers` 。如果密码参数是 ``None`` ，将返回一个不可用的密"
"码（永远不会被 :func:`check_password` 通过的密码）。"

msgid ""
"Returns ``False`` if the password is a result of :meth:`.User."
"set_unusable_password`."
msgstr ""
"如果密码是 :meth:`.User.set_unusable_password` 的结果，则返回 ``False`` 。"

msgid "Password validation"
msgstr "密码验证"

msgid ""
"Users often choose poor passwords. To help mitigate this problem, Django "
"offers pluggable password validation. You can configure multiple password "
"validators at the same time. A few validators are included in Django, but "
"you can write your own as well."
msgstr ""
"用户经常会选择弱密码。为了缓解这个问题，Django 提供可插拔的密码验证。你可以同"
"时配置多个密码验证。Django 已经包含了一些验证，但你也可以编写你自己的验证。"

msgid ""
"Each password validator must provide a help text to explain the requirements "
"to the user, validate a given password and return an error message if it "
"does not meet the requirements, and optionally receive passwords that have "
"been set. Validators can also have optional settings to fine tune their "
"behavior."
msgstr ""
"每个密码验证器必须提供给用户提供帮助文案以向用户解释要求，验证密码并在不符合"
"要求时返回错误信息，并且可选择接受已经设置过的密码。验证器也可以使用可选设置"
"来微调它们的行为。"

msgid ""
"Validation is controlled by the :setting:`AUTH_PASSWORD_VALIDATORS` setting. "
"The default for the setting is an empty list, which means no validators are "
"applied. In new projects created with the default :djadmin:`startproject` "
"template, a set of validators is enabled by default."
msgstr ""
"验证由 :setting:`AUTH_PASSWORD_VALIDATORS` 控制。默认的设置是一个空列表，这意"
"味着默认是不验证的。在使用默认的 :djadmin:`startproject` 创建的新项目中，默认"
"启用了验证器集合。"

msgid ""
"By default, validators are used in the forms to reset or change passwords "
"and in the :djadmin:`createsuperuser` and :djadmin:`changepassword` "
"management commands. Validators aren't applied at the model level, for "
"example in ``User.objects.create_user()`` and ``create_superuser()``, "
"because we assume that developers, not users, interact with Django at that "
"level and also because model validation doesn't automatically run as part of "
"creating models."
msgstr ""
"默认情况下，验证器在重置或修改密码的表单中使用，也可以在 :djadmin:"
"`createsuperuser` 和 :djadmin:`changepassword` 命令中使用。验证器不能应用在模"
"型层，比如 ``User.objects.create_user()`` 和 ``create_superuser()`` ，因为我"
"们假设开发者（非用户）会在模型层与 Django 进行交互，也因为模型验证不会在创建"
"模型时自动运行。"

msgid ""
"Password validation can prevent the use of many types of weak passwords. "
"However, the fact that a password passes all the validators doesn't "
"guarantee that it is a strong password. There are many factors that can "
"weaken a password that are not detectable by even the most advanced password "
"validators."
msgstr ""
"密码验证器可以防止使用很多类型的弱密码。但是，密码通过所有的验证器并不能保证"
"它就是强密码。这里有很多因素削弱即便最先进的密码验证程序也检测不到的密码。"

msgid "Enabling password validation"
msgstr "启用密码验证"

msgid ""
"Password validation is configured in the :setting:`AUTH_PASSWORD_VALIDATORS` "
"setting::"
msgstr "在 :setting:`AUTH_PASSWORD_VALIDATORS` 中设置密码验证："

msgid "This example enables all four included validators:"
msgstr "这个例子启用了所有包含的验证器："

msgid ""
"``UserAttributeSimilarityValidator``, which checks the similarity between "
"the password and a set of attributes of the user."
msgstr ""
"``UserAttributeSimilarityValidator`` 检查密码和一组用户属性集合之间的相似性。"

msgid ""
"``MinimumLengthValidator``, which checks whether the password meets a "
"minimum length. This validator is configured with a custom option: it now "
"requires the minimum length to be nine characters, instead of the default "
"eight."
msgstr ""
"``MinimumLengthValidator`` 用来检查密码是否符合最小长度。这个验证器可以自定义"
"设置：它现在需要最短9位字符，而不是默认的8个字符。"

msgid ""
"``CommonPasswordValidator``, which checks whether the password occurs in a "
"list of common passwords. By default, it compares to an included list of "
"20,000 common passwords."
msgstr ""
"``CommonPasswordValidator`` 检查密码是否在常用密码列表中。默认情况下，它会与"
"列表中的2000个常用密码作比较。"

msgid ""
"``NumericPasswordValidator``, which checks whether the password isn't "
"entirely numeric."
msgstr "``NumericPasswordValidator`` 检查密码是否是完全是数字的。"

msgid ""
"For ``UserAttributeSimilarityValidator`` and ``CommonPasswordValidator``, "
"we're using the default settings in this example. "
"``NumericPasswordValidator`` has no settings."
msgstr ""
"对于 ``UserAttributeSimilarityValidator`` 和 ``CommonPasswordValidator`` ，我"
"们在这个例子里使用默认配置。``NumericPasswordValidator`` 不需要设置。"

msgid ""
"The help texts and any errors from password validators are always returned "
"in the order they are listed in :setting:`AUTH_PASSWORD_VALIDATORS`."
msgstr ""
"帮助文本和来自密码验证器的任何错误信息始终按照  :setting:"
"`AUTH_PASSWORD_VALIDATORS` 列出的顺序返回。"

msgid "Included validators"
msgstr "已包含的验证器"

msgid "Django includes four validators:"
msgstr "Django 包含了四种验证器："

msgid ""
"Validates whether the password meets a minimum length. The minimum length "
"can be customized with the ``min_length`` parameter."
msgstr "验证密码是否符合最小长度。最小长度可以在 ``min_length`` 参数中自定义。"

msgid ""
"Validates whether the password is sufficiently different from certain "
"attributes of the user."
msgstr "验证密码是否与用户的某些属性有很大的区别。"

msgid ""
"The ``user_attributes`` parameter should be an iterable of names of user "
"attributes to compare to. If this argument is not provided, the default is "
"used: ``'username', 'first_name', 'last_name', 'email'``. Attributes that "
"don't exist are ignored."
msgstr ""
"``user_attributes`` 参数应该是可比较的用户属性名的可迭代参数。如果没有提供这"
"个参数，默认使用：``'username', 'first_name', 'last_name', 'email'`` 。不存在"
"的属性会被忽略。"

msgid ""
"The maximum allowed similarity of passwords can be set on a scale of 0.1 to "
"1.0 with the ``max_similarity`` parameter. This is compared to the result "
"of :meth:`difflib.SequenceMatcher.quick_ratio`. A value of 0.1 rejects "
"passwords unless they are substantially different from the "
"``user_attributes``, whereas a value of 1.0 rejects only passwords that are "
"identical to an attribute's value."
msgstr ""

msgid "The ``max_similarity`` parameter was limited to a minimum value of 0.1."
msgstr ""

msgid ""
"Validates whether the password is not a common password. This converts the "
"password to lowercase (to do a case-insensitive comparison) and checks it "
"against a list of 20,000 common password created by `Royce Williams <https://"
"gist.github.com/roycewilliams/281ce539915a947a23db17137d91aeb7>`_."
msgstr ""
"验证密码是否是常用密码。先转换密码为小写字母（做一个不区分大小写的比较），然"
"后根据 `Royce Williams <https://gist.github.com/"
"roycewilliams/281ce539915a947a23db17137d91aeb7>`_ 创建的2000个常用密码的列表"
"进行检查。"

msgid ""
"The ``password_list_path`` can be set to the path of a custom file of common "
"passwords. This file should contain one lowercase password per line and may "
"be plain text or gzipped."
msgstr ""
"``password_list_path`` 用来设置自定义的常用密码列表文件的路径。这个文件应该每"
"行包含一个小写密码，并且文件是纯文本或 gzip 压缩过的。"

msgid "Validates whether the password is not entirely numeric."
msgstr "检查密码是否完全是数字。"

msgid "Integrating validation"
msgstr "集成检查"

msgid ""
"There are a few functions in ``django.contrib.auth.password_validation`` "
"that you can call from your own forms or other code to integrate password "
"validation. This can be useful if you use custom forms for password setting, "
"or if you have API calls that allow passwords to be set, for example."
msgstr ""
"``django.contrib.auth.password_validation`` 包含一些你可以在表单或其他地方调"
"用的函数，用来集成密码检查。如果你使用自定义表单来进行密码设置或者你有允许密"
"码设置的 API 调用，此功能会很有用。"

msgid ""
"Validates a password. If all validators find the password valid, returns "
"``None``. If one or more validators reject the password, raises a :exc:"
"`~django.core.exceptions.ValidationError` with all the error messages from "
"the validators."
msgstr ""
"验证密码。如果所有验证器验证密码有效，则返回 ``None`` 。如果一个或多个验证器"
"拒绝此密码，将会引发 :exc:`~django.core.exceptions.ValidationError` 和验证器"
"的错误信息。"

msgid ""
"The ``user`` object is optional: if it's not provided, some validators may "
"not be able to perform any validation and will accept any password."
msgstr ""
"``user`` 对象是可选的：如果不提供用户对象，一些验证器将不能执行验证，并将接受"
"所有密码。"

msgid ""
"Informs all validators that the password has been changed. This can be used "
"by validators such as one that prevents password reuse. This should be "
"called once the password has been successfully changed."
msgstr ""
"通知所有验证器密码已经更改。这可以由验证器使用，例如防止密码重用。一旦密码更"
"改成功，则调用此方法。"

msgid ""
"For subclasses of :class:`~django.contrib.auth.models.AbstractBaseUser`, the "
"password field will be marked as \"dirty\" when calling :meth:`~django."
"contrib.auth.models.AbstractBaseUser.set_password` which triggers a call to "
"``password_changed()`` after the user is saved."
msgstr ""
"对于 :class:`~django.contrib.auth.models.AbstractBaseUser` 子类，当调用 :"
"meth:`~django.contrib.auth.models.AbstractBaseUser.set_password` 是会将密码字"
"段标记为 \"dirty\" ，这会在用户保存后调用 ``password_changed()`` 。"

msgid ""
"Returns a list of the help texts of all validators. These explain the "
"password requirements to the user."
msgstr "返回一个所有验证器帮助文案的列表。这些向用户解释了密码要求。"

msgid ""
"Returns an HTML string with all help texts in an ``<ul>``. This is helpful "
"when adding password validation to forms, as you can pass the output "
"directly to the ``help_text`` parameter of a form field."
msgstr ""
"返回一个``<ul>`` ，包含所有帮助文案的 HTML 字符串。这在表单中添加密码验证时有"
"帮助，因为你可以直接将输出传递到表单字段的 ``help_text`` 参数。"

msgid ""
"Returns a set of validator objects based on the ``validator_config`` "
"parameter. By default, all functions use the validators defined in :setting:"
"`AUTH_PASSWORD_VALIDATORS`, but by calling this function with an alternate "
"set of validators and then passing the result into the "
"``password_validators`` parameter of the other functions, your custom set of "
"validators will be used instead. This is useful when you have a typical set "
"of validators to use for most scenarios, but also have a special situation "
"that requires a custom set. If you always use the same set of validators, "
"there is no need to use this function, as the configuration from :setting:"
"`AUTH_PASSWORD_VALIDATORS` is used by default."
msgstr ""
"返回一个基于 ``validator_config`` 的验证器对象的集合。默认情况下，所有函数使"
"用 :setting:`AUTH_PASSWORD_VALIDATORS` 定义的验证器，但通过一个验证器替代集合"
"来调用此函数，然后向其他函数传递的密码验证器参数传递结果，将使用你自定义的验"
"证器集合。当你有一个应用于大多数场景的通用的验证器集合时，需要一个自定义的集"
"合来用于特殊情况。当你始终使用同一个验证器集合时，则不需要这个函数，因为默认"
"使用是 :setting:`AUTH_PASSWORD_VALIDATORS` 的配置。"

msgid ""
"The structure of ``validator_config`` is identical to the structure of :"
"setting:`AUTH_PASSWORD_VALIDATORS`. The return value of this function can be "
"passed into the ``password_validators`` parameter of the functions listed "
"above."
msgstr ""
"``validator_config`` 的结构和 :setting:`AUTH_PASSWORD_VALIDATORS` 的结构相"
"同。这个函数的返回值可以传递给上述函数列表的``password_validators`` 参数。"

msgid ""
"Note that where the password is passed to one of these functions, this "
"should always be the clear text password - not a hashed password."
msgstr ""
"注意，如果将密码传递给其中一个函数，应该始终是明文密码，而不是哈希过的密码。"

msgid "Writing your own validator"
msgstr "编写自定义的验证器"

msgid ""
"If Django's built-in validators are not sufficient, you can write your own "
"password validators. Validators have a fairly small interface. They must "
"implement two methods:"
msgstr ""
"如果 Django 内置的验证器不满足你的需求，你可以编写自定义的验证器。验证器的接"
"口很小。它们必须实现两个方法："

msgid ""
"``validate(self, password, user=None)``: validate a password. Return "
"``None`` if the password is valid, or raise a :exc:`~django.core.exceptions."
"ValidationError` with an error message if the password is not valid. You "
"must be able to deal with ``user`` being ``None`` - if that means your "
"validator can't run, return ``None`` for no error."
msgstr ""
"``validate(self, password, user=None)`` ：验证密码。如果密码有效，返回 "
"``None`` ，否则引发 :exc:`~django.core.exceptions.ValidationError` 错误。你必"
"须能够处理 ``user`` 为 ``None`` 的情况，如果这样会让验证器无法运行，只需返回 "
"``None`` 即可。"

msgid ""
"``get_help_text()``: provide a help text to explain the requirements to the "
"user."
msgstr "``get_help_text()`` ：提供一个帮助文本向用户解释密码要求。"

msgid ""
"Any items in the ``OPTIONS`` in :setting:`AUTH_PASSWORD_VALIDATORS` for your "
"validator will be passed to the constructor. All constructor arguments "
"should have a default value."
msgstr ""
"验证器的 :setting:`AUTH_PASSWORD_VALIDATORS` 中， ``OPTIONS`` 里的任何条目将"
"会传递到构造器中。所有构造器参数应该有一个默认值。"

msgid "Here's a basic example of a validator, with one optional setting::"
msgstr "这里是一个验证器的基本示例，其中包含一个可选的设置："

msgid ""
"You can also implement ``password_changed(password, user=None``), which will "
"be called after a successful password change. That can be used to prevent "
"password reuse, for example. However, if you decide to store a user's "
"previous passwords, you should never do so in clear text."
msgstr ""
"你也可以实现 ``password_changed(password, user=None)`` ，在密码修改成功后调"
"用。比如说用来防止密码重用。但是，如果你决定存储用户之前的密码，则不应该以明"
"文形式存储。"

msgid "Django's cache framework"
msgstr "Django 缓存框架"

msgid ""
"A fundamental trade-off in dynamic websites is, well, they're dynamic. Each "
"time a user requests a page, the web server makes all sorts of calculations "
"-- from database queries to template rendering to business logic -- to "
"create the page that your site's visitor sees. This is a lot more expensive, "
"from a processing-overhead perspective, than your standard read-a-file-off-"
"the-filesystem server arrangement."
msgstr ""

msgid ""
"For most web applications, this overhead isn't a big deal. Most web "
"applications aren't ``washingtonpost.com`` or ``slashdot.org``; they're "
"small- to medium-sized sites with so-so traffic. But for medium- to high-"
"traffic sites, it's essential to cut as much overhead as possible."
msgstr ""

msgid "That's where caching comes in."
msgstr "这就是缓存的用武之地。"

msgid ""
"To cache something is to save the result of an expensive calculation so that "
"you don't have to perform the calculation next time. Here's some pseudocode "
"explaining how this would work for a dynamically generated web page::"
msgstr ""

msgid ""
"Django comes with a robust cache system that lets you save dynamic pages so "
"they don't have to be calculated for each request. For convenience, Django "
"offers different levels of cache granularity: You can cache the output of "
"specific views, you can cache only the pieces that are difficult to produce, "
"or you can cache your entire site."
msgstr ""
"Django 自带强大的缓存系统，可以让你保存动态页面，这样就不必为每次请求计算。为"
"了方便，Django 提供了不同级别的缓存粒度。你可以缓存特定视图的输出，你可以只缓"
"存难以生成的部分，或者你可以缓存整个网站。"

msgid ""
"Django also works well with \"downstream\" caches, such as `Squid <http://"
"www.squid-cache.org/>`_ and browser-based caches. These are the types of "
"caches that you don't directly control but to which you can provide hints "
"(via HTTP headers) about which parts of your site should be cached, and how."
msgstr ""

msgid ""
"The :ref:`Cache Framework design philosophy <cache-design-philosophy>` "
"explains a few of the design decisions of the framework."
msgstr ""
":ref:`缓存框架设计理念 <cache-design-philosophy>` 解释了框架的一些设计决策。"

msgid "Setting up the cache"
msgstr "设置缓存"

msgid ""
"The cache system requires a small amount of setup. Namely, you have to tell "
"it where your cached data should live -- whether in a database, on the "
"filesystem or directly in memory. This is an important decision that affects "
"your cache's performance; yes, some cache types are faster than others."
msgstr ""
"缓存系统需要少量的设置。也就是说，你必须告诉它你的缓存数据应该放在哪里 —— 是"
"在数据库中，还是在文件系统上，或者直接放在内存中。这是一个重要的决定，会影响"
"你的缓存的性能；是的，有些缓存类型比其他类型快。"

msgid ""
"Your cache preference goes in the :setting:`CACHES` setting in your settings "
"file. Here's an explanation of all available values for :setting:`CACHES`."
msgstr ""
"缓存设置项位于你的配置文件的缓存配置中。这里有缓存配置所有可用值的说明。"

msgid "Memcached"
msgstr "Memcached"

msgid ""
"Memcached__ is an entirely memory-based cache server, originally developed "
"to handle high loads at LiveJournal.com and subsequently open-sourced by "
"Danga Interactive. It is used by sites such as Facebook and Wikipedia to "
"reduce database access and dramatically increase site performance."
msgstr ""

msgid ""
"Memcached runs as a daemon and is allotted a specified amount of RAM. All it "
"does is provide a fast interface for adding, retrieving and deleting data in "
"the cache. All data is stored directly in memory, so there's no overhead of "
"database or filesystem usage."
msgstr ""
"Memcached 以一个守护进程的形式运行，并且被分配了指定数量的 RAM。它所做的就是"
"提供一个快速接口用于在缓存中添加，检索和删除数据。所有数据都直接存储在内存"
"中，因此不会产生数据库或文件系统使用的开销。"

msgid ""
"After installing Memcached itself, you'll need to install a Memcached "
"binding. There are several Python Memcached bindings available; the two "
"supported by Django are `pylibmc`_ and `pymemcache`_."
msgstr ""
"在安装了 Memcached 本身之后，你需要安装一个 Memcached 绑定。有几个 Python "
"Memcached 绑定可用；Django 支持的两个绑定是 `pylibmc`_ 和 `pymemcache`_ 。"

msgid "To use Memcached with Django:"
msgstr "在 Django 中使用 Memcached ："

msgid ""
"Set :setting:`BACKEND <CACHES-BACKEND>` to ``django.core.cache.backends."
"memcached.PyMemcacheCache`` or ``django.core.cache.backends.memcached."
"PyLibMCCache`` (depending on your chosen memcached binding)"
msgstr ""
"设置 :setting:`BACKEND <CACHES-BACKEND>` 为 `django.core.cache.backends."
"memcached.PyMemcacheCache` 或 `django.core.cache.backends.memcached."
"PyLibMCCache` （取决于你选择的 memcached 绑定）。"

msgid ""
"Set :setting:`LOCATION <CACHES-LOCATION>` to ``ip:port`` values, where "
"``ip`` is the IP address of the Memcached daemon and ``port`` is the port on "
"which Memcached is running, or to a ``unix:path`` value, where ``path`` is "
"the path to a Memcached Unix socket file."
msgstr ""
"将 :setting:`LOCATION <CACHES-LOCATION>` 设置为 ``ip:port`` 值，其中 ``ip`` "
"是 Memcached 守护进程的 IP 地址，``port`` 是 Memcached 运行的端口，或者设置"
"为 ``unix:path`` 值，其中 ``path`` 是 Memcached Unix socket 文件的路径。"

msgid ""
"In this example, Memcached is running on localhost (127.0.0.1) port 11211, "
"using the ``pymemcache`` binding::"
msgstr ""
"在这个例子中，Memcached 运行在 localhost（127.0.0.1）端口 11211，使用 "
"``pymemcache`` 绑定："

msgid ""
"In this example, Memcached is available through a local Unix socket file :"
"file:`/tmp/memcached.sock` using the ``pymemcache`` binding::"
msgstr ""
"在这个例子中，Memcached 可以通过本地 Unix 套接字文件 :file:`/tmp/memcached."
"sock` 使用 ``pymemcache`` 绑定："

msgid ""
"One excellent feature of Memcached is its ability to share a cache over "
"multiple servers. This means you can run Memcached daemons on multiple "
"machines, and the program will treat the group of machines as a *single* "
"cache, without the need to duplicate cache values on each machine. To take "
"advantage of this feature, include all server addresses in :setting:"
"`LOCATION <CACHES-LOCATION>`, either as a semicolon or comma delimited "
"string, or as a list."
msgstr ""
"Memcached 有一个很好的特性，就是它可以在多台服务器上共享一个缓存。这意味着你"
"可以在多台机器上运行 Memcached 守护进程，程序将把这组机器作为一个 *单一* 的缓"
"存，而不需要在每台机器上重复缓存值。要利用这个特性，请在 :setting:`LOCATION "
"<CACHES-LOCATION>` 中包含所有服务器地址，可以是分号或逗号分隔的字符串，也可以"
"是一个列表。"

msgid ""
"In this example, the cache is shared over Memcached instances running on IP "
"address 172.19.26.240 and 172.19.26.242, both on port 11211::"
msgstr ""
"在这个例子中，缓存是通过运行在 IP 地址 172.19.26.240 和 172.19.26.242 上的 "
"Memcached 实例共享的，这两个实例都在 11211 端口上："

msgid ""
"In the following example, the cache is shared over Memcached instances "
"running on the IP addresses 172.19.26.240 (port 11211), 172.19.26.242 (port "
"11212), and 172.19.26.244 (port 11213)::"
msgstr ""
"在下面的例子中，缓存是由运行在 IP 地址 172.19.26.240（端口11211）、"
"172.19.26.242（端口11212）和 172.19.26.244（端口11213）上的 Memcached 实例共"
"享的："

msgid ""
"A final point about Memcached is that memory-based caching has a "
"disadvantage: because the cached data is stored in memory, the data will be "
"lost if your server crashes. Clearly, memory isn't intended for permanent "
"data storage, so don't rely on memory-based caching as your only data "
"storage. Without a doubt, *none* of the Django caching backends should be "
"used for permanent storage -- they're all intended to be solutions for "
"caching, not storage -- but we point this out here because memory-based "
"caching is particularly temporary."
msgstr ""
"关于 Memcached 的最后一点是，基于内存的缓存有一个缺点：因为缓存的数据存储在内"
"存中，如果你的服务器崩溃，数据将丢失。显然，内存并不是用来永久存储数据的，所"
"以不要依赖基于内存的缓存作为你唯一的数据存储。毫无疑问，Django 缓存后端中的 *"
"每个* 都不应该用于永久存储 —— 它们的目的都是为了缓存的解决方案，而不是存储 "
"—— 但我们在这里指出这一点是因为基于内存的缓存是格外临时的。"

msgid "The ``PyMemcacheCache`` backend was added."
msgstr "增加了 ``PyMemcacheCache`` 后端。"

msgid ""
"The ``MemcachedCache`` backend is deprecated as ``python-memcached`` has "
"some problems and seems to be unmaintained. Use ``PyMemcacheCache`` or "
"``PyLibMCCache`` instead."
msgstr ""
"`MemcachedCache`` 后端已被废弃，因为 ``python-memcached`` 有一些问题，而且似"
"乎没有维护。使用 ``PyMemcacheCache`` 或 ``PyLibMCCache`` 代替。"

msgid "Redis"
msgstr ""

msgid ""
"Redis__ is an in-memory database that can be used for caching. To begin "
"you'll need a Redis server running either locally or on a remote machine."
msgstr ""

msgid ""
"After setting up the Redis server, you'll need to install Python bindings "
"for Redis. `redis-py`_ is the binding supported natively by Django. "
"Installing the additional `hiredis-py`_ package is also recommended."
msgstr ""

msgid "To use Redis as your cache backend with Django:"
msgstr ""

msgid ""
"Set :setting:`BACKEND <CACHES-BACKEND>` to ``django.core.cache.backends."
"redis.RedisCache``."
msgstr ""

msgid ""
"Set :setting:`LOCATION <CACHES-LOCATION>` to the URL pointing to your Redis "
"instance, using the appropriate scheme. See the ``redis-py`` docs for "
"`details on the available schemes <https://redis-py.readthedocs.io/en/stable/"
"#redis.ConnectionPool.from_url>`_."
msgstr ""

msgid "For example, if Redis is running on localhost (127.0.0.1) port 6379::"
msgstr ""

msgid ""
"Often Redis servers are protected with authentication. In order to supply a "
"username and password, add them in the ``LOCATION`` along with the URL::"
msgstr ""

msgid ""
"If you have multiple Redis servers set up in the replication mode, you can "
"specify the servers either as a semicolon or comma delimited string, or as a "
"list. While using multiple servers, write operations are performed on the "
"first server (leader). Read operations are performed on the other servers "
"(replicas) chosen at random::"
msgstr ""

msgid "Database caching"
msgstr "数据库缓存"

msgid ""
"Django can store its cached data in your database. This works best if you've "
"got a fast, well-indexed database server."
msgstr ""
"Django 可以在数据库中存储缓存数据。如果你有一个快速、索引正常的数据库服务器，"
"这种缓存效果最好。"

msgid "To use a database table as your cache backend:"
msgstr "用数据库表作为你的缓存后端："

msgid ""
"Set :setting:`BACKEND <CACHES-BACKEND>` to ``django.core.cache.backends.db."
"DatabaseCache``"
msgstr ""
"将 :setting:`BACKEND <CACHES-BACKEND>` 设置为 ``django.core.cache.backends."
"db.DatabaseCache``"

msgid ""
"Set :setting:`LOCATION <CACHES-LOCATION>` to ``tablename``, the name of the "
"database table. This name can be whatever you want, as long as it's a valid "
"table name that's not already being used in your database."
msgstr ""
"将 :setting:`LOCATION <CACHES-LOCATION>` 设置为数据库表的 ``tablename``。这个"
"表名可以是没有使用过的任何符合要求的名称。"

msgid "In this example, the cache table's name is ``my_cache_table``::"
msgstr "在这个例子中，缓存表的名称是 ``my_cache_table`` ："

msgid ""
"Unlike other cache backends, the database cache does not support automatic "
"culling of expired entries at the database level. Instead, expired cache "
"entries are culled each time ``add()``, ``set()``, or ``touch()`` is called."
msgstr ""

msgid "Creating the cache table"
msgstr "创建缓存表"

msgid ""
"Before using the database cache, you must create the cache table with this "
"command::"
msgstr "使用数据库缓存之前，必须通过下面的命令创建缓存表："

msgid ""
"This creates a table in your database that is in the proper format that "
"Django's database-cache system expects. The name of the table is taken from :"
"setting:`LOCATION <CACHES-LOCATION>`."
msgstr ""
"这将在数据库中创建一个表，该表的格式与 Django 数据库缓存系统期望的一致。该表"
"的表名取自 :setting:`LOCATION <CACHES-LOCATION>` 。"

msgid ""
"If you are using multiple database caches, :djadmin:`createcachetable` "
"creates one table for each cache."
msgstr ""
"如果你正在使用多个数据库缓存， :djadmin:`createcachetable` 会为每个缓存创建一"
"个表。"

msgid ""
"If you are using multiple databases, :djadmin:`createcachetable` observes "
"the ``allow_migrate()`` method of your database routers (see below)."
msgstr ""
"如果你正在使用多个数据库， :djadmin:`createcachetable` 观察你的数据库路由器"
"的 ``allow_migrate()`` 方法（见下文）。"

msgid ""
"Like :djadmin:`migrate`, :djadmin:`createcachetable` won't touch an existing "
"table. It will only create missing tables."
msgstr ""
"像 :djadmin:`migrate` 一样， :djadmin:`createcachetable` 不会影响已经存在的"
"表，它只创建缺失的表。"

msgid ""
"To print the SQL that would be run, rather than run it, use the :option:"
"`createcachetable --dry-run` option."
msgstr ""
"要打印即将运行的 SQL，而不是运行它，请使用 :option:`createcachetable --dry-"
"run` 选项。"

msgid "Multiple databases"
msgstr "多数据库"

msgid ""
"If you use database caching with multiple databases, you'll also need to set "
"up routing instructions for your database cache table. For the purposes of "
"routing, the database cache table appears as a model named ``CacheEntry``, "
"in an application named ``django_cache``. This model won't appear in the "
"models cache, but the model details can be used for routing purposes."
msgstr ""
"如果在多数据库中使用缓存，你也需要设置数据库缓存表的路由指令。因为路由的原"
"因，数据库缓存表在 ``django_cache`` 应用程序中显示为 ``CacheEntry`` 的模型"
"名。这个模型不会出现在模型缓存中，但模型详情可用于路由目的。"

msgid ""
"For example, the following router would direct all cache read operations to "
"``cache_replica``, and all write operations to ``cache_primary``. The cache "
"table will only be synchronized onto ``cache_primary``::"
msgstr ""
"比如，下面的路由可以将所有缓存读取操作指向 ``cache_replica`` ，并且所有的写操"
"作指向 ``cache_primary``。缓存表将会只同步到 ``cache_primary``。"

msgid ""
"If you don't specify routing directions for the database cache model, the "
"cache backend will use the ``default`` database."
msgstr ""
"如果你没有指定路由指向数据库缓存模型，缓存后端将使用 ``默认`` 的数据库。"

msgid ""
"And if you don't use the database cache backend, you don't need to worry "
"about providing routing instructions for the database cache model."
msgstr "如果没使用数据库缓存后端，则无需担心为数据库缓存模型提供路由指令。"

msgid "Filesystem caching"
msgstr "文件系统缓存"

msgid ""
"The file-based backend serializes and stores each cache value as a separate "
"file. To use this backend set :setting:`BACKEND <CACHES-BACKEND>` to ``"
"\"django.core.cache.backends.filebased.FileBasedCache\"`` and :setting:"
"`LOCATION <CACHES-LOCATION>` to a suitable directory. For example, to store "
"cached data in ``/var/tmp/django_cache``, use this setting::"
msgstr ""
"基于文件的后端序列化并保存每个缓存值作为单独的文件。要使用此后端，可将 :"
"setting:`BACKEND <CACHES-BACKEND>` 设置为 ``\"django.core.cache.backends."
"filebased.FileBasedCache\"`` 并将 :setting:`LOCATION <CACHES-LOCATION>` 设置"
"为一个合适的路径。比如，在 ``/var/tmp/django_cache`` 存储缓存数据，使用以下配"
"置："

msgid ""
"If you're on Windows, put the drive letter at the beginning of the path, "
"like this::"
msgstr "如果使用 Windows 系统，将驱动器号放在路径开头，如下："

msgid ""
"The directory path should be absolute -- that is, it should start at the "
"root of your filesystem. It doesn't matter whether you put a slash at the "
"end of the setting."
msgstr ""
"目录路径应该是绝对路径——因此，它应该以文件系统根目录开始。无需担心是否需要以"
"斜杠结尾。"

msgid ""
"Make sure the directory pointed-to by this setting either exists and is "
"readable and writable, or that it can be created by the system user under "
"which your web server runs. Continuing the above example, if your server "
"runs as the user ``apache``, make sure the directory ``/var/tmp/"
"django_cache`` exists and is readable and writable by the user ``apache``, "
"or that it can be created by the user ``apache``."
msgstr ""

msgid ""
"When the cache :setting:`LOCATION <CACHES-LOCATION>` is contained within :"
"setting:`MEDIA_ROOT`, :setting:`STATIC_ROOT`, or :setting:"
"`STATICFILES_FINDERS`, sensitive data may be exposed."
msgstr ""
"当缓存 :setting:`LOCATION <CACHES-LOCATION>` 包含在 :setting:`MEDIA_ROOT` "
"或 :setting:`STATICFILES_FINDERS` 中，敏感数据可能被暴露。"

msgid ""
"An attacker who gains access to the cache file can not only falsify HTML "
"content, which your site will trust, but also remotely execute arbitrary "
"code, as the data is serialized using :mod:`pickle`."
msgstr ""
"获得访问缓存文件的攻击者不仅可以伪造 HTML 内容，你的网站会信任它，而且还可以"
"远程执行任意代码，因为数据是用 :mod:`pickle` 序列化的。"

msgid "Local-memory caching"
msgstr "本地内存缓存"

msgid ""
"This is the default cache if another is not specified in your settings file. "
"If you want the speed advantages of in-memory caching but don't have the "
"capability of running Memcached, consider the local-memory cache backend. "
"This cache is per-process (see below) and thread-safe. To use it, set :"
"setting:`BACKEND <CACHES-BACKEND>` to ``\"django.core.cache.backends.locmem."
"LocMemCache\"``. For example::"
msgstr ""
"如果你的配置文件中没有指定其他缓存，那么这是默认的缓存。如果你想获得内存缓存"
"的速度优势，但又不具备运行 Memcached 的能力，可以考虑使用本地内存缓存后端。这"
"个缓存是每进程所有（见下文）和线程安全的。要使用它，可以将 :setting:`BACKEND "
"<CACHES-BACKEND>` 设置为 ``\"django.core.cache.backends.locmem.LocMemCache"
"\"``。例如："

msgid ""
"The cache :setting:`LOCATION <CACHES-LOCATION>` is used to identify "
"individual memory stores. If you only have one ``locmem`` cache, you can "
"omit the :setting:`LOCATION <CACHES-LOCATION>`; however, if you have more "
"than one local memory cache, you will need to assign a name to at least one "
"of them in order to keep them separate."
msgstr ""
":setting:`LOCATION <CACHES-LOCATION>` 被用于标识各个内存存储。如果只有一个 "
"``locmem`` 缓存，你可以忽略 :setting:`LOCATION <CACHES-LOCATION>` 。但是如果"
"你有多个本地内存缓存，那么你至少要为其中一个起个名字，以便将它们区分开。"

msgid "The cache uses a least-recently-used (LRU) culling strategy."
msgstr "这种缓存使用最近最少使用（LRU）的淘汰策略。"

msgid ""
"Note that each process will have its own private cache instance, which means "
"no cross-process caching is possible. This also means the local memory cache "
"isn't particularly memory-efficient, so it's probably not a good choice for "
"production environments. It's nice for development."
msgstr ""
"请注意，每个进程都会有自己的私有缓存实例，这意味着不可能进行跨进程缓存。这也"
"意味着本地内存缓存的内存效率不是特别高，所以对于生产环境来说，它可能不是一个"
"好的选择。对于开发来说是不错的选择。"

msgid "Dummy caching (for development)"
msgstr "虚拟缓存（用于开发模式）"

msgid ""
"Finally, Django comes with a \"dummy\" cache that doesn't actually cache -- "
"it just implements the cache interface without doing anything."
msgstr ""
"最后，Django 带有一个实际上不是缓存的 “虚拟” 缓存，它只是实现缓存接口，并不做"
"其他操作。"

msgid ""
"This is useful if you have a production site that uses heavy-duty caching in "
"various places but a development/test environment where you don't want to "
"cache and don't want to have to change your code to special-case the latter. "
"To activate dummy caching, set :setting:`BACKEND <CACHES-BACKEND>` like so::"
msgstr ""
"如果你有一个生产网站，在不同的地方使用了大量的缓存，但在开发／测试环境中，你"
"不想缓存，也不想单独修改你的代码，那么这就很有用。要激活虚拟缓存，可以像这样"
"设置 :setting:`BACKEND <CACHES-BACKEND>` ："

msgid "Using a custom cache backend"
msgstr "使用自定义缓存后端"

msgid ""
"While Django includes support for a number of cache backends out-of-the-box, "
"sometimes you might want to use a customized cache backend. To use an "
"external cache backend with Django, use the Python import path as the :"
"setting:`BACKEND <CACHES-BACKEND>` of the :setting:`CACHES` setting, like "
"so::"
msgstr ""
"虽然 Django 包含了许多开箱即用的缓存后端支持，但有时你可能会想使用一个自定义"
"的缓存后端。要在 Django 中使用外部缓存后端，使用 Python 导入路径作为 :"
"setting:`BACKEND` 的 :setting:`CACHES` 配置中的 :setting:`BACKEND <CACHES-"
"BACKEND>`，像这样："

msgid ""
"If you're building your own backend, you can use the standard cache backends "
"as reference implementations. You'll find the code in the ``django/core/"
"cache/backends/`` directory of the Django source."
msgstr ""
"如果你正在创建自己的后端，你可以使用标准缓存作为参考实现。你可以在 Django 源"
"代码的 ``django/core/cache/backends/`` 目录找到代码。"

msgid ""
"Note: Without a really compelling reason, such as a host that doesn't "
"support them, you should stick to the cache backends included with Django. "
"They've been well-tested and are well-documented."
msgstr ""
"注意：除非是令人信服的理由，诸如服务器不支持缓存，否则你应该使用 Django 附带"
"的缓存后端。他们经过了良好的测试并有完整文档。"

msgid "Cache arguments"
msgstr "缓存参数"

msgid ""
"Each cache backend can be given additional arguments to control caching "
"behavior. These arguments are provided as additional keys in the :setting:"
"`CACHES` setting. Valid arguments are as follows:"
msgstr ""
"每个缓存后端可以通过额外的参数来控制缓存行为。这些参数在 :setting:`CACHES` 配"
"置中作为附加键提供。有效参数如下："

msgid ""
":setting:`TIMEOUT <CACHES-TIMEOUT>`: The default timeout, in seconds, to use "
"for the cache. This argument defaults to ``300`` seconds (5 minutes). You "
"can set ``TIMEOUT`` to ``None`` so that, by default, cache keys never "
"expire. A value of ``0`` causes keys to immediately expire (effectively "
"\"don't cache\")."
msgstr ""
":setting:`TIMEOUT <CACHES-TIMEOUT>` ：缓存的默认超时时间，以秒为单位。这个参"
"数默认为 ``300`` 秒（5 分钟）。你可以将 ``TIMEOUT`` 设置为 ``None``，这样，默"
"认情况下，缓存键永远不会过期。值为 ``0`` 会导致键立即过期（实际上是 “不缓"
"存”）。"

msgid ""
":setting:`OPTIONS <CACHES-OPTIONS>`: Any options that should be passed to "
"the cache backend. The list of valid options will vary with each backend, "
"and cache backends backed by a third-party library will pass their options "
"directly to the underlying cache library."
msgstr ""
":setting:`OPTIONS <CACHES-OPTIONS>` ：任何应该传递给缓存后端的选项。有效的选"
"项列表会随着每个后端而变化，由第三方库支持的缓存后端会直接将其选项传递给底层"
"缓存库。"

msgid ""
"Cache backends that implement their own culling strategy (i.e., the "
"``locmem``, ``filesystem`` and ``database`` backends) will honor the "
"following options:"
msgstr ""
"实施自有缓存策略的缓存后端（即 ``locmem``、``filesystem`` 和 ``database`` 后"
"端）将尊重以下选项："

msgid ""
"``MAX_ENTRIES``: The maximum number of entries allowed in the cache before "
"old values are deleted. This argument defaults to ``300``."
msgstr "``MAX_ENTRIES`` ：删除旧值之前允许缓存的最大条目。默认是 ``300`` 。"

msgid ""
"``CULL_FREQUENCY``: The fraction of entries that are culled when "
"``MAX_ENTRIES`` is reached. The actual ratio is ``1 / CULL_FREQUENCY``, so "
"set ``CULL_FREQUENCY`` to ``2`` to cull half the entries when "
"``MAX_ENTRIES`` is reached. This argument should be an integer and defaults "
"to ``3``."
msgstr ""
"``CULL_FREQUENCY`` ：当达到 ``MAX_ENTRIES`` 时，被删除的条目的比例。实际比例"
"是 ``1 / CULL_FREQUENCY``，所以将 ``CULL_FREQUENCY`` 设置为 ``2``，即当达到 "
"``MAX_ENTRIES`` 时将删除一半的条目。这个参数应该是一个整数，默认为 ``3``。"

msgid ""
"A value of ``0`` for ``CULL_FREQUENCY`` means that the entire cache will be "
"dumped when ``MAX_ENTRIES`` is reached. On some backends (``database`` in "
"particular) this makes culling *much* faster at the expense of more cache "
"misses."
msgstr ""
"``CULL_FREQUENCY`` 的值为 ``0`` 意味着当达到 ``MAX_ENTRIES`` 时，整个缓存将被"
"转储。在某些后端（特别是 ``database`` ），这使得缓存速度 *更* 快，但代价是缓"
"存未命中更多。"

msgid ""
"The Memcached and Redis backends pass the contents of :setting:`OPTIONS "
"<CACHES-OPTIONS>` as keyword arguments to the client constructors, allowing "
"for more advanced control of client behavior. For example usage, see below."
msgstr ""

msgid ""
":setting:`KEY_PREFIX <CACHES-KEY_PREFIX>`: A string that will be "
"automatically included (prepended by default) to all cache keys used by the "
"Django server."
msgstr ""
":setting:`KEY_PREFIX <CACHES-KEY_PREFIX>`。一个自动包含在 Django 服务器使用的"
"所有缓存键中的字符串（默认为前缀）。"

msgid ""
"See the :ref:`cache documentation <cache_key_prefixing>` for more "
"information."
msgstr "查看 :ref:`缓存文档 <cache_key_prefixing>` 获取更多信息。"

msgid ""
":setting:`VERSION <CACHES-VERSION>`: The default version number for cache "
"keys generated by the Django server."
msgstr ""
":setting:`VERSION <CACHES-VERSION>` ：Django 服务器生成的缓存键的默认版本号。"

msgid ""
"See the :ref:`cache documentation <cache_versioning>` for more information."
msgstr "查看 :ref:`缓存文档 <cache_versioning>` 获取更多信息。"

msgid ""
":setting:`KEY_FUNCTION <CACHES-KEY_FUNCTION>` A string containing a dotted "
"path to a function that defines how to compose a prefix, version and key "
"into a final cache key."
msgstr ""
":setting:`KEY_FUNCTION <CACHES-KEY_FUNCTION>` 一个字符串，包含一个函数的点分"
"隔路径，该函数定义了如何将前缀、版本和键组成一个最终的缓存键。"

msgid ""
"See the :ref:`cache documentation <cache_key_transformation>` for more "
"information."
msgstr "查看 :ref:`缓存文档 <cache_key_transformation>` 获取更多信息。"

msgid ""
"In this example, a filesystem backend is being configured with a timeout of "
"60 seconds, and a maximum capacity of 1000 items::"
msgstr "在本例中，正在配置一个文件系统后端，超时为 60 秒，最大容量 1000 项："

msgid ""
"Here's an example configuration for a ``pylibmc`` based backend that enables "
"the binary protocol, SASL authentication, and the ``ketama`` behavior mode::"
msgstr ""
"下面是一个基于 ``pylibmc`` 的后端配置的例子，它启用了二进制协议、SASL 认证和 "
"``ketama`` 行为模式："

msgid ""
"Here's an example configuration for a ``pymemcache`` based backend that "
"enables client pooling (which may improve performance by keeping clients "
"connected), treats memcache/network errors as cache misses, and sets the "
"``TCP_NODELAY`` flag on the connection's socket::"
msgstr ""
"下面是一个基于 ``pymemcache`` 的后端配置实例，它启用了客户端池（通过保持客户"
"端连接来提高性能），将 memcache／网络错误视为缓存失效，并在连接的 socket 上设"
"置了 ``TCP_NODELAY`` 标志："

msgid ""
"Here's an example configuration for a ``redis`` based backend that selects "
"database ``10`` (by default Redis ships with 16 logical databases), "
"specifies a `parser class`_ (``redis.connection.HiredisParser`` will be used "
"by default if the ``hiredis-py`` package is installed), and sets a custom "
"`connection pool class`_ (``redis.ConnectionPool`` is used by default)::"
msgstr ""

msgid "The per-site cache"
msgstr "站点缓存"

msgid ""
"Once the cache is set up, the simplest way to use caching is to cache your "
"entire site. You'll need to add ``'django.middleware.cache."
"UpdateCacheMiddleware'`` and ``'django.middleware.cache."
"FetchFromCacheMiddleware'`` to your :setting:`MIDDLEWARE` setting, as in "
"this example::"
msgstr ""
"一旦缓存设置完毕，使用缓存最简便的方式就是缓存整个站点。你需要在 :setting:"
"`MIDDLEWARE` 设置中添加 ``'django.middleware.cache.UpdateCacheMiddleware'`` "
"和 ``'django.middleware.cache.FetchFromCacheMiddleware'`` ，像下面这个例子一"
"样："

msgid ""
"No, that's not a typo: the \"update\" middleware must be first in the list, "
"and the \"fetch\" middleware must be last. The details are a bit obscure, "
"but see `Order of MIDDLEWARE`_ below if you'd like the full story."
msgstr ""
"不，这不是错别字：“update” 中间件必须在列表的第一位，而 “fetch” 中间件必须在"
"最后。细节有点晦涩难懂，但如果你想知道完整的故事，请看下面的 `中间件的顺序"
"`_ 。"

msgid "Then, add the following required settings to your Django settings file:"
msgstr "最后，在 Django 设置文件里添加下面的必需配置："

msgid ""
":setting:`CACHE_MIDDLEWARE_ALIAS` -- The cache alias to use for storage."
msgstr ":setting:`CACHE_MIDDLEWARE_ALIAS` -- 用于存储的缓存别名。"

msgid ""
":setting:`CACHE_MIDDLEWARE_SECONDS` -- The number of seconds each page "
"should be cached."
msgstr ":setting:`CACHE_MIDDLEWARE_SECONDS` -- 应缓存每个页面的秒数。"

msgid ""
":setting:`CACHE_MIDDLEWARE_KEY_PREFIX` -- If the cache is shared across "
"multiple sites using the same Django installation, set this to the name of "
"the site, or some other string that is unique to this Django instance, to "
"prevent key collisions. Use an empty string if you don't care."
msgstr ""
":setting:`CACHE_MIDDLEWARE_KEY_PREFIX` -- 如果使用相同的 Django "
"installation ，通过多站点进行缓存共享，请将此值设置为站点名，或者设置成在"
"Django 实例中唯一的其他字符串，以此防止键冲突。如果你不介意，可以设置成空字符"
"串。"

msgid ""
"``FetchFromCacheMiddleware`` caches GET and HEAD responses with status 200, "
"where the request and response headers allow. Responses to requests for the "
"same URL with different query parameters are considered to be unique pages "
"and are cached separately. This middleware expects that a HEAD request is "
"answered with the same response headers as the corresponding GET request; in "
"which case it can return a cached GET response for HEAD request."
msgstr ""
"在请求和响应标头允许的情况下，``FetchFromCacheMiddleware`` 缓存状态为200的 "
"GET 和 HEAD 响应。对于具有不同查询参数的相同URL的请求的响应被认为是单独的页"
"面，并分别缓存。这个中间件期望一个HEAD请求的响应头与相应的GET请求具有相同的响"
"应头；在这种情况下，它可以为HEAD请求返回一个缓存的GET响应。"

msgid ""
"Additionally, ``UpdateCacheMiddleware`` automatically sets a few headers in "
"each :class:`~django.http.HttpResponse` which affect :ref:`downstream caches "
"<downstream-caches>`:"
msgstr ""
"此外，``UpdateCacheMiddleware`` 在每个 :class:`~django.http.HttpResponse`  里"
"会自动设置一些 headers，这会影响 :ref:`下游缓存 <downstream-caches>`:"

msgid ""
"Sets the ``Expires`` header to the current date/time plus the defined :"
"setting:`CACHE_MIDDLEWARE_SECONDS`."
msgstr ""
"设置 ``Expires`` header 为当前日期/时间加上定义的 :setting:"
"`CACHE_MIDDLEWARE_SECONDS` 。"

msgid ""
"Sets the ``Cache-Control`` header to give a max age for the page -- again, "
"from the :setting:`CACHE_MIDDLEWARE_SECONDS` setting."
msgstr ""
"设置  ``Cache-Control`` header 为缓存页面的最长时间，同样，在 :setting:"
"`CACHE_MIDDLEWARE_SECONDS` 里设置。"

msgid "See :doc:`/topics/http/middleware` for more on middleware."
msgstr "查看 :doc:`/topics/http/middleware` 获取更多中间件信息。"

msgid ""
"If a view sets its own cache expiry time (i.e. it has a ``max-age`` section "
"in its ``Cache-Control`` header) then the page will be cached until the "
"expiry time, rather than :setting:`CACHE_MIDDLEWARE_SECONDS`. Using the "
"decorators in ``django.views.decorators.cache`` you can easily set a view's "
"expiry time (using the :func:`~django.views.decorators.cache.cache_control` "
"decorator) or disable caching for a view (using the :func:`~django.views."
"decorators.cache.never_cache` decorator). See the `using other headers`__ "
"section for more on these decorators."
msgstr ""
"如果一个视图设置了它自己的缓存过期时间（比如在它的 ``Cache-Control`` header "
"里有 ``max-age`` 部分），然后页面将被缓存起来直到过期，而不是 :setting:"
"`CACHE_MIDDLEWARE_SECONDS` 。使用在 ``django.views.decorators.cache`` 的装饰"
"器，你可以很轻松的设置视图的过期时间（使用 :func:`~django.views.decorators."
"cache.cache_control` 装饰器）或者禁用视图缓存（使用 :func:`~django.views."
"decorators.cache.never_cache` 装饰器）。有关这些装饰器的更多信息，请查看 "
"`using other headers`__ 部分。"

msgid ""
"If :setting:`USE_I18N` is set to ``True`` then the generated cache key will "
"include the name of the active :term:`language<language code>` -- see also :"
"ref:`how-django-discovers-language-preference`). This allows you to easily "
"cache multilingual sites without having to create the cache key yourself."
msgstr ""
"如果设置 :setting:`USE_I18N` 为 ``True``，然后已生成的缓存键将包含动态 :term:"
"`language<language code>` 的名称（参阅 :ref:`how-django-discovers-language-"
"preference`）。这将允许你轻松缓存使用多语言的站点，而不用再创建缓存键。"

msgid ""
"Cache keys also include the :ref:`current time zone <default-current-time-"
"zone>` when :setting:`USE_TZ` is set to ``True``."
msgstr ""
"当 :setting:`USE_TZ` 被设置为 ``True`` 时，缓存键也包括 :ref:`当前时区 "
"<default-current-time-zone>`。"

msgid "The per-view cache"
msgstr "视图缓存"

msgid ""
"A more granular way to use the caching framework is by caching the output of "
"individual views. ``django.views.decorators.cache`` defines a ``cache_page`` "
"decorator that will automatically cache the view's response for you::"
msgstr ""
"使用缓存框架的通用办法是缓存视图结果。``django.views.decorators.cache`` 定义"
"了一个 ``cache_page`` 装饰器，它将自动缓存视图的响应："

msgid ""
"``cache_page`` takes a single argument: the cache timeout, in seconds. In "
"the above example, the result of the ``my_view()`` view will be cached for "
"15 minutes. (Note that we've written it as ``60 * 15`` for the purpose of "
"readability. ``60 * 15`` will be evaluated to ``900`` -- that is, 15 minutes "
"multiplied by 60 seconds per minute.)"
msgstr ""
"``cache_page`` 使用了一个单独的参数：缓存过期时间，以秒为单位。在上面的例子"
"里，``my_view()`` 视图的结果将缓存15分钟。（注意，我们用 ``60 * 15`` 这样的方"
"式编写，目的是方便阅读。 ``60 * 15`` 将计算为 ``900``，也就是15分钟乘以每分钟"
"60秒。）"

msgid ""
"The cache timeout set by ``cache_page`` takes precedence over the ``max-"
"age`` directive from the ``Cache-Control`` header."
msgstr ""
"``cache_page`` 设置的缓存超时优先于 ``Cache-Control`` 头中的 ``max-age'' 指"
"令。"

msgid ""
"The per-view cache, like the per-site cache, is keyed off of the URL. If "
"multiple URLs point at the same view, each URL will be cached separately. "
"Continuing the ``my_view`` example, if your URLconf looks like this::"
msgstr ""
"和缓存站点一样，对视图缓存，以 URL 为键。如果许多 URL 指向相同的视图，每个 "
"URL 将被单独缓存。继续以 ``my_view`` 为例，如果你的 URLconf 是这样的："

msgid ""
"then requests to ``/foo/1/`` and ``/foo/23/`` will be cached separately, as "
"you may expect. But once a particular URL (e.g., ``/foo/23/``) has been "
"requested, subsequent requests to that URL will use the cache."
msgstr ""
"那么 ``/foo/1/`` 和 ``/foo/23/`` 的请求将被分别缓存，正如你所料。但一旦部分 "
"URL （比如 ``/foo/23/`` ）已经被请求，那么随后的请求都将使用缓存。"

msgid ""
"``cache_page`` can also take an optional keyword argument, ``cache``, which "
"directs the decorator to use a specific cache (from your :setting:`CACHES` "
"setting) when caching view results. By default, the ``default`` cache will "
"be used, but you can specify any cache you want::"
msgstr ""
"``cache_page`` 也可以传递可选关键字参数 ``cache``，它指引装饰器在缓存视图结果"
"时使用特定的缓存（来自 :setting:`CACHES` 设置）。默认情况下，将使用默认缓存，"
"但你可以指定任何你想要的缓存："

msgid ""
"You can also override the cache prefix on a per-view basis. ``cache_page`` "
"takes an optional keyword argument, ``key_prefix``, which works in the same "
"way as the :setting:`CACHE_MIDDLEWARE_KEY_PREFIX` setting for the "
"middleware.  It can be used like this::"
msgstr ""
"你可以基于每个视图覆盖缓存前缀。``cache_page`` 传递了一个可选关键字参数 "
"``key_prefix`` ，它的工作方式与中间件的 :setting:"
"`CACHE_MIDDLEWARE_KEY_PREFIX` 相同。可以这样使用它："

msgid ""
"The ``key_prefix`` and ``cache`` arguments may be specified together. The "
"``key_prefix`` argument and the :setting:`KEY_PREFIX <CACHES-KEY_PREFIX>` "
"specified under :setting:`CACHES` will be concatenated."
msgstr ""
"``key_prefix`` 和 ``cache`` 参数可能需要被一起指定。``key_prefix`` 参数和 :"
"setting:`CACHES` 下指定的 :setting:`KEY_PREFIX <CACHES-KEY_PREFIX>` 将被连接"
"起来。"

msgid ""
"Additionally, ``cache_page`` automatically sets ``Cache-Control`` and "
"``Expires`` headers in the response which affect :ref:`downstream caches "
"<downstream-caches>`."
msgstr ""
"此外， ``cache_page`` 在响应中自动设置 ``Cache-Control`` 和 ``Expires`` 头， "
"这会影响 :ref:`下游缓存 <downstream-caches>`."

msgid "Specifying per-view cache in the URLconf"
msgstr "在 URLconf 中指定视图缓存"

msgid ""
"The examples in the previous section have hard-coded the fact that the view "
"is cached, because ``cache_page`` alters the ``my_view`` function in place. "
"This approach couples your view to the cache system, which is not ideal for "
"several reasons. For instance, you might want to reuse the view functions on "
"another, cache-less site, or you might want to distribute the views to "
"people who might want to use them without being cached. The solution to "
"these problems is to specify the per-view cache in the URLconf rather than "
"next to the view functions themselves."
msgstr ""
"上一节的例子硬编码了视图被缓存的事实，因为 ``cache_page`` 改变了  "
"``my_view`` 函数。这种方法将你的视图和缓存系统耦合起来，这样并不理想。例如，"
"你可能想在其他没有缓存的站点上重用这个视图函数，或者你可能想分发这个视图给那"
"些想使用视图但不想缓存它们的人员。解决这些问题的办法是在 URLconf 中指定视图缓"
"存，而不是视图函数旁边指定。"

msgid ""
"You can do so by wrapping the view function with ``cache_page`` when you "
"refer to it in the URLconf. Here's the old URLconf from earlier::"
msgstr ""
"当你在 URLconf 中使用 ``cache_page`` 时，可以这样包装视图函数。这是之前提到"
"的 URLconf："

msgid "Here's the same thing, with ``my_view`` wrapped in ``cache_page``::"
msgstr "将 ``my_view`` 包含在 ``cache_page`` 中："

msgid "Template fragment caching"
msgstr "模板片段缓存"

msgid ""
"If you're after even more control, you can also cache template fragments "
"using the ``cache`` template tag. To give your template access to this tag, "
"put ``{% load cache %}`` near the top of your template."
msgstr ""
"如果你获得更多的控制，你也可以使用 ``cache`` 模板标签(tag)来缓存模板片段。要"
"使你的模板能够访问这个标签，请将 ``{% load cache %}`` 放在模板顶部。"

msgid ""
"The ``{% cache %}`` template tag caches the contents of the block for a "
"given amount of time. It takes at least two arguments: the cache timeout, in "
"seconds, and the name to give the cache fragment. The fragment is cached "
"forever if timeout is ``None``. The name will be taken as is, do not use a "
"variable. For example:"
msgstr ""
"``{% cache %}`` 模板标签在给定的时间里缓存片段内容。它需要至少两个参数：缓存"
"时效时间（以秒为单位），缓存片段的名称。如果缓存失效时间被设置为 ``None`` ，"
"那么片段将被永久缓存。名称不能使变量名。例如："

msgid ""
"Sometimes you might want to cache multiple copies of a fragment depending on "
"some dynamic data that appears inside the fragment. For example, you might "
"want a separate cached copy of the sidebar used in the previous example for "
"every user of your site. Do this by passing one or more additional "
"arguments, which may be variables with or without filters, to the ``{% cache "
"%}`` template tag to uniquely identify the cache fragment:"
msgstr ""
"有时你想缓存片段的多个副本，这取决于显示在的片段内一些动态数据。比如，你可能"
"想为你的站点内每个用户分别独立缓存上面例子中的使用的 sidebar 副本。通过传递一"
"个或多个附加参数，参数可能是带有或不带过滤器的变量，``{% cache %}`` 模板标签"
"必须在缓存片断中被唯一识别："

msgid ""
"If :setting:`USE_I18N` is set to ``True`` the per-site middleware cache "
"will :ref:`respect the active language<i18n-cache-key>`. For the ``cache`` "
"template tag you could use one of the :ref:`translation-specific "
"variables<template-translation-vars>` available in templates to achieve the "
"same result:"
msgstr ""
"如果 :setting:`USE_I18N` 被设为 ``True``，那么站点中间件缓存将支持多语言（ :"
"ref:`respect the active language` ）。对于 ``cache`` 模板标签来说，你可以使用"
"模板中可用的特定翻译变量之一（ :ref:`translation-specific variables` ）来达到"
"同样的结果："

msgid ""
"The cache timeout can be a template variable, as long as the template "
"variable resolves to an integer value. For example, if the template variable "
"``my_timeout`` is set to the value ``600``, then the following two examples "
"are equivalent:"
msgstr ""
"缓存失效时间可以是模板变量，只要模板变量解析为一个整数值即可。例如，如果模板"
"变量 ``my_timeout`` 被设置成 ``600``，那么下面两个例子是一样的："

msgid ""
"This feature is useful in avoiding repetition in templates. You can set the "
"timeout in a variable, in one place, and reuse that value."
msgstr ""
"这个可以避免在模板中重复。你可以在某处设置缓存失效时间，然后复用这个值。"

msgid ""
"By default, the cache tag will try to use the cache called "
"\"template_fragments\". If no such cache exists, it will fall back to using "
"the default cache. You may select an alternate cache backend to use with the "
"``using`` keyword argument, which must be the last argument to the tag."
msgstr ""
"默认情况下，缓存标签会先尝试使用名为 \"template_fragments\" 的缓存。如果这个"
"缓存不存在，它将回退使用默认缓存。你可以选择一个备用缓存后端与 ``using`` 关键"
"字参数一起使用，这个参数必须是标签的最后一个参数。"

msgid ""
"It is considered an error to specify a cache name that is not configured."
msgstr "未设置指定的缓存名称将被视为错误。"

msgid ""
"If you want to obtain the cache key used for a cached fragment, you can use "
"``make_template_fragment_key``. ``fragment_name`` is the same as second "
"argument to the ``cache`` template tag; ``vary_on`` is a list of all "
"additional arguments passed to the tag. This function can be useful for "
"invalidating or overwriting a cached item, for example:"
msgstr ""
"如果你想获得用于缓存片段的缓存键，你可以使用 "
"``make_template_fragment_key`` 。``fragment_name`` 是 ``cache`` 模板标签的第"
"二个参数；``vary_on`` 是所有传递给标签的附加参数列表。这个函数可用来使缓存项"
"无效或者重写。例如："

msgid "The low-level cache API"
msgstr "底层缓存 API"

msgid ""
"Sometimes, caching an entire rendered page doesn't gain you very much and "
"is, in fact, inconvenient overkill."
msgstr "有时，缓存整个渲染页面并不会带来太多好处，事实上，这样会很不方便。"

msgid ""
"Perhaps, for instance, your site includes a view whose results depend on "
"several expensive queries, the results of which change at different "
"intervals. In this case, it would not be ideal to use the full-page caching "
"that the per-site or per-view cache strategies offer, because you wouldn't "
"want to cache the entire result (since some of the data changes often), but "
"you'd still want to cache the results that rarely change."
msgstr ""
"或许，你的站点包含了一个视图，它的结果依赖于许多费时的查询，而且结果会随着时"
"间变化而改变。在这个情况下，使用站点或视图缓存策略提供的全页面缓存并不理想，"
"因为不能缓存所有结果（一些数据经常变动），不过你仍然可以缓存几乎没有变化的结"
"果。"

msgid ""
"For cases like this, Django exposes a low-level cache API. You can use this "
"API to store objects in the cache with any level of granularity you like.  "
"You can cache any Python object that can be pickled safely: strings, "
"dictionaries, lists of model objects, and so forth. (Most common Python "
"objects can be pickled; refer to the Python documentation for more "
"information about pickling.)"
msgstr ""
"像这样的情况，Django 公开了一个底层的缓存 API 。你可以使用这个 API 以任意级别"
"粒度在缓存中存储对象。你可以缓存任何可以安全的 pickle 的 Python 对象：模型对"
"象的字符串、字典、列表，或者其他。（大部分通用的 Python 对象都可以被 pickle；"
"可以参考 Python 文档关于 pickling 的信息）"

msgid "Accessing the cache"
msgstr "访问缓存"

msgid ""
"You can access the caches configured in the :setting:`CACHES` setting "
"through a dict-like object: ``django.core.cache.caches``. Repeated requests "
"for the same alias in the same thread will return the same object."
msgstr ""
"你可以通过类似字典一样的  object: ``django.core.cache.caches`` 对象访问在 :"
"setting:`CACHES` 配置的缓存。重复请求同一个线程里的同一个别名将返回同一个对"
"象。"

msgid ""
"If the named key does not exist, ``InvalidCacheBackendError`` will be raised."
msgstr "如果键名不存在，将会引发 ``InvalidCacheBackendError`` 错误。"

msgid ""
"To provide thread-safety, a different instance of the cache backend will be "
"returned for each thread."
msgstr "为了支持线程安全，将为每个线程返回缓存后端的不同实例。"

msgid ""
"As a shortcut, the default cache is available as ``django.core.cache."
"cache``::"
msgstr "作为快捷方式，默认缓存可以通过 ``django.core.cache.cache`` 引用："

msgid "This object is equivalent to ``caches['default']``."
msgstr "这个对象等价于 ``caches['default']`` 。"

msgid "Basic usage"
msgstr "基本用法"

msgid "The basic interface is:"
msgstr "基本接口是："

msgid ""
"``key`` should be a ``str``, and ``value`` can be any picklable Python "
"object."
msgstr ""
"``key`` 是一个字符串，``value`` 可以任何 picklable 形式的 Python 对象。"

msgid ""
"The ``timeout`` argument is optional and defaults to the ``timeout`` "
"argument of the appropriate backend in the :setting:`CACHES` setting "
"(explained above). It's the number of seconds the value should be stored in "
"the cache. Passing in ``None`` for ``timeout`` will cache the value forever. "
"A ``timeout`` of ``0`` won't cache the value."
msgstr ""
"``timeout`` 参数是可选的，默认为 :setting:`CACHES` 中相应后端的 ``timeout`` "
"参数。它是值存在缓存里的秒数。``timeout`` 设置为 ``None`` 时将永久缓存。"
"``timeout`` 为0将不缓存值。"

msgid ""
"If the object doesn't exist in the cache, ``cache.get()`` returns ``None``::"
msgstr "如果对象不在缓存中，``cache.get()`` 将返回 ``None``。"

msgid ""
"If you need to determine whether the object exists in the cache and you have "
"stored a literal value ``None``, use a sentinel object as the default::"
msgstr ""
"如果你需要确定对象是否存在于缓存中，并且你已经存储了一个字面值 ``None``，使用"
"一个前哨对象作为默认："

msgid "``MemcachedCache``"
msgstr "``MemcachedCache``"

msgid ""
"Due to a ``python-memcached`` limitation, it's not possible to distinguish "
"between stored ``None`` value and a cache miss signified by a return value "
"of ``None`` on the deprecated ``MemcachedCache`` backend."
msgstr ""
"由于 ``python-memcached`` 的限制，在已废弃的 ``MemcachedCache`` 后端，不可能"
"区分存储的 ``None`` 值和返回值为 ``None`` 的缓存失效。"

msgid ""
"``cache.get()`` can take a ``default`` argument. This specifies which value "
"to return if the object doesn't exist in the cache::"
msgstr ""
"``cache.get()`` 可以带一个默认参数。如果对象不在缓存中，将返回指定的值。"

msgid ""
"To add a key only if it doesn't already exist, use the ``add()`` method. It "
"takes the same parameters as ``set()``, but it will not attempt to update "
"the cache if the key specified is already present::"
msgstr ""
"在键不存在的时候，使用 ``add()`` 方法可以添加键。它与 ``set()`` 带有相同的参"
"数，但如果指定的键已经存在，将不会尝试更新缓存。"

msgid ""
"If you need to know whether ``add()`` stored a value in the cache, you can "
"check the return value. It will return ``True`` if the value was stored, "
"``False`` otherwise."
msgstr ""
"如果你想知道通过 ``add()`` 存储的值是否在缓存中，你可以检查返回值。如果值已保"
"存，将返回 ``True`` ，否则返回 ``False`` 。"

msgid ""
"If you want to get a key's value or set a value if the key isn't in the "
"cache, there is the ``get_or_set()`` method. It takes the same parameters as "
"``get()`` but the default is set as the new cache value for that key, rather "
"than returned::"
msgstr ""
"如果你想得到键值或者如果键不在缓存中时设置一个值，可以使用 ``get_or_set()`` "
"方法。它带有和 ``get()`` 一样的参数，但默认是为那个键设置一个新缓存值，而不是"
"返回："

msgid "You can also pass any callable as a *default* value::"
msgstr "你也可以传递任何可调用的值作为默认值："

msgid ""
"There's also a ``get_many()`` interface that only hits the cache once. "
"``get_many()`` returns a dictionary with all the keys you asked for that "
"actually exist in the cache (and haven't expired)::"
msgstr ""
"这里也有 ``get_many()`` 接口，返回一个字典，其中包含你请求的键，这些键真实存"
"在缓存中（并且没过期）："

msgid ""
"To set multiple values more efficiently, use ``set_many()`` to pass a "
"dictionary of key-value pairs::"
msgstr "使用 ``set_many()`` 传递键值对的字典，可以更有效的设置多个值。"

msgid ""
"Like ``cache.set()``, ``set_many()`` takes an optional ``timeout`` parameter."
msgstr "类似 ``cache.set()``，``set_many()`` 带有一个可选的 ``timeout`` 参数。"

msgid ""
"On supported backends (memcached), ``set_many()`` returns a list of keys "
"that failed to be inserted."
msgstr "在已支持的后端（memcached），``set_many()`` 会返回无法插入的键列表。"

msgid ""
"You can delete keys explicitly with ``delete()`` to clear the cache for a "
"particular object::"
msgstr "你可以使用 ``delete()`` 显示地删除键，以清空特定对象的缓存："

msgid ""
"``delete()`` returns ``True`` if the key was successfully deleted, ``False`` "
"otherwise."
msgstr "如果键被成功删除，将返回 ``delete()`` ，否则返回 ``False`` 。"

msgid ""
"If you want to clear a bunch of keys at once, ``delete_many()`` can take a "
"list of keys to be cleared::"
msgstr ""
"如果你想一次性清除很多键，给 ``delete_many()`` 传递一个键列表即可删除。"

msgid ""
"Finally, if you want to delete all the keys in the cache, use ``cache."
"clear()``.  Be careful with this; ``clear()`` will remove *everything* from "
"the cache, not just the keys set by your application. ::"
msgstr ""
"最后，如果你想删除缓存里的所有键，使用 ``cache.clear()``。注意，``clear()`` "
"将删除缓存里的 *任何* 键，不只是你应用里设置的那些键。"

msgid ""
"``cache.touch()`` sets a new expiration for a key. For example, to update a "
"key to expire 10 seconds from now::"
msgstr ""
"``cache.touch()`` 为键设置一个新的过期时间。比如，更新一个键为从现在起10秒钟"
"后过期："

msgid ""
"Like other methods, the ``timeout`` argument is optional and defaults to the "
"``TIMEOUT`` option of the appropriate backend in the :setting:`CACHES` "
"setting."
msgstr ""
"和其他方法一样，``timeout`` 参数是可选的，并且默认是 :setting:`CACHES` 设置的"
"相应后端的 ``TIMEOUT`` 选项。"

msgid ""
"``touch()`` returns ``True`` if the key was successfully touched, ``False`` "
"otherwise."
msgstr "如果键被成功 ``touch()``，将返回 ``True``，否则返回 ``False``。"

msgid ""
"You can also increment or decrement a key that already exists using the "
"``incr()`` or ``decr()`` methods, respectively. By default, the existing "
"cache value will be incremented or decremented by 1. Other increment/"
"decrement values can be specified by providing an argument to the increment/"
"decrement call. A ValueError will be raised if you attempt to increment or "
"decrement a nonexistent cache key.::"
msgstr ""
"你也可以使用分别使用 ``incr()`` 或 ``decr()`` 方法来递增或递减一个已经存在的"
"键的值。默认情况下，存在的缓存值将递增或递减1。通过为递增/递减的调用提供参数"
"来指定其他递增/递减值。如果你试图递增或递减一个不存在的缓存键，将会引发 "
"ValueError 错误。"

msgid ""
"``incr()``/``decr()`` methods are not guaranteed to be atomic. On those "
"backends that support atomic increment/decrement (most notably, the "
"memcached backend), increment and decrement operations will be atomic. "
"However, if the backend doesn't natively provide an increment/decrement "
"operation, it will be implemented using a two-step retrieve/update."
msgstr ""
"不保证 ``incr()`` / ``decr()`` 方法是原子。那些后端支持原子递增/递减（最值得"
"注意的是 memcached 后端），递增和递减操作是原子的。然而，如果后端本身没有提供"
"递增/递减方法，则将使用两步（检索和更新）来实现。"

msgid ""
"You can close the connection to your cache with ``close()`` if implemented "
"by the cache backend."
msgstr "如果缓存后端已经实现了 ``close()`` 方法，你可以关闭和缓存的连接。"

msgid "For caches that don't implement ``close`` methods it is a no-op."
msgstr "对于没有实现 ``close`` 方法的缓存，它将无效操作。"

msgid ""
"The async variants of base methods are prefixed with ``a``, e.g. ``cache."
"aadd()`` or ``cache.adelete_many()``. See `Asynchronous support`_ for more "
"details."
msgstr ""

msgid "The async variants of methods were added to the ``BaseCache``."
msgstr ""

msgid "Cache key prefixing"
msgstr "缓存键前缀"

msgid ""
"If you are sharing a cache instance between servers, or between your "
"production and development environments, it's possible for data cached by "
"one server to be used by another server. If the format of cached data is "
"different between servers, this can lead to some very hard to diagnose "
"problems."
msgstr ""
"如果你正在服务器之间或者生产/开发缓存之间共享缓存实例，有可能会使得一个服务器"
"使用另一个服务器的缓存数据。如果缓存数据格式是相同的，这会导致一些难以诊断的"
"问题。"

msgid ""
"To prevent this, Django provides the ability to prefix all cache keys used "
"by a server. When a particular cache key is saved or retrieved, Django will "
"automatically prefix the cache key with the value of the :setting:"
"`KEY_PREFIX <CACHES-KEY_PREFIX>` cache setting."
msgstr ""
"为了防止这个问题，Django 为单台服务器提供了为所有缓存键提供前缀的方法。当一个"
"特殊的缓存键被保存或检索时，Django 会为缓存键自动添加 :setting:`KEY_PREFIX "
"<CACHES-KEY_PREFIX>` 缓存设置的前缀值。"

msgid ""
"By ensuring each Django instance has a different :setting:`KEY_PREFIX "
"<CACHES-KEY_PREFIX>`, you can ensure that there will be no collisions in "
"cache values."
msgstr ""
"要确保每个 Django 实例有不同的 :setting:`KEY_PREFIX <CACHES-KEY_PREFIX>` ，这"
"样就保证缓存值不会发生冲突。"

msgid "Cache versioning"
msgstr "缓存版本控制"

msgid ""
"When you change running code that uses cached values, you may need to purge "
"any existing cached values. The easiest way to do this is to flush the "
"entire cache, but this can lead to the loss of cache values that are still "
"valid and useful."
msgstr ""
"当更改使用缓存值的运行代码时，你可能需要清除任何已存的缓存值。最简单的方法是"
"刷新整个缓存，但这会导致那些仍然有用且有效的缓存值。"

msgid ""
"Django provides a better way to target individual cache values. Django's "
"cache framework has a system-wide version identifier, specified using the :"
"setting:`VERSION <CACHES-VERSION>` cache setting. The value of this setting "
"is automatically combined with the cache prefix and the user-provided cache "
"key to obtain the final cache key."
msgstr ""
"Django 提供更好的方式来指向单个缓存值。Django 缓存框架有一个系统范围的版本标"
"识，需要在 :setting:`VERSION <CACHES-VERSION>` 缓存配置中指定。这个配置的值将"
"自动与缓存前缀和用户提供的缓存键组合起来获取最终的缓存键。"

msgid ""
"By default, any key request will automatically include the site default "
"cache key version. However, the primitive cache functions all include a "
"``version`` argument, so you can specify a particular cache key version to "
"set or get. For example::"
msgstr ""
"默认情况下，任何键请求将自动包含站点默认缓存键版本。但是，早期的缓存函数都包"
"含一个 ``version`` 参数，因此你可以指定 set 还是 get 特定缓存键的版本。举例："

msgid ""
"The version of a specific key can be incremented and decremented using the "
"``incr_version()`` and ``decr_version()`` methods. This enables specific "
"keys to be bumped to a new version, leaving other keys unaffected. "
"Continuing our previous example::"
msgstr ""
"一个指定键的版本可以使用 ``incr_version()`` 和 ``decr_version()`` 方法来递增"
"或递减。这使得特定键会自动获取新版本，而不影响其他键。继续我们前面的例子："

msgid "Cache key transformation"
msgstr "缓存键转换"

msgid ""
"As described in the previous two sections, the cache key provided by a user "
"is not used verbatim -- it is combined with the cache prefix and key version "
"to provide a final cache key. By default, the three parts are joined using "
"colons to produce a final string::"
msgstr ""
"如前面两节所述，用户提供的缓存键不是单独使用的，它是与缓存前缀和键版本组合后"
"获取最终缓存键。默认情况下，使用冒号连接这三部分生成最终的字符串："

msgid ""
"If you want to combine the parts in different ways, or apply other "
"processing to the final key (e.g., taking a hash digest of the key parts), "
"you can provide a custom key function."
msgstr ""
"如果你想用不同方式组合，或者应用其他处理来获得最终键（比如，获得关键部分的哈"
"希摘要），那么你可以提供一个自定义的键函数。"

msgid ""
"The :setting:`KEY_FUNCTION <CACHES-KEY_FUNCTION>` cache setting specifies a "
"dotted-path to a function matching the prototype of ``make_key()`` above. If "
"provided, this custom key function will be used instead of the default key "
"combining function."
msgstr ""
":setting:`KEY_FUNCTION <CACHES-KEY_FUNCTION>` 缓存设置指定一个与上面的 "
"``make_key()`` 原型匹配的函数路径。如果提供，这个自定义键函数将代替默认的键组"
"合函数来使用。"

msgid "Cache key warnings"
msgstr "缓存键警告"

msgid ""
"Memcached, the most commonly-used production cache backend, does not allow "
"cache keys longer than 250 characters or containing whitespace or control "
"characters, and using such keys will cause an exception. To encourage cache-"
"portable code and minimize unpleasant surprises, the other built-in cache "
"backends issue a warning (``django.core.cache.backends.base."
"CacheKeyWarning``) if a key is used that would cause an error on memcached."
msgstr ""
"Memcached 作为最常用的缓存后端，不允许缓存键超过250个字符、包含空格或控制字"
"符，并且使用这些键将会导致异常。为了增加代码可移植性和最小惊讶，如果使用会导"
"致 memcached 报错的键，那么其他内置的缓存框架会发出警告（ ``django.core."
"cache.backends.base.CacheKeyWarning`` ）。"

msgid ""
"If you are using a production backend that can accept a wider range of keys "
"(a custom backend, or one of the non-memcached built-in backends), and want "
"to use this wider range without warnings, you can silence "
"``CacheKeyWarning`` with this code in the ``management`` module of one of "
"your :setting:`INSTALLED_APPS`::"
msgstr ""
"如果你正在使用的生产后端能接受更大范围的键（自定义后端或非 memcached 的内置后"
"端），并且在没有警告的情况下使用更广的范围，你可以在 :setting:"
"`INSTALLED_APPS` 中的 ``management`` 模块里静默 ``CacheKeyWarning`` 使用这个"
"代码："

msgid ""
"If you want to instead provide custom key validation logic for one of the "
"built-in backends, you can subclass it, override just the ``validate_key`` "
"method, and follow the instructions for `using a custom cache backend`_. For "
"instance, to do this for the ``locmem`` backend, put this code in a module::"
msgstr ""
"如果你想为某个内置的后端提供自定义的键检验逻辑，你可以将其子类化，只覆盖 "
"``validate_key`` 方法，并且按照 ``使用自定义缓存后端`` 的说明操作。比如，想要"
"为 ``locmem`` 后端执行此操作，请将下面代码放入模块中："

msgid ""
"...and use the dotted Python path to this class in the :setting:`BACKEND "
"<CACHES-BACKEND>` portion of your :setting:`CACHES` setting."
msgstr ""
"...然后在 :setting:`CACHES` 里的 :setting:`BACKEND <CACHES-BACKEND>` 部分使用"
"路径导入此类。"

msgid ""
"Django has developing support for asynchronous cache backends, but does not "
"yet support asynchronous caching. It will be coming in a future release."
msgstr ""

msgid ""
"``django.core.cache.backends.base.BaseCache`` has async variants of :ref:"
"`all base methods <cache-basic-interface>`. By convention, the asynchronous "
"versions of all methods are prefixed with ``a``. By default, the arguments "
"for both variants are the same::"
msgstr ""

msgid "Downstream caches"
msgstr "下游缓存"

msgid ""
"So far, this document has focused on caching your *own* data. But another "
"type of caching is relevant to web development, too: caching performed by "
"\"downstream\" caches. These are systems that cache pages for users even "
"before the request reaches your website."
msgstr ""

msgid "Here are a few examples of downstream caches:"
msgstr "下面是一些下游缓存的例子："

msgid ""
"When using HTTP, your :abbr:`ISP (Internet Service Provider)` may cache "
"certain pages, so if you requested a page from ``http://example.com/``, your "
"ISP would send you the page without having to access example.com directly. "
"The maintainers of example.com have no knowledge of this caching; the ISP "
"sits between example.com and your web browser, handling all of the caching "
"transparently. Such caching is not possible under HTTPS as it would "
"constitute a man-in-the-middle attack."
msgstr ""

msgid ""
"Your Django website may sit behind a *proxy cache*, such as Squid Web Proxy "
"Cache (http://www.squid-cache.org/), that caches pages for performance. In "
"this case, each request first would be handled by the proxy, and it would be "
"passed to your application only if needed."
msgstr ""
"您的 Django 网站可能会在一个*代理缓存*的后面，例如Squid 网页代理缓存（http://"
"www.squid-cache.org/），为了性能而缓存页面。在这种情况下，每个请求首先由代理"
"来处理，只有在需要时才将其传递给应用程序。"

msgid ""
"Your web browser caches pages, too. If a web page sends out the appropriate "
"headers, your browser will use the local cached copy for subsequent requests "
"to that page, without even contacting the web page again to see whether it "
"has changed."
msgstr ""

msgid ""
"Downstream caching is a nice efficiency boost, but there's a danger to it: "
"Many web pages' contents differ based on authentication and a host of other "
"variables, and cache systems that blindly save pages based purely on URLs "
"could expose incorrect or sensitive data to subsequent visitors to those "
"pages."
msgstr ""

msgid ""
"For example, if you operate a web email system, then the contents of the "
"\"inbox\" page depend on which user is logged in. If an ISP blindly cached "
"your site, then the first user who logged in through that ISP would have "
"their user-specific inbox page cached for subsequent visitors to the site.  "
"That's not cool."
msgstr ""

msgid ""
"Fortunately, HTTP provides a solution to this problem. A number of HTTP "
"headers exist to instruct downstream caches to differ their cache contents "
"depending on designated variables, and to tell caching mechanisms not to "
"cache particular pages. We'll look at some of these headers in the sections "
"that follow."
msgstr ""
"幸运的是，HTTP 为这个问题提供了解决方案。存在许多 HTTP 报头以指示下游缓存根据"
"指定的变量来区分它们的缓存内容，并且告诉缓存机制不缓存特定的页面。我们将在下"
"面的章节中查看这些标题。"

msgid "Using ``Vary`` headers"
msgstr "使用 ``Vary`` 标头"

msgid ""
"The ``Vary`` header defines which request headers a cache mechanism should "
"take into account when building its cache key. For example, if the contents "
"of a web page depend on a user's language preference, the page is said to "
"\"vary on language.\""
msgstr ""

msgid ""
"By default, Django's cache system creates its cache keys using the requested "
"fully-qualified URL -- e.g., ``\"https://www.example.com/stories/2005/?"
"order_by=author\"``. This means every request to that URL will use the same "
"cached version, regardless of user-agent differences such as cookies or "
"language preferences. However, if this page produces different content based "
"on some difference in request headers -- such as a cookie, or a language, or "
"a user-agent -- you'll need to use the ``Vary`` header to tell caching "
"mechanisms that the page output depends on those things."
msgstr ""
"默认情况下，Django 的缓存系统使用请求的完全合格的URL创建它的缓存密钥——例如，"
"``\"https://www.example.com/stories/2005/?order_by=author\"``。这意味着对该 "
"URL 的每个请求都将使用相同的缓存版本，而不管用户代理差异（如 cookies 或语言首"
"选项）。但是，如果这个页面基于请求头（如 cookie、语言或用户代理）中的某些差异"
"而产生不同的内容，则需要使用``Vary`` 标头来告诉缓存机制，页面输出取决于这些东"
"西。"

msgid ""
"To do this in Django, use the convenient :func:`django.views.decorators.vary."
"vary_on_headers` view decorator, like so::"
msgstr ""
"要在 Django 中执行此操作，请使用方便的 :func:`django.views.decorators.vary."
"vary_on_headers` 视图装饰器，像这样："

msgid ""
"In this case, a caching mechanism (such as Django's own cache middleware) "
"will cache a separate version of the page for each unique user-agent."
msgstr ""
"在这里，一个缓存机制（比如 Django 自带的缓存中间件）将为每一个唯一的用户代理"
"缓存一个独立的页面版本。"

msgid ""
"The advantage to using the ``vary_on_headers`` decorator rather than "
"manually setting the ``Vary`` header (using something like ``response."
"headers['Vary'] = 'user-agent'``) is that the decorator *adds* to the "
"``Vary`` header (which may already exist), rather than setting it from "
"scratch and potentially overriding anything that was already in there."
msgstr ""
"使用 ``vary_on_headers`` 装饰器而不是手动设置 ``Vary`` 头（使用 ``response."
"headers['Vary'] = 'user-agent'``）的好处是，装饰器 *添加* 到 ``Vary `` 头（可"
"能已经存在），而不是从头开始设置，可能会覆盖已经存在的东西。"

msgid "You can pass multiple headers to ``vary_on_headers()``::"
msgstr "你可以传递多个头参数给 ``vary_on_headers()``："

msgid ""
"This tells downstream caches to vary on *both*, which means each combination "
"of user-agent and cookie will get its own cache value. For example, a "
"request with the user-agent ``Mozilla`` and the cookie value ``foo=bar`` "
"will be considered different from a request with the user-agent ``Mozilla`` "
"and the cookie value ``foo=ham``."
msgstr ""
"这告诉下游缓存两者有所不同，意味着每个用户代理和 cookie 的组合将获取它自己的"
"缓存值。比如，一个请求带有用户代理 ``Mozilla`` 和 cookie 值 ``foo=bar`` 被认"
"为和用户代理 ``Mozilla`` 和 cookie 值 ``foo=ham`` 是不同的。"

msgid ""
"Because varying on cookie is so common, there's a :func:`django.views."
"decorators.vary.vary_on_cookie` decorator. These two views are equivalent::"
msgstr ""
"因为 cookie 的变化如此普遍，所以这里有个 :func:`django.views.decorators.vary."
"vary_on_cookie` 装饰器。这两个视图是等价的："

msgid ""
"The headers you pass to ``vary_on_headers`` are not case sensitive; ``\"User-"
"Agent\"`` is the same thing as ``\"user-agent\"``."
msgstr ""
"传递给 ``vary_on_headers`` 的头是不区分大小写的；``\"User-Agent\"`` 和 ``"
"\"user-agent\"`` 是一样的。"

msgid ""
"You can also use a helper function, :func:`django.utils.cache."
"patch_vary_headers`, directly. This function sets, or adds to, the ``Vary "
"header``. For example::"
msgstr ""
"你也可以直接使用帮助函数 :func:`django.utils.cache.patch_vary_headers` 。这个"
"函数可以设置或添加 ``Vary header`` 。比如："

msgid ""
"``patch_vary_headers`` takes an :class:`~django.http.HttpResponse` instance "
"as its first argument and a list/tuple of case-insensitive header names as "
"its second argument."
msgstr ""
"``patch_vary_headers`` 带有一个 :class:`~django.http.HttpResponse` 作为它的第"
"一个参数，一个不区分大小写的头名的列表/元组作为它的第二个参数。"

msgid ""
"For more on Vary headers, see the :rfc:`official Vary spec "
"<7231#section-7.1.4>`."
msgstr ""
"获取更多关于 Vary 头部信息，请查阅 :rfc:`official Vary spec "
"<7231#section-7.1.4>`。"

msgid "Controlling cache: Using other headers"
msgstr "使用其他标头控制高速缓存"

msgid ""
"Other problems with caching are the privacy of data and the question of "
"where data should be stored in a cascade of caches."
msgstr "缓存的其他问题是数据的隐私和数据应该存储在缓存的级联中的问题。"

msgid ""
"A user usually faces two kinds of caches: their own browser cache (a private "
"cache) and their provider's cache (a public cache). A public cache is used "
"by multiple users and controlled by someone else. This poses problems with "
"sensitive data--you don't want, say, your bank account number stored in a "
"public cache. So web applications need a way to tell caches which data is "
"private and which is public."
msgstr ""

msgid ""
"The solution is to indicate a page's cache should be \"private.\" To do this "
"in Django, use the :func:`~django.views.decorators.cache.cache_control` view "
"decorator. Example::"
msgstr ""
"解决方案是指出一个页面的缓存应该是“私有的”。在 Django中，使用 :func:`~django."
"views.decorators.cache.cache_control` 。例子："

msgid ""
"This decorator takes care of sending out the appropriate HTTP header behind "
"the scenes."
msgstr "这个装饰器负责在场景后面发送适当的 HTTP 头。"

msgid ""
"Note that the cache control settings \"private\" and \"public\" are mutually "
"exclusive. The decorator ensures that the \"public\" directive is removed if "
"\"private\" should be set (and vice versa). An example use of the two "
"directives would be a blog site that offers both private and public entries. "
"Public entries may be cached on any shared cache. The following code uses :"
"func:`~django.utils.cache.patch_cache_control`, the manual way to modify the "
"cache control header (it is internally called by the :func:`~django.views."
"decorators.cache.cache_control` decorator)::"
msgstr ""
"注意，缓存控制设置“私有”和“公共”是互斥的。装饰器确保“公共”指令被移除，如果应"
"该设置“私有”（反之亦然）。这两个指令的一个示例使用将是一个提供私人和公共条目"
"的博客站点。公共条目可以缓存在任何共享缓存上。下面的代码使用 :func:`~django."
"utils.cache.patch_cache_control`，手动修改缓存控制头的方法（内部调用的是 :"
"func:`~django.views.decorators.cache.cache_control` 装饰器）："

msgid ""
"You can control downstream caches in other ways as well (see :rfc:`7234` for "
"details on HTTP caching). For example, even if you don't use Django's server-"
"side cache framework, you can still tell clients to cache a view for a "
"certain amount of time with the :rfc:`max-age <7234#section-5.2.2.8>` "
"directive::"
msgstr ""
"你也可以通过其他方式控制下游缓存（关于 HTTP 缓存的细节请查阅 :rfc:`7234` ）。"
"比如，即使你没有使用 Django 服务器端的缓存框架，你仍然可以告诉客户端使用 :"
"rfc:`max-age <7234#section-5.2.2.8>` 指令缓存视图一段时间。"

msgid ""
"(If you *do* use the caching middleware, it already sets the ``max-age`` "
"with the value of the :setting:`CACHE_MIDDLEWARE_SECONDS` setting. In that "
"case, the custom ``max_age`` from the :func:`~django.views.decorators.cache."
"cache_control` decorator will take precedence, and the header values will be "
"merged correctly.)"
msgstr ""
"（如果你使用缓存中间件，它已经使用 :setting:`CACHE_MIDDLEWARE_SECONDS` 设置的"
"值设置了 ``max-age`` 。在这个例子里，:func:`~django.views.decorators.cache."
"cache_control` 装饰器里自定义的 ``max_age`` 将被优先使用，头值将被正确合"
"并。）"

msgid ""
"Any valid ``Cache-Control`` response directive is valid in "
"``cache_control()``. Here are some more examples:"
msgstr ""
"任何有效的 ``Cache-Control`` 响应指令在 ``cache_control()`` 中是有效的。这里"
"有很多例子："

msgid "``no_transform=True``"
msgstr "``no_transform=True``"

msgid "``must_revalidate=True``"
msgstr "``must_revalidate=True``"

msgid "``stale_while_revalidate=num_seconds``"
msgstr "``stale_while_revalidate=num_seconds``"

msgid "``no_cache=True``"
msgstr "``no_cache=True``"

msgid ""
"The full list of known directives can be found in the `IANA registry`_ (note "
"that not all of them apply to responses)."
msgstr ""
"已知指令的列表在  `IANA registry` 都能被找到（注意不是所有的都适用于响应）。"

msgid ""
"If you want to use headers to disable caching altogether, :func:`~django."
"views.decorators.cache.never_cache` is a view decorator that adds headers to "
"ensure the response won't be cached by browsers or other caches. Example::"
msgstr ""
"如果你想使用头部来完全禁用缓存，:func:`~django.views.decorators.cache."
"never_cache` 是一个视图装饰器，用来添加头部确保响应不被浏览器或其他缓存进行缓"
"存。比如："

msgid "Order of ``MIDDLEWARE``"
msgstr "``MIDDLEWARE`` 顺序"

msgid ""
"If you use caching middleware, it's important to put each half in the right "
"place within the :setting:`MIDDLEWARE` setting. That's because the cache "
"middleware needs to know which headers by which to vary the cache storage. "
"Middleware always adds something to the ``Vary`` response header when it can."
msgstr ""
"如果使用缓存中间件，重要的是将每一半放在 :setting:`MIDDLEWARE` 设置的正确位"
"置。这是因为缓存中间件需要知道哪些头可以改变缓存存储。中间件总是可以在 "
"``Vary`` 响应头中添加一些东西。"

msgid ""
"``UpdateCacheMiddleware`` runs during the response phase, where middleware "
"is run in reverse order, so an item at the top of the list runs *last* "
"during the response phase. Thus, you need to make sure that "
"``UpdateCacheMiddleware`` appears *before* any other middleware that might "
"add something to the ``Vary`` header. The following middleware modules do so:"
msgstr ""
"``UpdateCacheMiddleware`` 在响应阶段运行，其中中间件以相反的顺序运行，因此列"
"表顶部的项目在响应阶段的*最后*运行。因此，您需要确保 "
"``UpdateCacheMiddleware`` 出现在任何其他可能添加到 ``Vary`` 标头的其他中间件*"
"之前*。下面的中间件模块类似："

msgid "``SessionMiddleware`` adds ``Cookie``"
msgstr "``SessionMiddleware`` 添加 ``Cookie``"

msgid "``GZipMiddleware`` adds ``Accept-Encoding``"
msgstr "``GZipMiddleware`` 添加 ``Accept-Encoding``"

msgid "``LocaleMiddleware`` adds ``Accept-Language``"
msgstr "``LocaleMiddleware`` 添加 ``Accept-Language``"

msgid ""
"``FetchFromCacheMiddleware``, on the other hand, runs during the request "
"phase, where middleware is applied first-to-last, so an item at the top of "
"the list runs *first* during the request phase. The "
"``FetchFromCacheMiddleware`` also needs to run after other middleware "
"updates the ``Vary`` header, so ``FetchFromCacheMiddleware`` must be *after* "
"any item that does so."
msgstr ""
"另一方面，``FetchFromCacheMiddleware`` 在请求阶段运行，从头到尾应用中间件，因"
"此列表顶部的条目首先在请求阶段运行。在其他中间件更新 ``Vary`` 头部后，"
"``FetchFromCacheMiddleware`` 也需要运行，因此 ``FetchFromCacheMiddleware`` 必"
"须在任何条目之后运行。"

msgid "System check framework"
msgstr "系统检查框架"

msgid ""
"The system check framework is a set of static checks for validating Django "
"projects. It detects common problems and provides hints for how to fix them. "
"The framework is extensible so you can easily add your own checks."
msgstr ""
"系统检查框架是一组验证Django项目的静态检查。 它检测到常见的问题，并提供了如何"
"解决这些问题的提示。 该框架是可扩展的，所以你可以轻松地添加自己的检查。"

msgid ""
"Checks can be triggered explicitly via the :djadmin:`check` command. Checks "
"are triggered implicitly before most commands, including :djadmin:"
"`runserver` and :djadmin:`migrate`. For performance reasons, checks are not "
"run as part of the WSGI stack that is used in deployment. If you need to run "
"system checks on your deployment server, trigger them explicitly using :"
"djadmin:`check`."
msgstr ""
"通过 :djadmin:`check` 命令来显示的触发检查操作。检查会在大多数命令之前被隐式"
"触发，包括 :djadmin:`runserver` 和 :djadmin:`migrate` 。出于性能原因，检查不"
"会作为部署中使用的 WSGI 堆栈的一部分来运行。如果你需要在部署系统上运行系统检"
"查，可以使用 :djadmin:`check` 来触发他们。"

msgid ""
"Serious errors will prevent Django commands (such as :djadmin:`runserver`) "
"from running at all. Minor problems are reported to the console. If you have "
"inspected the cause of a warning and are happy to ignore it, you can hide "
"specific warnings using the :setting:`SILENCED_SYSTEM_CHECKS` setting in "
"your project settings file."
msgstr ""
"严重的错误将阻止 Django 命令（比如 :djadmin:`runserver`）运行。小问题将会在控"
"制台上报告出来。如果你已经检查了警告的原因并愿意忽略它，你可以在 settings.py "
"文件里的 :setting:`SILENCED_SYSTEM_CHECKS` 设置隐藏指定的警告。"

msgid ""
"A full list of all checks that can be raised by Django can be found in the :"
"doc:`System check reference </ref/checks>`."
msgstr ""
"Django 引发的所有检查的完整列表在 :doc:`System check reference </ref/"
"checks>` 中可查。"

msgid "Writing your own checks"
msgstr "编写自定义的检查"

msgid ""
"The framework is flexible and allows you to write functions that perform any "
"other kind of check you may require. The following is an example stub check "
"function::"
msgstr "框架是可伸缩的，并且允许你编写函数来执行其他你需要的其他检查。举例："

msgid ""
"The check function *must* accept an ``app_configs`` argument; this argument "
"is the list of applications that should be inspected. If ``None``, the check "
"must be run on *all* installed apps in the project."
msgstr ""

msgid ""
"The check will receive a ``databases`` keyword argument. This is a list of "
"database aliases whose connections may be used to inspect database level "
"configuration. If ``databases`` is ``None``, the check must not use any "
"database connections."
msgstr ""

msgid "The ``**kwargs`` argument is required for future expansion."
msgstr ""

msgid "Messages"
msgstr "消息"

msgid ""
"The function must return a list of messages. If no problems are found as a "
"result of the check, the check function must return an empty list."
msgstr ""
"函数必须返回消息列表。如果检查结果没有发现问题，检查函数必须返回空列表。"

msgid ""
"The warnings and errors raised by the check method must be instances of :"
"class:`~django.core.checks.CheckMessage`. An instance of :class:`~django."
"core.checks.CheckMessage` encapsulates a single reportable error or warning. "
"It also provides context and hints applicable to the message, and a unique "
"identifier that is used for filtering purposes."
msgstr ""
"警告和错误由必须是 :class:`~django.core.checks.CheckMessage` 的检查方法引"
"发。:class:`~django.core.checks.CheckMessage` 的实例概括了错误或警告。它也提"
"供适合消息的上下文和消息，和用来过滤目的的唯一标示。"

msgid ""
"The concept is very similar to messages from the :doc:`message framework </"
"ref/contrib/messages>` or the :doc:`logging framework </topics/logging>`. "
"Messages are tagged with a ``level`` indicating the severity of the message."
msgstr ""
"这个概念与来自  :doc:`message framework </ref/contrib/messages>` or the :doc:"
"`logging framework </topics/logging>` 的消息非常相似。消息标有 ``level`` ，标"
"示消息的严重性。"

msgid ""
"There are also shortcuts to make creating messages with common levels "
"easier. When using these classes you can omit the ``level`` argument because "
"it is implied by the class name."
msgstr ""
"也可以有快捷方式来简单创建公共级别的消息。当使用这些类你可以忽略 ``level`` 参"
"数，因为它已经通过类名隐含。"

msgid ":class:`Debug`"
msgstr ":class:`Debug`"

msgid ":class:`Info`"
msgstr ":class:`Info`"

msgid ":class:`Warning`"
msgstr ":class:`Warning`"

msgid ":class:`Error`"
msgstr ":class:`Error`"

msgid ":class:`Critical`"
msgstr ":class:`Critical`"

msgid "Registering and labeling checks"
msgstr "注册和标记检查"

msgid ""
"Lastly, your check function must be registered explicitly with system check "
"registry. Checks should be registered in a file that's loaded when your "
"application is loaded; for example, in the :meth:`AppConfig.ready() <django."
"apps.AppConfig.ready>` method."
msgstr ""
"最后，你的检查函数必须已经在系统检查注册表明确注册。检查应该在加载应用程序时"
"加载文件中注册；比如，在 :meth:`AppConfig.ready() <django.apps.AppConfig."
"ready>` 方法中。"

msgid ""
"You can pass as many tags to ``register`` as you want in order to label your "
"check. Tagging checks is useful since it allows you to run only a certain "
"group of checks. For example, to register a compatibility check, you would "
"make the following call::"
msgstr ""
"为了标记检查，你可以根据需要来传递很多标签给 ``register``。标记检查很有用，因"
"为它允许你仅运行一个特定的检查组。比如，为了注册一个兼容性检查，你可以进行以"
"下调用："

msgid ""
"You can register \"deployment checks\" that are only relevant to a "
"production settings file like this::"
msgstr "你可以注册仅与生产配置文件相关的\"部署检查\" ："

msgid ""
"These checks will only be run if the :option:`check --deploy` option is used."
msgstr "这些检查只在使用 :option:`check --deploy` 选项时运行。"

msgid ""
"You can also use ``register`` as a function rather than a decorator by "
"passing a callable object (usually a function) as the first argument to "
"``register``."
msgstr ""
"你也可以把 ``register`` 当做函数而不是装饰器，通过传递一个可调用对象（通常是"
"函数）作为第一参数传递给 ``register``。"

msgid "The code below is equivalent to the code above::"
msgstr "下面的代码和上面的代码等同："

msgid "Field, model, manager, and database checks"
msgstr "字段，模型，管理器和数据库检查"

msgid ""
"In some cases, you won't need to register your check function -- you can "
"piggyback on an existing registration."
msgstr "在某些情况下，你不需要注册检查函数——你可以使用现有的注册。"

msgid ""
"Fields, models, model managers, and database backends all implement a "
"``check()`` method that is already registered with the check framework. If "
"you want to add extra checks, you can extend the implementation on the base "
"class, perform any extra checks you need, and append any messages to those "
"generated by the base class. It's recommended that you delegate each check "
"to separate methods."
msgstr ""
"字段，模型，模型管理器和数据库后端都实现了一个检查方法，这个方法已经被检查框"
"架注册。如果你想添加其他检查，你可以在基类上扩展实现，完成任何你需要的检查，"
"将任何消息添加到基类生成的消息。建议你将每个检查委派给不同方法。"

msgid ""
"Consider an example where you are implementing a custom field named "
"``RangedIntegerField``. This field adds ``min`` and ``max`` arguments to the "
"constructor of ``IntegerField``. You may want to add a check to ensure that "
"users provide a min value that is less than or equal to the max value. The "
"following code snippet shows how you can implement this check::"
msgstr ""
"考虑一个例子，你正在实现一个自定义字段 ``RangedIntegerField``。这个字段添加 "
"``min`` 和 ``max`` 参数给 ``IntegerField`` 的构造器。你可能想添加一个检查来确"
"保用户提供小于或等于最大值的最小值。下面的代码片段显示如何实现这个检查："

msgid ""
"If you wanted to add checks to a model manager, you would take the same "
"approach on your subclass of :class:`~django.db.models.Manager`."
msgstr ""
"如果你想对模型管理器添加检查，你应该对 :class:`~django.db.models.Manager` 的"
"子类采用相同方法。"

msgid ""
"If you want to add a check to a model class, the approach is *almost* the "
"same: the only difference is that the check is a classmethod, not an "
"instance method::"
msgstr ""
"如果你想对模型类添加检查，这个方法几乎相同，唯一的区别是这个检查是一个类方"
"法，而不是实例方法。"

msgid "Writing tests"
msgstr "编写测试"

msgid "Messages are comparable. That allows you to easily write tests::"
msgstr "消息具有可比性。允许你轻松编写测试："

msgid "Built-in class-based generic views"
msgstr "内置的基于类的通用视图"

msgid ""
"Writing web applications can be monotonous, because we repeat certain "
"patterns again and again. Django tries to take away some of that monotony at "
"the model and template layers, but web developers also experience this "
"boredom at the view level."
msgstr ""

msgid ""
"Django's *generic views* were developed to ease that pain. They take certain "
"common idioms and patterns found in view development and abstract them so "
"that you can quickly write common views of data without having to write too "
"much code."
msgstr ""
"Django 通用视图是为了缓解这种情况而被开发的。他们采用在视图开发时发现的某些通"
"用的风格和模式，并把它们抽象化，因此你可能更快的编写公共的数据视图，而不是编"
"写更多的代码。"

msgid ""
"We can recognize certain common tasks, like displaying a list of objects, "
"and write code that displays a list of *any* object. Then the model in "
"question can be passed as an extra argument to the URLconf."
msgstr ""
"我们可以识别出某些通用任务，比如显示对象列表，编写显示任何对象列表的代码。然"
"后有问题的模型将被当做附加的参数传递给 URLconf。"

msgid "Django ships with generic views to do the following:"
msgstr "Django 附带通用视图来执行以下操作："

msgid ""
"Display list and detail pages for a single object. If we were creating an "
"application to manage conferences then a ``TalkListView`` and a "
"``RegisteredUserListView`` would be examples of list views. A single talk "
"page is an example of what we call a \"detail\" view."
msgstr ""
"为单个对象显示列表和详情页。如果我们创建一个管理会议的应用，那么 "
"``TalkListView`` 和 ``RegisteredUserListView`` 就是列表视图的例子。单个\"话题"
"页\"将作为例子中的\"详情页\"。"

msgid ""
"Present date-based objects in year/month/day archive pages, associated "
"detail, and \"latest\" pages."
msgstr "在年/月/日的归档页面，相关的详情和最新页面将显示基于日期的对象。"

msgid ""
"Allow users to create, update, and delete objects -- with or without "
"authorization."
msgstr "运行用户创建、更新和删除对象——无论是否授权。"

msgid ""
"Taken together, these views provide interfaces to perform the most common "
"tasks developers encounter."
msgstr "总之，这些视图提供的接口来执行开发者们遇到的最常见的通用任务。"

msgid "Extending generic views"
msgstr "扩展通用视图"

msgid ""
"There's no question that using generic views can speed up development "
"substantially. In most projects, however, there comes a moment when the "
"generic views no longer suffice. Indeed, the most common question asked by "
"new Django developers is how to make generic views handle a wider array of "
"situations."
msgstr ""
"毫无疑问，使用通用视图可以大大加快开发速度。然而，在很多项目中，会出现通用视"
"图不再适用。实际上，很多新手 Django 开发者问的最常见的问题是怎么让通用视图处"
"理更大范围的情况。"

msgid ""
"This is one of the reasons generic views were redesigned for the 1.3 release "
"- previously, they were view functions with a bewildering array of options; "
"now, rather than passing in a large amount of configuration in the URLconf, "
"the recommended way to extend generic views is to subclass them, and "
"override their attributes or methods."
msgstr ""
"这是通用视图在1.3版重新设计的原因之一——之前，它们只是具有各种选项的视图函数；"
"现在，扩展通用视图的推荐方法是将它们子类化并且覆盖它们的属性或方法，而不是在 "
"URLconf 中传递一个很庞杂的配置。"

msgid ""
"That said, generic views will have a limit. If you find you're struggling to "
"implement your view as a subclass of a generic view, then you may find it "
"more effective to write just the code you need, using your own class-based "
"or functional views."
msgstr ""
"也就是说，通用视图有一个限制。如果你发现很难将实现的视图作为通用视图的子类，"
"那么你可能会发现使用自己的基类或函数视图来编写你所需的代码会更有效率。"

msgid ""
"More examples of generic views are available in some third party "
"applications, or you could write your own as needed."
msgstr ""
"一些第三方应用里提供了很多通用视图案例，或者你可以编写你需要的通用视图。"

msgid "Generic views of objects"
msgstr "对象的通用视图"

msgid ""
":class:`~django.views.generic.base.TemplateView` certainly is useful, but "
"Django's generic views really shine when it comes to presenting views of "
"your database content. Because it's such a common task, Django comes with a "
"handful of built-in generic views to help generate list and detail views of "
"objects."
msgstr ""
":class:`~django.views.generic.base.TemplateView` 当然也很常用，但 Django 通用"
"视图在呈现数据库内容视图时确实很出色。因为这是一个很常见任务，Django 附带一些"
"内置的通用视图来协助生成列表和对象的详情视图。"

msgid ""
"Let's start by looking at some examples of showing a list of objects or an "
"individual object."
msgstr "让我们首先看一些显示对象列表或单独对象的例子。"

msgid "We'll be using these models::"
msgstr "我们将使用这些模型："

msgid "Now we need to define a view::"
msgstr "现在我们需要定义一个视图："

msgid "Finally hook that view into your urls::"
msgstr "最后将这个视图挂钩到你的urls："

msgid ""
"That's all the Python code we need to write. We still need to write a "
"template, however. We could explicitly tell the view which template to use "
"by adding a ``template_name`` attribute to the view, but in the absence of "
"an explicit template Django will infer one from the object's name. In this "
"case, the inferred template will be ``\"books/publisher_list.html\"`` -- the "
"\"books\" part comes from the name of the app that defines the model, while "
"the \"publisher\" bit is the lowercased version of the model's name."
msgstr ""
"这就是我们需要编写的所有代码。尽管我们仍然需要编写一个模板。我们可以给视图添"
"加 ``template_name`` 属性来告诉视图使用哪个模板，但如果没有明确的模板，"
"Django 将从对象名称中推断一个。在这个例子中，推断模板将是 ``\"books/"
"publisher_list.html\"`` —— \"books\" 部分来自定义模型所属 app 名称，而 "
"\"publisher\" 必须是模型名称的小写。"

msgid ""
"Thus, when (for example) the ``APP_DIRS`` option of a ``DjangoTemplates`` "
"backend is set to True in :setting:`TEMPLATES`, a template location could "
"be: /path/to/project/books/templates/books/publisher_list.html"
msgstr ""
"因此，假如一个 ``DjangoTemplates`` 后端的 ``APP_DIRS`` 选项在 :setting:"
"`TEMPLATES` 中被设为 True 时，模板地址将会是 /path/to/project/books/"
"templates/books/publisher_list.html 。"

msgid ""
"This template will be rendered against a context containing a variable "
"called ``object_list`` that contains all the publisher objects. A template "
"might look like this:"
msgstr ""
"这个模板将针对变量名为 ``object_list`` 的上下文进行渲染，这个变量包含所有的出"
"版者对象。模板可以是这个样子："

msgid ""
"That's really all there is to it. All the cool features of generic views "
"come from changing the attributes set on the generic view. The :doc:`generic "
"views reference</ref/class-based-views/index>` documents all the generic "
"views and their options in detail; the rest of this document will consider "
"some of the common ways you might customize and extend generic views."
msgstr ""
"这就是全部内容。通用视图的所有炫酷功能来自改变通用视图上的属性设置。:doc:"
"`generic views reference</ref/class-based-views/index>` 文档里有所有的通用视"
"图和选项的详细说明；这篇文档剩下的部分将介绍一些你可能需要自定义和扩展通用视"
"图的常用办法。"

msgid "Making \"friendly\" template contexts"
msgstr "制作\"友好\"的模板上下文"

msgid ""
"You might have noticed that our sample publisher list template stores all "
"the publishers in a variable named ``object_list``. While this works just "
"fine, it isn't all that \"friendly\" to template authors: they have to "
"\"just know\" that they're dealing with publishers here."
msgstr ""
"你可能已经注意到了例子中的出版者列表模板在变量名为 ``object_list`` 里保存了所"
"有的出版者。尽管它工作正常，但它对模板作者并不是特别友好：他们必须在这里处理"
"出版者信息。"

msgid ""
"Well, if you're dealing with a model object, this is already done for you. "
"When you are dealing with an object or queryset, Django is able to populate "
"the context using the lowercased version of the model class' name. This is "
"provided in addition to the default ``object_list`` entry, but contains "
"exactly the same data, i.e. ``publisher_list``."
msgstr ""
"如果你正在处理模型对象，这已经完成了。当你正在处理对象或查询，Django 使用小写"
"的模型类名来填充上下文。这是除了默认的 ``object_list`` 类目之外提供的，但包含"
"完全相同的数据，即 ``publisher_list``。"

msgid ""
"If this still isn't a good match, you can manually set the name of the "
"context variable. The ``context_object_name`` attribute on a generic view "
"specifies the context variable to use::"
msgstr ""
"如果仍然匹配的不好，你可以手工设置上下文变量的名称。通用视图上的"
"``context_object_name`` 属性指定要使用的上下文变量："

msgid ""
"Providing a useful ``context_object_name`` is always a good idea. Your "
"coworkers who design templates will thank you."
msgstr ""
"提供有用的 ``context_object_name`` 总是一个好主意。设计模板的合作者将会感激"
"你。"

msgid "Adding extra context"
msgstr "添加额外的上下文"

msgid ""
"Often you need to present some extra information beyond that provided by the "
"generic view. For example, think of showing a list of all the books on each "
"publisher detail page. The :class:`~django.views.generic.detail.DetailView` "
"generic view provides the publisher to the context, but how do we get "
"additional information in that template?"
msgstr ""
"通常，你只需要提供通用视图所提供的信息之外的一些附加的信息。比如，打算在每一"
"个出版者详情页上显示所有的书籍列表。:class:`~django.views.generic.detail."
"DetailView` 通用视图提供出版者至上下文，但是怎么在模板里获取更多的信息呢？"

msgid ""
"The answer is to subclass :class:`~django.views.generic.detail.DetailView` "
"and provide your own implementation of the ``get_context_data`` method. The "
"default implementation adds the object being displayed to the template, but "
"you can override it to send more::"
msgstr ""
"答案是子类化 :class:`~django.views.generic.detail.DetailView` ，并提供你实现"
"的 ``get_context_data`` 方法。默认的实现只是将正在显示的对象增加到模板，但你"
"需要覆盖它来发送更多信息："

msgid ""
"Generally, ``get_context_data`` will merge the context data of all parent "
"classes with those of the current class. To preserve this behavior in your "
"own classes where you want to alter the context, you should be sure to call "
"``get_context_data`` on the super class. When no two classes try to define "
"the same key, this will give the expected results. However if any class "
"attempts to override a key after parent classes have set it (after the call "
"to super), any children of that class will also need to explicitly set it "
"after super if they want to be sure to override all parents. If you're "
"having trouble, review the method resolution order of your view."
msgstr ""
"通常，``get_context_data`` 将合并当前类的所有父类的上下文数据。要在你想要改变"
"上下文的类中保留此行为，你应该确保在超类上调用了 ``get_context_data`` 。当没"
"有两个类尝试去定义相同的键是，会给出正确的结果。然而，如果任何类打算在父类已"
"经设置键（调用super后）后覆盖键，如果任何子类想确保覆盖了所有父类，那么就需要"
"在调用super后显式地设置它。如果有问题，请查看视图的方法解析顺序。"

msgid ""
"Another consideration is that the context data from class-based generic "
"views will override data provided by context processors; see :meth:`~django."
"views.generic.detail.SingleObjectMixin.get_context_data` for an example."
msgstr ""
"另一个考虑是来自基于类的通用视图的上下文数据将覆盖由上下文处理器提供的数据；"
"可以查看 :meth:`~django.views.generic.detail.SingleObjectMixin."
"get_context_data` 的例子。"

msgid "Viewing subsets of objects"
msgstr "查看对象的子集"

msgid ""
"Now let's take a closer look at the ``model`` argument we've been using all "
"along. The ``model`` argument, which specifies the database model that the "
"view will operate upon, is available on all the generic views that operate "
"on a single object or a collection of objects. However, the ``model`` "
"argument is not the only way to specify the objects that the view will "
"operate upon -- you can also specify the list of objects using the "
"``queryset`` argument::"
msgstr ""
"现在让我们仔细观察我们一直在使用的 ``model`` 参数。``model`` 参数指定了视图将"
"对其进行操作的数据模型，可用于对单个对象或对象集合进行操作的所有通用视图上。"
"然而，``model`` 参数不仅仅用来指定视图操作对象，还可以使用 ``queryset`` 参数"
"指定对象列表。"

msgid ""
"Specifying ``model = Publisher`` is shorthand for saying ``queryset = "
"Publisher.objects.all()``. However, by using ``queryset`` to define a "
"filtered list of objects you can be more specific about the objects that "
"will be visible in the view (see :doc:`/topics/db/queries` for more "
"information about :class:`~django.db.models.query.QuerySet` objects, and see "
"the :doc:`class-based views reference </ref/class-based-views/index>` for "
"the complete details)."
msgstr ""
"指定 ``model = Publisher`` 只是 ``queryset = Publisher.objects.all()`` 的简"
"写。然而，通过使用 ``queryset`` 定义过滤的对象列表，你可以更加具体的了解在视"
"图中可见的对象。（查看 :doc:`/topics/db/queries` 来获取更多 :class:`~django."
"db.models.query.QuerySet` 对象的信息，查看 :doc:`class-based views reference "
"</ref/class-based-views/index>` 来获取完整信息）"

msgid ""
"To pick an example, we might want to order a list of books by publication "
"date, with the most recent first::"
msgstr "举一个例子，我们想通过出版日期排序一个书籍列表，最新的排第一："

msgid ""
"That's a pretty minimal example, but it illustrates the idea nicely. You'll "
"usually want to do more than just reorder objects. If you want to present a "
"list of books by a particular publisher, you can use the same technique::"
msgstr ""
"这是一个很简单的例子，但很好的说明了问题。你通常会想做比重新排序对象更多的操"
"作。如果你想显示特定出版者的书籍列表，你可以使用相同技术："

msgid ""
"Notice that along with a filtered ``queryset``, we're also using a custom "
"template name. If we didn't, the generic view would use the same template as "
"the \"vanilla\" object list, which might not be what we want."
msgstr ""
"注意，和过滤的查询结果一起，我们还要指定自定义的模板名称。如果我们不这么做，"
"通用视图将使用与 \"vanilla\" 对象列表相同的模板，这可能不是我们想要的。"

msgid ""
"Also notice that this isn't a very elegant way of doing publisher-specific "
"books. If we want to add another publisher page, we'd need another handful "
"of lines in the URLconf, and more than a few publishers would get "
"unreasonable. We'll deal with this problem in the next section."
msgstr ""
"还需要注意，这不是一个特别优雅的获取指定出版者书籍的方法。如果你想添加其他出"
"版者页面，我们需要在URLconf中再添加几行，但如果多个出版者，这就变得不合理了。"
"我们将在下一个部分来处理这个问题。"

msgid ""
"If you get a 404 when requesting ``/books/acme/``, check to ensure you "
"actually have a Publisher with the name 'ACME Publishing'.  Generic views "
"have an ``allow_empty`` parameter for this case.  See the :doc:`class-based-"
"views reference</ref/class-based-views/index>` for more details."
msgstr ""
"如果你在请求 ``/books/acme/`` 时得到了404页面，请检查确保有叫 'ACME "
"Publishing' 的出版者。通用视图有一个 ``allow_empty`` 参数来解决这个问题。查"
"看 :doc:`class-based-views reference</ref/class-based-views/index>` 来获取更"
"多细节。"

msgid "Dynamic filtering"
msgstr "动态过滤"

msgid ""
"Another common need is to filter down the objects given in a list page by "
"some key in the URL. Earlier we hard-coded the publisher's name in the "
"URLconf, but what if we wanted to write a view that displayed all the books "
"by some arbitrary publisher?"
msgstr ""
"其他常见需求是通过URL中的某个键来过滤列表页面里的对象。之前我们在URLconf中硬"
"编码了出版者的名字，但如果我们想编写一个显示任意出版者书籍的视图呢？"

msgid ""
"Handily, the ``ListView`` has a :meth:`~django.views.generic.list."
"MultipleObjectMixin.get_queryset` method we can override. By default, it "
"returns the value of the ``queryset`` attribute, but we can use it to add "
"more logic."
msgstr ""
"我们可以方便地覆盖 ``ListView`` 的 :meth:`~django.views.generic.list."
"MultipleObjectMixin.get_queryset` 方法。默认情况下，它返回 ``queryset`` 属性"
"值，但现在我们可以用它来添加更多逻辑。"

msgid ""
"The key part to making this work is that when class-based views are called, "
"various useful things are stored on ``self``; as well as the request (``self."
"request``) this includes the positional (``self.args``) and name-based "
"(``self.kwargs``) arguments captured according to the URLconf."
msgstr ""
"这项工作的关键部分是当基于类的视图被调用的时候，各种常用的东西被存储在 "
"``self`` 上，而且请求  (``self.request``) 根据 URLconf 抓取位置(``self."
"args``) 和基于名称 (``self.kwargs``) 的参数。"

msgid "Here, we have a URLconf with a single captured group::"
msgstr "现在，我们有个带有单个抓取组的URLconf。"

msgid "Next, we'll write the ``PublisherBookListView`` view itself::"
msgstr "接下来，我们将编写 ``PublisherBookListView`` 视图本身："

msgid ""
"Using ``get_queryset`` to add logic to the queryset selection is as "
"convenient as it is powerful. For instance, if we wanted, we could use "
"``self.request.user`` to filter using the current user, or other more "
"complex logic."
msgstr ""
"可以很方便地使用 ``get_queryset`` 来给查询集添加逻辑。比如，我们可以使用 "
"``self.request.user`` 来过滤当前用户或其他更复杂的逻辑。"

msgid ""
"We can also add the publisher into the context at the same time, so we can "
"use it in the template::"
msgstr "我们也可以同时添加出版者到上下文中，因此我们能在模板中使用它："

msgid "Performing extra work"
msgstr "执行额外的任务"

msgid ""
"The last common pattern we'll look at involves doing some extra work before "
"or after calling the generic view."
msgstr "最后一个常见模式里，我们将看到涉及在调用通用视图前后执行一些附加任务。"

msgid ""
"Imagine we had a ``last_accessed`` field on our ``Author`` model that we "
"were using to keep track of the last time anybody looked at that author::"
msgstr ""
"想象在  ``Author``  模型上有一个 ``last_accessed`` 字段，用来查看谁是最新查看"
"作者的人："

msgid ""
"The generic ``DetailView`` class wouldn't know anything about this field, "
"but once again we could write a custom view to keep that field updated."
msgstr ""
"通用的 ``DetailView`` 类不知道关于这个字段的任何信息，但我们可以再次编写自定"
"义视图来保持字段更新。"

msgid ""
"First, we'd need to add an author detail bit in the URLconf to point to a "
"custom view::"
msgstr "首先，我们需要在URLconf中添加一个作者详情的url指向自定义视图："

msgid ""
"Then we'd write our new view -- ``get_object`` is the method that retrieves "
"the object -- so we override it and wrap the call::"
msgstr ""
"然后我们编写一个新的视图——``get_object`` 来查找对象——因此我们可以覆盖它并包装"
"调用："

msgid ""
"The URLconf here uses the named group ``pk`` - this name is the default name "
"that ``DetailView`` uses to find the value of the primary key used to filter "
"the queryset."
msgstr ""
"URLconf 在这里使用组 ``pk`` ，这个名字是 ``DetailView`` 用来查找过滤查询集的"
"主键值的默认名称。"

msgid ""
"If you want to call the group something else, you can set :attr:`~django."
"views.generic.detail.SingleObjectMixin.pk_url_kwarg` on the view."
msgstr ""
"如果你想调用组别的东西，你可以在视图上设置 :attr:`~django.views.generic."
"detail.SingleObjectMixin.pk_url_kwarg`。"

msgid "Form handling with class-based views"
msgstr "使用基于类的视图处理表单"

msgid "Form processing generally has 3 paths:"
msgstr "表单处理通常有3个途径："

msgid "Initial GET (blank or prepopulated form)"
msgstr "初始 GET （空白或预填充表单）"

msgid "POST with invalid data (typically redisplay form with errors)"
msgstr "带有合法数据的POST（通常是带有错误的重新显示的表单）"

msgid "POST with valid data (process the data and typically redirect)"
msgstr "带有合法数据的POST（处理数据和通常重定向）"

msgid ""
"Implementing this yourself often results in a lot of repeated boilerplate "
"code (see :ref:`Using a form in a view<using-a-form-in-a-view>`). To help "
"avoid this, Django provides a collection of generic class-based views for "
"form processing."
msgstr ""
"自己实现这个会导致很多重复的样板代码（查看 :ref:`Using a form in a "
"view<using-a-form-in-a-view>` ）。为了避免这个问题，Django 提供了一组通用基于"
"类的视图来处理表单。"

msgid "Basic forms"
msgstr "基础表单"

msgid "Given a contact form:"
msgstr "提供联系表单："

msgid "forms.py"
msgstr "forms.py"

msgid "The view can be constructed using a ``FormView``:"
msgstr "可以使用 ``FormView`` 构建视图："

msgid "views.py"
msgstr "views.py"

msgid "Notes:"
msgstr "注意："

msgid ""
"FormView inherits :class:`~django.views.generic.base.TemplateResponseMixin` "
"so :attr:`~django.views.generic.base.TemplateResponseMixin.template_name` "
"can be used here."
msgstr ""
"FormView 继承了 :class:`~django.views.generic.base.TemplateResponseMixin` ，"
"因此可以在这里使用 :attr:`~django.views.generic.base.TemplateResponseMixin."
"template_name` 。"

msgid ""
"The default implementation for :meth:`~django.views.generic.edit.FormMixin."
"form_valid` simply redirects to the :attr:`~django.views.generic.edit."
"FormMixin.success_url`."
msgstr ""
"默认实现了 :meth:`~django.views.generic.edit.FormMixin.form_valid`  简单重定"
"向至 :attr:`~django.views.generic.edit.FormMixin.success_url` 。"

msgid "Model forms"
msgstr "模型表单"

msgid ""
"Generic views really shine when working with models.  These generic views "
"will automatically create a :class:`~django.forms.ModelForm`, so long as "
"they can work out which model class to use:"
msgstr ""
"通用视图在模型一起工作时真的很赞。这些通用视图将自动创建 :class:`~django."
"forms.ModelForm` ，只要他们能找出要使用的模型类："

msgid ""
"If the :attr:`~django.views.generic.edit.ModelFormMixin.model` attribute is "
"given, that model class will be used."
msgstr ""
"如果已经给出了 :attr:`~django.views.generic.edit.ModelFormMixin.model` 属性，"
"则使用这个模型类。"

msgid ""
"If :meth:`~django.views.generic.detail.SingleObjectMixin.get_object()` "
"returns an object, the class of that object will be used."
msgstr ""
"如果 :meth:`~django.views.generic.detail.SingleObjectMixin.get_object()` 返回"
"一个对象，则使用这个对象的类。"

msgid ""
"If a :attr:`~django.views.generic.detail.SingleObjectMixin.queryset` is "
"given, the model for that queryset will be used."
msgstr ""
"如果已经给出了 :attr:`~django.views.generic.detail.SingleObjectMixin."
"queryset`  ，则使用这个查询集的模型。"

msgid ""
"Model form views provide a :meth:`~django.views.generic.edit.ModelFormMixin."
"form_valid()` implementation that saves the model automatically.  You can "
"override this if you have any special requirements; see below for examples."
msgstr ""
"模型表单视图提供一个 :meth:`~django.views.generic.edit.ModelFormMixin."
"form_valid()` 实现，来自动保存模型。如果你有特别的需求，你可以覆盖它。下面是"
"例子。"

msgid ""
"You don't even need to provide a ``success_url`` for :class:`~django.views."
"generic.edit.CreateView` or :class:`~django.views.generic.edit.UpdateView` - "
"they will use :meth:`~django.db.models.Model.get_absolute_url()` on the "
"model object if available."
msgstr ""
"你甚至不需要为 :class:`~django.views.generic.edit.CreateView` 或 :class:"
"`~django.views.generic.edit.UpdateView` 提供 ``success_url`` 。如果可用，它们"
"将在模型对象上使用 :meth:`~django.db.models.Model.get_absolute_url()` 。"

msgid ""
"If you want to use a custom :class:`~django.forms.ModelForm` (for instance "
"to add extra validation), set :attr:`~django.views.generic.edit.FormMixin."
"form_class` on your view."
msgstr ""
"如果你想使用一个自定义的  :class:`~django.forms.ModelForm` （比如添加额外的验"
"证），用来在视图上设置 :attr:`~django.views.generic.edit.FormMixin."
"form_class` 。"

msgid ""
"When specifying a custom form class, you must still specify the model, even "
"though the :attr:`~django.views.generic.edit.FormMixin.form_class` may be a :"
"class:`~django.forms.ModelForm`."
msgstr ""
"当指定一个自定义表单类时，必须也要指定模型，即使 :attr:`~django.views."
"generic.edit.FormMixin.form_class` 可能是一个 :class:`~django.forms."
"ModelForm` 。"

msgid ""
"First we need to add :meth:`~django.db.models.Model.get_absolute_url()` to "
"our ``Author`` class:"
msgstr ""
"首先我们需要添加 :meth:`~django.db.models.Model.get_absolute_url()` 到 "
"``Author`` 类："

msgid "models.py"
msgstr "models.py"

msgid ""
"Then we can use :class:`CreateView` and friends to do the actual work. "
"Notice how we're just configuring the generic class-based views here; we "
"don't have to write any logic ourselves:"
msgstr ""
"然后可以使用 :class:`CreateView` 并友好的执行实际工作。注意这里我们如何配置通"
"用基于类的视图。我们不用自己编写任何逻辑："

msgid ""
"We have to use :func:`~django.urls.reverse_lazy` instead of ``reverse()``, "
"as the urls are not loaded when the file is imported."
msgstr ""
"我们必须在这里使用 :func:`~django.urls.reverse_lazy` 来代替 ``reverse()`` ，"
"因为在文件导入时不加载  urls 。"

msgid ""
"The ``fields`` attribute works the same way as the ``fields`` attribute on "
"the inner ``Meta`` class on :class:`~django.forms.ModelForm`. Unless you "
"define the form class in another way, the attribute is required and the view "
"will raise an :exc:`~django.core.exceptions.ImproperlyConfigured` exception "
"if it's not."
msgstr ""
"``fields`` 属性的工作方式同 :class:`~django.forms.ModelForm` 中内部 ``Meta`` "
"类的 ``fields`` 属性一样。除非你使用其他方式定义表单类，该属性是必需的，如果"
"属性不存在，视图将引发 :exc:`~django.core.exceptions.ImproperlyConfigured` 异"
"常。"

msgid ""
"If you specify both the :attr:`~django.views.generic.edit.ModelFormMixin."
"fields` and :attr:`~django.views.generic.edit.FormMixin.form_class` "
"attributes, an :exc:`~django.core.exceptions.ImproperlyConfigured` exception "
"will be raised."
msgstr ""
"如果同时指定了 :attr:`~django.views.generic.edit.ModelFormMixin.fields` 和 :"
"attr:`~django.views.generic.edit.FormMixin.form_class` 属性，将会引发 :exc:"
"`~django.core.exceptions.ImproperlyConfigured` 异常。"

msgid "Finally, we hook these new views into the URLconf:"
msgstr "最后将这些新视图挂钩到URLconf中："

msgid "urls.py"
msgstr "urls.py"

msgid ""
"These views inherit :class:`~django.views.generic.detail."
"SingleObjectTemplateResponseMixin` which uses :attr:`~django.views.generic."
"detail.SingleObjectTemplateResponseMixin.template_name_suffix` to construct "
"the :attr:`~django.views.generic.base.TemplateResponseMixin.template_name` "
"based on the model."
msgstr ""
"这些视图继承 :class:`~django.views.generic.detail."
"SingleObjectTemplateResponseMixin` ，它使用 :attr:`~django.views.generic."
"detail.SingleObjectTemplateResponseMixin.template_name_suffix` 来构建基于模型"
"的 :attr:`~django.views.generic.base.TemplateResponseMixin.template_name` 。"

msgid "In this example:"
msgstr "在这个例子里："

msgid ""
":class:`CreateView` and :class:`UpdateView` use ``myapp/author_form.html``"
msgstr ""
":class:`CreateView` 和 :class:`UpdateView` 使用 ``myapp/author_form.html`` 。"

msgid ":class:`DeleteView` uses ``myapp/author_confirm_delete.html``"
msgstr ":class:`DeleteView` 使用 ``myapp/author_confirm_delete.html`` 。"

msgid ""
"If you wish to have separate templates for :class:`CreateView` and :class:"
"`UpdateView`, you can set either :attr:`~django.views.generic.base."
"TemplateResponseMixin.template_name` or :attr:`~django.views.generic.detail."
"SingleObjectTemplateResponseMixin.template_name_suffix` on your view class."
msgstr ""
"如果你想为 :class:`CreateView` 和 :class:`UpdateView` 制作单独的模板，你可以"
"在视图类上设置 :attr:`~django.views.generic.base.TemplateResponseMixin."
"template_name` 或 :attr:`~django.views.generic.detail."
"SingleObjectTemplateResponseMixin.template_name_suffix` 。"

msgid "Models and ``request.user``"
msgstr "模型和 ``request.user``"

msgid ""
"To track the user that created an object using a :class:`CreateView`, you "
"can use a custom :class:`~django.forms.ModelForm` to do this. First, add the "
"foreign key relation to the model:"
msgstr ""
"若要跟踪使用 :class:`CreateView` 创建的用户，你可以使用自定义的 :class:"
"`~django.forms.ModelForm` 来执行此操作。首先，在模型里添加外键关系："

msgid ""
"In the view, ensure that you don't include ``created_by`` in the list of "
"fields to edit, and override :meth:`~django.views.generic.edit."
"ModelFormMixin.form_valid()` to add the user:"
msgstr ""
"在这个视图中，确保你没有在要编辑的字段列表中包含 ``created_by`` 字段 ，并且要"
"覆盖 :meth:`~django.views.generic.edit.ModelFormMixin.form_valid()` 来添加用"
"户："

msgid ""
":class:`~django.contrib.auth.mixins.LoginRequiredMixin` prevents users who "
"aren't logged in from accessing the form. If you omit that, you'll need to "
"handle unauthorized users in :meth:`~.ModelFormMixin.form_valid()`."
msgstr ""
":class:`~django.contrib.auth.mixins.LoginRequiredMixin` 防止那些未登录的用户"
"访问表单。如果忽略，那么你将需要在 :meth:`~.ModelFormMixin.form_valid()` 里处"
"理未授权的用户。"

msgid "Content negotiation example"
msgstr "内容协商示例"

msgid ""
"Here is an example showing how you might go about implementing a form that "
"works with an API-based workflow as well as 'normal' form POSTs::"
msgstr ""
"下面是一个展示了如何实现基于API的工作流以及普通POST表单一起使用的表单："

msgid "Class-based views"
msgstr "基于类的视图"

msgid ""
"A view is a callable which takes a request and returns a response. This can "
"be more than just a function, and Django provides an example of some classes "
"which can be used as views. These allow you to structure your views and "
"reuse code by harnessing inheritance and mixins. There are also some generic "
"views for tasks which we'll get to later, but you may want to design your "
"own structure of reusable views which suits your use case. For full details, "
"see the :doc:`class-based views reference documentation</ref/class-based-"
"views/index>`."
msgstr ""
"视图是可调用的，能接受用户的请求并返回响应。视图远不只是个函数，Django提供了"
"一些可用作视图的类的示例，允许你通过继承和复用构建自己的视图并且复用这些代"
"码。虽然接下来还会介绍一些用于任务的通用视图，但你可能想自己设计可复用的视图"
"结构，以便针对某些特殊场景。详情请见 class-based views reference "
"documentation</ref/class-based-views/index> 。"

msgid "Basic examples"
msgstr "基础示例"

msgid ""
"Django provides base view classes which will suit a wide range of "
"applications. All views inherit from the :class:`~django.views.generic.base."
"View` class, which handles linking the view into the URLs, HTTP method "
"dispatching and other common features. :class:`~django.views.generic.base."
"RedirectView` provides a HTTP redirect, and :class:`~django.views.generic."
"base.TemplateView` extends the base class to make it also render a template."
msgstr ""
"Django 提供了适用于很多应用的基本视图类。所有视图继承自  :class:`~django."
"views.generic.base.View` 类，它处理视图链接到 URLs，HTTP 方法调度和其他简单功"
"能。:class:`~django.views.generic.base.RedirectView` 用于 HTTP 重定向，:"
"class:`~django.views.generic.base.TemplateView` 扩展基类来使它能渲染模板。"

msgid "Usage in your URLconf"
msgstr "在 URLconf 中的用法"

msgid ""
"The most direct way to use generic views is to create them directly in your "
"URLconf. If you're only changing a few attributes on a class-based view, you "
"can pass them into the :meth:`~django.views.generic.base.View.as_view` "
"method call itself::"
msgstr ""
"使用通用视图最直接的方式是在 URLconf 中直接创建它们。如果你只在基于类的视图上"
"改变一些属性，那么你可以把它们传递到 :meth:`~django.views.generic.base.View."
"as_view` 方法中调用："

msgid ""
"Any arguments passed to :meth:`~django.views.generic.base.View.as_view` will "
"override attributes set on the class. In this example, we set "
"``template_name`` on the ``TemplateView``. A similar overriding pattern can "
"be used for the ``url`` attribute on :class:`~django.views.generic.base."
"RedirectView`."
msgstr ""
"任何传递到 :meth:`~django.views.generic.base.View.as_view`  的参数将覆盖在类"
"上设置的属性。在这个例子中，我们在 ``TemplateView`` 上设置 "
"``template_name`` 。一个相似的覆盖模式可用于 :class:`~django.views.generic."
"base.RedirectView` 上的 ``url`` 属性。"

msgid "Subclassing generic views"
msgstr "子类化通用视图"

msgid ""
"The second, more powerful way to use generic views is to inherit from an "
"existing view and override attributes (such as the ``template_name``) or "
"methods (such as ``get_context_data``) in your subclass to provide new "
"values or methods. Consider, for example, a view that just displays one "
"template, ``about.html``. Django has a generic view to do this - :class:"
"`~django.views.generic.base.TemplateView` - so we can subclass it, and "
"override the template name::"
msgstr ""
"第二，使用通用视图更有力的方式是继承已存在的视图并覆盖子类里的属性（比如 "
"``template_name`` ）或方法（比如 ``get_context_data`` ）来提供新的值或方法。"
"例如，考虑只显示一个 ``about.html`` 模板的视图。Django 的 :class:`~django."
"views.generic.base.TemplateView` 可以完成这个工作，因此我们可以将其子类化并重"
"写模板名称："

msgid ""
"Then we need to add this new view into our URLconf. :class:`~django.views."
"generic.base.TemplateView` is a class, not a function, so we point the URL "
"to the :meth:`~django.views.generic.base.View.as_view` class method instead, "
"which provides a function-like entry to class-based views::"
msgstr ""
"最后我们需要在 URLconf 中添加这个新视图。:class:`~django.views.generic.base."
"TemplateView` 只是一个类，而不是一个函数，因此我们将 URL 指向 :meth:`~django."
"views.generic.base.View.as_view` ，它为基于类的视图提供一个类似函数的入口："

msgid ""
"For more information on how to use the built in generic views, consult the "
"next topic on :doc:`generic class-based views</topics/class-based-views/"
"generic-display>`."
msgstr ""
"有关如何使用内建通用视图的更多信息，请查阅在 :doc:`generic class-based "
"views</topics/class-based-views/generic-display>` 的下一个主题。"

msgid "Supporting other HTTP methods"
msgstr "支持其他 HTTP 方法"

msgid ""
"Suppose somebody wants to access our book library over HTTP using the views "
"as an API. The API client would connect every now and then and download book "
"data for the books published since last visit. But if no new books appeared "
"since then, it is a waste of CPU time and bandwidth to fetch the books from "
"the database, render a full response and send it to the client. It might be "
"preferable to ask the API when the most recent book was published."
msgstr ""
"如果某人想将视图作为 API 来访问图书馆。API 客户端会时不时地连接并下载上次访问"
"过后出版的书籍数据。但如果没有新的书籍出现，那么从数据库中获取书籍，渲染一个"
"完整响应并发送它到客户端的话，这将浪费CPU时间和带宽。当出版最新的书时，它访"
"问 API 最好。"

msgid "We map the URL to book list view in the URLconf::"
msgstr "我们需要在 URLconf 中映射 URL 到书籍列表视图："

msgid "And the view::"
msgstr "还有视图："

msgid ""
"If the view is accessed from a ``GET`` request, an object list is returned "
"in the response (using the ``book_list.html`` template). But if the client "
"issues a ``HEAD`` request, the response has an empty body and the ``Last-"
"Modified`` header indicates when the most recent book was published.  Based "
"on this information, the client may or may not download the full object list."
msgstr ""
"如果从 ``GET`` 请求访问视图，将在响应（使用 ``book_list.html`` 模板）中返回一"
"个干净的对象列表。但如果客户端发出一个 ``HEAD`` 请求，那么将响应一个空 body "
"和 ``Last-Modified`` 头将标识最新书籍的出版时间。基于这些信息，客户端可以选择"
"是否下载一个完整的对象类。"

msgid "Introduction to class-based views"
msgstr "基于类的视图"

msgid ""
"Class-based views provide an alternative way to implement views as Python "
"objects instead of functions. They do not replace function-based views, but "
"have certain differences and advantages when compared to function-based "
"views:"
msgstr ""
"基于类的视图提供另一种将视图实现为 Python 对象而不是函数的方法。它们不能替代"
"基于函数的视图，但与基于函数的视图相比，它们是有某些不同和优势的。"

msgid ""
"Organization of code related to specific HTTP methods (``GET``, ``POST``, "
"etc.) can be addressed by separate methods instead of conditional branching."
msgstr ""
"与特定的 HTTP 方法（``GET``, ``POST``, 等等）关联的代码组织能通过单独的方法替"
"代条件分支来解决。"

msgid ""
"Object oriented techniques such as mixins (multiple inheritance) can be used "
"to factor code into reusable components."
msgstr "面向对象技术（比如 mixins 多重继承）可用于将代码分解为可重用组件。"

msgid ""
"The relationship and history of generic views, class-based views, and class-"
"based generic views"
msgstr "通用视图、基于类的视图和基于类的通用视图的关系和历史"

msgid ""
"In the beginning there was only the view function contract, Django passed "
"your function an :class:`~django.http.HttpRequest` and expected back an :"
"class:`~django.http.HttpResponse`. This was the extent of what Django "
"provided."
msgstr ""
"一开始，这里只有视图函数，Django 传递 :class:`~django.http.HttpRequest` 函数"
"并预期返回一个 :class:`~django.http.HttpResponse` 。这是 Django 能提供的范"
"围。"

msgid ""
"Early on it was recognized that there were common idioms and patterns found "
"in view development. Function-based generic views were introduced to "
"abstract these patterns and ease view development for the common cases."
msgstr ""
"早期人们就发现在视图开发过程中有常见的约定和模式。引入了基于函数的通用视图为"
"这些常见情况抽象这些模式和简单视图的开发。"

msgid ""
"The problem with function-based generic views is that while they covered the "
"simple cases well, there was no way to extend or customize them beyond some "
"configuration options, limiting their usefulness in many real-world "
"applications."
msgstr ""
"基于函数的通用视图的问题是即便它们可以很好的处理简单案例，但除了一些配置选项"
"之外，没办法扩展或自定义它们，这样就限制了它们在实际应用中用途。"

msgid ""
"Class-based generic views were created with the same objective as function-"
"based generic views, to make view development easier. However, the way the "
"solution is implemented, through the use of mixins, provides a toolkit that "
"results in class-based generic views being more extensible and flexible than "
"their function-based counterparts."
msgstr ""
"创建基于类的通用视图与基于函数的通用视图具有相同的目标，那就是使视图开发更容"
"易。然而，通过使用 mixins 实现解决方案的方式提供了一个工具包，使基于类的通用"
"视图比基于函数的通用视图更灵活，更有扩展性。"

msgid ""
"If you have tried function based generic views in the past and found them "
"lacking, you should not think of class-based generic views as a class-based "
"equivalent, but rather as a fresh approach to solving the original problems "
"that generic views were meant to solve."
msgstr ""
"如果你之前有尝试过基于函数的通用视图并发现了它的不足之处，那么你不应该认为基"
"于类的通用视图只是基于类的等效视图，而是作为一种新的方法来解决通用视图要解决"
"的原始问题。"

msgid ""
"The toolkit of base classes and mixins that Django uses to build class-based "
"generic views are built for maximum flexibility, and as such have many hooks "
"in the form of default method implementations and attributes that you are "
"unlikely to be concerned with in the simplest use cases. For example, "
"instead of limiting you to a class-based attribute for ``form_class``, the "
"implementation uses a ``get_form`` method, which calls a ``get_form_class`` "
"method, which in its default implementation returns the ``form_class`` "
"attribute of the class. This gives you several options for specifying what "
"form to use, from an attribute, to a fully dynamic, callable hook. These "
"options seem to add hollow complexity for simple situations, but without "
"them, more advanced designs would be limited."
msgstr ""
"为了获得最大的灵活性，Django 使用基础类和mixins的工具包来构建通用视图，因此在"
"默认方法实现和属性的形式中有很多钩子，你在最简单的用例中不太可能涉及到这些钩"
"子。比如，不要将你限制为 ``form_class`` 的基于类的属性，使用 ``get_form`` 方"
"法来实现，使用 ``get_form`` 方法，它调用 ``get_form_class`` 方法，在默认实现"
"里只返回类的 ``form_class`` 属性。这给你一些选项来指定使用的表单，从简单属性"
"到完全动态的可调用属性。这些选项看起来增加了复杂度，但没有它们，会限制更高级"
"的设计。"

msgid "Using class-based views"
msgstr "使用基于类的视图"

msgid ""
"At its core, a class-based view allows you to respond to different HTTP "
"request methods with different class instance methods, instead of with "
"conditionally branching code inside a single view function."
msgstr ""
"本质上来说，基于类的视图允许你使用不同的类实例方法响应不同 HTTP 请求方法，而"
"不是在单个视图函数里使用有条件分支的代码。"

msgid ""
"So where the code to handle HTTP ``GET`` in a view function would look "
"something like::"
msgstr "因此在视图函数里处理 HTTP ``GET`` 的代码应该像下面这样："

msgid "In a class-based view, this would become::"
msgstr "而在基于类的视图里，会变成："

msgid ""
"Because Django's URL resolver expects to send the request and associated "
"arguments to a callable function, not a class, class-based views have an :"
"meth:`~django.views.generic.base.View.as_view` class method which returns a "
"function that can be called when a request arrives for a URL matching the "
"associated pattern. The function creates an instance of the class, calls :"
"meth:`~django.views.generic.base.View.setup` to initialize its attributes, "
"and then calls its :meth:`~django.views.generic.base.View.dispatch` method. "
"``dispatch`` looks at the request to determine whether it is a ``GET``, "
"``POST``, etc, and relays the request to a matching method if one is "
"defined, or raises :class:`~django.http.HttpResponseNotAllowed` if not::"
msgstr ""
"因为 Django 的 URL 解析器期望发送请求和相关参数来调动函数而不是类，基于类的视"
"图有一个 :meth:`~django.views.generic.base.View.as_view` 类方法，当一个请求到"
"达的 URL 被关联模式匹配时，这个类方法返回一个函数。这个函数创建一个类的实例，"
"调用 :meth:`~django.views.generic.base.View.setup` 初始化它的属性，然后调用 :"
"meth:`~django.views.generic.base.View.dispatch` 方法。 ``dispatch`` 观察请求"
"并决定它是  ``GET`` 和  ``POST``，等等。如果它被定义，那么依靠请求来匹配方"
"法，否则会引发 :class:`~django.http.HttpResponseNotAllowed` 。"

msgid ""
"It is worth noting that what your method returns is identical to what you "
"return from a function-based view, namely some form of :class:`~django.http."
"HttpResponse`. This means that :doc:`http shortcuts </topics/http/"
"shortcuts>` or :class:`~django.template.response.TemplateResponse` objects "
"are valid to use inside a class-based view."
msgstr ""
"值得注意的是，你的方法返回值和基于函数的视图返回值是相同的，既某种形式的 :"
"class:`~django.http.HttpResponse` 。这意味着 :doc:`http 快捷函数 </topics/"
"http/shortcuts>` 或 :class:`~django.template.response.TemplateResponse` 对象"
"可以使用基于类里的视图。"

msgid ""
"While a minimal class-based view does not require any class attributes to "
"perform its job, class attributes are useful in many class-based designs, "
"and there are two ways to configure or set class attributes."
msgstr ""
"虽然基于类的最小视图不需要任何类属性来执行任务，类属性在很多基于类的始终很常"
"见，这里有两种方法来配置或设置类属性。"

msgid ""
"The first is the standard Python way of subclassing and overriding "
"attributes and methods in the subclass. So that if your parent class had an "
"attribute ``greeting`` like this::"
msgstr ""
"第一种是子类化标准 Python 方式，并且在子类中覆盖属性和方法。所以如果父类有个"
"像 ``greeting`` 这样的属性："

msgid "You can override that in a subclass::"
msgstr "你可以在子类中覆盖它："

msgid ""
"Another option is to configure class attributes as keyword arguments to the :"
"meth:`~django.views.generic.base.View.as_view` call in the URLconf::"
msgstr ""
"另一个选择是在 URLconf 中将配置类属性作为参数来调用 :meth:`~django.views."
"generic.base.View.as_view` 。"

msgid ""
"While your class is instantiated for each request dispatched to it, class "
"attributes set through the :meth:`~django.views.generic.base.View.as_view` "
"entry point are configured only once at the time your URLs are imported."
msgstr ""
"当你的类为发送给它的每个请求实例化时，通过 :meth:`~django.views.generic.base."
"View.as_view` 入口点设置的类属性在导入 URLs  的时候只配置一次。"

msgid "Using mixins"
msgstr "使用 mixins"

msgid ""
"Mixins are a form of multiple inheritance where behaviors and attributes of "
"multiple parent classes can be combined."
msgstr "Mixins 是一个多继承表单，其中可组合多个父类的行为和属性。"

msgid ""
"For example, in the generic class-based views there is a mixin called :class:"
"`~django.views.generic.base.TemplateResponseMixin` whose primary purpose is "
"to define the method :meth:`~django.views.generic.base.TemplateResponseMixin."
"render_to_response`. When combined with the behavior of the :class:`~django."
"views.generic.base.View` base class, the result is a :class:`~django.views."
"generic.base.TemplateView` class that will dispatch requests to the "
"appropriate matching methods (a behavior defined in the ``View`` base "
"class), and that has a :meth:`~django.views.generic.base."
"TemplateResponseMixin.render_to_response` method that uses a :attr:`~django."
"views.generic.base.TemplateResponseMixin.template_name` attribute to return "
"a :class:`~django.template.response.TemplateResponse` object (a behavior "
"defined in the ``TemplateResponseMixin``)."
msgstr ""
"举例，在通用基于类的视图中，名为 :class:`~django.views.generic.base."
"TemplateResponseMixin` 的 mixin 的首要目的是定义方法 :meth:`~django.views."
"generic.base.TemplateResponseMixin.render_to_response`。当与视图的基类行为结"
"合使用时，结果是一个 :class:`~django.views.generic.base.TemplateView` 类，它"
"将请求分派到适当的匹配方法（在视图基类中定义的行为），并且具有 :meth:"
"`~django.views.generic.base.TemplateResponseMixin.render_to_response` 方法，"
"该方法使用 :attr:`~django.views.generic.base.TemplateResponseMixin."
"template_name` 属性返回一个 :class:`~django.template.response."
"TemplateResponse` 对象（在 ``TemplateResponseMixin`` 中定义的行为）。"

msgid ""
"Mixins are an excellent way of reusing code across multiple classes, but "
"they come with some cost. The more your code is scattered among mixins, the "
"harder it will be to read a child class and know what exactly it is doing, "
"and the harder it will be to know which methods from which mixins to "
"override if you are subclassing something that has a deep inheritance tree."
msgstr ""
"Mixins 是在多个类中重用代码的绝佳方法，但它们需要一些代价。代码分散在 Mixins "
"中的越多，理解子类并知道它到底在做什么就越困难，而且如果你正在子类化具有深继"
"承树的东西，那么就越难知道要从哪个 mixns 的方法中来覆盖它。"

msgid ""
"Note also that you can only inherit from one generic view - that is, only "
"one parent class may inherit from :class:`~django.views.generic.base.View` "
"and the rest (if any) should be mixins. Trying to inherit from more than one "
"class that inherits from ``View`` - for example, trying to use a form at the "
"top of a list and combining :class:`~django.views.generic.edit."
"ProcessFormView` and :class:`~django.views.generic.list.ListView` - won't "
"work as expected."
msgstr ""
"也需要注意你只能从一个通用视图继承——只有一个父类可以继承自 :class:`~django."
"views.generic.base.View` ，剩余的（如果有的话）应该继承自 mixins 。试着从更多"
"的继承自 ``View`` 的类继承的话——例如试着在列表顶部使用表单并组合 :class:"
"`~django.views.generic.list.ListView` ——将无法按照预期工作。"

msgid "Handling forms with class-based views"
msgstr "使用基于类的视图处理表单"

msgid ""
"A basic function-based view that handles forms may look something like this::"
msgstr "处理表单的基于函数的基础视图如下所示："

msgid "A similar class-based view might look like::"
msgstr "类似的基于类的视图可能看起来像这样："

msgid ""
"This is a minimal case, but you can see that you would then have the option "
"of customizing this view by overriding any of the class attributes, e.g. "
"``form_class``, via URLconf configuration, or subclassing and overriding one "
"or more of the methods (or both!)."
msgstr ""
"这是一个很小的案例，但你可以看到你可以选择通过覆盖类的任何属性来自定义这个视"
"图，比如 ``form_class`` ，通过 URLconf 配置或者子类化和重写一个或多个方法（或"
"者两种都可以）。"

msgid "Decorating class-based views"
msgstr "装饰基于类的视图"

msgid ""
"The extension of class-based views isn't limited to using mixins. You can "
"also use decorators. Since class-based views aren't functions, decorating "
"them works differently depending on if you're using ``as_view()`` or "
"creating a subclass."
msgstr ""
"基于类的视图的扩展不仅限于使用 mixins ，你也可以使用装饰器。因为基于类的视图"
"不是函数，所以根据你是使用 ``as_view()`` 还是创建子类，装饰它们的工作方式会有"
"不同。"

msgid "Decorating in URLconf"
msgstr "在 URLconf 中装饰"

msgid ""
"You can adjust class-based views by decorating the result of the :meth:"
"`~django.views.generic.base.View.as_view` method. The easiest place to do "
"this is in the URLconf where you deploy your view::"
msgstr ""
"可以通过装饰 :meth:`~django.views.generic.base.View.as_view` 方法的结果来调整"
"基于类的视图。最简单的方法是在你部署视图的 URLconf 中执行此操作："

msgid ""
"This approach applies the decorator on a per-instance basis. If you want "
"every instance of a view to be decorated, you need to take a different "
"approach."
msgstr ""
"这个方式在每个基本实例上应用装饰器。如果你想装饰视图的每个实例，你需要采用不"
"同方式。"

msgid "Decorating the class"
msgstr "装饰类"

msgid ""
"To decorate every instance of a class-based view, you need to decorate the "
"class definition itself. To do this you apply the decorator to the :meth:"
"`~django.views.generic.base.View.dispatch` method of the class."
msgstr ""
"装饰基于类的视图的每个实例，你需要装饰类定义本身。为此，你可以将装饰器应用到"
"类的 :meth:`~django.views.generic.base.View.dispatch` 方法。"

msgid ""
"A method on a class isn't quite the same as a standalone function, so you "
"can't just apply a function decorator to the method -- you need to transform "
"it into a method decorator first. The ``method_decorator`` decorator "
"transforms a function decorator into a method decorator so that it can be "
"used on an instance method. For example::"
msgstr ""
"类上的方法与独立函数完全不同，因此你不能应用函数装饰器到方法上——你需要先将它"
"转换为方法装饰器。``method_decorator`` 装饰器转换函数装饰器为防范装饰器，这样"
"它就被用在实例方法上。举例："

msgid ""
"Or, more succinctly, you can decorate the class instead and pass the name of "
"the method to be decorated as the keyword argument ``name``::"
msgstr ""
"或者，更简洁的说，你可以用装饰类来代替，并作为关键参数 ``name`` 传递要被装饰"
"的方法名："

msgid ""
"If you have a set of common decorators used in several places, you can "
"define a list or tuple of decorators and use this instead of invoking "
"``method_decorator()`` multiple times. These two classes are equivalent::"
msgstr ""
"如果你在一些地方使用了常见的装饰器，你可以定义一个装饰器列表或元组，并使用它"
"而不是多次调用 ``method_decorator()`` 。这两个类是等价的："

msgid ""
"The decorators will process a request in the order they are passed to the "
"decorator. In the example, ``never_cache()`` will process the request before "
"``login_required()``."
msgstr ""
"装饰器将按照它们传递给装饰器的顺序来处理请求。在这个例子里，"
"``never_cache()`` 将在 ``login_required()`` 之前处理请求。"

msgid ""
"In this example, every instance of ``ProtectedView`` will have login "
"protection. These examples use ``login_required``, however, the same "
"behavior can be obtained by using :class:`~django.contrib.auth.mixins."
"LoginRequiredMixin`."
msgstr ""
"在这个例子里，``ProtectedView`` 的每一个实例将被登录保护。尽管这些例子使用  "
"``login_required`` ，但可以使用 :class:`~django.contrib.auth.mixins."
"LoginRequiredMixin` 获得同样的行为。"

msgid ""
"``method_decorator`` passes ``*args`` and ``**kwargs`` as parameters to the "
"decorated method on the class. If your method does not accept a compatible "
"set of parameters it will raise a ``TypeError`` exception."
msgstr ""
"``method_decorator`` 将 ``*args`` 和 ``**kwargs`` 作为参数传递给类上的装饰方"
"法。如果你的方法不接受兼容参数集合，它会引发 ``TypeError`` 错误。"

msgid "Using mixins with class-based views"
msgstr "在基于类的视图中使用混入"

msgid ""
"This is an advanced topic. A working knowledge of :doc:`Django's class-based "
"views<index>` is advised before exploring these techniques."
msgstr ""
"这是一个进阶主题。在探索这些技术之前，建议先了解 :doc:`Django 基于类的视图 "
"<index>` 。"

msgid ""
"Django's built-in class-based views provide a lot of functionality, but some "
"of it you may want to use separately. For instance, you may want to write a "
"view that renders a template to make the HTTP response, but you can't use :"
"class:`~django.views.generic.base.TemplateView`; perhaps you need to render "
"a template only on ``POST``, with ``GET`` doing something else entirely. "
"While you could use :class:`~django.template.response.TemplateResponse` "
"directly, this will likely result in duplicate code."
msgstr ""
"Django 内置的基于类的视图提供了很多功能，但你可能想单独使用有些功能。例如，你"
"可能想写一个渲染一个模板来生成 HTTP 响应的视图，但你不能使用 :class:`~django."
"views.generic.base.TemplateView` ；也许你只需要在 ``POST`` 时渲染一个模板，"
"用 ``GET`` 来处理其他所有事。虽然你可以直接使用 :class:`~django.template."
"response.TemplateResponse`，但这很可能会导致重复代码。"

msgid ""
"For this reason, Django also provides a number of mixins that provide more "
"discrete functionality. Template rendering, for instance, is encapsulated in "
"the :class:`~django.views.generic.base.TemplateResponseMixin`. The Django "
"reference documentation contains :doc:`full documentation of all the mixins</"
"ref/class-based-views/mixins>`."
msgstr ""
"因此 Django 也提供了很多混入，它们提供了更多的离散功能。比如模板渲染，被封装"
"在 :class:`~django.views.generic.base.TemplateResponseMixin` 中。Django 参考"
"文档中包含 :doc:`所有混入的完整文档 </ref/class-based-views/mixins>`。"

msgid "Context and template responses"
msgstr "上下文和模板响应"

msgid ""
"Two central mixins are provided that help in providing a consistent "
"interface to working with templates in class-based views."
msgstr ""
"提供了两个重要的混入，它们有助于在基于类的视图中使用模板时提供一个一致的接"
"口。"

msgid ":class:`~django.views.generic.base.TemplateResponseMixin`"
msgstr ":class:`~django.views.generic.base.TemplateResponseMixin`"

msgid ""
"Every built in view which returns a :class:`~django.template.response."
"TemplateResponse` will call the :meth:`~django.views.generic.base."
"TemplateResponseMixin.render_to_response()` method that "
"``TemplateResponseMixin`` provides. Most of the time this will be called for "
"you (for instance, it is called by the ``get()`` method implemented by both :"
"class:`~django.views.generic.base.TemplateView` and :class:`~django.views."
"generic.detail.DetailView`); similarly, it's unlikely that you'll need to "
"override it, although if you want your response to return something not "
"rendered via a Django template then you'll want to do it. For an example of "
"this, see the :ref:`JSONResponseMixin example <jsonresponsemixin-example>`."
msgstr ""
"每个返回 :class:`~django.template.response.TemplateResponse` 的内置视图都将调"
"用 ``TemplateResponseMixin`` 提供的  :meth:`~django.views.generic.base."
"TemplateResponseMixin.render_to_response()` 方法。大多数时候，这个方法会被你"
"调用（例如，它被 :class:`~django.views.generic.base.TemplateView` 和 :class:"
"`~django.views.generic.detail.DetailView` 共同实现的 ``get()`` 方法调用）；同"
"样，你也不太可能需要覆盖它，但如果你想让你的响应返回一些没有通过 Django 模板"
"渲染的东西，那么你会想要这样做。关于这个例子，请看 :ref:`JSONResponseMixin 例"
"子 <jsonresponsemixin-example>`。"

msgid ""
"``render_to_response()`` itself calls :meth:`~django.views.generic.base."
"TemplateResponseMixin.get_template_names`, which by default will look up :"
"attr:`~django.views.generic.base.TemplateResponseMixin.template_name` on the "
"class-based view; two other mixins (:class:`~django.views.generic.detail."
"SingleObjectTemplateResponseMixin` and :class:`~django.views.generic.list."
"MultipleObjectTemplateResponseMixin`) override this to provide more flexible "
"defaults when dealing with actual objects."
msgstr ""
"``render_to_response()`` 本身会调用 :meth:`~django.views.generic.base."
"TemplateResponseMixin.get_template_names` ，默认情况下，它会在基于类的视图上"
"查找 :attr:`~django.views.generic.base.TemplateResponseMixin.template_name` "
"；另外两个混入（ :class:`~django.views.generic.detail."
"SingleObjectTemplateResponseMixin` 和 :class:`~django.views.generic.list."
"MultipleObjectTemplateResponseMixin` ）覆盖了这一点，以在处理实际对象时提供更"
"灵活的默认值。"

msgid ":class:`~django.views.generic.base.ContextMixin`"
msgstr ":class:`~django.views.generic.base.ContextMixin`"

msgid ""
"Every built in view which needs context data, such as for rendering a "
"template (including ``TemplateResponseMixin`` above), should call :meth:"
"`~django.views.generic.base.ContextMixin.get_context_data()` passing any "
"data they want to ensure is in there as keyword arguments. "
"``get_context_data()`` returns a dictionary; in ``ContextMixin`` it returns "
"its keyword arguments, but it is common to override this to add more members "
"to the dictionary. You can also use the :attr:`~django.views.generic.base."
"ContextMixin.extra_context` attribute."
msgstr ""
"每个需要上下文数据的内置视图，比如为了渲染一个模板（包括上面的 "
"``TemplateResponseMixin`` ），都应该将他们想确定传入的数据作为关键字参数传"
"入 :meth:`~django.views.generic.base.ContextMixin.get_context_data()` 调用。"
"``get_context_data()`` 返回一个字典；在 ``ContextMixin`` 中它返回它的关键字参"
"数，但通常覆盖此项来增加更多成员到字典中。你也可以使用 :attr:`~django.views."
"generic.base.ContextMixin.extra_context` 属性。"

msgid "Building up Django's generic class-based views"
msgstr "构造 Django 基于类的通用视图"

msgid ""
"Let's look at how two of Django's generic class-based views are built out of "
"mixins providing discrete functionality. We'll consider :class:`~django."
"views.generic.detail.DetailView`, which renders a \"detail\" view of an "
"object, and :class:`~django.views.generic.list.ListView`, which will render "
"a list of objects, typically from a queryset, and optionally paginate them. "
"This will introduce us to four mixins which between them provide useful "
"functionality when working with either a single Django object, or multiple "
"objects."
msgstr ""
"让我们看看 Django 的两个基于类的通用视图是如何由提供离散功能的混入构建的。我"
"们将考虑 :class:`~django.views.generic.detail.DetailView` ，它渲染一个对象的 "
"“详情” 视图，以及 :class:`~django.views.generic.list.ListView` ，它渲染一个对"
"象列表，通常来自一个查询集，并可选择将它们分页。这里将介绍四个混入，无论是在"
"处理单个 Django 对象还是多个对象时，它们都提供了有用的功能。"

msgid ""
"There are also mixins involved in the generic edit views (:class:`~django."
"views.generic.edit.FormView`, and the model-specific views :class:`~django."
"views.generic.edit.CreateView`, :class:`~django.views.generic.edit."
"UpdateView` and :class:`~django.views.generic.edit.DeleteView`), and in the "
"date-based generic views. These are covered in the :doc:`mixin reference "
"documentation</ref/class-based-views/mixins>`."
msgstr ""
"通用编辑视图（ :class:`~django.views.generic.edit.FormView`，和模型专用的视"
"图 :class:`~django.views.generic.edit.CreateView`，:class:`~django.views."
"generic.edit.UpdateView` 和 :class:`~django.views.generic.edit."
"DeleteView` ），以及基于日期的通用视图中也涉及到混入。这些内容在 :doc:`混入参"
"考文档 </ref/class-based-views/mixins>` 中有所涉及。"

msgid "``DetailView``: working with a single Django object"
msgstr "``DetailView`` ：使用单个 Django 对象"

msgid ""
"To show the detail of an object, we basically need to do two things: we need "
"to look up the object and then we need to make a :class:`~django.template."
"response.TemplateResponse` with a suitable template, and that object as "
"context."
msgstr ""
"要显示一个对象的详情，我们基本上需要做两件事：我们需要查询对象，然后将该对象"
"作为上下文，用一个合适的模板生成一个 :class:`~django.template.response."
"TemplateResponse` 。"

msgid ""
"To get the object, :class:`~django.views.generic.detail.DetailView` relies "
"on :class:`~django.views.generic.detail.SingleObjectMixin`, which provides "
"a :meth:`~django.views.generic.detail.SingleObjectMixin.get_object` method "
"that figures out the object based on the URL of the request (it looks for "
"``pk`` and ``slug`` keyword arguments as declared in the URLConf, and looks "
"the object up either from the :attr:`~django.views.generic.detail."
"SingleObjectMixin.model` attribute on the view, or the :attr:`~django.views."
"generic.detail.SingleObjectMixin.queryset` attribute if that's provided). "
"``SingleObjectMixin`` also overrides :meth:`~django.views.generic.base."
"ContextMixin.get_context_data()`, which is used across all Django's built in "
"class-based views to supply context data for template renders."
msgstr ""
"为了得到对象，:class:`~django.views.generic.detail.DetailView` 依赖于 :class:"
"`~django.views.generic.detail.SingleObjectMixin` ，它提供一个 :meth:`~django."
"views.generic.detail.SingleObjectMixin.get_object` 方法，该方法根据请求的 "
"URL 来找出对象（它查找 URLconf 中声明的 ``pk`` 和 ``slug`` 关键字参数，并从视"
"图上的 :attr:`~django.views.generic.detail.SingleObjectMixin.model`  属性查找"
"对象，或者从提供的 :attr:`~django.views.generic.detail.SingleObjectMixin."
"queryset` 属性中查找）。``SingleObjectMixin`` 还覆盖了 :meth:`~django.views."
"generic.base.ContextMixin.get_context_data()` ，它被用于所有 Django 内置的基"
"于类的视图，为模板渲染提供上下文数据。"

msgid ""
"To then make a :class:`~django.template.response.TemplateResponse`, :class:"
"`DetailView` uses :class:`~django.views.generic.detail."
"SingleObjectTemplateResponseMixin`, which extends :class:`~django.views."
"generic.base.TemplateResponseMixin`, overriding :meth:`~django.views.generic."
"base.TemplateResponseMixin.get_template_names()` as discussed above. It "
"actually provides a fairly sophisticated set of options, but the main one "
"that most people are going to use is ``<app_label>/<model_name>_detail."
"html``. The ``_detail`` part can be changed by setting :attr:`~django.views."
"generic.detail.SingleObjectTemplateResponseMixin.template_name_suffix` on a "
"subclass to something else. (For instance, the :doc:`generic edit "
"views<generic-editing>` use ``_form`` for create and update views, and "
"``_confirm_delete`` for delete views.)"
msgstr ""
"然后为了生成一个 :class:`~django.template.response.TemplateResponse`， :"
"class:`DetailView` 使用了 :class:`~django.views.generic.detail."
"SingleObjectTemplateResponseMixin`，它扩展了 :class:`~django. views.generic."
"base.TemplateResponseMixin`，如上所述的覆盖了 :meth:`~django.views.generic."
"base.TemplateResponseMixin.get_template_names()`。它实际上提供了一组相当复杂"
"的选项，但大多数人都会使用的主要选项是 ``<app_label>/<model_name> _detail."
"html``。``_detail`` 部分可以通过在子类上设置 :attr:`~django.views.generic."
"detail.SingleObjectTemplateResponseMixin.template_name_suffix` 来改变。（例"
"如 :doc:`通用编辑视图 <generic-editing>` 的创建和更新视图使用 ``_form``，删除"
"视图使用 ``_confirm_delete``。）"

msgid "``ListView``: working with many Django objects"
msgstr "``ListView`` ：使用多个 Django 对象"

msgid ""
"Lists of objects follow roughly the same pattern: we need a (possibly "
"paginated) list of objects, typically a :class:`~django.db.models.query."
"QuerySet`, and then we need to make a :class:`~django.template.response."
"TemplateResponse` with a suitable template using that list of objects."
msgstr ""
"对象列表大致遵循相同的模式：我们需要一个（可能是分页的）对象列表，通常是 :"
"class:`~django.db.models.query.QuerySet` ，然后根据这个对象列表使用合适的模板"
"生成 :class:`~django.template.response.TemplateResponse` 。"

msgid ""
"To get the objects, :class:`~django.views.generic.list.ListView` uses :class:"
"`~django.views.generic.list.MultipleObjectMixin`, which provides both :meth:"
"`~django.views.generic.list.MultipleObjectMixin.get_queryset` and :meth:"
"`~django.views.generic.list.MultipleObjectMixin.paginate_queryset`. Unlike "
"with :class:`~django.views.generic.detail.SingleObjectMixin`, there's no "
"need to key off parts of the URL to figure out the queryset to work with, so "
"the default uses the :attr:`~django.views.generic.list.MultipleObjectMixin."
"queryset` or :attr:`~django.views.generic.list.MultipleObjectMixin.model` "
"attribute on the view class. A common reason to override :meth:`~django."
"views.generic.list.MultipleObjectMixin.get_queryset` here would be to "
"dynamically vary the objects, such as depending on the current user or to "
"exclude posts in the future for a blog."
msgstr ""
"为了得到对象，:class:`~django.views.generic.list.ListView` 使用了 :class:"
"`~django.views.generic.list.MultipleObjectMixin` ，它同时提供 :meth:`~django."
"views.generic.list.MultipleObjectMixin.get_queryset` 和 :meth:`~django.views."
"generic.list.MultipleObjectMixin.paginate_queryset` 。与 :class:`~django."
"views.generic.detail.SingleObjectMixin` 不同的是，不需要使用部分 URL 来找出要"
"使用的查询集，所以默认使用视图类上的 :attr:`~django.views.generic.list."
"MultipleObjectMixin.queryset` 或  :attr:`~django.views.generic.list."
"MultipleObjectMixin.model` 属性。在这里覆盖 :meth:`~django.views.generic."
"list.MultipleObjectMixin.get_queryset` 的常见原因是为了动态变化的对象，比如根"
"据当前用户的情况，或者为了排除博客未来的文章。"

msgid ""
":class:`~django.views.generic.list.MultipleObjectMixin` also overrides :meth:"
"`~django.views.generic.base.ContextMixin.get_context_data()` to include "
"appropriate context variables for pagination (providing dummies if "
"pagination is disabled). It relies on ``object_list`` being passed in as a "
"keyword argument, which :class:`ListView` arranges for it."
msgstr ""
":class:`~django.views.generic.list.MultipleObjectMixin` 还覆盖了 :meth:"
"`~django.views.generic.base.ContextMixin.get_context_data()`，为分页加入了适"
"当的上下文变量（如果分页被禁用，则提供虚假分页）。它依赖于 :class:`ListView` "
"作为关键字参数传入的 ``object_list``。"

msgid ""
"To make a :class:`~django.template.response.TemplateResponse`, :class:"
"`ListView` then uses :class:`~django.views.generic.list."
"MultipleObjectTemplateResponseMixin`; as with :class:`~django.views.generic."
"detail.SingleObjectTemplateResponseMixin` above, this overrides "
"``get_template_names()`` to provide :meth:`a range of options <django.views."
"generic.list.MultipleObjectTemplateResponseMixin>`, with the most commonly-"
"used being ``<app_label>/<model_name>_list.html``, with the ``_list`` part "
"again being taken from the :attr:`~django.views.generic.list."
"MultipleObjectTemplateResponseMixin.template_name_suffix` attribute. (The "
"date based generic views use suffixes such as ``_archive``, "
"``_archive_year`` and so on to use different templates for the various "
"specialized date-based list views.)"
msgstr ""
"要生成一个 :class:`~django.template.response.TemplateResponse` ，:class:"
"`ListView` 则使用 :class:`~django.views.generic.list."
"MultipleObjectTemplateResponseMixin` ；和上面的 :class:`~django.views."
"generic.detail.SingleObjectTemplateResponseMixin` 一样，它覆盖 "
"``get_template_names()`` 来提供一系列选项，最常用的 ``<app_label>/"
"<model_name>_list.html`` ，``_list`` 部分同样从 :attr:`~django.views.generic."
"list.MultipleObjectTemplateResponseMixin.template_name_suffix` 属性中获取。"
"（基于日期的通用视图使用诸如  ``_archive`` 、``_archive_year`` 等后缀来为各种"
"专门的基于日期的列表视图使用不同的模板。）"

msgid "Using Django's class-based view mixins"
msgstr "使用 Django 的基于类的视图混入"

msgid ""
"Now we've seen how Django's generic class-based views use the provided "
"mixins, let's look at other ways we can combine them. We're still going to "
"be combining them with either built-in class-based views, or other generic "
"class-based views, but there are a range of rarer problems you can solve "
"than are provided for by Django out of the box."
msgstr ""
"现在我们已经知道 Django 的基于类的通用视图如何使用所提供的混入，让我们看看使"
"用它们的其他方式。我们仍然会将它们与内置的基于类的视图，或者其他通用的基于类"
"的视图结合起来，但是，有一系列比 Django 开箱即用所提供的更罕见的问题可以被解"
"决。"

msgid ""
"Not all mixins can be used together, and not all generic class based views "
"can be used with all other mixins. Here we present a few examples that do "
"work; if you want to bring together other functionality then you'll have to "
"consider interactions between attributes and methods that overlap between "
"the different classes you're using, and how `method resolution order`_ will "
"affect which versions of the methods will be called in what order."
msgstr ""
"不是所有的混入都可以一起使用，并且不是所有的基于类的通用视图能和所有其他的混"
"入一起使用。这里我们介绍一些有用的例子；如果你想把其他功能汇集在一起，那么你"
"就必须考虑你正在使用的不同类之间重叠的属性和方法之间的相互作用，以及 `method "
"resolution order`_ 将如何影响哪些版本的方法将以何种顺序被调用。"

msgid ""
"The reference documentation for Django's :doc:`class-based views</ref/class-"
"based-views/index>` and :doc:`class-based view mixins</ref/class-based-views/"
"mixins>` will help you in understanding which attributes and methods are "
"likely to cause conflict between different classes and mixins."
msgstr ""
"Django 的  :doc:`基于类的视图 </ref/class-based-views/index>` 和 :doc:`基于类"
"的视图混入 </ref/class-based-views/mixins>` 的参考文档将帮助你理解哪些属性和"
"方法可能会导致不同类和混入之间发生冲突。"

msgid ""
"If in doubt, it's often better to back off and base your work on :class:"
"`View` or :class:`TemplateView`, perhaps with :class:`~django.views.generic."
"detail.SingleObjectMixin` and :class:`~django.views.generic.list."
"MultipleObjectMixin`. Although you will probably end up writing more code, "
"it is more likely to be clearly understandable to someone else coming to it "
"later, and with fewer interactions to worry about you will save yourself "
"some thinking. (Of course, you can always dip into Django's implementation "
"of the generic class-based views for inspiration on how to tackle problems.)"
msgstr ""
"如果有问题，最好还是退而求其次，以 :class:`View` 或 :class:`TemplateView` 为"
"基础，或许可以用 :class:`~django.views.generic.detail.SingleObjectMixin` 和 :"
"class:`~django.views.generic.list.MultipleObjectMixin` 。虽然你最终可能会写出"
"更多的代码，但对于以后再来的人来说，更有可能清楚地理解，并且由于需要担心的交"
"互较少，你可以省去一些思考。（当然，你可以随时查阅 Django 的基于类的通用视图"
"的实现，以获得如何处理问题的灵感）。"

msgid "Using ``SingleObjectMixin`` with View"
msgstr "在视图中使用 ``SingleObjectMixin``"

msgid ""
"If we want to write a class-based view that responds only to ``POST``, we'll "
"subclass :class:`~django.views.generic.base.View` and write a ``post()`` "
"method in the subclass. However if we want our processing to work on a "
"particular object, identified from the URL, we'll want the functionality "
"provided by :class:`~django.views.generic.detail.SingleObjectMixin`."
msgstr ""
"如果我们想编写一个只响应 ``POST`` 的基于类的视图，我们将子类化 :class:"
"`~django.views.generic.base.View` 并且在子类中编写一个 ``post()`` 方法。但是"
"如果想让我们的程序在一个从 URL 中识别出来特定的对象上工作，我们就需要 :class:"
"`~django.views.generic.detail.SingleObjectMixin` 提供的功能。"

msgid ""
"We'll demonstrate this with the ``Author`` model we used in the :doc:"
"`generic class-based views introduction<generic-display>`."
msgstr ""
"我们将用在 :doc: `基于类的通用视图介绍 <generic-display>` 中使用的 "
"``Author`` 模型来演示。"

msgid ""
"In practice you'd probably want to record the interest in a key-value store "
"rather than in a relational database, so we've left that bit out. The only "
"bit of the view that needs to worry about using :class:`~django.views."
"generic.detail.SingleObjectMixin` is where we want to look up the author "
"we're interested in, which it does with a call to ``self.get_object()``. "
"Everything else is taken care of for us by the mixin."
msgstr ""
"在实际操作中，你可能会希望把兴趣记录在一个键值存储中，而不是关系数据库中，所"
"以我们把关于数据库的省略了。视图在使用 :class:`~django.views.generic.detail."
"SingleObjectMixin` 时，我们唯一需要担心的地方是想要查找我们感兴趣的作者，它通"
"过调用 ``self.get_object()`` 来实现。其他的一切都由混入替我们处理。"

msgid "We can hook this into our URLs easily enough:"
msgstr "我们可以很简单的将它挂接在我们的 URLs 中："

msgid ""
"Note the ``pk`` named group, which :meth:`~django.views.generic.detail."
"SingleObjectMixin.get_object` uses to look up the ``Author`` instance. You "
"could also use a slug, or any of the other features of :class:`~django.views."
"generic.detail.SingleObjectMixin`."
msgstr ""
"注意 ``pk`` 命名的组，:meth:`~django.views.generic.detail.SingleObjectMixin."
"get_object` 用它来查找 ``Author`` 实例。你也可以使用 slug，或者 :class:"
"`~django.views.generic.detail.SingleObjectMixin` 的任何其他功能。"

msgid "Using ``SingleObjectMixin`` with ``ListView``"
msgstr "在 ``ListView`` 中使用 ``SingleObjectMixin``"

msgid ""
":class:`~django.views.generic.list.ListView` provides built-in pagination, "
"but you might want to paginate a list of objects that are all linked (by a "
"foreign key) to another object. In our publishing example, you might want to "
"paginate through all the books by a particular publisher."
msgstr ""
":class:`~django.views.generic.list.ListView` 提供了内置的分页功能，但你可能想"
"将一个对象列表分页，而这些对象都是通过一个外键链接到另一个对象的。在我们的出"
"版示例中，你可能想对某一出版商的所有书籍进行分页。"

msgid ""
"One way to do this is to combine :class:`ListView` with :class:`~django."
"views.generic.detail.SingleObjectMixin`, so that the queryset for the "
"paginated list of books can hang off the publisher found as the single "
"object. In order to do this, we need to have two different querysets:"
msgstr ""
"一种方法是将 :class:`ListView` 和 :class:`~django.views.generic.detail."
"SingleObjectMixin` 结合起来，这样一来，用于图书分页列表的查询集就可以脱离作为"
"单个对象找到的出版商对象。 为此，我们需要两个不同的查询集："

msgid ""
"``Book`` queryset for use by :class:`~django.views.generic.list.ListView`"
msgstr ":class:`~django.views.generic.list.ListView` 使用的 ``Book`` 查询集"

msgid ""
"Since we have access to the ``Publisher`` whose books we want to list, we "
"override ``get_queryset()`` and use the ``Publisher``’s :ref:`reverse "
"foreign key manager<backwards-related-objects>`."
msgstr ""
"由于我们已经得到了我们所想要书籍列表的 ``Publisher`` ，我们只需覆盖 "
"``get_queryset()`` 并使用的 ``Publisher`` 的 :ref:`反向外键管理器 <backwards-"
"related-objects>`。"

msgid ""
"``Publisher`` queryset for use in :meth:`~django.views.generic.detail."
"SingleObjectMixin.get_object()`"
msgstr ""
":meth:`~django.views.generic.detail.SingleObjectMixin.get_object()` 使用的 "
"``Publisher`` 查询集"

msgid ""
"We'll rely on the default implementation of ``get_object()`` to fetch the "
"correct ``Publisher`` object. However, we need to explicitly pass a "
"``queryset`` argument because otherwise the default implementation of "
"``get_object()`` would call ``get_queryset()`` which we have overridden to "
"return ``Book`` objects instead of ``Publisher`` ones."
msgstr ""
"我们将依赖 ``get_object()`` 的默认实现来获取正确的 ``Publisher`` 对象。然而，"
"我们需要显式地传递一个 ``queryset`` 参数，因为 ``get_object()`` 的默认实现会"
"调用 ``get_queryset()`` ，我们已经覆盖了它并返回了 ``Book`` 对象而不是 "
"``Publisher`` 对象。"

msgid ""
"We have to think carefully about ``get_context_data()``. Since both :class:"
"`~django.views.generic.detail.SingleObjectMixin` and :class:`ListView` will "
"put things in the context data under the value of ``context_object_name`` if "
"it's set, we'll instead explicitly ensure the ``Publisher`` is in the "
"context data. :class:`ListView` will add in the suitable ``page_obj`` and "
"``paginator`` for us providing we remember to call ``super()``."
msgstr ""
"我们必须认真考虑 ``get_context_data()``。由于 :class:`~django.views.generic."
"detail.SingleObjectMixin` 和  :class:`ListView` 会将上下文数据放在 "
"``context_object_name`` 的值下（如果它已设置），我们要明确确保 ``Publisher`` "
"在上下文数据中。:class:`ListView` 将为我们添加合适的 ``page_obj`` 和 "
"``paginator``，只要我们记得调用 ``super()``。"

msgid "Now we can write a new ``PublisherDetailView``::"
msgstr ""

msgid ""
"Notice how we set ``self.object`` within ``get()`` so we can use it again "
"later in ``get_context_data()`` and ``get_queryset()``. If you don't set "
"``template_name``, the template will default to the normal :class:`ListView` "
"choice, which in this case would be ``\"books/book_list.html\"`` because "
"it's a list of books; :class:`ListView` knows nothing about :class:`~django."
"views.generic.detail.SingleObjectMixin`, so it doesn't have any clue this "
"view is anything to do with a ``Publisher``."
msgstr ""
"注意看我们如何在 ``get()`` 中设置 ``self.object`` ，这样我们可以在后面的 "
"``get_context_data()`` 和  ``get_queryset()`` 中再次使用它。如果你没有设置 "
"``template_name`` ，模板将为正常 :class:`ListView` 的默认选项，在这个例子里"
"是 ``\"books/book_list.html\"`` ，因为它是书籍的列表；:class:`ListView` 对 :"
"class:`~django.views.generic.detail.SingleObjectMixin` 一无所知，因此这个视图"
"和 ``Publisher`` 没有任何关系。"

msgid ""
"The ``paginate_by`` is deliberately small in the example so you don't have "
"to create lots of books to see the pagination working! Here's the template "
"you'd want to use:"
msgstr ""
"在这个例子中，``paginate_by`` 被刻意地缩小了，所以你不需要创建很多书就能看到"
"分页的效果。这里是你要使用的模板："

msgid "Avoid anything more complex"
msgstr "避免过度复杂的事情"

msgid ""
"Generally you can use :class:`~django.views.generic.base."
"TemplateResponseMixin` and :class:`~django.views.generic.detail."
"SingleObjectMixin` when you need their functionality. As shown above, with a "
"bit of care you can even combine ``SingleObjectMixin`` with :class:`~django."
"views.generic.list.ListView`. However things get increasingly complex as you "
"try to do so, and a good rule of thumb is:"
msgstr ""
"一般来说，你可以在需要的时候使用 :class:`~django.views.generic.base."
"TemplateResponseMixin` 和  :class:`~django.views.generic.detail."
"SingleObjectMixin` 的功能。如上所示，只要稍加注意，你甚至可以将 "
"``SingleObjectMixin`` 和 :class:`~django.views.generic.list.ListView` 结合起"
"来。然而当你尝试这样做时，事情会变得越来越复杂，一个好的经验法则是："

msgid ""
"Each of your views should use only mixins or views from one of the groups of "
"generic class-based views: :doc:`detail, list<generic-display>`, :doc:"
"`editing<generic-editing>` and date. For example it's fine to combine :class:"
"`TemplateView` (built in view) with :class:`~django.views.generic.list."
"MultipleObjectMixin` (generic list), but you're likely to have problems "
"combining ``SingleObjectMixin`` (generic detail) with "
"``MultipleObjectMixin`` (generic list)."
msgstr ""
"你的每个视图应该只使用混入或者来自一个通用基于类的视图的组里视图： :doc:`详"
"情，列表 <generic-display>`，:doc:`编辑 <generic-editing>` 和日期。例如，将 :"
"class:`TemplateView` （内置视图）和 :class:`~django.views.generic.list."
"MultipleObjectMixin` （通用列表）结合起来，但你可能会在 "
"``SingleObjectMixin`` （通用详情）和 ``MultipleObjectMixin`` （通用列表）结合"
"时遇到问题。"

msgid ""
"To show what happens when you try to get more sophisticated, we show an "
"example that sacrifices readability and maintainability when there is a "
"simpler solution. First, let's look at a naive attempt to combine :class:"
"`~django.views.generic.detail.DetailView` with :class:`~django.views.generic."
"edit.FormMixin` to enable us to ``POST`` a Django :class:`~django.forms."
"Form` to the same URL as we're displaying an object using :class:"
"`DetailView`."
msgstr ""
"为了给你展示当变得更复杂时发生了什么，我们展示了一个当有更简单的解决方案时，"
"牺牲了可读写和可维护性的例子。首先，让我们看看一个天真的尝试，将 :class:"
"`~django.views.generic.detail.DetailView` 和 :class:`~django.views.generic."
"edit.FormMixin` 结合起来，使我们能够在 ``POST`` 一个 Django :class:`~django."
"forms.Form` 和显示一个 :class:`DetailView` 时使用同一个 URL。"

msgid "Using ``FormMixin`` with ``DetailView``"
msgstr "``DetailView`` 和 ``FormMixin`` 一起使用"

msgid ""
"Think back to our earlier example of using :class:`View` and :class:`~django."
"views.generic.detail.SingleObjectMixin` together. We were recording a user's "
"interest in a particular author; say now that we want to let them leave a "
"message saying why they like them. Again, let's assume we're not going to "
"store this in a relational database but instead in something more esoteric "
"that we won't worry about here."
msgstr ""
"回想一下我们之前使用 :class:`View` 和 :class:`~django.views.generic.detail."
"SingleObjectMixin` 一起使用的例子。我们当时记录的是一个用户对某个作者的兴趣；"
"比如说现在我们想让他们留言说为什么喜欢他们。同样，我们假设我们不打算把这个存"
"储在关系型数据库中，而是存储在更深奥的东西中，我们在这里就不关心了。"

msgid ""
"At this point it's natural to reach for a :class:`~django.forms.Form` to "
"encapsulate the information sent from the user's browser to Django. Say also "
"that we're heavily invested in `REST`_, so we want to use the same URL for "
"displaying the author as for capturing the message from the user. Let's "
"rewrite our ``AuthorDetailView`` to do that."
msgstr ""
"这时自然而然就会用到一个 :class:`~django.forms.Form` 来封装从用户浏览器发送"
"到 Django 的信息。又比如说我们在 `REST`_ 上投入了大量的精力，所以我们希望用同"
"样的 URL 来显示作者和捕捉用户的信息。让我们重写我们的 ``AuthorDetailView`` 来"
"实现这个目标。"

msgid ""
"We'll keep the ``GET`` handling from :class:`DetailView`, although we'll "
"have to add a :class:`~django.forms.Form` into the context data so we can "
"render it in the template. We'll also want to pull in form processing from :"
"class:`~django.views.generic.edit.FormMixin`, and write a bit of code so "
"that on ``POST`` the form gets called appropriately."
msgstr ""
"我们将保留 :class:`DetailView` 中的 ``GET`` 处理，尽管我们必须在上下文数据中"
"添加一个 :class:`~django.forms.Form`，这样我们就可以在模板中渲染它。我们还要"
"从 :class:`~django.views.generic.edit.FormMixin` 中调入表单处理，并写一点代"
"码，这样在 ``POST` `时，表单会被适当地调用。"

msgid ""
"We use :class:`~django.views.generic.edit.FormMixin` and implement "
"``post()`` ourselves rather than try to mix :class:`DetailView` with :class:"
"`FormView` (which provides a suitable ``post()`` already) because both of "
"the views implement ``get()``, and things would get much more confusing."
msgstr ""
"我们使用 :class:`~django.views.generic.edit.FormMixin` 并自己实现了 "
"``post()`` ，而不是试着把 :class:`DetailView` 和 :class:`FormView` （也都提供"
"合适的 ``post()``）混着用，因为这两个视图都实现了 ``get()`` ，这样会让事情变"
"得更复杂。"

msgid "Our new ``AuthorDetailView`` looks like this::"
msgstr ""

msgid ""
"``get_success_url()`` provides somewhere to redirect to, which gets used in "
"the default implementation of ``form_valid()``. We have to provide our own "
"``post()`` as noted earlier."
msgstr ""
"``get_success_url()`` 提供了重定向的去处，它在 ``form_valid()`` 的默认实现中"
"使用。如前所述，我们需要提供自己的 ``post()`` 。"

msgid "A better solution"
msgstr "更好的解决方案"

msgid ""
"The number of subtle interactions between :class:`~django.views.generic.edit."
"FormMixin` and :class:`DetailView` is already testing our ability to manage "
"things. It's unlikely you'd want to write this kind of class yourself."
msgstr ""
":class:`~django.views.generic.edit.FormMixin` 和 :class:`DetailView` 之间微妙"
"交互已经在测试我们管理事务的能力了。你不太可能想写这样的类。"

msgid ""
"In this case, you could write the ``post()`` method yourself, keeping :class:"
"`DetailView` as the only generic functionality, although writing :class:"
"`~django.forms.Form` handling code involves a lot of duplication."
msgstr ""
"在这个例子里，你可以编写 ``post()`` 让 :class:`DetailView` 作为唯一的通用功"
"能，尽管编写 :class:`~django.forms.Form` 的处理代码会涉及到很多重复的地方。"

msgid ""
"Alternatively, it would still be less work than the above approach to have a "
"separate view for processing the form, which could use :class:`~django.views."
"generic.edit.FormView` distinct from :class:`DetailView` without concerns."
msgstr ""
"或者，使用单独的视图来处理表单仍然比上述方法工作量小，它可以使用 :class:"
"`~django.views.generic.edit.FormView` ，而不必担心任何问题。"

msgid "An alternative better solution"
msgstr "另一种更好的解决方案"

msgid ""
"What we're really trying to do here is to use two different class based "
"views from the same URL. So why not do just that? We have a very clear "
"division here: ``GET`` requests should get the :class:`DetailView` (with "
"the :class:`~django.forms.Form` added to the context data), and ``POST`` "
"requests should get the :class:`FormView`. Let's set up those views first."
msgstr ""
"我们在这里真正想做的是在同一个 URL 中使用两个不同的基于类的视图。那么为什么不"
"这样做呢？我们在这里有一个非常明确的划分。``GET`` 请求应该得到 :class:"
"`DetailView` （在上下文数据中添加了 :class:`~django.forms.Form` ），而 "
"``POST`` 请求应该得到 :class:`FormView`。我们先来设置一下这些视图。"

msgid ""
"The ``AuthorDetailView`` view is almost the same as :ref:`when we first "
"introduced AuthorDetailView<generic-views-extra-work>`; we have to write our "
"own ``get_context_data()`` to make the ``AuthorInterestForm`` available to "
"the template. We'll skip the ``get_object()`` override from before for "
"clarity::"
msgstr ""

msgid ""
"Then the ``AuthorInterestForm`` is a :class:`FormView`, but we have to bring "
"in :class:`~django.views.generic.detail.SingleObjectMixin` so we can find "
"the author we're talking about, and we have to remember to set "
"``template_name`` to ensure that form errors will render the same template "
"as ``AuthorDetailView`` is using on ``GET``::"
msgstr ""

msgid ""
"Finally we bring this together in a new ``AuthorView`` view. We already know "
"that calling :meth:`~django.views.generic.base.View.as_view()` on a class-"
"based view gives us something that behaves exactly like a function based "
"view, so we can do that at the point we choose between the two subviews."
msgstr ""

msgid ""
"You can pass through keyword arguments to :meth:`~django.views.generic.base."
"View.as_view()` in the same way you would in your URLconf, such as if you "
"wanted the ``AuthorInterestFormView`` behavior to also appear at another URL "
"but using a different template::"
msgstr ""

msgid ""
"This approach can also be used with any other generic class-based views or "
"your own class-based views inheriting directly from :class:`View` or :class:"
"`TemplateView`, as it keeps the different views as separate as possible."
msgstr ""
"这个方式也可以被任何其他通用基于类的视图，或你自己实现的直接继承自 :class:"
"`View` 或 :class:`TemplateView` 的基于类的视图使用，因为它使不同视图尽可能分"
"离。"

msgid "More than just HTML"
msgstr "不仅仅是 HTML"

msgid ""
"Where class-based views shine is when you want to do the same thing many "
"times. Suppose you're writing an API, and every view should return JSON "
"instead of rendered HTML."
msgstr ""
"基于类的视图的优势是你可以多次执行相同操作。假设你正在编写 API，那么每个视图"
"应该返回 JSON，而不是渲染 HTML。"

msgid ""
"We can create a mixin class to use in all of our views, handling the "
"conversion to JSON once."
msgstr "我们可以创建一个混入类来在所有视图里使用，用它来进行一次转换到 JSON。"

msgid "For example, a JSON mixin might look something like this::"
msgstr "比如，一个 JSON 混入可以是这样："

msgid ""
"Check out the :doc:`/topics/serialization` documentation for more "
"information on how to correctly transform Django models and querysets into "
"JSON."
msgstr ""
"查看 :doc:`/topics/serialization` 文档来获取更多有关如何正确转换 Django 模型"
"和查询集为 JSON。"

msgid ""
"This mixin provides a ``render_to_json_response()`` method with the same "
"signature as :func:`~django.views.generic.base.TemplateResponseMixin."
"render_to_response()`. To use it, we need to mix it into a ``TemplateView`` "
"for example, and override ``render_to_response()`` to call "
"``render_to_json_response()`` instead::"
msgstr ""
"混入提供了 ``render_to_json_response()`` 方法，其签名与 :func:`~django.views."
"generic.base.TemplateResponseMixin.render_to_response()` 相同。为了使用它，我"
"们需要把它混入一个 ``TemplateView`` 里，并且重写 ``render_to_response()`` 来"
"调用 ``render_to_json_response()`` ："

msgid ""
"Equally we could use our mixin with one of the generic views. We can make "
"our own version of :class:`~django.views.generic.detail.DetailView` by "
"mixing ``JSONResponseMixin`` with the :class:`~django.views.generic.detail."
"BaseDetailView` -- (the :class:`~django.views.generic.detail.DetailView` "
"before template rendering behavior has been mixed in)::"
msgstr ""

msgid ""
"This view can then be deployed in the same way as any other :class:`~django."
"views.generic.detail.DetailView`, with exactly the same behavior -- except "
"for the format of the response."
msgstr ""
"然后这个视图和其他 :class:`~django.views.generic.detail.DetailView` 使用相同"
"方式部署，除了响应的格式外其他都相同。"

msgid ""
"If you want to be really adventurous, you could even mix a :class:`~django."
"views.generic.detail.DetailView` subclass that is able to return *both* HTML "
"and JSON content, depending on some property of the HTTP request, such as a "
"query argument or an HTTP header. Mix in both the ``JSONResponseMixin`` and "
"a :class:`~django.views.generic.detail.SingleObjectTemplateResponseMixin`, "
"and override the implementation of :func:`~django.views.generic.base."
"TemplateResponseMixin.render_to_response()` to defer to the appropriate "
"rendering method depending on the type of response that the user requested::"
msgstr ""

msgid ""
"Because of the way that Python resolves method overloading, the call to "
"``super().render_to_response(context)`` ends up calling the :meth:`~django."
"views.generic.base.TemplateResponseMixin.render_to_response()` "
"implementation of :class:`~django.views.generic.base.TemplateResponseMixin`."
msgstr ""
"由于 Python 解析方法重载的方式，对 ``super().render_to_response(context)`` 的"
"调用最终会调用 :class:`~django.views.generic.base.TemplateResponseMixin` 的 :"
"meth:`~django.views.generic.base.TemplateResponseMixin.render_to_response()` "
"实现。"

msgid "Conditional View Processing"
msgstr "条件视图处理"

msgid ""
"HTTP clients can send a number of headers to tell the server about copies of "
"a resource that they have already seen. This is commonly used when "
"retrieving a web page (using an HTTP ``GET`` request) to avoid sending all "
"the data for something the client has already retrieved. However, the same "
"headers can be used for all HTTP methods (``POST``, ``PUT``, ``DELETE``, "
"etc.)."
msgstr ""

msgid ""
"For each page (response) that Django sends back from a view, it might "
"provide two HTTP headers: the ``ETag`` header and the ``Last-Modified`` "
"header. These headers are optional on HTTP responses. They can be set by "
"your view function, or you can rely on the :class:`~django.middleware.http."
"ConditionalGetMiddleware` middleware to set the ``ETag`` header."
msgstr ""
"针对每个从 Django 视图返回的页面（响应），它可能提供了两种HTTP headers："
"``ETag`` header 和  ``Last-Modified`` header。这些 headers 是 HTTP 的可选项。"
"他们可以在视图函数里设置，或者依赖 :class:`~django.middleware.http."
"ConditionalGetMiddleware` 中间件来设置 ``ETag`` header 。"

msgid ""
"When the client next requests the same resource, it might send along a "
"header such as either :rfc:`If-modified-since <7232#section-3.3>` or :rfc:"
"`If-unmodified-since <7232#section-3.4>`, containing the date of the last "
"modification time it was sent, or either :rfc:`If-match <7232#section-3.1>` "
"or :rfc:`If-none-match <7232#section-3.2>`, containing the last ``ETag`` it "
"was sent. If the current version of the page matches the ``ETag`` sent by "
"the client, or if the resource has not been modified, a 304 status code can "
"be sent back, instead of a full response, telling the client that nothing "
"has changed. Depending on the header, if the page has been modified or does "
"not match the ``ETag`` sent by the client, a 412 status code (Precondition "
"Failed) may be returned."
msgstr ""
"当客户端下一次请求相同资源时，它可能会发送header，如 :rfc:`If-modified-since "
"<7232#section-3.3>`  或 :rfc:`If-unmodified-since <7232#section-3.4>` ，包含"
"它发送后最后一次修改时间，或者 :rfc:`If-match <7232#section-3.1>` 或者 :rfc:"
"`If-none-match <7232#section-3.2>` ，包含它发送的最后一个 ``ETag``。如果页面"
"的当前版本与客户端发送的 ``ETag`` 匹配，或者如果资源没有被修改，那么就会返回"
"一个304状态，告诉客户端：“资源没有任何变化”，而不是返回所有资源响应。根据这"
"个 header，如果页面发生了修改或者客户端没有匹配 ``ETag`` ，会返回 412 状态"
"码。"

msgid ""
"When you need more fine-grained control you may use per-view conditional "
"processing functions."
msgstr "当你需要更多的控制，你可以使用针对每个视图的条件处理函数。"

msgid "The ``condition`` decorator"
msgstr "条件装饰器"

msgid ""
"Sometimes (in fact, quite often) you can create functions to rapidly compute "
"the :rfc:`ETag <7232#section-2.3>` value or the last-modified time for a "
"resource, **without** needing to do all the computations needed to construct "
"the full view. Django can then use these functions to provide an \"early "
"bailout\" option for the view processing. Telling the client that the "
"content has not been modified since the last request, perhaps."
msgstr ""

msgid ""
"These two functions are passed as parameters to the ``django.views."
"decorators.http.condition`` decorator. This decorator uses the two functions "
"(you only need to supply one, if you can't compute both quantities easily "
"and quickly) to work out if the headers in the HTTP request match those on "
"the resource. If they don't match, a new copy of the resource must be "
"computed and your normal view is called."
msgstr ""
"这两个函数被当做参数传递到 ``django.views.decorators.http.condition`` 装饰"
"器。这个装饰器使用两个函数（你只需要支持其中一个，如果你不能很快计算这两个数"
"量）来判断 HTTP 请求的 headers 和这些资源是否匹配。如果它们没有匹配，会计算一"
"份资源的副本，并调用视图。"

msgid "The ``condition`` decorator's signature looks like this::"
msgstr "条件装饰器如下："

msgid ""
"The two functions, to compute the ETag and the last modified time, will be "
"passed the incoming ``request`` object and the same parameters, in the same "
"order, as the view function they are helping to wrap. The function passed "
"``last_modified_func`` should return a standard datetime value specifying "
"the last time the resource was modified, or ``None`` if the resource doesn't "
"exist. The function passed to the ``etag`` decorator should return a string "
"representing the :rfc:`ETag <7232#section-2.3>` for the resource, or "
"``None`` if it doesn't exist."
msgstr ""

msgid ""
"The decorator sets the ``ETag`` and ``Last-Modified`` headers on the "
"response if they are not already set by the view and if the request's method "
"is safe (``GET`` or ``HEAD``)."
msgstr ""
"如果它们没有通过视图设置并且请求的方法是安全的(``GET`` 和 ``HEAD``)，那么装饰"
"器就会在请求上设置 ``ETag`` 和 ``Last-Modified`` headers 。"

msgid ""
"Using this feature usefully is probably best explained with an example. "
"Suppose you have this pair of models, representing a small blog system::"
msgstr ""
"用一个例子来解释如何有效地使用这个功能。假设你已经有了这些模型，代表一个博客"
"系统："

msgid ""
"If the front page, displaying the latest blog entries, only changes when you "
"add a new blog entry, you can compute the last modified time very quickly. "
"You need the latest ``published`` date for every entry associated with that "
"blog. One way to do this would be::"
msgstr ""
"如果在首页正在显示最新的博客文章，只会在有新博客文章时改变，你可以很快地计算"
"最后修改时间。你需要与该博客关联的每篇文章的最新发布时间。一种方法是这样做"
"的："

msgid ""
"You can then use this function to provide early detection of an unchanged "
"page for your front page view::"
msgstr "然后你可以使用这个函数预先为首页视图提供未变动页面的检测："

msgid "Be careful with the order of decorators"
msgstr "小心装饰器的顺序"

msgid ""
"When ``condition()`` returns a conditional response, any decorators below it "
"will be skipped and won't apply to the response. Therefore, any decorators "
"that need to apply to both the regular view response and a conditional "
"response must be above ``condition()``. In particular, :func:`~django.views."
"decorators.vary.vary_on_cookie`, :func:`~django.views.decorators.vary."
"vary_on_headers`, and :func:`~django.views.decorators.cache.cache_control` "
"should come first because :rfc:`RFC 7232 <7232#section-4.1>` requires that "
"the headers they set be present on 304 responses."
msgstr ""
"当 ``condition()`` 返回一个条件响应，在其下面的任何装饰器将被忽略并不会应用于"
"响应。因此，任何需要同时应用于常规视图响应和条件响应的装饰器必须在  "
"``condition()`` 上面。特别是，:func:`~django.views.decorators.vary."
"vary_on_cookie`, :func:`~django.views.decorators.vary.vary_on_headers` 和  :"
"func:`~django.views.decorators.cache.cache_control` 应该首先出现，因为 :rfc:"
"`RFC 7232 <7232#section-4.1>` 要求设置的 headers 需要出现在 304 响应中。"

msgid "Shortcuts for only computing one value"
msgstr "仅用于计算一个值的快捷方式"

msgid ""
"As a general rule, if you can provide functions to compute *both* the ETag "
"and the last modified time, you should do so. You don't know which headers "
"any given HTTP client will send you, so be prepared to handle both. However, "
"sometimes only one value is easy to compute and Django provides decorators "
"that handle only ETag or only last-modified computations."
msgstr ""
"作为常用规则，如果你可以提供函数去同时计算 ETag 和最后的修改时间，你应该这样"
"做。你不知道任何给定的 HTTP 客户端将向你发送哪一个headers，因此需要同时处理这"
"两个headers。然而，有时候只有一个值易于计算，Django 提供的装饰器处理只有 "
"ETag 或 只有 last-modified 的计算。"

msgid ""
"The ``django.views.decorators.http.etag`` and ``django.views.decorators.http."
"last_modified`` decorators are passed the same type of functions as the "
"``condition`` decorator. Their signatures are::"
msgstr ""
"``django.views.decorators.http.etag`` 和 ``django.views.decorators.http."
"last_modified`` 装饰器和 ``condition`` 装饰器一样传递相同的函数类型。它们的签"
"名是这样的："

msgid ""
"We could write the earlier example, which only uses a last-modified "
"function, using one of these decorators::"
msgstr ""
"我们可以使用其中一个装饰器来编写更早一些的那个只使用last-modified函数的例子："

msgid "...or::"
msgstr "...或::"

msgid "Use ``condition`` when testing both conditions"
msgstr "测试两个条件时使用 ``condition``"

msgid ""
"It might look nicer to some people to try and chain the ``etag`` and "
"``last_modified`` decorators if you want to test both preconditions. "
"However, this would lead to incorrect behavior."
msgstr ""
"如果你想测试两个先决条件，那么试着链接 ``etag`` 和 ``last_modified`` 装饰器可"
"能看起来更好。然而，这会导致错误的行为。"

msgid ""
"The first decorator doesn't know anything about the second and might answer "
"that the response is not modified even if the second decorators would "
"determine otherwise. The ``condition`` decorator uses both callback "
"functions simultaneously to work out the right action to take."
msgstr ""
"第一个装饰器不知道关于第二个装饰器的任何信息，而且可能回答“这个响应没有被修"
"改”，即使第二个装饰器确定不是那样。``condition`` 装饰器同时使用两个回调函数来"
"执行正确的动作。"

msgid "Using the decorators with other HTTP methods"
msgstr "将装饰器和其他 HTTP 方法一起使用"

msgid ""
"The ``condition`` decorator is useful for more than only ``GET`` and "
"``HEAD`` requests (``HEAD`` requests are the same as ``GET`` in this "
"situation). It can also be used to provide checking for ``POST``, ``PUT`` "
"and ``DELETE`` requests. In these situations, the idea isn't to return a "
"\"not modified\" response, but to tell the client that the resource they are "
"trying to change has been altered in the meantime."
msgstr ""
"``condition`` 装饰器不仅仅用于 ``GET`` 和 ``HEAD`` 请求（在这个解决方案里 "
"``HEAD``请求和 ``GET`` 类似）。它也可以被用于提供  ``POST``, ``PUT`` 和 "
"``DELETE`` 请求的检查。在这些情况下，不会返回一个“未修改”的响应，但会告诉客户"
"端它们尝试修改的资源在这期间已被修改。"

msgid ""
"For example, consider the following exchange between the client and server:"
msgstr "例如，在客户端和服务端之间考虑下面的交换："

msgid "Client requests ``/foo/``."
msgstr "用户请求``/foo/``。"

msgid "Server responds with some content with an ETag of ``\"abcd1234\"``."
msgstr "服务端用一些带有 ``\"abcd1234\"`` 的 ETag 响应一些内容。"

msgid ""
"Client sends an HTTP ``PUT`` request to ``/foo/`` to update the resource. It "
"also sends an ``If-Match: \"abcd1234\"`` header to specify the version it is "
"trying to update."
msgstr ""
"客户端发送一个 HTTP ``PUT`` 请求到 ``/foo/`` 来更新一些资源。它也发送 ``If-"
"Match: \"abcd1234\"`` header 来指定它准备更新的版本。"

msgid ""
"Server checks to see if the resource has changed, by computing the ETag the "
"same way it does for a ``GET`` request (using the same function). If the "
"resource *has* changed, it will return a 412 status code, meaning "
"\"precondition failed\"."
msgstr ""
"服务端通过计算 ETag（与 ``GET`` 请求计算的方式相同，使用相同的函数）来检查资"
"源是否被修改。如果资源被改变，它将返回 412 状态码，意思是 \"先决条件失败\" 。"

msgid ""
"Client sends a ``GET`` request to ``/foo/``, after receiving a 412 response, "
"to retrieve an updated version of the content before updating it."
msgstr ""
"客户端在收到一个412响应后会发送一个 ``GET`` 请求到 ``/foo/``，在更新它之前用"
"来寻找内容更新的版本。"

msgid ""
"The important thing this example shows is that the same functions can be "
"used to compute the ETag and last modification values in all situations. In "
"fact, you **should** use the same functions, so that the same values are "
"returned every time."
msgstr ""
"重要的是这个例子显示的是相同函数在所有情形下可以被用来计算ETag和最后一次修"
"改。事实上，你应该使用相同的函数，这样相同的值会被实时返回。"

msgid "Validator headers with non-safe request methods"
msgstr "具有不安全请求方法的验证 headers"

msgid ""
"The ``condition`` decorator only sets validator headers (``ETag`` and ``Last-"
"Modified``) for safe HTTP methods, i.e. ``GET`` and ``HEAD``. If you wish to "
"return them in other cases, set them in your view. See :rfc:"
"`7231#section-4.3.4` to learn about the distinction between setting a "
"validator header in response to requests made with ``PUT`` versus ``POST``."
msgstr ""
"``condition`` 装饰器只为安全的HTTP方法设置验证器headers（``ETag`` 和 ``Last-"
"Modified``）。如果你想在其他案例中返回它们，那就在你的视图中设置它们。查看 :"
"rfc:`7231#section-4.3.4` 来了解关于为响应 ``PUT`` 和 ``POST`` 发出的请求而设"
"置验证器 header 之间的区别。"

msgid "Comparison with middleware conditional processing"
msgstr "对比中间件的条件处理"

msgid ""
"Django provides conditional ``GET`` handling via :class:`django.middleware."
"http.ConditionalGetMiddleware`. While being suitable for many situations, "
"the middleware has limitations for advanced usage:"
msgstr ""
"Django 通过 :class:`django.middleware.http.ConditionalGetMiddleware` 提供了有"
"条件的 ``GET`` 处理。虽然易于使用，但是中间件在高级用法上是有限制的："

msgid "It's applied globally to all views in your project."
msgstr "它可被全局应用于项目的所有视图。"

msgid ""
"It doesn't save you from generating the response, which may be expensive."
msgstr "它不会阻止你生成响应，这样代价可能很昂贵。"

msgid "It's only appropriate for HTTP ``GET`` requests."
msgstr "它只适合HTTP 的 ``GET`` 请求。"

msgid ""
"You should choose the most appropriate tool for your particular problem "
"here. If you have a way to compute ETags and modification times quickly and "
"if some view takes a while to generate the content, you should consider "
"using the ``condition`` decorator described in this document. If everything "
"already runs fairly quickly, stick to using the middleware and the amount of "
"network traffic sent back to the clients will still be reduced if the view "
"hasn't changed."
msgstr ""
"你应该为你的特殊需求选择最合适的工具。如果你有方法可以很迅速地计算 ETags 和 "
"修改时间，并且如果一些视图花了一些时间去生成内容，那么你应该在这个文档中考虑"
"使用 ``condition`` 装饰器描述。如果所有事务都运行的非常快了，那么坚持使用中间"
"件。如果视图没有变动，那么发送回客户端的网络流量将仍然会减少。"

msgid "Aggregation"
msgstr "聚合"

msgid ""
"The topic guide on :doc:`Django's database-abstraction API </topics/db/"
"queries>` described the way that you can use Django queries that create, "
"retrieve, update and delete individual objects. However, sometimes you will "
"need to retrieve values that are derived by summarizing or *aggregating* a "
"collection of objects. This topic guide describes the ways that aggregate "
"values can be generated and returned using Django queries."
msgstr ""
":doc:`Django 数据库抽象 API` 描述了使用 Django queries 来增删查改单个对象的方"
"法。 然而，有时候你要获取的值需要根据一组对象聚合后才能得到。这个主题指南描述"
"了如何使用 Django queries 来生成和返回聚合值的方法。"

msgid ""
"Throughout this guide, we'll refer to the following models. These models are "
"used to track the inventory for a series of online bookstores:"
msgstr "整篇指南我们将引用以下模型。这些模型用来记录多个网上书店的库存。"

msgid "Cheat sheet"
msgstr "速查表"

msgid ""
"In a hurry? Here's how to do common aggregate queries, assuming the models "
"above::"
msgstr "下面是根据以上模型执行常见的聚合查询："

msgid "Generating aggregates over a ``QuerySet``"
msgstr "在 ``QuerySet`` 上生成聚合"

msgid ""
"Django provides two ways to generate aggregates. The first way is to "
"generate summary values over an entire ``QuerySet``. For example, say you "
"wanted to calculate the average price of all books available for sale. "
"Django's query syntax provides a means for describing the set of all books::"
msgstr ""
"Django 提供了两种生成聚合的方法。第一种方法是从整个 ``QuerySet`` 生成汇总值。"
"比如你想要计算所有在售书的平均价格。Django 的查询语法提供了一种用来描述所有图"
"书集合的方法："

msgid ""
"What we need is a way to calculate summary values over the objects that "
"belong to this ``QuerySet``. This is done by appending an ``aggregate()`` "
"clause onto the ``QuerySet``::"
msgstr ""
"可以通过在 ``QuerySet`` 后添加 ``aggregate()`` 子句来计算 ``QuerySet`` 对象的"
"汇总值。"

msgid ""
"The ``all()`` is redundant in this example, so this could be simplified to::"
msgstr "本例中的 ``all()`` 是多余的，所以可以简化成这样的::"

msgid ""
"The argument to the ``aggregate()`` clause describes the aggregate value "
"that we want to compute - in this case, the average of the ``price`` field "
"on the ``Book`` model. A list of the aggregate functions that are available "
"can be found in the :ref:`QuerySet reference <aggregation-functions>`."
msgstr ""
"传递给 ``aggregate()`` 的参数描述了我们想要计算的聚合值。在这个例子里，要计算"
"的就是 ``Book`` 模型上的 ``price`` 字段的平均值。可用的聚合函数列表可以在 :"
"ref:`QuerySet reference <aggregation-functions>` 中找到。"

msgid ""
"``aggregate()`` is a terminal clause for a ``QuerySet`` that, when invoked, "
"returns a dictionary of name-value pairs. The name is an identifier for the "
"aggregate value; the value is the computed aggregate. The name is "
"automatically generated from the name of the field and the aggregate "
"function. If you want to manually specify a name for the aggregate value, "
"you can do so by providing that name when you specify the aggregate clause::"
msgstr ""
"``aggregate()`` 是 ``QuerySet`` 的一个终端子句，使用后将返回“名称-值”的字典，"
"其中“名称”就是聚合值的标志，“值”就是计算出的聚合结果。“名称”是根据字段名和聚"
"合函数而自动生成的。如果你想指定一个聚合值的名称，你可以在指定聚合子句的时候"
"提供指定的名称："

msgid ""
"If you want to generate more than one aggregate, you add another argument to "
"the ``aggregate()`` clause. So, if we also wanted to know the maximum and "
"minimum price of all books, we would issue the query::"
msgstr ""
"如果你想生成更多的聚合内容，你需要在 ``aggregate()`` 子句中加入其它参数即可。"
"所以，如果我们也想知道所有书中最高和最低的价格，我们可以写这样的查询："

msgid "Generating aggregates for each item in a ``QuerySet``"
msgstr "为 ``QuerySet`` 中的每一个条目生成聚合"

msgid ""
"The second way to generate summary values is to generate an independent "
"summary for each object in a :class:`.QuerySet`. For example, if you are "
"retrieving a list of books, you may want to know how many authors "
"contributed to each book. Each Book has a many-to-many relationship with the "
"Author; we want to summarize this relationship for each book in the "
"``QuerySet``."
msgstr ""
"生成值的汇总的另一个办法是为 :class:`.QuerySet` 的每一个对象生成独立汇总。比"
"如，如果你想检索书籍列表，你可能想知道每一本书有多少作者。每一本书与作者有多"
"对多的关系；我们想在 ``QuerySet`` 中为每一本书总结这个关系。"

msgid ""
"Per-object summaries can be generated using the :meth:`~.QuerySet.annotate` "
"clause. When an ``annotate()`` clause is specified, each object in the "
"``QuerySet`` will be annotated with the specified values."
msgstr ""
"使用 :meth:`~.QuerySet.annotate` 子句可以生成每一个对象的汇总。当指定  "
"``annotate()`` 子句，``QuerySet`` 中的每一个对象将对指定值进行汇总。"

msgid ""
"The syntax for these annotations is identical to that used for the :meth:`~."
"QuerySet.aggregate` clause. Each argument to ``annotate()`` describes an "
"aggregate that is to be calculated. For example, to annotate books with the "
"number of authors::"
msgstr ""
"这些汇总语法规则与 :meth:`~.QuerySet.aggregate` 子句的规则相同。"
"``annotate()`` 的每一个参数描述了一个要计算的聚合。比如，注解（annotate）所有"
"书的所有作者："

msgid ""
"As with ``aggregate()``, the name for the annotation is automatically "
"derived from the name of the aggregate function and the name of the field "
"being aggregated. You can override this default name by providing an alias "
"when you specify the annotation::"
msgstr ""
"与 ``aggregate()`` 一样，注解的名称是根据聚合函数和被聚合的字段名自动生成的。"
"当你在指定注解的时候，你可以通过提供一个别名重写这个默认名："

msgid ""
"Unlike ``aggregate()``, ``annotate()`` is *not* a terminal clause. The "
"output of the ``annotate()`` clause is a ``QuerySet``; this ``QuerySet`` can "
"be modified using any other ``QuerySet`` operation, including ``filter()``, "
"``order_by()``, or even additional calls to ``annotate()``."
msgstr ""
"与 ``aggregate()`` 不同的是，``annotate()`` 不是终端子句。``annotate()`` 子句"
"的输出就是 ``QuerySet``；这个 ``QuerySet`` 被其他 ``QuerySet`` 操作进行修改，"
"包括 `filter()``, ``order_by()`` ，甚至可以对 ``annotate()`` 进行额外调用。"

msgid "Combining multiple aggregations"
msgstr "组合多个聚合"

msgid ""
"Combining multiple aggregations with ``annotate()`` will :ticket:`yield the "
"wrong results <10060>` because joins are used instead of subqueries:"
msgstr ""
"使用 ``annotate()`` 组合多个聚合将产生错误的结果( :ticket:`yield the wrong "
"results <10060>` )，因为它使用连接(joins)而不是子查询："

msgid ""
"For most aggregates, there is no way to avoid this problem, however, the :"
"class:`~django.db.models.Count` aggregate has a ``distinct`` parameter that "
"may help:"
msgstr ""
"对大部分聚合来说，没办法避免这个问题，但是，:class:`~django.db.models.Count` "
"聚合可以使用 ``distinct`` 参数来避免："

msgid "If in doubt, inspect the SQL query!"
msgstr "如有疑问，请检查 SQL 查询！"

msgid ""
"In order to understand what happens in your query, consider inspecting the "
"``query`` property of your ``QuerySet``."
msgstr ""
"为了搞清楚你的查询发生了什么问题，你得在 ``QuerySet`` 中检查一下``query`` 属"
"性。"

msgid "Joins and aggregates"
msgstr "连接(Joins)和聚合"

msgid ""
"So far, we have dealt with aggregates over fields that belong to the model "
"being queried. However, sometimes the value you want to aggregate will "
"belong to a model that is related to the model you are querying."
msgstr ""
"到目前为止，我们已经处理了被查询模型字段的聚合。然而，有时候想聚合的值属于你"
"正在查询模型的关联模型。"

msgid ""
"When specifying the field to be aggregated in an aggregate function, Django "
"will allow you to use the same :ref:`double underscore notation <field-"
"lookups-intro>` that is used when referring to related fields in filters. "
"Django will then handle any table joins that are required to retrieve and "
"aggregate the related value."
msgstr ""
"在聚合函数里面指定聚合的字段时，Django 允许你在过滤相关字段的时候使用相同的双"
"下划线表示法。Django 将处理任何需要检索和聚合的关联值的表连接(table joins)。"

msgid ""
"For example, to find the price range of books offered in each store, you "
"could use the annotation::"
msgstr ""
"比如，要寻找每个书店提供的书籍价格区间，你可以使用这个注解(annotation)："

msgid ""
"This tells Django to retrieve the ``Store`` model, join (through the many-to-"
"many relationship) with the ``Book`` model, and aggregate on the price field "
"of the book model to produce a minimum and maximum value."
msgstr ""
"这告诉 Django 去检索 ``Store`` 模型，连接（通过多对多关系） ``Book`` 模型，并"
"且聚合书籍模型的价格字段来获取最大最小值。"

msgid ""
"The same rules apply to the ``aggregate()`` clause. If you wanted to know "
"the lowest and highest price of any book that is available for sale in any "
"of the stores, you could use the aggregate::"
msgstr ""
"相同规则应用于 ``aggregate()`` 从句。如果你想知道任何店铺正在销售的任何书籍的"
"最低最高价，你可以使用这个聚合："

msgid ""
"Join chains can be as deep as you require. For example, to extract the age "
"of the youngest author of any book available for sale, you could issue the "
"query::"
msgstr ""
"Join 链可以根据你的需求尽可能深。比如，要提取所出售的书籍中最年轻的作者年龄，"
"你可以写这样的查询："

msgid "Following relationships backwards"
msgstr "反向关系"

msgid ""
"In a way similar to :ref:`lookups-that-span-relationships`, aggregations and "
"annotations on fields of models or models that are related to the one you "
"are querying can include traversing \"reverse\" relationships. The lowercase "
"name of related models and double-underscores are used here too."
msgstr ""
"类似于 :ref:`lookups-that-span-relationships` ，你正在查询的在模型和模型字段"
"上的聚合和注解(annotations)可以包含反向关系。关系模型的小写名和双下划线也可以"
"用在这里。"

msgid ""
"For example, we can ask for all publishers, annotated with their respective "
"total book stock counters (note how we use ``'book'`` to specify the "
"``Publisher`` -> ``Book`` reverse foreign key hop)::"
msgstr ""
"比如我们可以要求所有出版者，注解他们各自的图书库存总数（注意我们如何使用 "
"``'book'`` 来指定 ``Publisher`` -> ``Book`` 反向外键跳转）："

msgid ""
"(Every ``Publisher`` in the resulting ``QuerySet`` will have an extra "
"attribute called ``book__count``.)"
msgstr "(查询结果里的每一个 ``Publisher`` 会有多余的属性—— ``book__count`` 。)"

msgid ""
"We can also ask for the oldest book of any of those managed by every "
"publisher::"
msgstr "我们也可以找出最古老的一本："

msgid ""
"(The resulting dictionary will have a key called ``'oldest_pubdate'``. If no "
"such alias were specified, it would be the rather long "
"``'book__pubdate__min'``.)"
msgstr ""
"(结果字典中会有一个叫 ``'oldest_pubdate'`` 的键。如果没有指定这样的别名，它将"
"会是一个很长的名字 ``'book__pubdate__min'`` 。)"

msgid ""
"This doesn't apply just to foreign keys. It also works with many-to-many "
"relations. For example, we can ask for every author, annotated with the "
"total number of pages considering all the books the author has (co-)authored "
"(note how we use ``'book'`` to specify the ``Author`` -> ``Book`` reverse "
"many-to-many hop)::"
msgstr ""
"它不仅仅用于外键，它也适用于多对多关系。比如，我们能查询每一个作者，注解作者"
"(共同)创作的书籍总页数(注意我们如何使用 ``'book'`` 来指定 ``Author`` -> "
"``Book`` 反向多对多跳转)："

msgid ""
"(Every ``Author`` in the resulting ``QuerySet`` will have an extra attribute "
"called ``total_pages``. If no such alias were specified, it would be the "
"rather long ``book__pages__sum``.)"
msgstr ""
"（结果集里的每一个 ``Author`` 会有一个额外的属性——``total_pages``）如果没有指"
"定这样的别名，它将会是一个很长的名字 ``book__pages__sum``）"

msgid ""
"Or ask for the average rating of all the books written by author(s) we have "
"on file::"
msgstr "或查询书籍的平均评分："

msgid ""
"(The resulting dictionary will have a key called ``'average_rating'``. If no "
"such alias were specified, it would be the rather long "
"``'book__rating__avg'``.)"
msgstr ""
"（结果字典会有一个叫 ``'average_rating'`` 的键。如果没有指定这样的别名，它将"
"会是一个很长的名字 ``'book__rating__avg'``。）"

msgid "Aggregations and other ``QuerySet`` clauses"
msgstr "聚合和其他 ``QuerySet`` 子句"

msgid "``filter()`` and ``exclude()``"
msgstr "``filter()`` 和 ``exclude()``"

msgid ""
"Aggregates can also participate in filters. Any ``filter()`` (or "
"``exclude()``) applied to normal model fields will have the effect of "
"constraining the objects that are considered for aggregation."
msgstr ""
"聚合也可以参与过滤。任何应用于普通模型字段的 ``filter()`` （或 "
"``exclude()``）会具有约束被认为是聚合的对象的效果。"

msgid ""
"When used with an ``annotate()`` clause, a filter has the effect of "
"constraining the objects for which an annotation is calculated. For example, "
"you can generate an annotated list of all books that have a title starting "
"with \"Django\" using the query::"
msgstr ""
"当使用 ``annotate()`` 从句，过滤器具有约束计算注解的对象的效果。比如，你可以"
"使用查询生成一个所有书籍的注解列表，这个列表的标题以 \"Django\" 开头。"

msgid ""
"When used with an ``aggregate()`` clause, a filter has the effect of "
"constraining the objects over which the aggregate is calculated. For "
"example, you can generate the average price of all books with a title that "
"starts with \"Django\" using the query::"
msgstr ""
"当使用 ``aggregate()`` 子句，过滤器将具有约束计算聚合的对象的效果。比如，你可"
"以使用查询生成所有标题以 \"Django\" 开头的平均价格。"

msgid "Filtering on annotations"
msgstr "过滤注解"

msgid ""
"Annotated values can also be filtered. The alias for the annotation can be "
"used in ``filter()`` and ``exclude()`` clauses in the same way as any other "
"model field."
msgstr ""
"注解过的值也可以使用过滤器。注解的别名可以和任何其他模型字段一样使用 "
"``filter()`` 和 ``exclude()`` 子句。"

msgid ""
"For example, to generate a list of books that have more than one author, you "
"can issue the query::"
msgstr "比如，要生成多名作者的书籍列表，可以发出这种查询："

msgid ""
"This query generates an annotated result set, and then generates a filter "
"based upon that annotation."
msgstr "这个查询生成一个注解结果集，然后生成一个基于注解的过滤器。"

msgid ""
"If you need two annotations with two separate filters you can use the "
"``filter`` argument with any aggregate. For example, to generate a list of "
"authors with a count of highly rated books::"
msgstr ""
"如果你需要两个带有两个独立的过滤器的注解，你可以在任何聚合中使用 ``filter`` "
"语句。比如，要生成一个带有高评价书籍的作者列表："

msgid ""
"Each ``Author`` in the result set will have the ``num_books`` and "
"``highly_rated_books`` attributes. See also :ref:`conditional-aggregation`."
msgstr ""
"结果集中的每个 ``Author`` 都有 ``num_books`` 和 ``highly_rated_books`` 属性。"
"参见 :ref:`conditional-aggregation`。"

msgid "Choosing between ``filter`` and ``QuerySet.filter()``"
msgstr "在 ``filter`` 和 ``QuerySet.filter()`` 中做选择"

msgid ""
"Avoid using the ``filter`` argument with a single annotation or aggregation. "
"It's more efficient to use ``QuerySet.filter()`` to exclude rows. The "
"aggregation ``filter`` argument is only useful when using two or more "
"aggregations over the same relations with different conditionals."
msgstr ""
"避免在单个注解和聚合中使用 ``filter`` 语句。使用 ``QuerySet.filter()`` 来排除"
"列会很高效。聚合 ``filter`` 语句只在使用具有不同条件的相同关系的两个或以上的"
"聚合时有用。"

msgid "Order of ``annotate()`` and ``filter()`` clauses"
msgstr "``annotate()`` 和 ``filter()`` 子句的顺序"

msgid ""
"When developing a complex query that involves both ``annotate()`` and "
"``filter()`` clauses, pay particular attention to the order in which the "
"clauses are applied to the ``QuerySet``."
msgstr ""
"当开发一个涉及 ``annotate()`` 和 ``filter()`` 子句的复杂查询时，要特别注意应"
"用于  ``QuerySet`` 的子句的顺序。"

msgid ""
"When an ``annotate()`` clause is applied to a query, the annotation is "
"computed over the state of the query up to the point where the annotation is "
"requested. The practical implication of this is that ``filter()`` and "
"``annotate()`` are not commutative operations."
msgstr ""
"当一个 ``annotate()`` 子句应用于查询，会根据查询状态来计算注解，直到请求的注"
"解为止。这实际上意味着 ``filter()`` 和 ``annotate()`` 不是可交换的操作。"

msgid "Given:"
msgstr "比如："

msgid "Publisher A has two books with ratings 4 and 5."
msgstr "出版者A有两本评分4和5的书。"

msgid "Publisher B has two books with ratings 1 and 4."
msgstr "出版者B有两本评分1和4的书。"

msgid "Publisher C has one book with rating 1."
msgstr "出版者C有一本评分1的书。"

msgid "Here's an example with the ``Count`` aggregate::"
msgstr "下面就是 ``Count`` 聚合的例子："

msgid ""
"Both queries return a list of publishers that have at least one book with a "
"rating exceeding 3.0, hence publisher C is excluded."
msgstr "两个查询返回出版者列表，这些出版者至少有一本评分3的书，因此排除了C。"

msgid ""
"In the first query, the annotation precedes the filter, so the filter has no "
"effect on the annotation. ``distinct=True`` is required to avoid a :ref:"
"`query bug <combining-multiple-aggregations>`."
msgstr ""
"在第一个查询里，注解优先于过滤器，因此过滤器没有影响注解。``distinct=True`` "
"用来避免 a :ref:`query bug <combining-multiple-aggregations>`。"

msgid ""
"The second query counts the number of books that have a rating exceeding 3.0 "
"for each publisher. The filter precedes the annotation, so the filter "
"constrains the objects considered when calculating the annotation."
msgstr ""
"第二个查询每个发布者评分3以上的书籍数量。过滤器优先于注解，因此过滤器约束计算"
"注解时考虑的对象。"

msgid "Here's another example with the ``Avg`` aggregate::"
msgstr "这里是另一个关于 ``Avg`` 聚合的例子："

msgid ""
"The first query asks for the average rating of all a publisher's books for "
"publisher's that have at least one book with a rating exceeding 3.0. The "
"second query asks for the average of a publisher's book's ratings for only "
"those ratings exceeding 3.0."
msgstr ""
"第一个查询请求至少有一本评分3以上的书籍的出版者的书籍平均分。第二个查询只请求"
"评分3以上的作者书籍的平均评分。"

msgid ""
"It's difficult to intuit how the ORM will translate complex querysets into "
"SQL queries so when in doubt, inspect the SQL with ``str(queryset.query)`` "
"and write plenty of tests."
msgstr ""
"很难凭直觉了解ORM如何将复杂的查询集转化为SQL查询，因此当有疑问时，请使用 "
"`str(queryset.query)`` 检查SQL，并写大量的测试。"

msgid "``order_by()``"
msgstr "``order_by()``"

msgid ""
"Annotations can be used as a basis for ordering. When you define an "
"``order_by()`` clause, the aggregates you provide can reference any alias "
"defined as part of an ``annotate()`` clause in the query."
msgstr ""
"注解可以当做基本排序来使用。当你定义了一个 ``order_by()`` 子句，你提供的聚合"
"可以引用任何定义为查询中 ``annotate()`` 子句的一部分的别名。"

msgid ""
"For example, to order a ``QuerySet`` of books by the number of authors that "
"have contributed to the book, you could use the following query::"
msgstr ""
"比如，通过书籍的作者数量来对书籍的 ``QuerySet`` 排序，你可以使用下面的查询："

msgid "``values()``"
msgstr "``values()``"

msgid ""
"Ordinarily, annotations are generated on a per-object basis - an annotated "
"``QuerySet`` will return one result for each object in the original "
"``QuerySet``. However, when a ``values()`` clause is used to constrain the "
"columns that are returned in the result set, the method for evaluating "
"annotations is slightly different. Instead of returning an annotated result "
"for each result in the original ``QuerySet``, the original results are "
"grouped according to the unique combinations of the fields specified in the "
"``values()`` clause. An annotation is then provided for each unique group; "
"the annotation is computed over all members of the group."
msgstr ""
"通常，注解值会添加到每个对象上，即一个被注解的 ``QuerySet`` 将会为初始 "
"``QuerySet`` 的每个对象返回一个结果集。然而，当使用 ``values()`` 子句来对结果"
"集进行约束时，生成注解值的方法会稍有不同。不是在原始 ``QuerySet`` 中对每个对"
"象添加注解并返回，而是根据定义在 ``values()`` 子句中的字段组合先对结果进行分"
"组，再对每个单独的分组进行注解，这个注解值是根据分组中所有的对象计算得到的。"

msgid ""
"For example, consider an author query that attempts to find out the average "
"rating of books written by each author:"
msgstr "下面是一个关于作者的查询例子，查询每个作者所著书的平均评分："

msgid ""
"This will return one result for each author in the database, annotated with "
"their average book rating."
msgstr "这段代码返回的是数据库中的所有作者及其所著书的平均评分。"

msgid ""
"However, the result will be slightly different if you use a ``values()`` "
"clause::"
msgstr "但是如果你使用 ``values()`` 子句，结果会稍有不同："

msgid ""
"In this example, the authors will be grouped by name, so you will only get "
"an annotated result for each *unique* author name. This means if you have "
"two authors with the same name, their results will be merged into a single "
"result in the output of the query; the average will be computed as the "
"average over the books written by both authors."
msgstr ""
"在这个例子中，作者会按名字分组，所以你只能得到不重名的作者分组的注解值。这意"
"味着如果你有两个作者同名，那么他们原本各自的查询结果将被合并到同一个结果中；"
"两个作者的所有评分都将被计算为一个平均分。"

msgid "Order of ``annotate()`` and ``values()`` clauses"
msgstr "``annotate()`` 和 ``values()`` 的顺序"

msgid ""
"As with the ``filter()`` clause, the order in which ``annotate()`` and "
"``values()`` clauses are applied to a query is significant. If the "
"``values()`` clause precedes the ``annotate()``, the annotation will be "
"computed using the grouping described by the ``values()`` clause."
msgstr ""
"和使用 ``filter()`` 一样，作用于某个查询的 ``annotate()`` 和 ``values()`` 子"
"句的顺序非常重要。如果 ``values()`` 子句在 ``annotate()`` 之前，就会根据 "
"``values()`` 子句产生的分组来计算注解。"

msgid ""
"However, if the ``annotate()`` clause precedes the ``values()`` clause, the "
"annotations will be generated over the entire query set. In this case, the "
"``values()`` clause only constrains the fields that are generated on output."
msgstr ""
"然而如果 ``annotate()`` 子句在 ``values()`` 之前，就会根据整个查询集生成注"
"解。这种情况下，``values()`` 子句只能限制输出的字段。"

msgid ""
"For example, if we reverse the order of the ``values()`` and ``annotate()`` "
"clause from our previous example::"
msgstr ""
"举个例子，如果我们颠倒上个例子中 ``values()`` 和 ``annotate()`` 的顺序："

msgid ""
"This will now yield one unique result for each author; however, only the "
"author's name and the ``average_rating`` annotation will be returned in the "
"output data."
msgstr ""
"这段代码将为每个作者添加一个唯一注解，但只有作者姓名和 ``average_rating`` 注"
"解会返回在输出结果中。"

msgid ""
"You should also note that ``average_rating`` has been explicitly included in "
"the list of values to be returned. This is required because of the ordering "
"of the ``values()`` and ``annotate()`` clause."
msgstr ""
"你应该也会注意 ``average_rating`` 已经明确包含在返回的值列表中。这是必需的，"
"因为 ``values()`` 和 ``annotate()`` 子句的顺序。"

msgid ""
"If the ``values()`` clause precedes the ``annotate()`` clause, any "
"annotations will be automatically added to the result set. However, if the "
"``values()`` clause is applied after the ``annotate()`` clause, you need to "
"explicitly include the aggregate column."
msgstr ""
"如果 ``values()`` 子句在 ``annotate()`` 子句之前，任何注解将自动添加在结果集"
"中。然而，如果 ``values()`` 子句应用在 ``annotate()`` 子句之后，则需要显式包"
"含聚合列。"

msgid "Interaction with ``order_by()``"
msgstr ""

msgid ""
"Fields that are mentioned in the ``order_by()`` part of a queryset are used "
"when selecting the output data, even if they are not otherwise specified in "
"the ``values()`` call. These extra fields are used to group \"like\" results "
"together and they can make otherwise identical result rows appear to be "
"separate. This shows up, particularly, when counting things."
msgstr ""

msgid "By way of example, suppose you have a model like this::"
msgstr "举个例子，假设你有这样的模型："

msgid ""
"If you want to count how many times each distinct ``data`` value appears in "
"an ordered queryset, you might try this::"
msgstr ""

msgid ""
"...which will group the ``Item`` objects by their common ``data`` values and "
"then count the number of ``id`` values in each group. Except that it won't "
"quite work. The ordering by ``name`` will also play a part in the grouping, "
"so this query will group by distinct ``(data, name)`` pairs, which isn't "
"what you want. Instead, you should construct this queryset::"
msgstr ""

msgid ""
"...clearing any ordering in the query. You could also order by, say, "
"``data`` without any harmful effects, since that is already playing a role "
"in the query."
msgstr ""
"清除任何查询中的排序。你也可以通过 ``data`` 排序，没有任何有害影响，因为它已"
"经在查询中发挥了作用。"

msgid ""
"This behavior is the same as that noted in the queryset documentation for :"
"meth:`~django.db.models.query.QuerySet.distinct` and the general rule is the "
"same: normally you won't want extra columns playing a part in the result, so "
"clear out the ordering, or at least make sure it's restricted only to those "
"fields you also select in a ``values()`` call."
msgstr ""
"这个行为与 :meth:`~django.db.models.query.QuerySet.distinct` 的查询文档指出的"
"行为相同，一般规则是一样的：通常情况下，你不希望额外的列在结果中发挥作用，因"
"此要清除排序，或者至少确保它只限于您在 ``values()`` 调用中选择的那些字段。"

msgid ""
"You might reasonably ask why Django doesn't remove the extraneous columns "
"for you. The main reason is consistency with ``distinct()`` and other "
"places: Django **never** removes ordering constraints that you have "
"specified (and we can't change those other methods' behavior, as that would "
"violate our :doc:`/misc/api-stability` policy)."
msgstr ""
"你可以会问为什么 Django 没有移除无关的列。主要原因就是与 ``distinct()`` 和其"
"他地方的一致性:Django从不删除你指定的排序约束（我们不能改变其他方法的行为，因"
"为这会违反我们的应用编程接口的稳定性政策）。"

msgid "Aggregating annotations"
msgstr "聚合注解"

msgid ""
"You can also generate an aggregate on the result of an annotation. When you "
"define an ``aggregate()`` clause, the aggregates you provide can reference "
"any alias defined as part of an ``annotate()`` clause in the query."
msgstr ""
"你也可以在注解结果上生成聚合。当你定义 ``aggregate()`` 子句时，你提供的聚合可"
"以引用任何定义在查询中 ``annotate()`` 子句的别名。"

msgid ""
"For example, if you wanted to calculate the average number of authors per "
"book you first annotate the set of books with the author count, then "
"aggregate that author count, referencing the annotation field::"
msgstr ""
"比如，如果你想计算每本书的平均作者数，首先使用作者数注解书籍集合，然后引用注"
"解字段聚合作者数："

msgid "Examples of model relationship API usage"
msgstr "模型关联 API 用法示例"

msgid "Many-to-many relationships"
msgstr "多对多关联"

msgid ""
"To define a many-to-many relationship, use :class:`~django.db.models."
"ManyToManyField`."
msgstr "使用：class:`~django.db.models.ManyToManyField` 来定义多对多关系"

msgid ""
"In this example, an ``Article`` can be published in multiple ``Publication`` "
"objects, and a ``Publication`` has multiple ``Article`` objects:"
msgstr ""
"在这个例子中，一篇“Article（报刊上的文章）”可能在多个“公开发行物（对象"
"objects）”中发布，并且一个“公开发行物（对象objects）”也有多个具体发行的对象"
"（Article）："

msgid ""
"What follows are examples of operations that can be performed using the "
"Python API facilities."
msgstr ""
"下面是可以使用PythonAPI工具执行的操作示例。\n"
" "

msgid "Create a few ``Publications``::"
msgstr ""
"创建几个“公共出版物”：\n"
" "

msgid "Create an ``Article``::"
msgstr ""
"创建一个“Article（报刊上的文章-具体的出版物）”：\n"
" "

msgid "You can't associate it with a ``Publication`` until it's been saved::"
msgstr "“公开出版物”被保存前，你不能关联它。"

msgid "Save it! ::"
msgstr "保存它！"

msgid "Associate the ``Article`` with a ``Publication``::"
msgstr "用一个 ``Publication``来关联 ``Article``:"

msgid ""
"Create another ``Article``, and set it to appear in the ``Publications``::"
msgstr "创建另一个``Article``, 并且设置它的``Publications``"

msgid "Adding a second time is OK, it will not duplicate the relation::"
msgstr "二次添加是OK的，但它不会重复这一关系。"

msgid "Adding an object of the wrong type raises :exc:`TypeError`::"
msgstr ""
"添加错误类型的对象会引发：exc：`TypeError‘：\n"
" "

msgid ""
"Create and add a ``Publication`` to an ``Article`` in one step using :meth:"
"`~django.db.models.fields.related.RelatedManager.create`::"
msgstr ""
"使用：meth：`~django.db.models.fields.related.RelatedManager.create`::一步一"
"步地创建和添加一个“Publication”到一个“Article”\n"
" "

msgid ""
"``Article`` objects have access to their related ``Publication`` objects::"
msgstr "``Article`` 对象可以访问于它们相关的 ``Publication`` 对象："

msgid ""
"``Publication`` objects have access to their related ``Article`` objects::"
msgstr "``Publication`` 对象可以访问于它们相关的 ``Article`` 对象："

msgid ""
"Many-to-many relationships can be queried using :ref:`lookups across "
"relationships <lookups-that-span-relationships>`::"
msgstr ""
"可通过 :ref:`跨关联查询 <lookups-that-span-relationships>` 查询多对多关联::"

msgid ""
"The :meth:`~django.db.models.query.QuerySet.count` function respects :meth:"
"`~django.db.models.query.QuerySet.distinct` as well::"
msgstr ""
":meth:`~django.db.models.query.QuerySet.count` 函数也可以配合 :meth:`~django."
"db.models.query.QuerySet.distinct` 。"

msgid ""
"Reverse m2m queries are supported (i.e., starting at the table that doesn't "
"have a :class:`~django.db.models.ManyToManyField`)::"
msgstr ""
"支持反向m2m查询（比如，从没有  :class:`~django.db.models.ManyToManyField` 的"
"表开始）："

msgid ""
"Excluding a related item works as you would expect, too (although the SQL "
"involved is a little complex)::"
msgstr "排除相关条目的工作方式正如你所期望的那样（尽管相关 SQL 有点复杂）："

msgid ""
"If we delete a ``Publication``, its ``Articles`` won't be able to access it::"
msgstr "如果我们删除 ``Publication``， 它的 ``Articles`` 无法访问它："

msgid ""
"If we delete an ``Article``, its ``Publications`` won't be able to access "
"it::"
msgstr "如果我们删除了 ``Article``，它的 ``Publications`` 也无法访问它："

msgid "Adding via the 'other' end of an m2m::"
msgstr "通过m2m的另一端添加："

msgid "Adding via the other end using keywords::"
msgstr "使用关键字通过另一端添加："

msgid "Removing ``Publication`` from an ``Article``::"
msgstr "从 ``Article`` 中移除 ``Publication``："

msgid "And from the other end::"
msgstr "从另一端移除："

msgid "Relation sets can be set::"
msgstr "可以设置关系："

msgid "Relation sets can be cleared::"
msgstr "关系可以被清除："

msgid "And you can clear from the other end::"
msgstr "可以从另一端清除："

msgid "Recreate the ``Article`` and ``Publication`` we have deleted::"
msgstr "重新创建我们刚删除的 ``Article`` 和 ``Publication`` ："

msgid ""
"Bulk delete some ``Publications`` - references to deleted publications "
"should go::"
msgstr "批量删除 ``Publications`` - 引用已经删除的出版者应该是："

msgid "Bulk delete some articles - references to deleted objects should go::"
msgstr "批量删除文章："

msgid ""
"After the :meth:`~django.db.models.query.QuerySet.delete`, the :class:"
"`~django.db.models.query.QuerySet` cache needs to be cleared, and the "
"referenced objects should be gone::"
msgstr ""
" :meth:`~django.db.models.query.QuerySet.delete` 后，:class:`~django.db."
"models.query.QuerySet` 缓存需要被清除，引用的对象应该消失："

msgid "Many-to-one relationships"
msgstr "多对一关联"

msgid ""
"To define a many-to-one relationship, use :class:`~django.db.models."
"ForeignKey`::"
msgstr "要定义一个多对一关联，使用 :class:`~django.db.models.ForeignKey`::"

msgid "Create a few Reporters::"
msgstr "创建一些 Reporters："

msgid "Create an Article::"
msgstr "创建一个 Article："

msgid ""
"Note that you must save an object before it can be assigned to a foreign key "
"relationship. For example, creating an ``Article`` with unsaved ``Reporter`` "
"raises ``ValueError``::"
msgstr ""
"注意你必须先保存对象，然后再给它指定外键关系。比如，使用未保存的 "
"``Reporter`` 创建 ``Article`` ，会引发 ``ValueError``："

msgid "Article objects have access to their related Reporter objects::"
msgstr "Article 对象可以访问与它们相关联的 Reporter 对象："

msgid "Create an Article via the Reporter object::"
msgstr "通过 Reporter 对象来创建一个 Article"

msgid "Create a new article::"
msgstr "创建一个新的article："

msgid "Add the same article to a different article set - check that it moves::"
msgstr "添加相同的article到一个不同的article集合，请观察它怎么移动："

msgid "Adding an object of the wrong type raises TypeError::"
msgstr "添加错误类型的对象，会引发TypeError："

msgid "Note that in the last example the article has moved from John to Paul."
msgstr "注意在最后的例子里，那篇 article 的 reporter 已经从 John 变为 Paul。"

msgid ""
"Related managers support field lookups as well. The API automatically "
"follows relationships as far as you need. Use double underscores to separate "
"relationships. This works as many levels deep as you want. There's no limit. "
"For example::"
msgstr ""
"相关管理器也提供字段查询。只要你需要，API会自动跟踪关系，使用双下划线来分隔，"
"你可以根据需要获取深层关系。这没有限制。比如："

msgid "Exact match is implied here::"
msgstr "这里的查询是完全匹配："

msgid ""
"Query twice over the related field. This translates to an AND condition in "
"the WHERE clause::"
msgstr "在相关字段上查询两次。这里转化成WHERE从句里的AND条件。"

msgid ""
"For the related lookup you can supply a primary key value or pass the "
"related object explicitly::"
msgstr "对于相关查询，你可以提供主键值或显式传递相关对象："

msgid "You can also use a queryset instead of a literal list of instances::"
msgstr "你也可以使用查询集而不是实例的文字列表："

msgid "Querying in the opposite direction::"
msgstr "反向查询："

msgid ""
"Counting in the opposite direction works in conjunction with distinct()::"
msgstr "反向查询的计数与 distinct() ："

msgid "Queries can go round in circles::"
msgstr "可以循环查询："

msgid ""
"If you delete a reporter, their articles will be deleted (assuming that the "
"ForeignKey was defined with :attr:`django.db.models.ForeignKey.on_delete` "
"set to ``CASCADE``, which is the default)::"
msgstr ""
"如果删除了一个reporter，他的articlles文章将被删除（假设使用设置了 "
"``CASCADE`` 的 :attr:`django.db.models.ForeignKey.on_delete` 来定义主键，这是"
"默认设置）："

msgid "You can delete using a JOIN in the query::"
msgstr "可以在查询中使用JOIN进行删除："

msgid "One-to-one relationships"
msgstr "一对一关联"

msgid ""
"To define a one-to-one relationship, use :class:`~django.db.models."
"OneToOneField`."
msgstr "要定义一对一关联，使用 :class:`~django.db.models.OneToOneField`。"

msgid "In this example, a ``Place`` optionally can be a ``Restaurant``::"
msgstr "在本例中，一个 ``Place`` 可是一个 ``Restaurant``::"

msgid "Create a couple of Places::"
msgstr "创建几个 Place："

msgid ""
"Create a Restaurant. Pass the \"parent\" object as this object's primary "
"key::"
msgstr "创建一个 Restaurant。传递 “父” 对象作为该对象的主键："

msgid "A Restaurant can access its place::"
msgstr "餐厅可以获取所在地："

msgid "A Place can access its restaurant, if available::"
msgstr "地点可以访问关联的餐厅（如果有的话）："

msgid "p2 doesn't have an associated restaurant::"
msgstr "p2 没有关联餐厅："

msgid "You can also use ``hasattr`` to avoid the need for exception catching::"
msgstr "您还可以使用 ``hasattr`` 来免除异常捕获："

msgid ""
"Set the place using assignment notation. Because place is the primary key on "
"Restaurant, the save will create a new restaurant::"
msgstr "使用赋值符号来设置地方。因为地方是餐厅的主键，保存将创建一个新的餐馆："

msgid "Set the place back again, using assignment in the reverse direction::"
msgstr "再次设置地方，使用相反方向的赋值："

msgid ""
"Note that you must save an object before it can be assigned to a one-to-one "
"relationship. For example, creating a ``Restaurant`` with unsaved ``Place`` "
"raises ``ValueError``::"
msgstr ""
"注意，将某个对象指定给一个一对一关联关系之前，必须先保存它。例如，利用未保存"
"的 ``Place`` 创建一个 ``Restaurant`` 会抛出 ``ValueError``::"

msgid ""
"Restaurant.objects.all() returns the Restaurants, not the Places. Note that "
"there are two restaurants - Ace Hardware the Restaurant was created in the "
"call to r.place = p2::"
msgstr ""
"Restaurant.objects.all() 返回所有餐厅，而不是地点。注意，这里有两个餐厅 —— "
"Ace Hardware the Restaurant 是在调用 r.place = p2 时创建的："

msgid ""
"Place.objects.all() returns all Places, regardless of whether they have "
"Restaurants::"
msgstr "Place.objects.all() 返回所有的 Place，不管其是否有关联餐厅::"

msgid ""
"You can query the models using :ref:`lookups across relationships <lookups-"
"that-span-relationships>`::"
msgstr ""
"你可以用 :ref:`跨关联查询 <lookups-that-span-relationships>` 查询这些模型::"

msgid "This also works in reverse::"
msgstr "反向查询也是可以的::"

msgid "Add a Waiter to the Restaurant::"
msgstr "为餐厅添加一个服务员::"

msgid "Query the waiters::"
msgstr "查询服务员::"

msgid "Models and databases"
msgstr "模型和数据库"

msgid ""
"A model is the single, definitive source of information about your data. It "
"contains the essential fields and behaviors of the data you're storing. "
"Generally, each model maps to a single database table."
msgstr ""
"模型准确且唯一的描述了数据。它包含您储存的数据的重要字段和行为。一般来说，每"
"一个模型都映射一张数据库表。"

msgid "Database instrumentation"
msgstr "数据库工具"

msgid ""
"To help you understand and control the queries issued by your code, Django "
"provides a hook for installing wrapper functions around the execution of "
"database queries. For example, wrappers can count queries, measure query "
"duration, log queries, or even prevent query execution (e.g. to make sure "
"that no queries are issued while rendering a template with prefetched data)."
msgstr ""
"为了帮助你更好的理解并控制由你的代码所产生的数据库查询,Django提供了一个钩子函"
"数,在这个钩子函数中你可以在数据库查询方法外层添加一层wrappers方法.举例说明, "
"wrappers方法可以记录数据库查询的数量, 计算查询持续的事件, 为查询记录日志, 甚"
"至可以阻止查询的执行(例如在渲染使用了预取的数据的模板时确保没有数据库查询被执"
"行)."

msgid ""
"The wrappers are modeled after :doc:`middleware </topics/http/middleware>` "
"-- they are callables which take another callable as one of their arguments. "
"They call that callable to invoke the (possibly wrapped) database query, and "
"they can do what they want around that call. They are, however, created and "
"installed by user code, and so don't need a separate factory like middleware "
"do."
msgstr ""
"装饰器是在 :doc:`middleware </topics/http/middleware>` 之后建模的--它们是可调"
"用的，并把其他调用作为它们的参数之一。它们调用可调用函数来调用（可能是包装"
"的）数据库查询，并且它们可以围绕这个调用做一些工作。然而，它们通过用户代码来"
"创建和安装，因此不需要独立像中间件这样的独立文件。"

msgid ""
"Installing a wrapper is done in a context manager -- so the wrappers are "
"temporary and specific to some flow in your code."
msgstr ""
"wrapper方法的安装是在上下文管理器中完成的 -- 因此wrapper方法是暂时的, 也是针"
"对于你代码里的某些特定逻辑的."

msgid ""
"As mentioned above, an example of a wrapper is a query execution blocker. It "
"could look like this::"
msgstr ""
"正如上面提到的, 一个使用wrapper方法的例子是阻塞查询的执行. 类似的代码为::"

msgid ""
"And it would be used in a view to block queries from the template like so::"
msgstr "它可以被用在视图里阻止来自模板的查询，如下所示："

msgid "The parameters sent to the wrappers are:"
msgstr "发给wrapper方法的参数是:"

msgid ""
"``execute`` -- a callable, which should be invoked with the rest of the "
"parameters in order to execute the query."
msgstr "\"execute\" -- 一个可以被执行的对象, 使用剩下的参数触发来执行查询."

msgid "``sql`` -- a ``str``, the SQL query to be sent to the database."
msgstr "``sql`` -- 一个 ``str``，要发送到数据库的SQL 查询。"

msgid ""
"``params`` -- a list/tuple of parameter values for the SQL command, or a "
"list/tuple of lists/tuples if the wrapped call is ``executemany()``."
msgstr ""
"``params`` -- SQL命令行参数值的列表/二元组，或者列表集/二元组集的一个列表/二"
"元组（如果包装过的调用是  ``executemany()`` 的话）。"

msgid ""
"``many`` -- a ``bool`` indicating whether the ultimately invoked call is "
"``execute()`` or ``executemany()`` (and whether ``params`` is expected to be "
"a sequence of values, or a sequence of sequences of values)."
msgstr ""
"``many`` -- 一个布尔值，标识最终的调用是否是 ``execute()`` 还是 "
"``executemany()`` （以及 ``params`` 是否是一个值系列，还是一系列值的序列）。"

msgid ""
"``context`` -- a dictionary with further data about the context of "
"invocation. This includes the connection and cursor."
msgstr "``context`` -- 一个字典，包含带有关于调用上下文的数据。"

msgid ""
"Using the parameters, a slightly more complex version of the blocker could "
"include the connection name in the error message::"
msgstr "使用这个参数，稍微复杂一点的阻塞函数包含在错误信息中的连接名："

msgid "For a more complete example, a query logger could look like this::"
msgstr "有关更完整的例子，一个查询日志器看起来像这样："

msgid ""
"To use this, you would create a logger object and install it as a wrapper::"
msgstr "要使用它，你可以创建一个日志器对象，并且将其作为装饰器来安装："

msgid "``connection.execute_wrapper()``"
msgstr "``connection.execute_wrapper()``"

msgid ""
"Returns a context manager which, when entered, installs a wrapper around "
"database query executions, and when exited, removes the wrapper. The wrapper "
"is installed on the thread-local connection object."
msgstr ""
"返回一个上下文管理器，当进入时，会安装一个围绕数据库查询执行的装饰器，当离开"
"时，会移除这个装饰器。装饰器是在本地线程的连接对象上安装的。"

msgid ""
"``wrapper`` is a callable taking five arguments.  It is called for every "
"query execution in the scope of the context manager, with arguments "
"``execute``, ``sql``, ``params``, ``many``, and ``context`` as described "
"above. It's expected to call ``execute(sql, params, many, context)`` and "
"return the return value of that call."
msgstr ""
"``wrapper`` 是一个带有五个参数的可调用函数。它在上下文管理器的范围内被每个查"
"询调用，带着上面所述的五个参数 ``execute``, ``sql``, ``params``, ``many``, "
"and ``context`` 。它预计会调用 ``execute(sql, params, many, context)`` ，并且"
"返回那个调用的返回值。"

msgid "Managers"
msgstr "管理器"

msgid ""
"A ``Manager`` is the interface through which database query operations are "
"provided to Django models. At least one ``Manager`` exists for every model "
"in a Django application."
msgstr ""
"``Manager`` 是一种接口，它赋予了 Django 模型操作数据库的能力。Django 应用中每"
"个模型拥有至少一个 ``Manager``。"

msgid ""
"The way ``Manager`` classes work is documented in :doc:`/topics/db/queries`; "
"this document specifically touches on model options that customize "
"``Manager`` behavior."
msgstr ""
"``Manager`` 类的文档介绍位于 :doc:`/topics/db/queries`；本页着重介绍自定义 "
"``Manager`` 行为的模型选项。"

msgid "Manager names"
msgstr "管理器名称"

msgid ""
"By default, Django adds a ``Manager`` with the name ``objects`` to every "
"Django model class. However, if you want to use ``objects`` as a field name, "
"or if you want to use a name other than ``objects`` for the ``Manager``, you "
"can rename it on a per-model basis. To rename the ``Manager`` for a given "
"class, define a class attribute of type ``models.Manager()`` on that model. "
"For example::"
msgstr ""
"默认情况下，Django 为每个模型类添加了一个名为 ``objects`` 的 ``Manager``。不"
"过，若你想将 ``objects`` 用作字段名，或想使用 ``objects`` 以外的 ``Manager`` "
"名字，就要在模型基类中重命名。要为指定类重命名 ``Manager``，在该模型中定义一"
"个类型为 ``models.Manager`` 的属性。例如::"

msgid ""
"Using this example model, ``Person.objects`` will generate an "
"``AttributeError`` exception, but ``Person.people.all()`` will provide a "
"list of all ``Person`` objects."
msgstr ""
"使用这个实例模型时， ``Person.objects`` 会产生一个 ``AttributeError`` 异常，"
"而 ``Person.people.all()`` 会返回包含所有 ``Person`` 对象的列表。"

msgid "Custom managers"
msgstr "自定义管理器"

msgid ""
"You can use a custom ``Manager`` in a particular model by extending the base "
"``Manager`` class and instantiating your custom ``Manager`` in your model."
msgstr ""
"继承基类 ``Manager``，在模型中实例化自定义 ``Manager``，你就可以在该模型中使"
"用自定义的 ``Manager``。"

msgid ""
"There are two reasons you might want to customize a ``Manager``: to add "
"extra ``Manager`` methods, and/or to modify the initial ``QuerySet`` the "
"``Manager`` returns."
msgstr ""
"有两种原因可能使你想要自定义 ``Manager``：添加额外的 ``Manager`` 方法，修改 "
"``Manager`` 返回的原始 ``QuerySet``。"

msgid "Adding extra manager methods"
msgstr "添加额外的管理器方法"

msgid ""
"Adding extra ``Manager`` methods is the preferred way to add \"table-level\" "
"functionality to your models. (For \"row-level\" functionality -- i.e., "
"functions that act on a single instance of a model object -- use :ref:`Model "
"methods <model-methods>`, not custom ``Manager`` methods.)"
msgstr ""
"添加额外的 ``Manager`` 方法一般是为模型添加 “表级” 功能的更好方法。（对于 “行"
"级” 功能 —— 即，只操作单个模型对象 —— 通过 :ref:`模型方法 <model-methods>`，"
"而不是自定义 ``Manager`` 的方法。）"

msgid "For example, this custom ``Manager`` adds a method ``with_counts()``::"
msgstr ""

msgid ""
"With this example, you'd use ``OpinionPoll.objects.with_counts()`` to get a "
"``QuerySet`` of ``OpinionPoll`` objects with the extra ``num_responses`` "
"attribute attached."
msgstr ""

msgid ""
"A custom ``Manager`` method can return anything you want. It doesn't have to "
"return a ``QuerySet``."
msgstr ""
"自定义 ``Manager`` 方法能返回任何东西，没有强制它必须返回一个 ``QuerySet``。"

msgid ""
"Another thing to note is that ``Manager`` methods can access ``self.model`` "
"to get the model class to which they're attached."
msgstr ""

msgid "Modifying a manager's initial ``QuerySet``"
msgstr "修改管理器的初始 ``QuerySet``"

msgid ""
"A ``Manager``’s base ``QuerySet`` returns all objects in the system. For "
"example, using this model::"
msgstr ""
"``Manager`` 的基础 ``QuerySet`` 会返回系统中所有的对象。例如，使用以下模型::"

msgid ""
"...the statement ``Book.objects.all()`` will return all books in the "
"database."
msgstr "……语句 ``Book.objects.all()`` 会返回数据库中所有的书。"

msgid ""
"You can override a ``Manager``’s base ``QuerySet`` by overriding the "
"``Manager.get_queryset()`` method. ``get_queryset()`` should return a "
"``QuerySet`` with the properties you require."
msgstr ""
"你可以通过重写 ``Manager.get_queryset()`` 方法来覆盖 ``Manager`` 的基础 "
"``QuerySet``。 ``get_queryset()`` 返回的 ``QuerySet`` 应该包含你需要的属性。"

msgid ""
"For example, the following model has *two* ``Manager``\\s -- one that "
"returns all objects, and one that returns only the books by Roald Dahl::"
msgstr ""
"例如，以下模型有 *两个* ``Manager`` —— 一个返回所有对象，另一个仅返回 Roald "
"Dahl 写的书::"

msgid ""
"With this sample model, ``Book.objects.all()`` will return all books in the "
"database, but ``Book.dahl_objects.all()`` will only return the ones written "
"by Roald Dahl."
msgstr ""
"使用这个实例模型时， ``Book.objects.all()`` 会返回数据库中所有的书，而 "
"``Book.dahl_objects.all()`` 仅返回 Roald Dahl 写的书。"

msgid ""
"Because ``get_queryset()`` returns a ``QuerySet`` object, you can use "
"``filter()``, ``exclude()`` and all the other ``QuerySet`` methods on it. So "
"these statements are all legal::"
msgstr ""
"因为 ``get_queryset()`` 返回一个 ``QuerySet`` 对象，你可以在上面调用 "
"``filter()``， ``exclude()`` 和其它的 ``QuerySet`` 方法。所以，以下语句是等效"
"的::"

msgid ""
"This example also pointed out another interesting technique: using multiple "
"managers on the same model. You can attach as many ``Manager()`` instances "
"to a model as you'd like. This is a non-repetitive way to define common "
"\"filters\" for your models."
msgstr ""
"本例同时介绍了另一个有趣的技巧：在一个模型中使用多个管理器。你可以为一个模型"
"添加任意多个 ``Manager()``。为模型定义通用 \"filters\" 的非重复方式。"

msgid ""
"This example allows you to request ``Person.authors.all()``, ``Person."
"editors.all()``, and ``Person.people.all()``, yielding predictable results."
msgstr ""
"本例允许你调用 ``Person.authors.all()``， ``Person.editors.all()`` 和 "
"``Person.people.all()``，返回符合期望的结果。"

msgid "Default managers"
msgstr "默认管理器"

msgid ""
"If you use custom ``Manager`` objects, take note that the first ``Manager`` "
"Django encounters (in the order in which they're defined in the model) has a "
"special status. Django interprets the first ``Manager`` defined in a class "
"as the \"default\" ``Manager``, and several parts of Django (including :"
"djadmin:`dumpdata`) will use that ``Manager`` exclusively for that model. As "
"a result, it's a good idea to be careful in your choice of default manager "
"in order to avoid a situation where overriding ``get_queryset()`` results in "
"an inability to retrieve objects you'd like to work with."
msgstr ""
"若你使用自定义 ``Manager`` 对象，注意 Django 遇到的第一个 ``Manager`` （按照"
"你在模型中定义的顺序）会拥有一个独特的状态。Django 将类定义中的第一个 "
"``Manager`` 视作 “默认” ``Manager``，Django 的几个组件（包括 :djadmin:"
"`dumpdata`）在用到该模型时会独立地调用该 ``Manager``。故此，选择默认管理器时"
"要万分小心，避免遇到重写的 ``get_queryset()`` 无法获取期望的结果这种情况。"

msgid ""
"You can specify a custom default manager using :attr:`Meta."
"default_manager_name <django.db.models.Options.default_manager_name>`."
msgstr ""
"你可以通过 :attr:`Meta.default_manager_name <django.db.models.Options."
"default_manager_name>` 指定一个自定义的默认管理器。"

msgid ""
"If you're writing some code that must handle an unknown model, for example, "
"in a third-party app that implements a generic view, use this manager (or :"
"attr:`~Model._base_manager`) rather than assuming the model has an "
"``objects`` manager."
msgstr ""
"若你正在编写的代码必须处理未知模型，例如，在实现了通用视图的第三方应用中使用"
"这个管理器（或 :attr:`~Model._base_manager`），而不是假定该模型有一个名为 "
"``objects`` 的管理器。"

msgid "Base managers"
msgstr "基础管理器"

msgid "Using managers for related object access"
msgstr "用于访问关联对象的管理器"

msgid ""
"By default, Django uses an instance of the ``Model._base_manager`` manager "
"class when accessing related objects (i.e. ``choice.question``), not the "
"``_default_manager`` on the related object. This is because Django needs to "
"be able to retrieve the related object, even if it would otherwise be "
"filtered out (and hence be inaccessible) by the default manager."
msgstr ""
"默认情况下，Django 访问关联对象（即 ``choice.question``）时使用 ``Model."
"_base_manager`` 管理器类的实例，而不是关联对象的 ``_default_manager``。这是因"
"为 Django 要检索那些可能被默认管理器筛选掉（所以无法访问）的关联对象。"

msgid ""
"If the normal base manager class (:class:`django.db.models.Manager`) isn't "
"appropriate for your circumstances, you can tell Django which class to use "
"by setting :attr:`Meta.base_manager_name <django.db.models.Options."
"base_manager_name>`."
msgstr ""
"若基本管理器类 (:class:`django.db.models.Manager`) 无法满足需求，你可以通过设"
"置 :attr:`Meta.base_manager_name <django.db.models.Options."
"base_manager_name>` 告诉 Django 使用哪个类。 "

msgid ""
"Base managers aren't used when querying on related models, or when :ref:"
"`accessing a one-to-many or many-to-many relationship <backwards-related-"
"objects>`. For example, if the ``Question`` model :ref:`from the tutorial "
"<creating-models>` had a ``deleted`` field and a base manager that filters "
"out instances with ``deleted=True``, a queryset like ``Choice.objects."
"filter(question__name__startswith='What')`` would include choices related to "
"deleted questions."
msgstr ""
"在关联模型上执行查询时不会使用基础管理器，或者当访问一对多或多对多关系( :ref:"
"`accessing a one-to-many or many-to-many relationship <backwards-related-"
"objects>` )。例如，若 :ref:`来自教程 <creating-models>` 的模型 ``Question`` "
"有个 ``deleted`` 字段，还有一个基础管理器，用于过滤掉 ``deleted=True`` 的实"
"例。由 ``Choice.objects.filter(question__name__startswith='What')`` 返回的查"
"询结果集会包含关联至已删除的问题的选项。"

msgid "Don't filter away any results in this type of manager subclass"
msgstr "不要在这类管理器子类中过滤掉任何结果"

msgid ""
"This manager is used to access objects that are related to from some other "
"model. In those situations, Django has to be able to see all the objects for "
"the model it is fetching, so that *anything* which is referred to can be "
"retrieved."
msgstr ""
"该管理器用于访问由其它模型关联过来的对象。这些情况下，Django 要能访问待获取模"
"型的全部对象，这样就能检索出其指向的 *任何东西*。"

msgid ""
"Therefore, you should not override ``get_queryset()`` to filter out any "
"rows. If you do so, Django will return incomplete results."
msgstr ""
"因此，你不应该覆盖 ``get_queryset()`` 来过滤任何rows。如果你这么做，Django 会"
"返回不完整的结果。"

msgid "Calling custom ``QuerySet`` methods from the manager"
msgstr "管理器调用自定义 ``QuerySet`` 方法"

msgid ""
"While most methods from the standard ``QuerySet`` are accessible directly "
"from the ``Manager``, this is only the case for the extra methods defined on "
"a custom ``QuerySet`` if you also implement them on the ``Manager``::"
msgstr ""
"因为大部分的标准 ``QuerySet`` 方法能直接从 ``Manager`` 访问，这个实例仅适用于"
"你在自定义 ``QuerySet`` 中定义了额外方法，且在 ``Manager`` 中实现了它们::"

msgid ""
"This example allows you to call both ``authors()`` and ``editors()`` "
"directly from the manager ``Person.people``."
msgstr ""
"本例允许你从管理器 ``Person.people`` 直接调用 ``authors()`` 和 "
"``editors()``。"

msgid "Creating a manager with ``QuerySet`` methods"
msgstr "创建带有 ``QuerySet`` 方法的管理器"

msgid ""
"In lieu of the above approach which requires duplicating methods on both the "
"``QuerySet`` and the ``Manager``, :meth:`QuerySet.as_manager() <django.db."
"models.query.QuerySet.as_manager>` can be used to create an instance of "
"``Manager`` with a copy of a custom ``QuerySet``’s methods::"
msgstr ""
"要替换前面的要求复制 ``QuerySet`` 和 ``Manager``  方法的方案， 可以用 :meth:"
"`QuerySet.as_manager() <django.db.models.query.QuerySet.as_manager>` 创建一"
"个 ``Manager`` 实例，拷贝了自定义 ``QuerySet`` 的方法::"

msgid ""
"The ``Manager`` instance created by :meth:`QuerySet.as_manager() <django.db."
"models.query.QuerySet.as_manager>` will be virtually identical to the "
"``PersonManager`` from the previous example."
msgstr ""
"由 :meth:`QuerySet.as_manager() <django.db.models.query.QuerySet."
"as_manager>` 创建的 ``Manager`` 实例实质上等价于前面例子中的 "
"``PersonManager``。"

msgid ""
"Not every ``QuerySet`` method makes sense at the ``Manager`` level; for "
"instance we intentionally prevent the :meth:`QuerySet.delete() <django.db."
"models.query.QuerySet.delete>` method from being copied onto the ``Manager`` "
"class."
msgstr ""
"不是每个 ``QuerySet`` 方法在 ``Manager`` 层都是有意义的；例如，我们故意阻止 :"
"meth:`QuerySet.delete() <django.db.models.query.QuerySet.delete>` 被拷贝进 "
"``Manager`` 类中。"

msgid "Methods are copied according to the following rules:"
msgstr "方法拷贝规则如下："

msgid "Public methods are copied by default."
msgstr "公开方法默认会被拷贝。"

msgid ""
"Private methods (starting with an underscore) are not copied by default."
msgstr "私有方法（以下划线打头）默认不会被复制。"

msgid ""
"Methods with a ``queryset_only`` attribute set to ``False`` are always "
"copied."
msgstr "``queryset_only`` 属性值为 ``False`` 的方法总是会被复制。"

msgid ""
"Methods with a ``queryset_only`` attribute set to ``True`` are never copied."
msgstr "``queryset_only`` 属性值为 ``True`` 的方法永远不会被复制。"

msgid "``from_queryset()``"
msgstr "``from_queryset()``"

msgid ""
"For advanced usage you might want both a custom ``Manager`` and a custom "
"``QuerySet``. You can do that by calling ``Manager.from_queryset()`` which "
"returns a *subclass* of your base ``Manager`` with a copy of the custom "
"``QuerySet`` methods::"
msgstr ""
"对于进阶用法，你可能同时要一个自定义 ``Manager`` 和一个自定义 ``QuerySet``。"
"你可以通过调用 ``Manager.from_queryset()`` 达成目的，这将会返回一个自定义基"
"础 ``Manager`` 的子类，带有一份自定义 ``QuerySet`` 方法的拷贝::"

msgid "You may also store the generated class into a variable::"
msgstr "还可以将生成的类存储到变量中："

msgid "Custom managers and model inheritance"
msgstr "自定义管理器和模型继承"

msgid ""
"Here's how Django handles custom managers and :ref:`model inheritance <model-"
"inheritance>`:"
msgstr ""
"下面是 Django 如何处理自定义管理器和 :ref:`模型继承 <model-inheritance>`："

msgid ""
"Managers from base classes are always inherited by the child class, using "
"Python's normal name resolution order (names on the child class override all "
"others; then come names on the first parent class, and so on)."
msgstr ""
"基类的管理器总是被子类以 Python 的普通名称解析顺序继承（子类上的属性会覆盖所"
"有父类上的同名属性；直接父类会覆盖更上一级的，以此类推）。"

msgid ""
"If no managers are declared on a model and/or its parents, Django "
"automatically creates the ``objects`` manager."
msgstr ""
"如果没有在模型或其父类申明管理器，Django 会自动创建 ``objects`` 管理器。"

msgid ""
"The default manager on a class is either the one chosen with :attr:`Meta."
"default_manager_name <django.db.models.Options.default_manager_name>`, or "
"the first manager declared on the model, or the default manager of the first "
"parent model."
msgstr ""
"一个类的默认管理器要么由 :attr:`Meta.default_manager_name <django.db.models."
"Options.default_manager_name>` 指定，要么是模型中申明的第一个管理器，或者是直"
"接父模型的默认管理器。"

msgid ""
"These rules provide the necessary flexibility if you want to install a "
"collection of custom managers on a group of models, via an abstract base "
"class, but still customize the default manager. For example, suppose you "
"have this base class::"
msgstr ""
"如果您想通过抽象基类在一组模型上安装自定义管理器，但仍能自定义默认管理器，这"
"些规则提供了必要的灵活性。例如，假设有此基类::"

msgid ""
"If you use this directly in a subclass, ``objects`` will be the default "
"manager if you declare no managers in the base class::"
msgstr ""
"如果您在子类中直接使用这一点，如果您在基类中没有声明任何管理器，那么 "
"``objects`` 将是默认的管理器："

msgid ""
"If you want to inherit from ``AbstractBase``, but provide a different "
"default manager, you can provide the default manager on the child class::"
msgstr ""
"如果您想继承 ``AbstractBase``，但提供不同的默认管理器，则可以在子类上提供该默"
"认管理器::"

msgid ""
"Here, ``default_manager`` is the default. The ``objects`` manager is still "
"available, since it's inherited, but isn't used as the default."
msgstr ""
"这里的 ``default_manager`` 是默认的。 ``objects`` 管理器仍然可用，因为它是继"
"承的，但没有被当做默认管理器。"

msgid ""
"Finally for this example, suppose you want to add extra managers to the "
"child class, but still use the default from ``AbstractBase``. You can't add "
"the new manager directly in the child class, as that would override the "
"default and you would have to also explicitly include all the managers from "
"the abstract base class. The solution is to put the extra managers in "
"another base class and introduce it into the inheritance hierarchy *after* "
"the defaults::"
msgstr ""
"最后，对于这个示例，假设您想要向子类中添加额外的管理器，但是仍然使用来自 "
"``AbstractBase`` 的默认管理器。您不能直接在子类中添加新的管理器，因为这将覆盖"
"默认管理器，并且您还必须显式地申明来自抽象基类的所有管理器。解决方案是将这个"
"管理器放到另一个基类中，并在默认管理器 *之后* 将其引入继承层次结构::"

msgid ""
"Note that while you can *define* a custom manager on the abstract model, you "
"can't *invoke* any methods using the abstract model. That is::"
msgstr ""
"请注意，虽然可以在抽象模型上 *定义* 自定义管理器，但不能使用抽象模型 *调用* "
"任何方法。即::"

msgid "is legal, but::"
msgstr "是合法的，但::"

msgid ""
"will raise an exception. This is because managers are intended to "
"encapsulate logic for managing collections of objects. Since you can't have "
"a collection of abstract objects, it doesn't make sense to be managing them. "
"If you have functionality that applies to the abstract model, you should put "
"that functionality in a ``staticmethod`` or ``classmethod`` on the abstract "
"model."
msgstr ""
"会引发一个异常。这是因为管理器意在封装管理映射对象集合的逻辑。因为您不能拥有"
"抽象对象的集合，所以管理抽象对象是没有意义的。如果您有适用于抽象模型的功能，"
"则应该将该功能放在抽象模型的 ``静态方法`` 或 ``类方法`` 中。"

msgid "Implementation concerns"
msgstr "执行关系"

msgid ""
"Whatever features you add to your custom ``Manager``, it must be possible to "
"make a shallow copy of a ``Manager`` instance; i.e., the following code must "
"work::"
msgstr ""
"无论您在自定义的 ``Manager`` 中添加了什么特性，都必须能够对 ``Manager`` 实例"
"进行简单的复制；也就是说，以下代码必须有效："

msgid ""
"Django makes shallow copies of manager objects during certain queries; if "
"your Manager cannot be copied, those queries will fail."
msgstr ""
"Django 在某些查询期间对管理器对象进行浅拷贝；如果您的管理器无法被复制，那么这"
"些查询将失败。"

msgid ""
"This won't be an issue for most custom managers. If you are just adding "
"simple methods to your ``Manager``, it is unlikely that you will "
"inadvertently make instances of your ``Manager`` uncopyable. However, if "
"you're overriding ``__getattr__`` or some other private method of your "
"``Manager`` object that controls object state, you should ensure that you "
"don't affect the ability of your ``Manager`` to be copied."
msgstr ""
"对于大多数的资源管理器来说，这不是问题。若你只是为 ``Manager`` 添加简单的方"
"法，一般不会疏忽地把 ``Manager`` 变的不可拷贝。但是，若重写了 ``Manager`` 对"
"象用于控制对象状态的 ``__getattr__`` 或其它私有方法，你需要确认你的修改不会影"
"响 ``Manager`` 被复制。"

msgid "Models"
msgstr "模型"

msgid "The basics:"
msgstr "基础："

msgid ""
"Each model is a Python class that subclasses :class:`django.db.models.Model`."
msgstr ""
"每个模型都是一个 Python 的类，这些类继承 :class:`django.db.models.Model`"

msgid "Each attribute of the model represents a database field."
msgstr "模型类的每个属性都相当于一个数据库的字段。"

msgid ""
"With all of this, Django gives you an automatically-generated database-"
"access API; see :doc:`/topics/db/queries`."
msgstr ""
"利用这些，Django 提供了一个自动生成访问数据库的 API；请参阅 :doc:`/topics/db/"
"queries`。"

msgid "Quick example"
msgstr "快速上手"

msgid ""
"This example model defines a ``Person``, which has a ``first_name`` and "
"``last_name``::"
msgstr ""
"这个样例定义了一个 ``Person`` 模型，拥有 ``first_name`` 和 ``last_name``::"

msgid ""
"``first_name`` and ``last_name`` are fields_ of the model. Each field is "
"specified as a class attribute, and each attribute maps to a database column."
msgstr ""
"``first_name`` 和 ``last_name`` 是模型的 字段_。每个字段都被指定为一个类属"
"性，并且每个属性映射为一个数据库列。"

msgid "The above ``Person`` model would create a database table like this:"
msgstr "上面的 ``Person`` 模型会创建一个如下的数据库表："

msgid "Some technical notes:"
msgstr "一些技术上的说明："

msgid ""
"The name of the table, ``myapp_person``, is automatically derived from some "
"model metadata but can be overridden. See :ref:`table-names` for more "
"details."
msgstr ""
"该表的名称 ``myapp_person`` 是自动从某些模型元数据中派生出来，但可以被改写。"
"参阅 :ref:`table-names` 获取更多信息。"

msgid ""
"An ``id`` field is added automatically, but this behavior can be overridden. "
"See :ref:`automatic-primary-key-fields`."
msgstr ""
"一个 ``id`` 字段会被自动添加，但是这种行为可以被改写。请参阅 :ref:`automatic-"
"primary-key-fields`。"

msgid ""
"The ``CREATE TABLE`` SQL in this example is formatted using PostgreSQL "
"syntax, but it's worth noting Django uses SQL tailored to the database "
"backend specified in your :doc:`settings file </topics/settings>`."
msgstr ""
"本例子中 ``创建数据表`` 的语法是 PostgreSQL 格式的。值得注意的是，Django 依据"
"你在 :doc:`配置文件 </topics/settings>` 中指定的数据库后端生成对应的 SQL 语"
"句。"

msgid "Using models"
msgstr "使用模型"

msgid ""
"Once you have defined your models, you need to tell Django you're going to "
"*use* those models. Do this by editing your settings file and changing the :"
"setting:`INSTALLED_APPS` setting to add the name of the module that contains "
"your ``models.py``."
msgstr ""
"一旦你定义了你的模型，你需要告诉 Django 你准备 *使用* 这些模型。你需要修改设"
"置文件中的 :setting:`INSTALLED_APPS` ，在这个设置中添加包含  ``models.py`` 文"
"件的模块名称。"

msgid ""
"For example, if the models for your application live in the module ``myapp."
"models`` (the package structure that is created for an application by the :"
"djadmin:`manage.py startapp <startapp>` script), :setting:`INSTALLED_APPS` "
"should read, in part::"
msgstr ""
"例如，若模型位于项目中的 ``myapp.models`` 模块（ 此包结构由 :djadmin:`manage."
"py startapp <startapp>` 命令创建）， :setting:`INSTALLED_APPS` 应设置如下："

msgid ""
"When you add new apps to :setting:`INSTALLED_APPS`, be sure to run :djadmin:"
"`manage.py migrate <migrate>`, optionally making migrations for them first "
"with :djadmin:`manage.py makemigrations <makemigrations>`."
msgstr ""
"当你向 :setting:`INSTALLED_APPS` 添加新的应用的时候，请务必运行 :djadmin:"
"`manage.py migrate <migrate>`，此外你也可以先使用以下命令进行迁移 :djadmin:"
"`manage.py makemigrations <makemigrations>`。"

msgid "Fields"
msgstr "字段"

msgid ""
"The most important part of a model -- and the only required part of a model "
"-- is the list of database fields it defines. Fields are specified by class "
"attributes. Be careful not to choose field names that conflict with the :doc:"
"`models API </ref/models/instances>` like ``clean``, ``save``, or ``delete``."
msgstr ""
"模型中最重要且唯一必要的是数据库的字段定义。字段在类属性中定义。定义字段名时"
"应小心避免使用与 :doc:`模型 API </ref/models/instances>` 冲突的名称， 如 "
"``clean``, ``save``, or ``delete`` 等."

msgid "Example::"
msgstr "举例："

msgid "Field types"
msgstr "字段类型"

msgid ""
"Each field in your model should be an instance of the appropriate :class:"
"`~django.db.models.Field` class. Django uses the field class types to "
"determine a few things:"
msgstr ""
"模型中每一个字段都应该是某个 :class:`~django.db.models.Field` 类的实例， "
"Django 利用这些字段类来实现以下功能："

msgid ""
"The column type, which tells the database what kind of data to store (e.g. "
"``INTEGER``, ``VARCHAR``, ``TEXT``)."
msgstr ""
"字段类型用以指定数据库数据类型（如：``INTEGER``, ``VARCHAR``, ``TEXT``）。"

msgid ""
"The default HTML :doc:`widget </ref/forms/widgets>` to use when rendering a "
"form field (e.g. ``<input type=\"text\">``, ``<select>``)."
msgstr ""
"在渲染表单字段时默认使用的 HTML :doc:`视图 </ref/forms/widgets>`  (如： "
"``<input type=\"text\">``, ``<select>``)。"

msgid ""
"The minimal validation requirements, used in Django's admin and in "
"automatically-generated forms."
msgstr "基本的有效性验证功能，用于 Django 后台和自动生成的表单。"

msgid ""
"Django ships with dozens of built-in field types; you can find the complete "
"list in the :ref:`model field reference <model-field-types>`. You can easily "
"write your own fields if Django's built-in ones don't do the trick; see :doc:"
"`/howto/custom-model-fields`."
msgstr ""
"Django 内置了数十种字段类型；你可以在 :ref:`模型字段参考<model-field-types>` "
"中看到完整列表。如果 Django 内置类型不能满足你的需求，你可以很轻松地编写自定"
"义的字段类型；参见 :doc:`/howto/custom-model-fields`。"

msgid "Field options"
msgstr "字段选项"

msgid ""
"Each field takes a certain set of field-specific arguments (documented in "
"the :ref:`model field reference <model-field-types>`). For example, :class:"
"`~django.db.models.CharField` (and its subclasses) require a :attr:`~django."
"db.models.CharField.max_length` argument which specifies the size of the "
"``VARCHAR`` database field used to store the data."
msgstr ""
"每一种字段都需要指定一些特定的参数（参考 :ref:`模型字段 <model-field-"
"types>` ）。 例如， :class:`~django.db.models.CharField` （以及它的子类）需要"
"接收一个 :attr:`~django.db.models.CharField.max_length` 参数，用以指定数据库"
"存储 ``VARCHAR`` 数据时用的字节数。"

msgid ""
"There's also a set of common arguments available to all field types. All are "
"optional. They're fully explained in the :ref:`reference <common-model-field-"
"options>`, but here's a quick summary of the most often-used ones:"
msgstr ""
"一些可选的参数是通用的，可以用于任何字段类型，详情请见 :ref:`参考 <common-"
"model-field-options>` ，下面介绍一部分经常用到的通用参数："

msgid ":attr:`~Field.null`"
msgstr ":attr:`~Field.null`"

msgid ""
"If ``True``, Django will store empty values as ``NULL`` in the database. "
"Default is ``False``."
msgstr ""
"如果设置为 ``True``，当该字段为空时，Django 会将数据库中该字段设置为 "
"``NULL``。默认为 ``False`` 。"

msgid ":attr:`~Field.blank`"
msgstr ":attr:`~Field.blank`"

msgid "If ``True``, the field is allowed to be blank. Default is ``False``."
msgstr "如果设置为 ``True``，该字段允许为空。默认为 ``False``。"

msgid ""
"Note that this is different than :attr:`~Field.null`. :attr:`~Field.null` is "
"purely database-related, whereas :attr:`~Field.blank` is validation-related. "
"If a field has :attr:`blank=True <Field.blank>`, form validation will allow "
"entry of an empty value. If a field has :attr:`blank=False <Field.blank>`, "
"the field will be required."
msgstr ""
"注意该选项与 ``null`` 不同， :attr:`~Field.null` 选项仅仅是数据库层面的设置，"
"而 :attr:`~Field.blank` 是涉及表单验证方面。如果一个字段设置为 :attr:"
"`blank=True <Field.blank>` ，在进行表单验证时，接收的数据该字段值允许为空，而"
"设置为 :attr:`blank=False <Field.blank>` 时，不允许为空。"

msgid ":attr:`~Field.choices`"
msgstr ":attr:`~Field.choices`"

msgid ""
"A :term:`sequence` of 2-tuples to use as choices for this field. If this is "
"given, the default form widget will be a select box instead of the standard "
"text field and will limit choices to the choices given."
msgstr ""
"一系列二元组，用作此字段的选项。如果提供了二元组，默认表单小部件是一个选择"
"框，而不是标准文本字段，并将限制给出的选项。"

msgid "A choices list looks like this::"
msgstr "一个选项列表："

msgid "A new migration is created each time the order of ``choices`` changes."
msgstr "每当 ``choices`` 的顺序变动时将会创建新的迁移。"

msgid ""
"The first element in each tuple is the value that will be stored in the "
"database. The second element is displayed by the field's form widget."
msgstr ""
"每个二元组的第一个值会储存在数据库中，而第二个值将只会用于在表单中显示。"

msgid ""
"Given a model instance, the display value for a field with ``choices`` can "
"be accessed using the :meth:`~django.db.models.Model.get_FOO_display` "
"method. For example::"
msgstr ""
"对于一个模型实例，要获取该字段二元组中相对应的第二个值，使用 :meth:`~django."
"db.models.Model.get_FOO_display` 方法。例如："

msgid ""
"You can also use enumeration classes to define ``choices`` in a concise way::"
msgstr "你也可以使用枚举类以简洁的方式来定义 ``choices`` ："

msgid ""
"Further examples are available in the :ref:`model field reference <field-"
"choices>`."
msgstr ":ref:`model field reference <field-choices>` 中定义了更多的示例。"

msgid ":attr:`~Field.default`"
msgstr ":attr:`~Field.default`"

msgid ""
"The default value for the field. This can be a value or a callable object. "
"If callable it will be called every time a new object is created."
msgstr ""
"该字段的默认值。可以是一个值或者是个可调用的对象，如果是个可调用对象，每次实"
"例化模型时都会调用该对象。"

msgid ":attr:`~Field.help_text`"
msgstr ":attr:`~Field.help_text`"

msgid ""
"Extra \"help\" text to be displayed with the form widget. It's useful for "
"documentation even if your field isn't used on a form."
msgstr ""
"额外的“帮助”文本，随表单控件一同显示。即便你的字段未用于表单，它对于生成文档"
"也是很有用的。"

msgid ":attr:`~Field.primary_key`"
msgstr ":attr:`~Field.primary_key`"

msgid "If ``True``, this field is the primary key for the model."
msgstr "如果设置为 ``True`` ，将该字段设置为该模型的主键。"

msgid ""
"If you don't specify :attr:`primary_key=True <Field.primary_key>` for any "
"fields in your model, Django will automatically add an :class:`IntegerField` "
"to hold the primary key, so you don't need to set :attr:`primary_key=True "
"<Field.primary_key>` on any of your fields unless you want to override the "
"default primary-key behavior. For more, see :ref:`automatic-primary-key-"
"fields`."
msgstr ""
"在一个模型中，如果你没有对任何一个字段设置 :attr:`primary_key=True <Field."
"primary_key>` 选项。 Django 会自动添加一个 :class:`IntegerField` 字段，并设置"
"为主键，因此除非你想重写 Django 默认的主键设置行为，你可以不手动设置主键。详"
"情请见 :ref:`automatic-primary-key-fields` 。"

msgid ""
"The primary key field is read-only. If you change the value of the primary "
"key on an existing object and then save it, a new object will be created "
"alongside the old one. For example::"
msgstr ""
"主键字段是只可读的，如果你修改一个模型实例的主键并保存，这等同于创建了一个新"
"的模型实例。例如："

msgid ":attr:`~Field.unique`"
msgstr ":attr:`~Field.unique`"

msgid "If ``True``, this field must be unique throughout the table."
msgstr "如果设置为 ``True``，这个字段的值必须在整个表中保持唯一。"

msgid ""
"Again, these are just short descriptions of the most common field options. "
"Full details can be found in the :ref:`common model field option reference "
"<common-model-field-options>`."
msgstr ""
"再次声明，以上只是一些通用参数的简略描述。你可以在 :ref:`通用可选参数参考"
"<common-model-field-options>` 中找到完整的介绍。"

msgid "Automatic primary key fields"
msgstr "自动设置主键"

msgid ""
"By default, Django gives each model an auto-incrementing primary key with "
"the type specified per app in :attr:`AppConfig.default_auto_field <django."
"apps.AppConfig.default_auto_field>` or globally in the :setting:"
"`DEFAULT_AUTO_FIELD` setting. For example::"
msgstr ""
"默认情况下，Django 给每个模型一个自动递增的主键，其类型在 :attr:`AppConfig."
"default_auto_field <django.apps.AppConfig.default_auto_field>` 中指定，或者"
"在 :setting:`DEFAULT_AUTO_FIELD` 配置中全局指定。例如："

msgid ""
"If you'd like to specify a custom primary key, specify :attr:"
"`primary_key=True <Field.primary_key>` on one of your fields. If Django sees "
"you've explicitly set :attr:`Field.primary_key`, it won't add the automatic "
"``id`` column."
msgstr ""
"如果你想自己指定主键， 在你想要设置为主键的字段上设置参数 :attr:"
"`primary_key=True <Field.primary_key>`。如果 Django 看到你显式地设置了 :attr:"
"`Field.primary_key`，将不会自动在表（模型）中添加 ``id`` 列。"

msgid ""
"Each model requires exactly one field to have :attr:`primary_key=True <Field."
"primary_key>` (either explicitly declared or automatically added)."
msgstr ""
"每个模型都需要拥有一个设置了 :attr:`primary_key=True <Field.primary_key>` 的"
"字段（无论是显式的设置还是 Django 自动设置）。"

msgid ""
"In older versions, auto-created primary key fields were always :class:"
"`AutoField`\\s."
msgstr "在旧版本中，自动创建的主键字段总是 :class:`AutoField`。"

msgid "Verbose field names"
msgstr "字段备注名"

msgid ""
"Each field type, except for :class:`~django.db.models.ForeignKey`, :class:"
"`~django.db.models.ManyToManyField` and :class:`~django.db.models."
"OneToOneField`, takes an optional first positional argument -- a verbose "
"name. If the verbose name isn't given, Django will automatically create it "
"using the field's attribute name, converting underscores to spaces."
msgstr ""
"除了  :class:`~django.db.models.ForeignKey`， :class:`~django.db.models."
"ManyToManyField` 和 :class:`~django.db.models.OneToOneField`，任何字段类型都"
"接收一个可选的位置参数 :attr:`~Field.verbose_name`，如果未指定该参数值， "
"Django 会自动使用字段的属性名作为该参数值，并且把下划线转换为空格。"

msgid "In this example, the verbose name is ``\"person's first name\"``::"
msgstr "在该例中：备注名为 ``\"person's first name\"``::"

msgid "In this example, the verbose name is ``\"first name\"``::"
msgstr "在该例中：备注名为 ``\"first name\"``::"

msgid ""
":class:`~django.db.models.ForeignKey`, :class:`~django.db.models."
"ManyToManyField` and :class:`~django.db.models.OneToOneField` require the "
"first argument to be a model class, so use the :attr:`~Field.verbose_name` "
"keyword argument::"
msgstr ""
":class:`~django.db.models.ForeignKey`, :class:`~django.db.models."
"ManyToManyField` and :class:`~django.db.models.OneToOneField` 接收的第一个参"
"数为模型的类名，后面可以添加一个 :attr:`~Field.verbose_name` 参数："

msgid ""
"The convention is not to capitalize the first letter of the :attr:`~Field."
"verbose_name`. Django will automatically capitalize the first letter where "
"it needs to."
msgstr ""
"惯例是不将 :attr:`~Field.verbose_name` 的首字母大写，必要时 Djanog 会自动把首"
"字母转换为大写。"

msgid "Relationships"
msgstr "关联关系"

msgid ""
"Clearly, the power of relational databases lies in relating tables to each "
"other. Django offers ways to define the three most common types of database "
"relationships: many-to-one, many-to-many and one-to-one."
msgstr ""
"显然，关系型数据库的强大之处在于各表之间的关联关系。 Django 提供了定义三种最"
"常见的数据库关联关系的方法：多对一，多对多，一对一。"

msgid ""
"To define a many-to-one relationship, use :class:`django.db.models."
"ForeignKey`. You use it just like any other :class:`~django.db.models.Field` "
"type: by including it as a class attribute of your model."
msgstr ""
"定义一个多对一的关联关系，使用 :class:`django.db.models.ForeignKey` 类。就和"
"其它 :class:`~django.db.models.Field` 字段类型一样，只需要在你模型中添加一个"
"值为该类的属性。"

msgid ""
":class:`~django.db.models.ForeignKey` requires a positional argument: the "
"class to which the model is related."
msgstr ""
":class:`~django.db.models.ForeignKey` 类需要添加一个位置参数，即你想要关联的"
"模型类名。"

msgid ""
"For example, if a ``Car`` model has a ``Manufacturer`` -- that is, a "
"``Manufacturer`` makes multiple cars but each ``Car`` only has one "
"``Manufacturer`` -- use the following definitions::"
msgstr ""
"例如，如果一个 ``Car`` 模型有一个制造者 ``Manufacturer`` --就是说一个 "
"``Manufacturer`` 制造许多辆车，但是每辆车都仅有一个制造者-- 那么使用下面的方"
"法定义这个关系："

msgid ""
"You can also create :ref:`recursive relationships <recursive-relationships>` "
"(an object with a many-to-one relationship to itself) and :ref:"
"`relationships to models not yet defined <lazy-relationships>`; see :ref:"
"`the model field reference <ref-foreignkey>` for details."
msgstr ""
"你也可以创建 :ref:`自关联关系 <recursive-relationships>` （一个模型与它本身有"
"多对一的关系）和 :ref:`与未定义的模型间的关联关系 <lazy-relationships>` ；详"
"情请见  :ref:`模型字段参考 <ref-foreignkey>` 。"

msgid ""
"It's suggested, but not required, that the name of a :class:`~django.db."
"models.ForeignKey` field (``manufacturer`` in the example above) be the name "
"of the model, lowercase. You can call the field whatever you want. For "
"example::"
msgstr ""
"建议设置 :class:`~django.db.models.ForeignKey` 字段名（上例中的 "
"``manufacturer`` ）为想要关联的模型名，但是你也可以随意设置为你想要的名称，例"
"如："

msgid ""
":class:`~django.db.models.ForeignKey` fields accept a number of extra "
"arguments which are explained in :ref:`the model field reference <foreign-"
"key-arguments>`. These options help define how the relationship should work; "
"all are optional."
msgstr ""
":class:`~django.db.models.ForeignKey` 字段还可以接收一些其他的参数，详见 :"
"ref:`模型字段参考 <foreign-key-arguments>` ，这些可选的参数可以更深入的规定关"
"联关系的具体实现。"

msgid ""
"For details on accessing backwards-related objects, see the :ref:`Following "
"relationships backward example <backwards-related-objects>`."
msgstr ""
"关于反向关联对象的细节，参见 :ref:`反向关联例子 <backwards-related-"
"objects>`。"

msgid ""
"For sample code, see the :doc:`Many-to-one relationship model example </"
"topics/db/examples/many_to_one>`."
msgstr ""
"如要查看相关示例代码，详见 :doc:`模型多对一关联实例 </topics/db/examples/"
"many_to_one>` 。"

msgid ""
"To define a many-to-many relationship, use :class:`~django.db.models."
"ManyToManyField`. You use it just like any other :class:`~django.db.models."
"Field` type: by including it as a class attribute of your model."
msgstr ""
"定义一个多对多的关联关系，使用 :class:`django.db.models.ManyToManyField` 类。"
"就和其他 :class:`~django.db.models.Field` 字段类型一样，只需要在你模型中添加"
"一个值为该类的属性。"

msgid ""
":class:`~django.db.models.ManyToManyField` requires a positional argument: "
"the class to which the model is related."
msgstr ""
":class:`~django.db.models.ManyToManyField` 类需要添加一个位置参数，即你想要关"
"联的模型类名。"

msgid ""
"For example, if a ``Pizza`` has multiple ``Topping`` objects -- that is, a "
"``Topping`` can be on multiple pizzas and each ``Pizza`` has multiple "
"toppings -- here's how you'd represent that::"
msgstr ""
"例如：如果 ``Pizza`` 含有多种 ``Topping`` （配料） -- 也就是一种 ``Topping`` "
"可能存在于多个 ``Pizza`` 中，并且每个 ``Pizza`` 含有多种 ``Topping`` --那么可"
"以这样表示这种关系："

msgid ""
"As with :class:`~django.db.models.ForeignKey`, you can also create :ref:"
"`recursive relationships <recursive-relationships>` (an object with a many-"
"to-many relationship to itself) and :ref:`relationships to models not yet "
"defined <lazy-relationships>`."
msgstr ""
"和 :class:`~django.db.models.ForeignKey` 类一样，你也可以创建 :ref:`自关联关"
"系 <recursive-relationships>` （一个对象与他本身有着多对多的关系）和 :ref:`与"
"未定义的模型的关系 <lazy-relationships>` 。"

msgid ""
"It's suggested, but not required, that the name of a :class:`~django.db."
"models.ManyToManyField` (``toppings`` in the example above) be a plural "
"describing the set of related model objects."
msgstr ""
"建议设置 :class:`~django.db.models.ManyToManyField` 字段名（上例中的 "
"``toppings`` ）为一个复数名词，表示所要关联的模型对象的集合。"

msgid ""
"It doesn't matter which model has the :class:`~django.db.models."
"ManyToManyField`, but you should only put it in one of the models -- not "
"both."
msgstr ""
"对于多对多关联关系的两个模型，可以在任何一个模型中添加 :class:`~django.db."
"models.ManyToManyField` 字段，但只能选择一个模型设置该字段，即不能同时在两模"
"型中添加该字段。"

msgid ""
"Generally, :class:`~django.db.models.ManyToManyField` instances should go in "
"the object that's going to be edited on a form. In the above example, "
"``toppings`` is in ``Pizza`` (rather than ``Topping`` having a ``pizzas`` :"
"class:`~django.db.models.ManyToManyField` ) because it's more natural to "
"think about a pizza having toppings than a topping being on multiple pizzas. "
"The way it's set up above, the ``Pizza`` form would let users select the "
"toppings."
msgstr ""
"一般来讲，应该把 :class:`~django.db.models.ManyToManyField` 实例放到需要在表"
"单中被编辑的对象中。在之前的例子中， ``toppings`` 被放在 ``Pizza`` 当中（而不"
"是 ``Topping`` 中有指向 ``pizzas`` 的 :class:`~django.db.models."
"ManyToManyField` 实例 ）因为相较于配料被放在不同的披萨当中，披萨当中有很多种"
"配料更加符合常理。按照先前说的，在编辑 ``Pizza`` 的表单时用户可以选择多种配"
"料。"

msgid ""
"See the :doc:`Many-to-many relationship model example </topics/db/examples/"
"many_to_many>` for a full example."
msgstr ""
"如要查看完整示例代码，详见 :doc:`模型多对多关联实例 </topics/db/examples/"
"many_to_many>`。"

msgid ""
":class:`~django.db.models.ManyToManyField` fields also accept a number of "
"extra arguments which are explained in :ref:`the model field reference "
"<manytomany-arguments>`. These options help define how the relationship "
"should work; all are optional."
msgstr ""
":class:`~django.db.models.ManyToManyField` 字段也接受一些 :ref:`模型字段参考 "
"<manytomany-arguments>` 中介绍的参数。这些可选的参数可以更深入地规定关联关系"
"的具体实现。"

msgid "Extra fields on many-to-many relationships"
msgstr "在多对多(many-to-many)关系中添加添加额外的属性字段"

msgid ""
"When you're only dealing with many-to-many relationships such as mixing and "
"matching pizzas and toppings, a standard :class:`~django.db.models."
"ManyToManyField` is all you need. However, sometimes you may need to "
"associate data with the relationship between two models."
msgstr ""
"如果你只是想要一个类似于记录披萨和配料之间混合和搭配的多对多关系，标准的 :"
"class:`~django.db.models.ManyToManyField` 就足够你用了。但是，有时你可能需要"
"将数据与两个模型之间的关系相关联。"

msgid ""
"For example, consider the case of an application tracking the musical groups "
"which musicians belong to. There is a many-to-many relationship between a "
"person and the groups of which they are a member, so you could use a :class:"
"`~django.db.models.ManyToManyField` to represent this relationship. However, "
"there is a lot of detail about the membership that you might want to "
"collect, such as the date at which the person joined the group."
msgstr ""
"举例来讲，考虑一个需要跟踪音乐人属于哪个音乐组的应用程序。在人和他们所在的组"
"之间有一个多对多关系，你可以使用 :class:`~django.db.models.ManyToManyField` "
"来代表这个关系。然而，你想要记录更多的信息在这样的关联关系当中，比如你想要记"
"录某人是何时加入一个组的。"

msgid ""
"For these situations, Django allows you to specify the model that will be "
"used to govern the many-to-many relationship. You can then put extra fields "
"on the intermediate model. The intermediate model is associated with the :"
"class:`~django.db.models.ManyToManyField` using the :attr:`through "
"<ManyToManyField.through>` argument to point to the model that will act as "
"an intermediary. For our musician example, the code would look something "
"like this::"
msgstr ""
"对于这些情况，Django 允许你指定用于控制多对多关系的模型。你可以在中间模型当中"
"添加额外的字段。在实例化 :class:`~django.db.models.ManyToManyField` 的时候使"
"用 :attr:`through <ManyToManyField.through>` 参数指定多对多关系使用哪个中间模"
"型。对于我们举的音乐家的例子，代码如下："

msgid ""
"When you set up the intermediary model, you explicitly specify foreign keys "
"to the models that are involved in the many-to-many relationship. This "
"explicit declaration defines how the two models are related."
msgstr ""
"你需要在设置中间模型的时候，显式地为多对多关系中涉及的中间模型指定外键。这种"
"显式声明定义了这两个模型之间是如何关联的。"

msgid "There are a few restrictions on the intermediate model:"
msgstr "在中间模型当中有一些限制条件："

msgid ""
"Your intermediate model must contain one - and *only* one - foreign key to "
"the source model (this would be ``Group`` in our example), or you must "
"explicitly specify the foreign keys Django should use for the relationship "
"using :attr:`ManyToManyField.through_fields <ManyToManyField."
"through_fields>`. If you have more than one foreign key and "
"``through_fields`` is not specified, a validation error will be raised. A "
"similar restriction applies to the foreign key to the target model (this "
"would be ``Person`` in our example)."
msgstr ""
"你的中间模型要么有且 *仅* 有一个指向源模型（我们例子当中的 ``Group`` ）的外"
"键，要么你必须通过 :attr:`ManyToManyField.through_fields <ManyToManyField."
"through_fields>` 参数在多个外键当中手动选择一个外键，如果有多个外健且没有用 "
"``through_fields`` 参数选择一个的话，会出现验证错误。对于指向目标模型（我们例"
"子当中的 ``Person`` ）的外键也有同样的限制。"

msgid ""
"For a model which has a many-to-many relationship to itself through an "
"intermediary model, two foreign keys to the same model are permitted, but "
"they will be treated as the two (different) sides of the many-to-many "
"relationship. If there are *more* than two foreign keys though, you must "
"also specify ``through_fields`` as above, or a validation error will be "
"raised."
msgstr ""
"在一个用于描述模型当中自己指向自己的多对多关系的中间模型当中，可以有两个指向"
"同一个模型的外健，但这两个外健分表代表多对多关系（不同）的两端。如果外健的个"
"数 *超过* 两个，你必须和上面一样指定 ``through_fields`` 参数，要不然会出现验"
"证错误。"

msgid ""
"Now that you have set up your :class:`~django.db.models.ManyToManyField` to "
"use your intermediary model (``Membership``, in this case), you're ready to "
"start creating some many-to-many relationships. You do this by creating "
"instances of the intermediate model::"
msgstr ""
"现在你已经通过中间模型完成你的 :class:`~django.db.models.ManyToManyField` "
"（例子中的 ``Membership`` ），可以开始创建一些多对多关系了。你通过实例化中间"
"模型来创建关系："

msgid ""
"You can also use :meth:`~django.db.models.fields.related.RelatedManager."
"add`, :meth:`~django.db.models.fields.related.RelatedManager.create`, or :"
"meth:`~django.db.models.fields.related.RelatedManager.set` to create "
"relationships, as long as you specify ``through_defaults`` for any required "
"fields::"
msgstr ""
"你也可以使用 :meth:`~django.db.models.fields.related.RelatedManager.add`, :"
"meth:`~django.db.models.fields.related.RelatedManager.create`, 或者 :meth:"
"`~django.db.models.fields.related.RelatedManager.set` 创建关系，只要你为任何"
"必需的字段指定 ``through_defaults``"

msgid "You may prefer to create instances of the intermediate model directly."
msgstr "你可能更倾向直接创建中间模型。"

msgid ""
"If the custom through table defined by the intermediate model does not "
"enforce uniqueness on the ``(model1, model2)`` pair, allowing multiple "
"values, the :meth:`~django.db.models.fields.related.RelatedManager.remove` "
"call will remove all intermediate model instances::"
msgstr ""
"如果自定义中间模型没有强制 ``(model1, model2)`` 对的唯一性，调用 :meth:"
"`~django.db.models.fields.related.RelatedManager.remove` 方法会删除所有中间模"
"型的实例："

msgid ""
"The :meth:`~django.db.models.fields.related.RelatedManager.clear` method can "
"be used to remove all many-to-many relationships for an instance::"
msgstr ""
"方法 :meth:`~django.db.models.fields.related.RelatedManager.clear` 用于实例的"
"所有多对多关系："

msgid ""
"Once you have established the many-to-many relationships, you can issue "
"queries. Just as with normal many-to-many relationships, you can query using "
"the attributes of the many-to-many-related model::"
msgstr ""
"一旦你建立了自定义多对多关联关系，就可以执行查询操作。和一般的多对多关联关系"
"一样，你可以使用多对多关联模型的属性来查询："

msgid ""
"As you are using an intermediate model, you can also query on its "
"attributes::"
msgstr "当你使用中间模型的时候，你也可以查询他的属性："

msgid ""
"If you need to access a membership's information you may do so by directly "
"querying the ``Membership`` model::"
msgstr "如果你想访问一个关系的信息时你可以直接查询 ``Membership`` 模型："

msgid ""
"Another way to access the same information is by querying the :ref:`many-to-"
"many reverse relationship<m2m-reverse-relationships>` from a ``Person`` "
"object::"
msgstr ""
"另一种访问同样信息的方法是通过 ``Person`` 对象来查询 :ref:`多对多递归关联关系"
"<m2m-reverse-relationships>` ："

msgid ""
"To define a one-to-one relationship, use :class:`~django.db.models."
"OneToOneField`. You use it just like any other ``Field`` type: by including "
"it as a class attribute of your model."
msgstr ""
"使用 :class:`~django.db.models.OneToOneField` 来定义一对一关系。就像使用其他"
"类型的 ``Field`` 一样：在模型属性中包含它。"

msgid ""
"This is most useful on the primary key of an object when that object "
"\"extends\" another object in some way."
msgstr "当一个对象以某种方式“继承”另一个对象时，这对该对象的主键非常有用。"

msgid ""
":class:`~django.db.models.OneToOneField` requires a positional argument: the "
"class to which the model is related."
msgstr ""
":class:`~django.db.models.OneToOneField` 需要一个位置参数：与模型相关的类。"

msgid ""
"For example, if you were building a database of \"places\", you would build "
"pretty standard stuff such as address, phone number, etc. in the database. "
"Then, if you wanted to build a database of restaurants on top of the places, "
"instead of repeating yourself and replicating those fields in the "
"``Restaurant`` model, you could make ``Restaurant`` have a :class:`~django."
"db.models.OneToOneField` to ``Place`` (because a restaurant \"is a\" place; "
"in fact, to handle this you'd typically use :ref:`inheritance <model-"
"inheritance>`, which involves an implicit one-to-one relation)."
msgstr ""
"例如，当你要建立一个有关“位置”信息的数据库时，你可能会包含通常的地址，电话等"
"字段。接着，如果你想接着建立一个关于关于餐厅的数据库，除了将位置数据库当中的"
"字段复制到 ``Restaurant`` 模型，你也可以将一个指向 ``Place`` :class:`~django."
"db.models.OneToOneField` 放到 ``Restaurant`` 当中（因为餐厅“是一个”地点）；事"
"实上，在处理这样的情况时最好使用 :ref:`模型继承<model-inheritance>` ，它隐含"
"的包括了一个一对一关系。"

msgid ""
"As with :class:`~django.db.models.ForeignKey`, a :ref:`recursive "
"relationship <recursive-relationships>` can be defined and :ref:`references "
"to as-yet undefined models <lazy-relationships>` can be made."
msgstr ""
"和  :class:`~django.db.models.ForeignKey` 一样，可以创建 :ref:`自关联关系 "
"<recursive-relationships>` 也可以创建 :ref:`与尚未定义的模型的关系 <lazy-"
"relationships>` 。"

msgid ""
"See the :doc:`One-to-one relationship model example </topics/db/examples/"
"one_to_one>` for a full example."
msgstr ""
"点击文档 :doc:`一对一关联模型实例 </topics/db/examples/one_to_one>` 来查看完"
"整的例子。"

msgid ""
":class:`~django.db.models.OneToOneField` fields also accept an optional :"
"attr:`~django.db.models.OneToOneField.parent_link` argument."
msgstr ""
":class:`~django.db.models.OneToOneField` 字段还接受一个可选的 :attr:`~django."
"db.models.OneToOneField.parent_link` 参数。"

msgid ""
":class:`~django.db.models.OneToOneField` classes used to automatically "
"become the primary key on a model. This is no longer true (although you can "
"manually pass in the :attr:`~django.db.models.Field.primary_key` argument if "
"you like). Thus, it's now possible to have multiple fields of type :class:"
"`~django.db.models.OneToOneField` on a single model."
msgstr ""
":class:`~django.db.models.OneToOneField` 类通常自动的成为模型的主键，这条规则"
"现在不再使用了（然而你可以手动指定 :attr:`~django.db.models.Field."
"primary_key` 参数）。因此，现在可以在单个模型当中指定多个 :class:`~django.db."
"models.OneToOneField` 字段。"

msgid "Models across files"
msgstr "跨文件模型"

msgid ""
"It's perfectly OK to relate a model to one from another app. To do this, "
"import the related model at the top of the file where your model is defined. "
"Then, refer to the other model class wherever needed. For example::"
msgstr ""
"关联另一个应用中的模型是当然可以的。为了实现这一点，在定义模型的文件开头导入"
"需要被关联的模型。接着就可以在其他有需要的模型类当中关联它了。比如："

msgid "Field name restrictions"
msgstr "字段命名限制"

msgid "Django places some restrictions on model field names:"
msgstr "Django 对模型的字段名有一些限制："

msgid ""
"A field name cannot be a Python reserved word, because that would result in "
"a Python syntax error. For example::"
msgstr ""
"一个字段的名称不能是 Python 保留字，因为这会导致 Python 语法错误。比如："

msgid ""
"A field name cannot contain more than one underscore in a row, due to the "
"way Django's query lookup syntax works. For example::"
msgstr ""
"一个字段名称不能包含连续的多个下划线，原因在于 Django 查询语法的工作方式。比"
"如："

msgid "A field name cannot end with an underscore, for similar reasons."
msgstr "字段名不能以下划线结尾，原因同上。"

msgid ""
"These limitations can be worked around, though, because your field name "
"doesn't necessarily have to match your database column name. See the :attr:"
"`~Field.db_column` option."
msgstr ""
"但是，这些限制是可以被解决的，因为字段名没要求和数据库列名一样。查看 :attr:"
"`~Field.db_column` 选项。"

msgid ""
"SQL reserved words, such as ``join``, ``where`` or ``select``, *are* allowed "
"as model field names, because Django escapes all database table names and "
"column names in every underlying SQL query. It uses the quoting syntax of "
"your particular database engine."
msgstr ""
"SQL保留字，例如 ``join``， ``where`` 或 ``select``， *是* 可以被用在模型字段"
"名当中的，因为 Django 在对底层的 SQL 查询当中清洗了所有的数据库表名和字段名，"
"通过使用特定数据库引擎的引用语法。"

msgid "Custom field types"
msgstr "自定义的字段类型"

msgid ""
"If one of the existing model fields cannot be used to fit your purposes, or "
"if you wish to take advantage of some less common database column types, you "
"can create your own field class. Full coverage of creating your own fields "
"is provided in :doc:`/howto/custom-model-fields`."
msgstr ""
"如果已经存在的模型字段不能满足你的需求，或者你希望支持一些不太常见的数据库列"
"类型，你可以创建自己的字段类。在 :doc:`/howto/custom-model-fields` 中提供了创"
"建自定义字段的各方面内容。"

msgid "``Meta`` options"
msgstr "``Meta`` 选项"

msgid "Give your model metadata by using an inner ``class Meta``, like so::"
msgstr "使用内部 ``Meta类`` 来给模型赋予元数据，就像："

msgid ""
"Model metadata is \"anything that's not a field\", such as ordering options "
"(:attr:`~Options.ordering`), database table name (:attr:`~Options."
"db_table`), or human-readable singular and plural names (:attr:`~Options."
"verbose_name` and :attr:`~Options.verbose_name_plural`). None are required, "
"and adding ``class Meta`` to a model is completely optional."
msgstr ""
"模型的元数据即“所有不是字段的东西”，比如排序选项（ :attr:`~Options."
"ordering` ），数据库表名（ :attr:`~Options.db_table` ），或是阅读友好的单复数"
"名（ :attr:`~Options.verbose_name` 和 :attr:`~Options."
"verbose_name_plural` ）。这些都不是必须的，并且在模型当中添加 ``Meta类`` 也完"
"全是可选的。"

msgid ""
"A complete list of all possible ``Meta`` options can be found in the :doc:"
"`model option reference </ref/models/options>`."
msgstr ""
"在 :doc:`模型可选参数参考 </ref/models/options>` 中列出了 ``Meta`` 可使用的全"
"部选项。"

msgid "Model attributes"
msgstr "模型属性"

msgid "``objects``"
msgstr "``objects``"

msgid ""
"The most important attribute of a model is the :class:`~django.db.models."
"Manager`. It's the interface through which database query operations are "
"provided to Django models and is used to :ref:`retrieve the instances "
"<retrieving-objects>` from the database. If no custom ``Manager`` is "
"defined, the default name is :attr:`~django.db.models.Model.objects`. "
"Managers are only accessible via model classes, not the model instances."
msgstr ""
"模型当中最重要的属性是 :class:`~django.db.models.Manager`。它是 Django 模型和"
"数据库查询操作之间的接口，并且它被用作从数据库当中 :ref:`获取实例 "
"<retrieving-objects>`，如果没有指定自定义的 ``Manager`` 默认名称是 :attr:"
"`~django.db.models.Model.objects`。Manager 只能通过模型类来访问，不能通过模型"
"实例来访问。"

msgid "Model methods"
msgstr "模型方法"

msgid ""
"Define custom methods on a model to add custom \"row-level\" functionality "
"to your objects. Whereas :class:`~django.db.models.Manager` methods are "
"intended to do \"table-wide\" things, model methods should act on a "
"particular model instance."
msgstr ""
"在模型中添加自定义方法会给你的对象提供自定义的“行级”操作能力。与之对应的是"
"类 :class:`~django.db.models.Manager` 的方法意在提供“表级”的操作，模型方法应"
"该在某个对象实例上生效。"

msgid ""
"This is a valuable technique for keeping business logic in one place -- the "
"model."
msgstr "这是一个将相关逻辑代码放在一个地方的技巧——模型。"

msgid "For example, this model has a few custom methods::"
msgstr "比如，该模型有一些自定义方法："

msgid "The last method in this example is a :term:`property`."
msgstr "例子中最后一个方法是 :term:`property`。"

msgid ""
"The :doc:`model instance reference </ref/models/instances>` has a complete "
"list of :ref:`methods automatically given to each model <model-instance-"
"methods>`. You can override most of these -- see `overriding predefined "
"model methods`_, below -- but there are a couple that you'll almost always "
"want to define:"
msgstr ""
"文档 :doc:`模型实例参考 </ref/models/instances>` 包含了 :ref:`自动提供给每个"
"模型的方法 <model-instance-methods>` 的完整列表。你可以复写大部分的方法，参考"
"下面的 `overriding predefined model methods`_ ——下面介绍两个你最可能期望复写"
"的："

msgid ":meth:`~Model.__str__`"
msgstr ":meth:`~Model.__str__`"

msgid ""
"A Python \"magic method\" that returns a string representation of any "
"object. This is what Python and Django will use whenever a model instance "
"needs to be coerced and displayed as a plain string. Most notably, this "
"happens when you display an object in an interactive console or in the admin."
msgstr ""
"一个 Python 的“魔法方法”，返回值友好地展示了一个对象。Python 和 Django 在要将"
"模型实例展示为纯文本时调用。最有可能的应用场景是交互式控制台或后台。"

msgid ""
"You'll always want to define this method; the default isn't very helpful at "
"all."
msgstr "你将会经常定义此方法；默认提供的不是很好用。"

msgid ":meth:`~Model.get_absolute_url`"
msgstr ":meth:`~Model.get_absolute_url`"

msgid ""
"This tells Django how to calculate the URL for an object. Django uses this "
"in its admin interface, and any time it needs to figure out a URL for an "
"object."
msgstr ""
"该方法告诉 Django 如何计算一个对象的 URL。Django 在后台接口使用此方法，或任意"
"时间它需要计算一个对象的 URL。"

msgid ""
"Any object that has a URL that uniquely identifies it should define this "
"method."
msgstr "任何需要一个唯一 URL 的对象需要定义此方法。"

msgid "Overriding predefined model methods"
msgstr "重写之前定义的模型方法"

msgid ""
"There's another set of :ref:`model methods <model-instance-methods>` that "
"encapsulate a bunch of database behavior that you'll want to customize. In "
"particular you'll often want to change the way :meth:`~Model.save` and :meth:"
"`~Model.delete` work."
msgstr ""
"还有一个 :ref:`模型方法 <model-instance-methods>` 的集合，包含了一些你可能自"
"定义的数据库行为。尤其是这两个你最有可能定制的方法 :meth:`~Model.save` 和 :"
"meth:`~Model.delete`。"

msgid ""
"You're free to override these methods (and any other model method) to alter "
"behavior."
msgstr "你可以随意地重写这些方法（或其它模型方法）来更改方法的行为。"

msgid ""
"A classic use-case for overriding the built-in methods is if you want "
"something to happen whenever you save an object. For example (see :meth:"
"`~Model.save` for documentation of the parameters it accepts)::"
msgstr ""
"一个典型的重写内置方法的场景是你想在保存对象时额外做些事。比如（查看文档 :"
"meth:`~Model.save` 了解其接受的参数）::"

msgid "You can also prevent saving::"
msgstr "你也可以阻止保存::"

msgid ""
"It's important to remember to call the superclass method -- that's that "
"``super().save(*args, **kwargs)`` business -- to ensure that the object "
"still gets saved into the database. If you forget to call the superclass "
"method, the default behavior won't happen and the database won't get touched."
msgstr ""
"调用父类的方法非常重要——这里指 ``super().save(*args, **kwargs)`` ——确保对象正"
"确的写入数据库。若你忘记调用父类方法，默认行为不会被触发，数据库也不会被操"
"作。"

msgid ""
"It's also important that you pass through the arguments that can be passed "
"to the model method -- that's what the ``*args, **kwargs`` bit does. Django "
"will, from time to time, extend the capabilities of built-in model methods, "
"adding new arguments. If you use ``*args, **kwargs`` in your method "
"definitions, you are guaranteed that your code will automatically support "
"those arguments when they are added."
msgstr ""
"同时传递模型方法接受的参数也很重要—— ``*args, **kwargs`` 会接受这些参数。"
"Django 会不时地扩展模型内置方法的功能，也会添加新参数。如果你在重写的方法中使"
"用了 ``*args, **kwargs``，这将确保你的方法能接受这些新加的参数。"

msgid "Overridden model methods are not called on bulk operations"
msgstr "重写的模型方法不会在批量操作中调用"

msgid ""
"Note that the :meth:`~Model.delete()` method for an object is not "
"necessarily called when :ref:`deleting objects in bulk using a QuerySet "
"<topics-db-queries-delete>` or as a result of a :attr:`cascading delete "
"<django.db.models.ForeignKey.on_delete>`. To ensure customized delete logic "
"gets executed, you can use :data:`~django.db.models.signals.pre_delete` and/"
"or :data:`~django.db.models.signals.post_delete` signals."
msgstr ""
"注意，删除一个模型对象不总是要调用 :meth:`~Model.delete()` 方法。例如， ref:`"
"使用 QuerySet 批量删除对象 <topics-db-queries-delete>` 和 :attr:`级联删除 "
"<django.db.models.ForeignKey.on_delete>`。为了确保自定义的删除逻辑被执行，你"
"可以使用 :data:`~django.db.models.signals.pre_delete` 和 :data:`~django.db."
"models.signals.post_delete` 信号。"

msgid ""
"Unfortunately, there isn't a workaround when :meth:`creating<django.db."
"models.query.QuerySet.bulk_create>` or :meth:`updating<django.db.models."
"query.QuerySet.update>` objects in bulk, since none of :meth:`~Model."
"save()`, :data:`~django.db.models.signals.pre_save`, and :data:`~django.db."
"models.signals.post_save` are called."
msgstr ""
"不幸的是，批量 :meth:`creating<django.db.models.query.QuerySet.bulk_create>` "
"和 :meth:`updating<django.db.models.query.QuerySet.update>` 操作不支持上述操"
"作，因为这两种操作未调用 :meth:`~Model.save()`，:data:`~django.db.models."
"signals.pre_save` 和 :data:`~django.db.models.signals.post_save`。"

msgid "Executing custom SQL"
msgstr "执行自定义 SQL"

msgid ""
"Another common pattern is writing custom SQL statements in model methods and "
"module-level methods. For more details on using raw SQL, see the "
"documentation on :doc:`using raw SQL</topics/db/sql>`."
msgstr ""
"另一个常见的模式是在模型方法和模块方法中编写自定义 SQL 语句。更多关于使用原"
"生 SQL的细节，参见文档 :doc:`使用原生 SQL </topics/db/sql>`。"

msgid "Model inheritance"
msgstr "模型继承"

msgid ""
"Model inheritance in Django works almost identically to the way normal class "
"inheritance works in Python, but the basics at the beginning of the page "
"should still be followed. That means the base class should subclass :class:"
"`django.db.models.Model`."
msgstr ""
"模型继承在 Django 中与普通类继承在 Python 中的工作方式几乎完全相同，但也仍应"
"遵循本页开头的内容。这意味着其基类应该继承自 :class:`django.db.models."
"Model`。"

msgid ""
"The only decision you have to make is whether you want the parent models to "
"be models in their own right (with their own database tables), or if the "
"parents are just holders of common information that will only be visible "
"through the child models."
msgstr ""
"你只需要决定父类模型是否需要拥有它们的权利（拥有它们的数据表），或者父类仅作"
"为承载仅子类中可见的公共信息的载体。"

msgid "There are three styles of inheritance that are possible in Django."
msgstr "Django 有三种可用的集成风格。"

msgid ""
"Often, you will just want to use the parent class to hold information that "
"you don't want to have to type out for each child model. This class isn't "
"going to ever be used in isolation, so :ref:`abstract-base-classes` are what "
"you're after."
msgstr ""
"常见情况下，你仅将父类用于子类公共信息的载体，因为你不会想在每个子类中把这些"
"代码都敲一遍。这样的父类永远都不会单独使用，所以 :ref:`abstract-base-"
"classes` 是你需要的。"

msgid ""
"If you're subclassing an existing model (perhaps something from another "
"application entirely) and want each model to have its own database table, :"
"ref:`multi-table-inheritance` is the way to go."
msgstr ""
"若你继承了一个模型（可能来源其它应用），且想要每个模型都有对应的数据表，客官"
"这边请 :ref:`multi-table-inheritance`。"

msgid ""
"Finally, if you only want to modify the Python-level behavior of a model, "
"without changing the models fields in any way, you can use :ref:`proxy-"
"models`."
msgstr ""
"最后，若你只想修改模型的 Python 级行为，而不是以任何形式修改模型字段， :ref:"
"`proxy-models` 会是你的菜。"

msgid "Abstract base classes"
msgstr "抽象基类"

msgid ""
"Abstract base classes are useful when you want to put some common "
"information into a number of other models. You write your base class and put "
"``abstract=True`` in the :ref:`Meta <meta-options>` class. This model will "
"then not be used to create any database table. Instead, when it is used as a "
"base class for other models, its fields will be added to those of the child "
"class."
msgstr ""
"抽象基类在你要将公共信息放入很多模型时会很有用。编写你的基类，并在 :ref:"
"`Meta <meta-options>` 类中填入 ``abstract=True``。该模型将不会创建任何数据"
"表。当其用作其它模型类的基类时，它的字段会自动添加至子类。"

msgid "An example::"
msgstr "一个例子："

msgid ""
"The ``Student`` model will have three fields: ``name``, ``age`` and "
"``home_group``. The ``CommonInfo`` model cannot be used as a normal Django "
"model, since it is an abstract base class. It does not generate a database "
"table or have a manager, and cannot be instantiated or saved directly."
msgstr ""
"``Student`` 模型拥有3个字段： ``name``， ``age`` 和 ``home_group``。 "
"``CommonInfo`` 模型不能用作普通的 Django 模型，因为它是一个抽象基类。它不会生"
"成数据表，也没有管理器，也不能被实例化和保存。"

msgid ""
"Fields inherited from abstract base classes can be overridden with another "
"field or value, or be removed with ``None``."
msgstr "从抽象基类继承来的字段可被其它字段或值重写，或用 ``None`` 删除。"

msgid ""
"For many uses, this type of model inheritance will be exactly what you want. "
"It provides a way to factor out common information at the Python level, "
"while still only creating one database table per child model at the database "
"level."
msgstr ""
"对很多用户来说，这种继承可能就是你想要的。它提供了一种在 Python 级抽出公共信"
"息的方法，但仍会在子类模型中创建数据表。"

msgid "``Meta`` inheritance"
msgstr "``Meta`` 继承"

msgid ""
"When an abstract base class is created, Django makes any :ref:`Meta <meta-"
"options>` inner class you declared in the base class available as an "
"attribute. If a child class does not declare its own :ref:`Meta <meta-"
"options>` class, it will inherit the parent's :ref:`Meta <meta-options>`. If "
"the child wants to extend the parent's :ref:`Meta <meta-options>` class, it "
"can subclass it. For example::"
msgstr ""
"当一个抽象基类被建立，Django 将所有你在基类中申明的 :ref:`Meta <meta-"
"options>` 内部类以属性的形式提供。若子类未定义自己的 :ref:`Meta <meta-"
"options>` 类，它会继承父类的 :ref:`Meta <meta-options>`。当然，子类也可继承父"
"类的 :ref:`Meta <meta-options>`，比如::"

msgid ""
"Django does make one adjustment to the :ref:`Meta <meta-options>` class of "
"an abstract base class: before installing the :ref:`Meta <meta-options>` "
"attribute, it sets ``abstract=False``. This means that children of abstract "
"base classes don't automatically become abstract classes themselves. To make "
"an abstract base class that inherits from another abstract base class, you "
"need to explicitly set ``abstract=True`` on the child."
msgstr ""
"Django 在安装 :ref:`Meta <meta-options>` 属性前，对抽象基类的 :ref:`Meta "
"<meta-options>` 做了一个调整——设置 ``abstract=False``。这意味着抽象基类的子类"
"不会自动地变成抽象类。为了继承一个抽象基类创建另一个抽象基类，你需要在子类上"
"显式地设置 ``abstract=True``。"

msgid ""
"Some attributes won't make sense to include in the :ref:`Meta <meta-"
"options>` class of an abstract base class. For example, including "
"``db_table`` would mean that all the child classes (the ones that don't "
"specify their own :ref:`Meta <meta-options>`) would use the same database "
"table, which is almost certainly not what you want."
msgstr ""
"抽象基类的某些 :ref:`Meta <meta-options>` 属性对子类是没用的。比如，包含 "
"``db_table`` 意味着所有的子类（你并未在子类中指定它们的 :ref:`Meta <meta-"
"options>`）会使用同一张数据表，这肯定不是你想要的。"

msgid ""
"Due to the way Python inheritance works, if a child class inherits from "
"multiple abstract base classes, only the :ref:`Meta <meta-options>` options "
"from the first listed class will be inherited by default. To inherit :ref:"
"`Meta <meta-options>` options from multiple abstract base classes, you must "
"explicitly declare the :ref:`Meta <meta-options>` inheritance. For example::"
msgstr ""
"由于Python继承的工作方式，如果子类从多个抽象基类继承，则默认情况下仅继承第一"
"个列出的类的 :ref:`Meta <meta-options>` 选项。为了从多个抽象类中继承 :ref:"
"`Meta <meta-options>` 选项，必须显式地声明 :ref:`Meta <meta-options>` 继承。"
"例如："

msgid "Be careful with ``related_name`` and ``related_query_name``"
msgstr "对  ``related_name`` 和 ``related_query_name`` 要格外小心"

msgid ""
"If you are using :attr:`~django.db.models.ForeignKey.related_name` or :attr:"
"`~django.db.models.ForeignKey.related_query_name` on a ``ForeignKey`` or "
"``ManyToManyField``, you must always specify a *unique* reverse name and "
"query name for the field. This would normally cause a problem in abstract "
"base classes, since the fields on this class are included into each of the "
"child classes, with exactly the same values for the attributes (including :"
"attr:`~django.db.models.ForeignKey.related_name` and :attr:`~django.db."
"models.ForeignKey.related_query_name`) each time."
msgstr ""
"若你在 ``外键`` 或 ``多对多字段`` 使用了 :attr:`~django.db.models.ForeignKey."
"related_name` 或 :attr:`~django.db.models.ForeignKey.related_query_name`，你"
"必须为该字段提供一个 *独一无二* 的反向名字和查询名字。这在抽象基类中一般会引"
"发问题，因为基类中的字段都被子类继承，且保持了同样的值（包括 :attr:`~django."
"db.models.ForeignKey.related_name` 和 :attr:`~django.db.models.ForeignKey."
"related_query_name`）。"

msgid ""
"To work around this problem, when you are using :attr:`~django.db.models."
"ForeignKey.related_name` or :attr:`~django.db.models.ForeignKey."
"related_query_name` in an abstract base class (only), part of the value "
"should contain ``'%(app_label)s'`` and ``'%(class)s'``."
msgstr ""
"为了解决此问题，当你在抽象基类中（也只能是在抽象基类中）使用 :attr:`~django."
"db.models.ForeignKey.related_name` 和 :attr:`~django.db.models.ForeignKey."
"related_query_name`，部分值需要包含 ``'%(app_label)s'`` 和 ``'%(class)s'``。"

msgid ""
"``'%(class)s'`` is replaced by the lowercased name of the child class that "
"the field is used in."
msgstr "``'%(class)s'`` 用使用了该字段的子类的小写类名替换。"

msgid ""
"``'%(app_label)s'`` is replaced by the lowercased name of the app the child "
"class is contained within. Each installed application name must be unique "
"and the model class names within each app must also be unique, therefore the "
"resulting name will end up being different."
msgstr ""
"``'%(app_label)s'`` 用小写的包含子类的应用名替换。每个安装的应用名必须是唯一"
"的，应用内的每个模型类名也必须是唯一的。因此，替换后的名字也是唯一的。"

msgid "For example, given an app ``common/models.py``::"
msgstr "举个例子，有个应用 ``common/models.py``::"

msgid "Along with another app ``rare/models.py``::"
msgstr "附带另一个应用 ``rare/models.py``::"

msgid ""
"The reverse name of the ``common.ChildA.m2m`` field will be "
"``common_childa_related`` and the reverse query name will be "
"``common_childas``. The reverse name of the ``common.ChildB.m2m`` field will "
"be ``common_childb_related`` and the reverse query name will be "
"``common_childbs``. Finally, the reverse name of the ``rare.ChildB.m2m`` "
"field will be ``rare_childb_related`` and the reverse query name will be "
"``rare_childbs``. It's up to you how you use the ``'%(class)s'`` and "
"``'%(app_label)s'`` portion to construct your related name or related query "
"name but if you forget to use it, Django will raise errors when you perform "
"system checks (or run :djadmin:`migrate`)."
msgstr ""
"``common.ChildA.m2m`` 字段的反转名是 ``common_childa_related``，反转查询名是 "
"``common_childas``。 ``common.ChildB.m2m`` 字段的反转名是 "
"``common_childb_related``， 反转查询名是 ``common_childbs``。 ``rare.ChildB."
"m2m`` 字段的反转名是 ``rare_childb_related``，反转查询名是 ``rare_childbs``。"
"这决定于你如何使用 ``'%(class)s'`` 和 ``'%(app_label)s'`` 构建关联名字和关联"
"查询名。但是，若你忘了使用它们，Django 会在你执行系统检查（或运行 :djadmin:"
"`migrate`）时抛出错误。"

msgid ""
"If you don't specify a :attr:`~django.db.models.ForeignKey.related_name` "
"attribute for a field in an abstract base class, the default reverse name "
"will be the name of the child class followed by ``'_set'``, just as it "
"normally would be if you'd declared the field directly on the child class. "
"For example, in the above code, if the :attr:`~django.db.models.ForeignKey."
"related_name` attribute was omitted, the reverse name for the ``m2m`` field "
"would be ``childa_set`` in the ``ChildA`` case and ``childb_set`` for the "
"``ChildB`` field."
msgstr ""
"如果你未指定抽象基类中的 :attr:`~django.db.models.ForeignKey.related_name` 属"
"性，默认的反转名会是子类名，后接 ``'_set'`` 。这名字看起来就像你在子类中定义"
"的一样。比如，在上述代码中，若省略了 :attr:`~django.db.models.ForeignKey."
"related_name` 属性，  ``ChildA`` 的 ``m2m`` 字段的反转名会是 "
"``childa_set`` ， ``ChildB`` 的是 ``childb_set``。"

msgid "Multi-table inheritance"
msgstr "多表继承"

msgid ""
"The second type of model inheritance supported by Django is when each model "
"in the hierarchy is a model all by itself. Each model corresponds to its own "
"database table and can be queried and created individually. The inheritance "
"relationship introduces links between the child model and each of its "
"parents (via an automatically-created :class:`~django.db.models."
"OneToOneField`). For example::"
msgstr ""
"Django 支持的第二种模型继承方式是层次结构中的每个模型都是一个单独的模型。每个"
"模型都指向分离的数据表，且可被独立查询和创建。继承关系介绍了子类和父类之间的"
"连接（通过一个自动创建的 :class:`~django.db.models.OneToOneField` ）。比如::"

msgid ""
"All of the fields of ``Place`` will also be available in ``Restaurant``, "
"although the data will reside in a different database table. So these are "
"both possible::"
msgstr ""
"``Place`` 的所有字段均在 ``Restaurant`` 中可用，虽然数据分别存在不同的表中。"
"所有，以下操作均可::"

msgid ""
"If you have a ``Place`` that is also a ``Restaurant``, you can get from the "
"``Place`` object to the ``Restaurant`` object by using the lowercase version "
"of the model name::"
msgstr ""
"若有一个 ``Place`` 同时也是 ``Restaurant``，你可以通过小写的模型名将 "
"``Place`` 对象转为 ``Restaurant`` 对象。"

msgid ""
"However, if ``p`` in the above example was *not* a ``Restaurant`` (it had "
"been created directly as a ``Place`` object or was the parent of some other "
"class), referring to ``p.restaurant`` would raise a ``Restaurant."
"DoesNotExist`` exception."
msgstr ""
"然而，若上述例子中的 ``p`` *不是* 一个 ``Restaurant`` （它仅是个 ``Place`` 对"
"象或是其它类的父类），指向 ``p.restaurant`` 会抛出一个 ``Restaurant."
"DoesNotExist`` 异常。"

msgid ""
"The automatically-created :class:`~django.db.models.OneToOneField` on "
"``Restaurant`` that links it to ``Place`` looks like this::"
msgstr ""
"``Restaurant`` 中自动创建的连接至 ``Place`` 的 :class:`~django.db.models."
"OneToOneField` 看起来像这样::"

msgid ""
"You can override that field by declaring your own :class:`~django.db.models."
"OneToOneField` with :attr:`parent_link=True <django.db.models.OneToOneField."
"parent_link>` on ``Restaurant``."
msgstr ""
"你可以在 ``Restaurant`` 中重写该字段，通过申明你自己的 :class:`~django.db."
"models.OneToOneField`，并设置 :attr:`parent_link=True <django.db.models."
"OneToOneField.parent_link>`。"

msgid "``Meta`` and multi-table inheritance"
msgstr "``Meta`` 和多表继承"

msgid ""
"In the multi-table inheritance situation, it doesn't make sense for a child "
"class to inherit from its parent's :ref:`Meta <meta-options>` class. All "
"the :ref:`Meta <meta-options>` options have already been applied to the "
"parent class and applying them again would normally only lead to "
"contradictory behavior (this is in contrast with the abstract base class "
"case, where the base class doesn't exist in its own right)."
msgstr ""
"多表继承情况下，子类不会继承父类的 :ref:`Meta <meta-options>`。所以的 :ref:"
"`Meta <meta-options>` 类选项已被应用至父类，在子类中再次应用会导致行为冲突"
"（与抽象基类中应用场景对比，这种情况下，基类并不存在）。"

msgid ""
"So a child model does not have access to its parent's :ref:`Meta <meta-"
"options>` class. However, there are a few limited cases where the child "
"inherits behavior from the parent: if the child does not specify an :attr:"
"`~django.db.models.Options.ordering` attribute or a :attr:`~django.db.models."
"Options.get_latest_by` attribute, it will inherit these from its parent."
msgstr ""
"故，子类模型无法访问父类的 :ref:`Meta <meta-options>` 类。不过，有限的几种情"
"况下：若子类未指定 :attr:`~django.db.models.Options.ordering` 属性或 :attr:"
"`~django.db.models.Options.get_latest_by` 属性，子类会从父类继承这些。"

msgid ""
"If the parent has an ordering and you don't want the child to have any "
"natural ordering, you can explicitly disable it::"
msgstr "如果父类有排序，而你并不期望子类有排序，你可以显示的禁止它::"

msgid "Inheritance and reverse relations"
msgstr "继承与反向关系"

msgid ""
"Because multi-table inheritance uses an implicit :class:`~django.db.models."
"OneToOneField` to link the child and the parent, it's possible to move from "
"the parent down to the child, as in the above example. However, this uses up "
"the name that is the default :attr:`~django.db.models.ForeignKey."
"related_name` value for :class:`~django.db.models.ForeignKey` and :class:"
"`~django.db.models.ManyToManyField` relations.  If you are putting those "
"types of relations on a subclass of the parent model, you **must** specify "
"the :attr:`~django.db.models.ForeignKey.related_name` attribute on each such "
"field. If you forget, Django will raise a validation error."
msgstr ""
"由于多表继承使用隐式的 :class:`~django.db.models.OneToOneField` 连接子类和父"
"类，所以直接从父类访问子类是可能的，就像上述例子展示的那样。然而，使用的名字"
"是 :class:`~django.db.models.ForeignKey` 和 :class:`~django.db.models."
"ManyToManyField` 关系的默认值。如果你在继承父类模型的子类中添加了这些关联，"
"你 **必须** 指定 :attr:`~django.db.models.ForeignKey.related_name` 属性。假如"
"你忘了，Django 会抛出一个合法性错误。"

msgid ""
"For example, using the above ``Place`` class again, let's create another "
"subclass with a :class:`~django.db.models.ManyToManyField`::"
msgstr ""
"比如，让我们用上面的 ``Place`` 类创建另一个子类，包含一个 :class:`~django.db."
"models.ManyToManyField`::"

msgid "This results in the error::"
msgstr "这会导致以下错误::"

msgid ""
"Adding ``related_name`` to the ``customers`` field as follows would resolve "
"the error: ``models.ManyToManyField(Place, related_name='provider')``."
msgstr ""
"将 ``related_name`` 像下面这样加至 ``customers`` 字段能解决此错误： ``models."
"ManyToManyField(Place, related_name='provider')``。"

msgid "Specifying the parent link field"
msgstr "指定父类连接字段"

msgid ""
"As mentioned, Django will automatically create a :class:`~django.db.models."
"OneToOneField` linking your child class back to any non-abstract parent "
"models. If you want to control the name of the attribute linking back to the "
"parent, you can create your own :class:`~django.db.models.OneToOneField` and "
"set :attr:`parent_link=True <django.db.models.OneToOneField.parent_link>` to "
"indicate that your field is the link back to the parent class."
msgstr ""
"如上所述，Django 会自动创建一个 :class:`~django.db.models.OneToOneField` ，将"
"子类连接回非抽象的父类。如果你想修改连接回父类的属性名，你可以自己创建 :"
"class:`~django.db.models.OneToOneField`，并设置 :attr:`parent_link=True "
"<django.db.models.OneToOneField.parent_link>`，表明该属性用于连接回父类。"

msgid ""
"When using :ref:`multi-table inheritance <multi-table-inheritance>`, a new "
"database table is created for each subclass of a model. This is usually the "
"desired behavior, since the subclass needs a place to store any additional "
"data fields that are not present on the base class. Sometimes, however, you "
"only want to change the Python behavior of a model -- perhaps to change the "
"default manager, or add a new method."
msgstr ""
"使用 :ref:`多表继承 <multi-table-inheritance>` 时，每个子类模型都会创建一张新"
"表。这一般是期望的行为，因为子类需要一个地方存储基类中不存在的额外数据字段。"
"不过，有时候你只想修改模型的 Python 级行为——可能是修改默认管理器，或添加一个"
"方法。"

msgid ""
"This is what proxy model inheritance is for: creating a *proxy* for the "
"original model. You can create, delete and update instances of the proxy "
"model and all the data will be saved as if you were using the original (non-"
"proxied) model. The difference is that you can change things like the "
"default model ordering or the default manager in the proxy, without having "
"to alter the original."
msgstr ""
"这是代理模型继承的目的：为原模型创建一个 *代理*。你可以创建，删除和更新代理模"
"型的实例，所以的数据都会存储的像你使用原模型（未代理的）一样。不同点是你可以"
"修改代理默认的模型排序和默认管理器，而不需要修改原模型。"

msgid ""
"Proxy models are declared like normal models. You tell Django that it's a "
"proxy model by setting the :attr:`~django.db.models.Options.proxy` attribute "
"of the ``Meta`` class to ``True``."
msgstr ""
"代理模型就像普通模型一样申明。你需要告诉 Django 这是一个代理模型，通过将 "
"``Meta`` 类的 :attr:`~django.db.models.Options.proxy` 属性设置为 ``True``。"

msgid ""
"For example, suppose you want to add a method to the ``Person`` model. You "
"can do it like this::"
msgstr "例如，假设你想为 ``Person`` 模型添加一个方法。你可以这么做::"

msgid ""
"The ``MyPerson`` class operates on the same database table as its parent "
"``Person`` class. In particular, any new instances of ``Person`` will also "
"be accessible through ``MyPerson``, and vice-versa::"
msgstr ""
"``MyPerson`` 类与父类 ``Person`` 操作同一张数据表。特别提醒， ``Person`` 的实"
"例能通过 ``MyPerson`` 访问，反之亦然。"

msgid ""
"You could also use a proxy model to define a different default ordering on a "
"model. You might not always want to order the ``Person`` model, but "
"regularly order by the ``last_name`` attribute when you use the proxy::"
msgstr ""
"你也可以用代理模型定义模型的另一种不同的默认排序方法。你也许不期望总对 "
"“Persion” 进行排序，但是在使用代理时，总是依据 “last_name” 属性进行排序："

msgid ""
"Now normal ``Person`` queries will be unordered and ``OrderedPerson`` "
"queries will be ordered by ``last_name``."
msgstr ""
"现在，普通的 ``Person`` 查询结果不会被排序，但 ``OrderdPerson`` 查询接轨会按 "
"``last_name`` 排序。"

msgid ""
"Proxy models inherit ``Meta`` attributes :ref:`in the same way as regular "
"models <meta-and-multi-table-inheritance>`."
msgstr ""
"代理模型继承“Meta”属性 :ref:`和普通模型一样 <meta-and-multi-table-"
"inheritance>`。"

msgid "``QuerySet``\\s still return the model that was requested"
msgstr "``QuerySet`` 仍会返回请求的模型"

msgid ""
"There is no way to have Django return, say, a ``MyPerson`` object whenever "
"you query for ``Person`` objects. A queryset for ``Person`` objects will "
"return those types of objects. The whole point of proxy objects is that code "
"relying on the original ``Person`` will use those and your own code can use "
"the extensions you included (that no other code is relying on anyway). It is "
"not a way to replace the ``Person`` (or any other) model everywhere with "
"something of your own creation."
msgstr ""
"当你用 ``Person`` 对象查询时，Django 永远不会返回 ``MyPerson`` 对象。"
"``Person`` 对象的查询结果集总是返回对应类型。代理对象存在的全部意义是帮你复用"
"原 ``Person`` 提供的代码和自定义的功能代码（并未依赖其它代码）。不存在什么方"
"法能在你创建完代理后，帮你替换所有 ``Person`` （或其它）模型。"

msgid "Base class restrictions"
msgstr "基类约束"

msgid ""
"A proxy model must inherit from exactly one non-abstract model class. You "
"can't inherit from multiple non-abstract models as the proxy model doesn't "
"provide any connection between the rows in the different database tables. A "
"proxy model can inherit from any number of abstract model classes, providing "
"they do *not* define any model fields. A proxy model may also inherit from "
"any number of proxy models that share a common non-abstract parent class."
msgstr ""
"一个代理模型必须继承自一个非抽象模型类。你不能继承多个非抽象模型类，因为代理"
"模型无法在不同数据表之间提供任何行间连接。一个代理模型可以继承任意数量的抽象"
"模型类，假如他们 *没有* 定义任何的模型字段。一个代理模型也可以继承任意数量的"
"代理模型，只需他们共享同一个非抽象父类。"

msgid "Proxy model managers"
msgstr "代理模型管理器"

msgid ""
"If you don't specify any model managers on a proxy model, it inherits the "
"managers from its model parents. If you define a manager on the proxy model, "
"it will become the default, although any managers defined on the parent "
"classes will still be available."
msgstr ""
"若你未在代理模型中指定模型管理器，它会从父类模型中继承。如果你在代理模型中指"
"定了管理器，它会成为默认管理器，但父类中定义的管理器仍是可用的。"

msgid ""
"Continuing our example from above, you could change the default manager used "
"when you query the ``Person`` model like this::"
msgstr ""
"随着上面的例子一路走下来，你可以在查询 ``Person`` 模型时这样修改默认管理器::"

msgid ""
"If you wanted to add a new manager to the Proxy, without replacing the "
"existing default, you can use the techniques described in the :ref:`custom "
"manager <custom-managers-and-inheritance>` documentation: create a base "
"class containing the new managers and inherit that after the primary base "
"class::"
msgstr ""
"若你在不替换已存在的默认管理器的情况下，为代理添加新管理器，你可以使用文档 :"
"ref:`自定义管理器 <custom-managers-and-inheritance>` 中介绍的技巧：创建一个包"
"含新管理器的基类，在继承列表中，主类后追加这个基类::"

msgid ""
"You probably won't need to do this very often, but, when you do, it's "
"possible."
msgstr "通常情况下，你可能不需要这么做。然而，你需要的时候，这也是可以的。"

msgid "Differences between proxy inheritance and unmanaged models"
msgstr "代理继承和未托管的模型间的区别"

msgid ""
"Proxy model inheritance might look fairly similar to creating an unmanaged "
"model, using the :attr:`~django.db.models.Options.managed` attribute on a "
"model's ``Meta`` class."
msgstr ""
"代理模型继承可能看起来和创建未托管的模型很类似，通过在模型的 ``Meta`` 类中定"
"义 :attr:`~django.db.models.Options.managed` 属性。"

msgid ""
"With careful setting of :attr:`Meta.db_table <django.db.models.Options."
"db_table>` you could create an unmanaged model that shadows an existing "
"model and adds Python methods to it. However, that would be very repetitive "
"and fragile as you need to keep both copies synchronized if you make any "
"changes."
msgstr ""
"通过小心地配置 :attr:`Meta.db_table <django.db.models.Options.db_table>`，你"
"将创建一个未托管的模型，该模型将对现有模型进行阴影处理，并添加一些 Python 方"
"法。然而，这会是个经常重复的且容易出错的过程，因为你要在做任何修改时保持两个"
"副本的同步。"

msgid ""
"On the other hand, proxy models are intended to behave exactly like the "
"model they are proxying for. They are always in sync with the parent model "
"since they directly inherit its fields and managers."
msgstr ""
"另一方面，代理模型意在表现的和所代理的模型一样。它们总是与父模型保持一致，因"
"为它们直接从福利继承字段和管理器。"

msgid "The general rules are:"
msgstr "通用性规则："

msgid ""
"If you are mirroring an existing model or database table and don't want all "
"the original database table columns, use ``Meta.managed=False``. That option "
"is normally useful for modeling database views and tables not under the "
"control of Django."
msgstr ""
"当你克隆一个已存在模型或数据表时，并且不想要所以的原数据表列，配置 ``Meta."
"managed=False``。这个选项在模型化未受 Django 控制的数据库视图和表格时很有用。"

msgid ""
"If you are wanting to change the Python-only behavior of a model, but keep "
"all the same fields as in the original, use ``Meta.proxy=True``. This sets "
"things up so that the proxy model is an exact copy of the storage structure "
"of the original model when data is saved."
msgstr ""
"如果你只想修改模型的 Python 行为，并保留原有字段，配置 ``Meta.proxy=True``。"
"这个配置使得代理模型在保存数据时，确保数据结构和原模型的完全一样。"

msgid "Multiple inheritance"
msgstr "多重继承"

msgid ""
"Just as with Python's subclassing, it's possible for a Django model to "
"inherit from multiple parent models. Keep in mind that normal Python name "
"resolution rules apply. The first base class that a particular name (e.g. :"
"ref:`Meta <meta-options>`) appears in will be the one that is used; for "
"example, this means that if multiple parents contain a :ref:`Meta <meta-"
"options>` class, only the first one is going to be used, and all others will "
"be ignored."
msgstr ""
"和 Python 中的继承一样，Django 模型也能继承自多个父类模型。请记住，Python 的"
"命名规则这里也有效。第一个出现的基类（比如 :ref:`Meta <meta-options>` ）就是"
"会被使用的那个；举个例子，如果存在多个父类包含 :ref:`Meta <meta-options>`，只"
"有第一个会被使用，其它的都会被忽略。"

msgid ""
"Generally, you won't need to inherit from multiple parents. The main use-"
"case where this is useful is for \"mix-in\" classes: adding a particular "
"extra field or method to every class that inherits the mix-in. Try to keep "
"your inheritance hierarchies as simple and straightforward as possible so "
"that you won't have to struggle to work out where a particular piece of "
"information is coming from."
msgstr ""
"一般来说，你并不会同时继承多个父类。常见的应用场景是 “混合” 类：为每个继承此"
"类的添加额外的字段或方法。试着保持你的继承层级尽可能的简单和直接，这样未来你"
"就不用为了确认某段信息是哪来的而拔你为数不多的头发了。"

msgid ""
"Note that inheriting from multiple models that have a common ``id`` primary "
"key field will raise an error. To properly use multiple inheritance, you can "
"use an explicit :class:`~django.db.models.AutoField` in the base models::"
msgstr ""
"注意，继承自多个包含 ``id`` 主键的字段会抛出错误。正确的使用多继承，你可以在"
"基类中显示使用 :class:`~django.db.models.AutoField`::"

msgid ""
"Or use a common ancestor to hold the :class:`~django.db.models.AutoField`. "
"This requires using an explicit :class:`~django.db.models.OneToOneField` "
"from each parent model to the common ancestor to avoid a clash between the "
"fields that are automatically generated and inherited by the child::"
msgstr ""
"或者在公共祖先中存储 :class:`~django.db.models.AutoField`。这会要求为每个父类"
"模型和公共祖先使用显式的 :class:`~django.db.models.OneToOneField` ，避免与子"
"类自动生成或继承的字段发生冲突::"

msgid "Field name \"hiding\" is not permitted"
msgstr "字段名 “隐藏” 是不允许的"

msgid ""
"In normal Python class inheritance, it is permissible for a child class to "
"override any attribute from the parent class. In Django, this isn't usually "
"permitted for model fields. If a non-abstract model base class has a field "
"called ``author``, you can't create another model field or define an "
"attribute called ``author`` in any class that inherits from that base class."
msgstr ""
"在正常的 Python 类继承中，允许子类覆盖父类的任何属性。在 Django 中，模型字段"
"通常不允许这样做。如果一个非抽象模型基类有一个名为 ``author`` 的字段，你就不"
"能在继承自该基类的任何类中，创建另一个名为 ``author`` 的模型字段或属性。"

msgid ""
"This restriction doesn't apply to model fields inherited from an abstract "
"model. Such fields may be overridden with another field or value, or be "
"removed by setting ``field_name = None``."
msgstr ""
"这个限制并不适用于从抽象模型继承的模型字段。这些字段可以用另一个字段或值覆"
"盖，或者通过设置 ``field_name = None`` 来删除。"

msgid ""
"Model managers are inherited from abstract base classes. Overriding an "
"inherited field which is referenced by an inherited :class:`~django.db."
"models.Manager` may cause subtle bugs. See :ref:`custom managers and model "
"inheritance <custom-managers-and-inheritance>`."
msgstr ""
"模型管理器是从抽象基类中继承的。重写一个被继承的 :class:`~django.db.models."
"Manager` 所引用的继承字段，可能会导致微妙的错误。参见 :ref:`自定义管理器和模"
"型继承 <custom-managers-and-inheritance>`。"

msgid ""
"Some fields define extra attributes on the model, e.g. a :class:`~django.db."
"models.ForeignKey` defines an extra attribute with ``_id`` appended to the "
"field name, as well as ``related_name`` and ``related_query_name`` on the "
"foreign model."
msgstr ""
"某些字段在模型内定义了额外的属性，例如 :class:`~django.db.models.ForeignKey` "
"定义了一个额外的属性 ``_id`` 附加在字段名上，类似的还有外键上的 "
"``related_name`` 和 ``related_query_name``。"

msgid ""
"These extra attributes cannot be overridden unless the field that defines it "
"is changed or removed so that it no longer defines the extra attribute."
msgstr ""
"这些额外的属性不能被覆盖，除非定义它的字段被改变或删除，使它不再定义额外的属"
"性。"

msgid ""
"Overriding fields in a parent model leads to difficulties in areas such as "
"initializing new instances (specifying which field is being initialized in "
"``Model.__init__``) and serialization. These are features which normal "
"Python class inheritance doesn't have to deal with in quite the same way, so "
"the difference between Django model inheritance and Python class inheritance "
"isn't arbitrary."
msgstr ""
"重写父模型中的字段会导致一些困难，比如初始化新实例（在 ``Model.__init__`` 中"
"指定哪个字段被初始化）和序列化。这些都是普通的 Python 类继承所不需要处理的功"
"能，所以 Django 模型继承和 Python 类继承之间的区别并不是任意的。"

msgid ""
"This restriction only applies to attributes which are :class:`~django.db."
"models.Field` instances. Normal Python attributes can be overridden if you "
"wish. It also only applies to the name of the attribute as Python sees it: "
"if you are manually specifying the database column name, you can have the "
"same column name appearing in both a child and an ancestor model for multi-"
"table inheritance (they are columns in two different database tables)."
msgstr ""
"这些限制只针对那些是 :class:`~django.db.models.Field` 实例的属性。普通的 "
"Python 属性可被随便重写。它还对 Python 能识别的属性生效：如果你同时在子类和多"
"表继承的祖先类中指定了数据表的列名（它们是两张不同的数据表中的列）。"

msgid ""
"Django will raise a :exc:`~django.core.exceptions.FieldError` if you "
"override any model field in any ancestor model."
msgstr ""
"若你在祖先模型中重写了任何模型字段，Django 会抛出一个 :exc:`~django.core."
"exceptions.FieldError`。"

msgid ""
"Note that because of the way fields are resolved during class definition, "
"model fields inherited from multiple abstract parent models are resolved in "
"a strict depth-first order. This contrasts with standard Python MRO, which "
"is resolved breadth-first in cases of diamond shaped inheritance. This "
"difference only affects complex model hierarchies, which (as per the advice "
"above) you should try to avoid."
msgstr ""

msgid "Organizing models in a package"
msgstr "在一个包中管理模型"

msgid ""
"The :djadmin:`manage.py startapp <startapp>` command creates an application "
"structure that includes a ``models.py`` file. If you have many models, "
"organizing them in separate files may be useful."
msgstr ""
":djadmin:`manage.py startapp <startapp>` 命令创建了一个应用结构，包含一个 "
"``models.py`` 文件。若你有很多  ``models.py``  文件，用独立的文件管理它们会很"
"实用。"

msgid ""
"To do so, create a ``models`` package. Remove ``models.py`` and create a "
"``myapp/models/`` directory with an ``__init__.py`` file and the files to "
"store your models. You must import the models in the ``__init__.py`` file."
msgstr ""
"为了达到此目的，创建一个 ``models`` 包。删除 ``models.py``，创建一个 ``myapp/"
"models`` 目录，包含一个 ``__init__.py`` 文件和存储模型的文件。你必须在 "
"``__init__.py`` 文件中导入这些模块。"

msgid ""
"For example, if you had ``organic.py`` and ``synthetic.py`` in the "
"``models`` directory:"
msgstr "比如，若你在 ``models`` 目录下有 ``organic.py`` 和 ``synthetic.py``："

msgid "myapp/models/__init__.py"
msgstr "myapp/models/__init__.py"

msgid ""
"Explicitly importing each model rather than using ``from .models import *`` "
"has the advantages of not cluttering the namespace, making code more "
"readable, and keeping code analysis tools useful."
msgstr ""
"显式导入每个模块，而不是使用 ``from .models import *`` 有助于不打乱命名空间，"
"使代码更具可读性，让代码分析工具更有用。"

msgid ":doc:`The Models Reference </ref/models/index>`"
msgstr ":doc:`模型参考 </ref/models/index>`"

msgid ""
"Covers all the model related APIs including model fields, related objects, "
"and ``QuerySet``."
msgstr "覆盖所有的模型关联 API，包括模型字段，关联对象和 ``QuerySet``。"

msgid ""
"This topic guide describes Django's support for interacting with multiple "
"databases. Most of the rest of Django's documentation assumes you are "
"interacting with a single database. If you want to interact with multiple "
"databases, you'll need to take some additional steps."
msgstr ""
"这个主题指南描述了 Django 对多数据库交互的支持。大部分的 Django 文档假设你进"
"行的是单数据库交互。如果你想多数据库交互，则需要执行一些其他步骤。"

msgid ""
"See :ref:`testing-multi-db` for information about testing with multiple "
"databases."
msgstr "查看 :ref:`testing-multi-db` 获取关于多数据库测试的信息。"

msgid "Defining your databases"
msgstr "定义数据库"

msgid ""
"The first step to using more than one database with Django is to tell Django "
"about the database servers you'll be using. This is done using the :setting:"
"`DATABASES` setting. This setting maps database aliases, which are a way to "
"refer to a specific database throughout Django, to a dictionary of settings "
"for that specific connection. The settings in the inner dictionaries are "
"described fully in the :setting:`DATABASES` documentation."
msgstr ""
"首先告知 Django，你正在使用至少2个数据库服务。通过 :setting:`DATABASES` 配置"
"来将指定的数据库链接放入一个字典，以此来映射数据库别名，数据库别名是在整个"
"Django中引用特定数据库的一种方式。"

msgid ""
"Databases can have any alias you choose. However, the alias ``default`` has "
"special significance. Django uses the database with the alias of ``default`` "
"when no other database has been selected."
msgstr ""
"可以选择任意的数据库别名，但是``default`` 别名具有特殊意义。当没有数据库指定"
"选择的时候，Django 使用带有  ``default`` 别名的数据库。"

msgid ""
"The following is an example ``settings.py`` snippet defining two databases "
"-- a default PostgreSQL database and a MySQL database called ``users``::"
msgstr ""
"接下来一个 ``settings.py`` 片段，定义了2个数据库——默认的 PostgreSQL 数据库和"
"名叫 ``users`` 的 MySQL 数据库。"

msgid ""
"If the concept of a ``default`` database doesn't make sense in the context "
"of your project, you need to be careful to always specify the database that "
"you want to use. Django requires that a ``default`` database entry be "
"defined, but the parameters dictionary can be left blank if it will not be "
"used. To do this, you must set up :setting:`DATABASE_ROUTERS` for all of "
"your apps' models, including those in any contrib and third-party apps "
"you're using, so that no queries are routed to the default database. The "
"following is an example ``settings.py`` snippet defining two non-default "
"databases, with the ``default`` entry intentionally left empty::"
msgstr ""
"如果 ``default`` 数据库的设计在项目中没有使用，那么你需要特别注意始终指定你所"
"使用的数据库。Django 需要定义  ``default`` 数据库，但如果没有使用数据库的话，"
"参数字典可以置空。这样，你必须为所有的模型，包括你所使用的任何 contrib 和第三"
"方 app 设置 :setting:`DATABASE_ROUTERS`，所以不会有任何查询路由到默认数据库。"
"下面示例来讲在默认数据库为空的情况下，如何定义两个非默认数据库："

msgid ""
"If you attempt to access a database that you haven't defined in your :"
"setting:`DATABASES` setting, Django will raise a ``django.utils.connection."
"ConnectionDoesNotExist`` exception."
msgstr ""

msgid "Synchronizing your databases"
msgstr "同步数据库"

msgid ""
"The :djadmin:`migrate` management command operates on one database at a "
"time. By default, it operates on the ``default`` database, but by providing "
"the :option:`--database <migrate --database>` option, you can tell it to "
"synchronize a different database. So, to synchronize all models onto all "
"databases in the first example above, you would need to call::"
msgstr ""
":djadmin:`migrate` 管理命令一次只在一个数据库上进行操作。默认情况下，它在 "
"``default`` 数据库上操作，但提供  :option:`--database <migrate --database>` "
"的话，它可以同步到不同数据库。因此，如果想在上面例子中的所有数据库上同步所有"
"模型，你可以这样调用："

msgid ""
"If you don't want every application to be synchronized onto a particular "
"database, you can define a :ref:`database router<topics-db-multi-db-"
"routing>` that implements a policy constraining the availability of "
"particular models."
msgstr ""
"如果不想每个应用同步到特定数据库，可以定义 :ref:`database router<topics-db-"
"multi-db-routing>` ，它实施限制特定模型可用性的策略。"

msgid ""
"If, as in the second example above, you've left the ``default`` database "
"empty, you must provide a database name each time you run :djadmin:"
"`migrate`. Omitting the database name would raise an error. For the second "
"example::"
msgstr ""
"如上述第二个例子，如果 ``default`` 数据库为空，每次执行 :djadmin:`migrate` 的"
"时候，必须提供数据库名，否则会报错。"

msgid "Using other management commands"
msgstr "使用其他管理命令"

msgid ""
"Most other ``django-admin`` commands that interact with the database operate "
"in the same way as :djadmin:`migrate` -- they only ever operate on one "
"database at a time, using ``--database`` to control the database used."
msgstr ""
"大部分 ``django-admin`` 命令像 :djadmin:`migrate` 一样操作数据库——它们一次只"
"操作一个数据库，使用  ``--database``  来控制所要使用的数据库。"

msgid ""
"An exception to this rule is the :djadmin:`makemigrations` command. It "
"validates the migration history in the databases to catch problems with the "
"existing migration files (which could be caused by editing them) before "
"creating new migrations. By default, it checks only the ``default`` "
"database, but it consults the :meth:`allow_migrate` method of :ref:`routers "
"<topics-db-multi-db-routing>` if any are installed."
msgstr ""
"这个规则的一个例外是 :djadmin:`makemigrations` 命令。它验证数据库中的迁移历"
"史，以便在创建新迁移之前发现现有迁移文件的问题（这可能是修改它们所产生）。默"
"认情况下，它只检查 ``default`` 数据库，但建议在任何模型安装时，执行 :meth:"
"`allow_migrate` method of :ref:`routers <topics-db-multi-db-routing>` 。"

msgid "Automatic database routing"
msgstr "自动数据库路由"

msgid ""
"The easiest way to use multiple databases is to set up a database routing "
"scheme. The default routing scheme ensures that objects remain 'sticky' to "
"their original database (i.e., an object retrieved from the ``foo`` database "
"will be saved on the same database). The default routing scheme ensures that "
"if a database isn't specified, all queries fall back to the ``default`` "
"database."
msgstr ""
"使用多数据库最简单的方式就是设置数据库路由方案。默认路由方案确保对象对原始数"
"据库保持粘性（比如，从 ``foo`` 数据库检索到的对象将被保持到同一个数据库）。默"
"认路由方案确保当数据库没有指定时，所有查询回退到  ``default`` 数据库。"

msgid ""
"You don't have to do anything to activate the default routing scheme -- it "
"is provided 'out of the box' on every Django project. However, if you want "
"to implement more interesting database allocation behaviors, you can define "
"and install your own database routers."
msgstr ""
"你无需执行任何操作来激活默认路由——在每个 Django 项目上是开箱即用的。然而，如"
"果想实现更多有趣的数据库分配行为，可以定义和安装自己的数据库路由。"

msgid "Database routers"
msgstr "数据库路由"

msgid "A database Router is a class that provides up to four methods:"
msgstr "数据库路由是一个类，它提供四种方法："

msgid ""
"Suggest the database that should be used for read operations for objects of "
"type ``model``."
msgstr "建议用于读取“模型”类型对象的数据库。"

msgid ""
"If a database operation is able to provide any additional information that "
"might assist in selecting a database, it will be provided in the ``hints`` "
"dictionary. Details on valid hints are provided :ref:`below <topics-db-multi-"
"db-hints>`."
msgstr ""
"如果数据库操作可以提供有助于选择数据库的任何附加信息，它将在 ``hints``  中提"
"供。这里 :ref:`below <topics-db-multi-db-hints>` 提供了有效提示的详细信息。"

msgid "Returns ``None`` if there is no suggestion."
msgstr "如果没有建议，则返回 ``None`` 。"

msgid ""
"Suggest the database that should be used for writes of objects of type Model."
msgstr "建议用于写入模型类型对象的数据库。"

msgid ""
"Return ``True`` if a relation between ``obj1`` and ``obj2`` should be "
"allowed, ``False`` if the relation should be prevented, or ``None`` if the "
"router has no opinion. This is purely a validation operation, used by "
"foreign key and many to many operations to determine if a relation should be "
"allowed between two objects."
msgstr ""
"如果允许 ``obj1`` 和 ``obj2`` 之间的关系，返回 ``True`` 。如果阻止关系，返回 "
"``False`` ，或如果路由没意见，则返回 ``None``。这纯粹是一种验证操作，由外键和"
"多对多操作决定是否应该允许关系。"

msgid ""
"If no router has an opinion (i.e. all routers return ``None``), only "
"relations within the same database are allowed."
msgstr ""
"如果没有路由有意见（比如所有路由返回 ``None``），则只允许同一个数据库内的关"
"系。"

msgid ""
"Determine if the migration operation is allowed to run on the database with "
"alias ``db``. Return ``True`` if the operation should run, ``False`` if it "
"shouldn't run, or ``None`` if the router has no opinion."
msgstr ""
"决定是否允许迁移操作在别名为 ``db`` 的数据库上运行。如果操作运行，那么返回 "
"``True`` ，如果没有运行则返回 ``False`` ，或路由没有意见则返回 ``None`` 。"

msgid ""
"The ``app_label`` positional argument is the label of the application being "
"migrated."
msgstr "``app_label`` 参数是要迁移的应用程序的标签。"

msgid ""
"``model_name`` is set by most migration operations to the value of ``model."
"_meta.model_name`` (the lowercased version of the model ``__name__``) of the "
"model being migrated. Its value is ``None`` for the :class:`~django.db."
"migrations.operations.RunPython` and :class:`~django.db.migrations."
"operations.RunSQL` operations unless they provide it using hints."
msgstr ""
"``model_name`` 由大部分迁移操作设置来要迁移的模型的 ``model._meta."
"model_name`` （模型 ``__name__`` 的小写版本） 的值。 对于 :class:`~django.db."
"migrations.operations.RunPython` 和 :class:`~django.db.migrations.operations."
"RunSQL` 操作的值是 ``None`` ，除非它们提示要提供它。"

msgid ""
"``hints`` are used by certain operations to communicate additional "
"information to the router."
msgstr "``hints`` 通过某些操作来向路由传达附加信息。"

msgid ""
"When ``model_name`` is set, ``hints`` normally contains the model class "
"under the key ``'model'``. Note that it may be a :ref:`historical model "
"<historical-models>`, and thus not have any custom attributes, methods, or "
"managers. You should only rely on ``_meta``."
msgstr ""
"当设置 ``model_name`` ，``hints`` 通常包含  ``'model'`` 下的模型类。注意它可"
"能是 :ref:`historical model <historical-models>` ，因此没有任何自定义属性，方"
"法或管理器。你应该只能依赖 ``_meta`` 。"

msgid ""
"This method can also be used to determine the availability of a model on a "
"given database."
msgstr "这个方法也可以用于确定给定数据库上模型的可用性。"

msgid ""
":djadmin:`makemigrations` always creates migrations for model changes, but "
"if ``allow_migrate()`` returns ``False``, any migration operations for the "
"``model_name`` will be silently skipped when running :djadmin:`migrate` on "
"the ``db``. Changing the behavior of ``allow_migrate()`` for models that "
"already have migrations may result in broken foreign keys, extra tables, or "
"missing tables. When :djadmin:`makemigrations` verifies the migration "
"history, it skips databases where no app is allowed to migrate."
msgstr ""
":djadmin:`makemigrations` 会在模型变动时创建迁移，但如果 ``allow_migrate()`` "
"返回 ``False` ，任何针对 ``model_name`` 的迁移操作会在运行 :djadmin:"
"`migrate` 的时候跳过。对于已经迁移过的模型，改变  ``allow_migrate()`` 的行"
"为，可能会破坏主键，格外表或丢失的表。当 :djadmin:`makemigrations` 核实迁移历"
"史，它跳过不允许迁移的 app 的数据库。"

msgid ""
"A router doesn't have to provide *all* these methods -- it may omit one or "
"more of them. If one of the methods is omitted, Django will skip that router "
"when performing the relevant check."
msgstr ""
"路由不是必须提供所有这些方法——它也许省略它们中的一个或多个。如果某个方法被省"
"略，Django会在执行相关检查时候，跳过这个路由。"

msgid "Hints"
msgstr "提示"

msgid ""
"The hints received by the database router can be used to decide which "
"database should receive a given request."
msgstr "通过数据库路由收到的提示可用来决定哪个数据库应该接收给定的请求。"

msgid ""
"At present, the only hint that will be provided is ``instance``, an object "
"instance that is related to the read or write operation that is underway. "
"This might be the instance that is being saved, or it might be an instance "
"that is being added in a many-to-many relation. In some cases, no instance "
"hint will be provided at all. The router checks for the existence of an "
"instance hint, and determine if that hint should be used to alter routing "
"behavior."
msgstr ""
"现在，将要提供的唯一的提示是 ``instance``，这是一个与正在进行读写操作相关的对"
"象实例。这可能是正在保存的实例，或是正在添加多对多关系的实例。在某些情况下，"
"根本不会提供实例提示。路由检查是否存在实例提示，并确定提示是否应该用来改变路"
"由行为。"

msgid "Using routers"
msgstr "使用路由"

msgid ""
"Database routers are installed using the :setting:`DATABASE_ROUTERS` "
"setting. This setting defines a list of class names, each specifying a "
"router that should be used by the master router (``django.db.router``)."
msgstr ""
"数据库路由 :setting:`DATABASE_ROUTERS` 配置安装。这个配置定义类名列表，每个类"
"名指定了主路由(``django.db.router``)应使用的路由。"

msgid ""
"The master router is used by Django's database operations to allocate "
"database usage. Whenever a query needs to know which database to use, it "
"calls the master router, providing a model and a hint (if available). Django "
"then tries each router in turn until a database suggestion can be found. If "
"no suggestion can be found, it tries the current :attr:`instance._state.db "
"<django.db.models.Model._state>` of the hint instance. If a hint instance "
"wasn't provided, or :attr:`instance._state.db <django.db.models.Model."
"_state>` is ``None``, the master router will allocate the ``default`` "
"database."
msgstr ""
"Django 的数据库操作使用主路由来分配数据库使用。每当查询需要知道正在使用哪个数"
"据库时，它会调用主路由，提供一个模型和提示（如果可用的话），然后 Django 会依"
"次尝试每个路由直到找到数据库。如果没有找到，它试着访问提示实例的当前 :attr:"
"`instance._state.db <django.db.models.Model._state>` 。如果没有提供提示实例，"
"或者 :attr:`instance._state.db <django.db.models.Model._state>` 为 "
"``None`` ，主路由将分配默认数据库。"

msgid "An example"
msgstr "一个例子"

msgid "Example purposes only!"
msgstr "仅供参考！"

msgid ""
"This example is intended as a demonstration of how the router infrastructure "
"can be used to alter database usage. It intentionally ignores some complex "
"issues in order to demonstrate how routers are used."
msgstr ""
"这个例子旨在演示如何使用路由基础结构来改变数据库使用情况。它有意忽略一些复杂"
"的问题，为了演示如何使用路由。"

msgid ""
"This example won't work if any of the models in ``myapp`` contain "
"relationships to models outside of the ``other`` database. :ref:`Cross-"
"database relationships <no_cross_database_relations>` introduce referential "
"integrity problems that Django can't currently handle."
msgstr ""
"如果 ``myapp`` 中的任何模型包含与其他数据库之外的模型的关系，那么这个例子将无"
"法运行。:ref:`Cross-database relationships <no_cross_database_relations>` 介"
"绍了 Django 目前无法解决的引用完整性问题。"

msgid ""
"The primary/replica (referred to as master/slave by some databases) "
"configuration described is also flawed -- it doesn't provide any solution "
"for handling replication lag (i.e., query inconsistencies introduced because "
"of the time taken for a write to propagate to the replicas). It also doesn't "
"consider the interaction of transactions with the database utilization "
"strategy."
msgstr ""
"主/副（一些数据库成为主/从）配置描述是有点问题的-它不提供任何处理复制滞后的解"
"决方案（比如，由于写入传播到复制副本需要时间，导致查询不一致）。它也没有考虑"
"事务与数据库利用策略的交互。"

msgid ""
"So - what does this mean in practice? Let's consider another sample "
"configuration. This one will have several databases: one for the ``auth`` "
"application, and all other apps using a primary/replica setup with two read "
"replicas. Here are the settings specifying these databases::"
msgstr ""
"所以-这在实践中意味着什么？我们考虑一下其他简单配置。它有一些数据库：一个 "
"``auth`` 应用，和其他应用使用带有两个只读副本的主/副设置。以下是指定这些数据"
"库的设置："

msgid ""
"Now we'll need to handle routing. First we want a router that knows to send "
"queries for the ``auth`` and ``contenttypes`` apps to ``auth_db`` (``auth`` "
"models are linked to ``ContentType``, so they must be stored in the same "
"database)::"
msgstr ""
"现在需要处理路由。首先需要一个将 ``auth`` 和 ``contenttypes`` app 的查询发送"
"到 ``auth_db`` 的路由(``auth`` 模型已经关联了 ``ContentType``，因此它们必须保"
"存在同一个数据库里)："

msgid ""
"And we also want a router that sends all other apps to the primary/replica "
"configuration, and randomly chooses a replica to read from::"
msgstr ""
"我们也需要一个发送所有其他应用到主/副配置的路由，并且随机选择一个副本来读取："

msgid ""
"Finally, in the settings file, we add the following (substituting ``path.to."
"`` with the actual Python path to the module(s) where the routers are "
"defined)::"
msgstr ""
"最后，在配置文件中，我们添加下面的代码（用定义路由器的模块的实际 Python 路径"
"替换 ``path.to.`` ）："

msgid ""
"The order in which routers are processed is significant. Routers will be "
"queried in the order they are listed in the :setting:`DATABASE_ROUTERS` "
"setting. In this example, the ``AuthRouter`` is processed before the "
"``PrimaryReplicaRouter``, and as a result, decisions concerning the models "
"in ``auth`` are processed before any other decision is made. If the :setting:"
"`DATABASE_ROUTERS` setting listed the two routers in the other order, "
"``PrimaryReplicaRouter.allow_migrate()`` would be processed first. The catch-"
"all nature of the PrimaryReplicaRouter implementation would mean that all "
"models would be available on all databases."
msgstr ""
"处理路由的顺序非常重要。路由将按照 :setting:`DATABASE_ROUTERS` 里设置的顺序查"
"询。在这个例子里， ``AuthRouter`` 将在 ``PrimaryReplicaRouter`` 前处理，因"
"此，在做出其他决定之前，先处理与 ``auth`` 相关的模型。如果 :setting:"
"`DATABASE_ROUTERS` 设置在其他顺序里列出两个路由，``PrimaryReplicaRouter."
"allow_migrate()`` 将首先处理。PrimaryReplicaRouter 实现的特性意味着所有模型可"
"用于所有数据库。"

msgid ""
"With this setup installed, and all databases migrated as per :ref:"
"`synchronizing_multiple_databases`, lets run some Django code::"
msgstr ""
"安装好这个设置，并按照 :ref:`synchronizing_multiple_databases` 的要求迁移所有"
"的数据库，让我们运行一些 Django 代码："

msgid ""
"This example defined a router to handle interaction with models from the "
"``auth`` app, and other routers to handle interaction with all other apps. "
"If you left your ``default`` database empty and don't want to define a catch-"
"all database router to handle all apps not otherwise specified, your routers "
"must handle the names of all apps in :setting:`INSTALLED_APPS` before you "
"migrate. See :ref:`contrib_app_multiple_databases` for information about "
"contrib apps that must be together in one database."
msgstr ""
"这个例子定义了一个路由来处理与来自 ``auth`` 应用的模型交互，其他路由处理与所"
"以其他应用的交互。如果 ``default`` 为空，并且不想定义一个全能数据库来处理所有"
"未指定的应用，那么路由必须在迁移之前处理 :setting:`INSTALLED_APPS` 的所有应用"
"名。查看 :ref:`contrib_app_multiple_databases` 来了解 contrib 应用必须在一个"
"数据库的信息。"

msgid "Manually selecting a database"
msgstr "手动选择数据库"

msgid ""
"Django also provides an API that allows you to maintain complete control "
"over database usage in your code. A manually specified database allocation "
"will take priority over a database allocated by a router."
msgstr ""
"Django也提供允许在代码中完全控制数据库的API。手工指定数据库分配将优先于路由分"
"配的数据库。"

msgid "Manually selecting a database for a ``QuerySet``"
msgstr "手动为查询集选择数据库"

msgid ""
"You can select the database for a ``QuerySet`` at any point in the "
"``QuerySet`` \"chain.\" Call ``using()`` on the ``QuerySet`` to get another "
"``QuerySet`` that uses the specified database."
msgstr ""
"你可以在查询集链的任一点为查询集选择数据库。调用查询集上的 ``using()`` 就可以"
"获取使用指定数据库的其他查询集。"

msgid ""
"``using()`` takes a single argument: the alias of the database on which you "
"want to run the query. For example::"
msgstr "``using()`` 使用单一参数：你打算进行查询的数据库别名。比如："

msgid "Selecting a database for ``save()``"
msgstr "为保存选择数据库"

msgid ""
"Use the ``using`` keyword to ``Model.save()`` to specify to which database "
"the data should be saved."
msgstr "使用 ``using`` 关键字来 ``Model.save()`` 到指定的数据保存的数据库。"

msgid ""
"For example, to save an object to the ``legacy_users`` database, you'd use "
"this::"
msgstr "比如，要保存对象到 ``legacy_users`` 数据库，你应该这样写："

msgid ""
"If you don't specify ``using``, the ``save()`` method will save into the "
"default database allocated by the routers."
msgstr ""
"如果你没有指定 ``using``，``save()`` 方法将保存到路由的默认数据库分配。"

msgid "Moving an object from one database to another"
msgstr "将对象从一个数据库移动到另一个"

msgid ""
"If you've saved an instance to one database, it might be tempting to use "
"``save(using=...)`` as a way to migrate the instance to a new database. "
"However, if you don't take appropriate steps, this could have some "
"unexpected consequences."
msgstr ""
"如果已经保存实例到数据库，它可能使用 ``save(using=...)`` 作为迁移实例到新数据"
"库的方法。然而，如果没有使用适合的步骤，这可能会产生意想不到的结果。"

msgid "Consider the following example::"
msgstr "考虑下面的例子："

msgid ""
"In statement 1, a new ``Person`` object is saved to the ``first`` database. "
"At this time, ``p`` doesn't have a primary key, so Django issues an SQL "
"``INSERT`` statement. This creates a primary key, and Django assigns that "
"primary key to ``p``."
msgstr ""
"在语句1，新的 ``Person`` 对象保存在 ``first`` 数据库。这一次，``p`` 没有主"
"键，因此 Django 发出了一个SQL ``INSERT`` 语句。这会创建主键，并且 Django 分配"
"那个主键到 ``p``。"

msgid ""
"When the save occurs in statement 2, ``p`` already has a primary key value, "
"and Django will attempt to use that primary key on the new database. If the "
"primary key value isn't in use in the ``second`` database, then you won't "
"have any problems -- the object will be copied to the new database."
msgstr ""
"在语句2中进行保存时，``p`` 也有主键值，Django 将试图在新的数据库上使用主键。"
"如果主键值未在 ``second`` 数据库中使用，那么将不会有任何问题——对象将被拷贝到"
"新数据库。"

msgid ""
"However, if the primary key of ``p`` is already in use on the ``second`` "
"database, the existing object in the ``second`` database will be overridden "
"when ``p`` is saved."
msgstr ""
"然而，如果 ``p`` 的主键已经在 ``second`` 数据库上使用，那么当保存 ``p`` 的时"
"候， ``second`` 数据库中存在的对象将被覆盖。"

msgid ""
"You can avoid this in two ways. First, you can clear the primary key of the "
"instance. If an object has no primary key, Django will treat it as a new "
"object, avoiding any loss of data on the ``second`` database::"
msgstr ""
"可以通过两种方式避免这种情况。首先，可以清理实例主键。如果对象没有主键，那么 "
"Django 将它作为新对象来处理，避免在 ``second`` 数据库上造成任何数据丢失："

msgid ""
"The second option is to use the ``force_insert`` option to ``save()`` to "
"ensure that Django does an SQL ``INSERT``::"
msgstr ""
"第二个办法就是使用 ``force_insert`` 选项来 ``save()`` ，确保 Django 执行了 "
"SQL ``INSERT`` ："

msgid ""
"This will ensure that the person named ``Fred`` will have the same primary "
"key on both databases. If that primary key is already in use when you try to "
"save onto the ``second`` database, an error will be raised."
msgstr ""
"这将确保 ``Fred`` 在两个数据库上拥有同一个主键。当试着在 ``second`` 上保存"
"时，如果主键已经保存，那么将会引发一个错误。"

msgid "Selecting a database to delete from"
msgstr "选择要删除的数据库"

msgid ""
"By default, a call to delete an existing object will be executed on the same "
"database that was used to retrieve the object in the first place::"
msgstr ""
"默认情况下，用来删除现有对象的调用将在用于首先检索对象的同一数据库上执行："

msgid ""
"To specify the database from which a model will be deleted, pass a ``using`` "
"keyword argument to the ``Model.delete()`` method. This argument works just "
"like the ``using`` keyword argument to ``save()``."
msgstr ""
"指定将要删除模型的数据库，传递 ``using`` 关键字参数到 ``Model.delete()`` 方"
"法。这个参数的工作方式与用关键字参数 ``save()`` 是一样的。"

msgid ""
"For example, if you're migrating a user from the ``legacy_users`` database "
"to the ``new_users`` database, you might use these commands::"
msgstr ""
"例如，如果你正在从 ``legacy_users`` 迁移用户到 ``new_users`` 数据库，你可以使"
"用这些命令："

msgid "Using managers with multiple databases"
msgstr "使用多个数据库管理器"

msgid ""
"Use the ``db_manager()`` method on managers to give managers access to a non-"
"default database."
msgstr "在管理器上使用 ``db_manager()`` 方法来让管理员访问非默认数据库。"

msgid ""
"For example, say you have a custom manager method that touches the database "
"-- ``User.objects.create_user()``. Because ``create_user()`` is a manager "
"method, not a ``QuerySet`` method, you can't do ``User.objects."
"using('new_users').create_user()``. (The ``create_user()`` method is only "
"available on ``User.objects``, the manager, not on ``QuerySet`` objects "
"derived from the manager.) The solution is to use ``db_manager()``, like "
"this::"
msgstr ""
"比如，假设有一个自定义管理器方法来触发数据库——``User.objects."
"create_user()``。因为 ``create_user()`` 是一个管理器方法，不是 ``QuerySet`` "
"方法，你不能操作 ``User.objects.using('new_users').create_user()`` 。"
"（``create_user()`` 方法只适用 ``User.objects`` ，即管理器，而不是来自管理器"
"上的 ``QuerySet`` 。）解决方案是使用 ``db_manager()`` ，像这样："

msgid ""
"``db_manager()`` returns a copy of the manager bound to the database you "
"specify."
msgstr "``db_manager()`` 返回绑定到指定数据库的管理器副本。"

msgid "Using ``get_queryset()`` with multiple databases"
msgstr "将 ``get_queryset()`` 和多个数据库使用"

msgid ""
"If you're overriding ``get_queryset()`` on your manager, be sure to either "
"call the method on the parent (using ``super()``) or do the appropriate "
"handling of the ``_db`` attribute on the manager (a string containing the "
"name of the database to use)."
msgstr ""
"如果在管理器上覆盖了 ``get_queryset()`` ，请确保在父类上调用这个方法（使用 "
"``super()`` ）或者在管理器（包含使用的数据库的名字）上适当处理 ``_db`` 属性。"

msgid ""
"For example, if you want to return a custom ``QuerySet`` class from the "
"``get_queryset`` method, you could do this::"
msgstr ""
"比如，如果你想从 ``get_queryset`` 方法返回自定义的 ``QuerySet`` 类，你可以这"
"样做："

msgid "Exposing multiple databases in Django's admin interface"
msgstr "在Django管理界面中使用多数据库"

msgid ""
"Django's admin doesn't have any explicit support for multiple databases. If "
"you want to provide an admin interface for a model on a database other than "
"that specified by your router chain, you'll need to write custom :class:"
"`~django.contrib.admin.ModelAdmin` classes that will direct the admin to use "
"a specific database for content."
msgstr ""
"Django的管理后台对多数据库没有明显的支持。如果要为路由指定的数据库以外的数据"
"库提供模型的管理界面，你需要编写自定义的 :class:`~django.contrib.admin."
"ModelAdmin` 类，这个类将指示管理后台使用指定数据库的内容。"

msgid ""
"``ModelAdmin`` objects have five methods that require customization for "
"multiple-database support::"
msgstr "``ModelAdmin`` 对象有五种需要为多数据库支持定制的方法："

msgid ""
"The implementation provided here implements a multi-database strategy where "
"all objects of a given type are stored on a specific database (e.g., all "
"``User`` objects are in the ``other`` database). If your usage of multiple "
"databases is more complex, your ``ModelAdmin`` will need to reflect that "
"strategy."
msgstr ""
"此处提供的实现方法实现了多数据库策略，其中给定类型的所有对象保存在指定数据库"
"上（比如所有 ``User`` 对象在 ``other`` 数据库中）。如果对多数据的使用很复杂，"
"那么``ModelAdmin`` 将需要映射策略。"

msgid ""
":class:`~django.contrib.admin.InlineModelAdmin` objects can be handled in a "
"similar fashion. They require three customized methods::"
msgstr ""
":class:`~django.contrib.admin.InlineModelAdmin` 对象可以以类似的方式处理。它"
"们需要三个自定义的方法："

msgid ""
"Once you've written your model admin definitions, they can be registered "
"with any ``Admin`` instance::"
msgstr "一旦编写了模型管理定义，就可以在任何 ``Admin`` 实例中注册："

msgid ""
"This example sets up two admin sites. On the first site, the ``Author`` and "
"``Publisher`` objects are exposed; ``Publisher`` objects have a tabular "
"inline showing books published by that publisher. The second site exposes "
"just publishers, without the inlines."
msgstr ""
"这个例子设置了两个管理长点。在第一个站点上，``Author`` 和 ``Publisher`` 对象"
"是显式的；``Publisher`` 对象有一个表格行来显示出版者的书籍。第二个站点只显示"
"出版者，不显示内嵌。"

msgid "Using raw cursors with multiple databases"
msgstr "将原始游标用于多个数据库"

msgid ""
"If you are using more than one database you can use ``django.db."
"connections`` to obtain the connection (and cursor) for a specific database. "
"``django.db.connections`` is a dictionary-like object that allows you to "
"retrieve a specific connection using its alias::"
msgstr ""
"如果正在使用不止一个数据库，可以使用 ``django.db.connections`` 来获得链接指定"
"的数据库。``django.db.connections`` 是一个类字典对象，它允许你通过链接别名来"
"获取指定连接："

msgid "Limitations of multiple databases"
msgstr "多数据库的局限性"

msgid "Cross-database relations"
msgstr "跨数据库关系"

msgid ""
"Django doesn't currently provide any support for foreign key or many-to-many "
"relationships spanning multiple databases. If you have used a router to "
"partition models to different databases, any foreign key and many-to-many "
"relationships defined by those models must be internal to a single database."
msgstr ""
"Django 当前不提供对跨多数据库的外键或多对多关系任何支持。如果已经使用路由来分"
"隔模型到不同数据库，那么通过这些模型来定义的任何外键和多对多关系必须在单一数"
"据库内。"

msgid ""
"This is because of referential integrity. In order to maintain a "
"relationship between two objects, Django needs to know that the primary key "
"of the related object is valid. If the primary key is stored on a separate "
"database, it's not possible to easily evaluate the validity of a primary key."
msgstr ""
"这是因为参照完整性。为了维护两个对象之间的关系，Djagno 需要知道这个相关对象的"
"外键是否是合法的。如果外键被保存在单独的数据库上，则无法轻松评价外键的合法"
"性。"

msgid ""
"If you're using Postgres, Oracle, or MySQL with InnoDB, this is enforced at "
"the database integrity level -- database level key constraints prevent the "
"creation of relations that can't be validated."
msgstr ""
"如果你正在使用 Postgres，Oracle，或支持 InnoDB 的 MySQL，这是在数据库完整性级"
"别上强制执行的——数据库级别的键约束防止创建无法验证的关系。"

msgid ""
"However, if you're using SQLite or MySQL with MyISAM tables, there is no "
"enforced referential integrity; as a result, you may be able to 'fake' cross "
"database foreign keys. However, this configuration is not officially "
"supported by Django."
msgstr ""
"然而，如果你正在使用 SQLite 或支持 MyISAM 表的MySQL，这就不会强制参照完整性；"
"因此，你可以伪造跨数据库的外键。尽管 Django 并没有正式支持这个设置。"

msgid "Behavior of contrib apps"
msgstr "contrib应用程序的行为"

msgid ""
"Several contrib apps include models, and some apps depend on others. Since "
"cross-database relationships are impossible, this creates some restrictions "
"on how you can split these models across databases:"
msgstr ""
"一些贡献应用包括模型，一些应用依赖于其他应用。 由于跨数据库关系是不可能的，因"
"此这会对如何跨数据库拆分这些模型产生一些限制："

msgid ""
"each one of ``contenttypes.ContentType``, ``sessions.Session`` and ``sites."
"Site`` can be stored in any database, given a suitable router."
msgstr ""
"在给定合适的路由器的情况下，``contenttypes.ContentType``，``sessions."
"Session``和``sites.Site``中的每一个都可以存储在任何数据库中。"

msgid ""
"``auth`` models — ``User``, ``Group`` and ``Permission`` — are linked "
"together and linked to ``ContentType``, so they must be stored in the same "
"database as ``ContentType``."
msgstr ""
"``auth``模型 - ``User``，``Group``和``Permission`` - 链接在一起并链接到"
"``ContentType``，因此它们必须与``ContentType存储在同一个数据库中``。"

msgid ""
"``admin`` depends on ``auth``, so its models must be in the same database as "
"``auth``."
msgstr "``admin``依赖于``auth``，所以它的模型必须和``auth``在同一个数据库中。"

msgid ""
"``flatpages`` and ``redirects`` depend on ``sites``, so their models must be "
"in the same database as ``sites``."
msgstr ""
"``flatpages``和``redirects``依赖于``sites``，所以他们的模型必须和``sites``在"
"同一个数据库中。"

msgid ""
"In addition, some objects are automatically created just after :djadmin:"
"`migrate` creates a table to hold them in a database:"
msgstr ""
"此外，一些对象在以下之后自动创建：djadmin：`migrate`创建一个表以将它们保存在"
"数据库中："

msgid "a default ``Site``,"
msgstr "默认的``Site``，"

msgid ""
"a ``ContentType`` for each model (including those not stored in that "
"database),"
msgstr "每个模型的``ContentType`` （包括那些未存储在该数据库中的模型），"

msgid ""
"the ``Permission``\\s for each model (including those not stored in that "
"database)."
msgstr "每个模型的``Permission``\\s（包括那些未存储在该数据库中的模型）。"

msgid ""
"For common setups with multiple databases, it isn't useful to have these "
"objects in more than one database. Common setups include primary/replica and "
"connecting to external databases. Therefore, it's recommended to write a :"
"ref:`database router<topics-db-multi-db-routing>` that allows synchronizing "
"these three models to only one database. Use the same approach for contrib "
"and third-party apps that don't need their tables in multiple databases."
msgstr ""
"对于具有多个数据库的常见设置，将这些对象放在多个数据库中是没有用的。 常见设置"
"包括主/副本和连接到外部数据库。 因此，建议编写一个：ref:`database router`，它"
"允许将这三个模型同步到一个数据库。 对于不需要在多个数据库中使用其表的contrib"
"和第三方应用程序，请使用相同的方法。"

msgid ""
"If you're synchronizing content types to more than one database, be aware "
"that their primary keys may not match across databases. This may result in "
"data corruption or data loss."
msgstr ""
"如果要将内容类型同步到多个数据库，请注意它们的主键可能在数据库之间不匹配。这"
"可能导致数据损坏或数据丢失。"

msgid "Database access optimization"
msgstr "数据库访问优化"

msgid ""
"Django's database layer provides various ways to help developers get the "
"most out of their databases. This document gathers together links to the "
"relevant documentation, and adds various tips, organized under a number of "
"headings that outline the steps to take when attempting to optimize your "
"database usage."
msgstr ""
"Django 的数据库层提供了各种方法来帮助开发者最大限度地利用数据库。本文档收集了"
"相关文档的链接，并添加了各种提示，按照一些标题组织，概述了在尝试优化数据库使"
"用时的步骤。"

msgid "Profile first"
msgstr "首先性能分析"

msgid ""
"As general programming practice, this goes without saying. Find out :ref:"
"`what queries you are doing and what they are costing you <faq-see-raw-sql-"
"queries>`. Use :meth:`.QuerySet.explain` to understand how specific "
"``QuerySet``\\s are executed by your database. You may also want to use an "
"external project like django-debug-toolbar_, or a tool that monitors your "
"database directly."
msgstr ""
"作为一般的编程实践，这个不用多说。找出 :ref:`你在做什么查询以及它们花费的代"
"价 <faq-see-raw-sql-queries>`。使用 :meth:`.QuerySet.explain` 来了解你的数据"
"库是如何执行特定的 ``QuerySet`` 的。你可能还想使用一个外部项目，比如 django-"
"debug-toolbar_ ，或者一个直接监控数据库的工具。"

msgid ""
"Remember that you may be optimizing for speed or memory or both, depending "
"on your requirements. Sometimes optimizing for one will be detrimental to "
"the other, but sometimes they will help each other. Also, work that is done "
"by the database process might not have the same cost (to you) as the same "
"amount of work done in your Python process. It is up to you to decide what "
"your priorities are, where the balance must lie, and profile all of these as "
"required since this will depend on your application and server."
msgstr ""
"请记住，你可能会根据你的需求，对速度或内存或两者进行优化。有时为其中之一进行"
"优化会损害另一个，但有时它们会相互帮助。另外，由数据库进程完成的工作可能与在 "
"Python 进程中完成的相同数量的工作的成本并不相同（对你来说）。这取决于你的优先"
"级是什么，平衡点在哪里，并根据需要对所有这些进行性能分析，因为这将取决于你的"
"应用程序和服务器。"

msgid ""
"With everything that follows, remember to profile after every change to "
"ensure that the change is a benefit, and a big enough benefit given the "
"decrease in readability of your code. **All** of the suggestions below come "
"with the caveat that in your circumstances the general principle might not "
"apply, or might even be reversed."
msgstr ""
"对于下面的所有内容，请记住在每次修改后都要进行性能分析，以确保修改有好处，而"
"且是一个足够大的好处，因为你的代码的可读性降低了。**以下所有** 的建议都有一个"
"警告，那就是在你自身情况下，一般的原则可能不适用，甚至可能会被反过来。"

msgid "Use standard DB optimization techniques"
msgstr "使用标准数据库优化技巧"

msgid "...including:"
msgstr "……包括："

msgid ""
"Indexes_. This is a number one priority, *after* you have determined from "
"profiling what indexes should be added. Use :attr:`Meta.indexes <django.db."
"models.Options.indexes>` or :attr:`Field.db_index <django.db.models.Field."
"db_index>` to add these from Django. Consider adding indexes to fields that "
"you frequently query using :meth:`~django.db.models.query.QuerySet."
"filter()`, :meth:`~django.db.models.query.QuerySet.exclude()`, :meth:"
"`~django.db.models.query.QuerySet.order_by()`, etc. as indexes may help to "
"speed up lookups. Note that determining the best indexes is a complex "
"database-dependent topic that will depend on your particular application. "
"The overhead of maintaining an index may outweigh any gains in query speed."
msgstr ""
"Indexes_ 。这是第一优先级，在你从性能分析中确定应该添加哪些索引 *之后*。这是"
"第一优先级的。使用 :attr:`Meta.indexes <django.db.models.Options.indexes>` "
"或 :attr:`Field.db_index <django.db.models.Field.db_index>` 从 Django 添加这"
"些索引。可以考虑使用 :meth:`~django.db.models.querySet.filter()`、:meth:"
"`~django.db.models.querySet.exclude()`、:meth:`~django.db.models.querySet."
"order_by()` 等方式为你经常查询的字段添加索引，因为索引可能有助于加快查询速"
"度。请注意，确定最好的索引是一个复杂的数据库依赖性话题，将取决于你的特定应"
"用。维护索引的开销可能会超过查询速度的任何收益。"

msgid "Appropriate use of field types."
msgstr "合理使用字段类型。"

msgid ""
"We will assume you have done the things listed above. The rest of this "
"document focuses on how to use Django in such a way that you are not doing "
"unnecessary work. This document also does not address other optimization "
"techniques that apply to all expensive operations, such as :doc:`general "
"purpose caching </topics/cache>`."
msgstr ""
"我们将假设你已经做了上面列出的事情。本文档的其余部分主要介绍如何使用 Django，"
"使你不做不必要的工作。本文档也不涉及其他适用于所有昂贵操作的优化技术，比如 :"
"doc:`通用缓存 </topics/cache>`。"

msgid "Understand ``QuerySet``\\s"
msgstr "理解 ``QuerySet``"

msgid ""
"Understanding :doc:`QuerySets </ref/models/querysets>` is vital to getting "
"good performance with simple code. In particular:"
msgstr ""
"理解 :doc:`QuerySets </ref/models/querysets>` 是用简单代码获得高效率的关键。"
"特别是在："

msgid "Understand ``QuerySet`` evaluation"
msgstr "理解 ``QuerySet`` 的执行过程"

msgid "To avoid performance problems, it is important to understand:"
msgstr "要避免执行过程中的问题，一定要理解："

msgid "that :ref:`QuerySets are lazy <querysets-are-lazy>`."
msgstr ":ref:`QuertSets 是惰性的 <querysets-are-lazy>`。"

msgid "when :ref:`they are evaluated <when-querysets-are-evaluated>`."
msgstr "当 :ref:`它们被计算时 <when-querysets-are-evaluated>`。"

msgid "how :ref:`the data is held in memory <caching-and-querysets>`."
msgstr "不过 :ref:`数据保存在内存中 <caching-and-querysets>`。"

msgid "Understand cached attributes"
msgstr "理解缓存属性"

msgid ""
"As well as caching of the whole ``QuerySet``, there is caching of the result "
"of attributes on ORM objects. In general, attributes that are not callable "
"will be cached. For example, assuming the :ref:`example blog models "
"<queryset-model-example>`::"
msgstr ""

msgid "But in general, callable attributes cause DB lookups every time::"
msgstr "但一般来说，可调用对象属性每次都会触发数据库查询："

msgid ""
"Be careful when reading template code - the template system does not allow "
"use of parentheses, but will call callables automatically, hiding the above "
"distinction."
msgstr ""
"阅读模板代码时要注意——模板系统不允许使用括号，但会自动调用可调用对象代码，隐"
"藏了上述区别。"

msgid ""
"Be careful with your own custom properties - it is up to you to implement "
"caching when required, for example using the :class:`~django.utils."
"functional.cached_property` decorator."
msgstr ""
"小心使用你自己的自定义属性——在需要的时候由你自己来实现缓存，例如使用 :class:"
"`~django.utils.functional.cached_property` 装饰器。"

msgid "Use the ``with`` template tag"
msgstr "使用 ``with`` 模板标签"

msgid ""
"To make use of the caching behavior of ``QuerySet``, you may need to use "
"the :ttag:`with` template tag."
msgstr "要使用 ``QuerySet`` 的缓存行为，你可能需要使用 :ttag:`with` 模板标签。"

msgid "Use ``iterator()``"
msgstr "使用 ``iterator()``"

msgid ""
"When you have a lot of objects, the caching behavior of the ``QuerySet`` can "
"cause a large amount of memory to be used. In this case, :meth:`~django.db."
"models.query.QuerySet.iterator()` may help."
msgstr ""
"当你有很多对象时，``QuerySet`` 的缓存行为可能会导致大量的内存被使用。在这种情"
"况下，:meth:`~django.db.models.query.QuerySet.iterator()` 可能会有帮助。"

msgid "Use ``explain()``"
msgstr "使用 ``explain()``"

msgid ""
":meth:`.QuerySet.explain` gives you detailed information about how the "
"database executes a query, including indexes and joins that are used. These "
"details may help you find queries that could be rewritten more efficiently, "
"or identify indexes that could be added to improve performance."
msgstr ""
":meth:`.QuerySet.explain` 为你提供有关数据库如何执行查询的详细信息，包括使用"
"的索引和连接（jion）。这些细节可能会帮助你找到可以更有效地重写的查询，或确定"
"可以添加的索引以提高性能。"

msgid "Do database work in the database rather than in Python"
msgstr "在数据库中执行数据库操作，而不是在 Python 代码中"

msgid "For instance:"
msgstr "例子："

msgid ""
"At the most basic level, use :ref:`filter and exclude <queryset-api>` to do "
"filtering in the database."
msgstr ""
"在最基本的层面上，使用 :ref:`filter 和 exclude <queryset-api>` 在数据库中进行"
"过滤。"

msgid ""
"Use :class:`F expressions <django.db.models.F>` to filter based on other "
"fields within the same model."
msgstr ""
"使用 :class:`F 表达式<django.db.models.F>` 根据同一模型中的其他字段进行过滤。"

msgid ""
"Use :doc:`annotate to do aggregation in the database </topics/db/"
"aggregation>`."
msgstr "利用 :doc:`注解在数据库中执行聚合 </topics/db/aggregation>`。"

msgid "If these aren't enough to generate the SQL you need:"
msgstr "若其不足以生成你需要的 SQL："

msgid "Use ``RawSQL``"
msgstr "使用 ``RawSQL``"

msgid ""
"A less portable but more powerful method is the :class:`~django.db.models."
"expressions.RawSQL` expression, which allows some SQL to be explicitly added "
"to the query. If that still isn't powerful enough:"
msgstr ""
"最简单直接的方法是 :class:`~django.db.models.expressions.RawSQL` 表达式，它允"
"许一些 SQL 显式的添加到查询中。如果这还不够强大："

msgid "Use raw SQL"
msgstr "使用原生 SQL"

msgid ""
"Write your own :doc:`custom SQL to retrieve data or populate models </topics/"
"db/sql>`. Use ``django.db.connection.queries`` to find out what Django is "
"writing for you and start from there."
msgstr ""
"编写你自己的 :doc:`自定义 SQL 来检索数据或填充模型 </topics/db/sql>`。使用 "
"``django.db.connection.query`` 找出 Django 为你写的东西，然后从那里开始。"

msgid "Retrieve individual objects using a unique, indexed column"
msgstr "使用唯一索引列来检索单个对象。"

msgid ""
"There are two reasons to use a column with :attr:`~django.db.models.Field."
"unique` or :attr:`~django.db.models.Field.db_index` when using :meth:"
"`~django.db.models.query.QuerySet.get` to retrieve individual objects. "
"First, the query will be quicker because of the underlying database index. "
"Also, the query could run much slower if multiple objects match the lookup; "
"having a unique constraint on the column guarantees this will never happen."
msgstr ""
"当使用 :meth:`~django.db.models.models.Field.unique` 或 :attr:`~django.db."
"models.Field.db_index` 的列来检索单个对象时，有两个原因。首先，由于底层数据库"
"索引的存在，查询的速度会更快。另外，如果多个对象与查找对象相匹配，查询的运行"
"速度可能会慢很多；在列上有一个唯一约束保证这种情况永远不会发生。"

msgid "So using the :ref:`example blog models <queryset-model-example>`::"
msgstr ""

msgid "will be quicker than:"
msgstr "会比以下更快："

msgid ""
"because ``id`` is indexed by the database and is guaranteed to be unique."
msgstr "因为 ``id`` 通过数据库索引，并且保证是唯一的。"

msgid "Doing the following is potentially quite slow:"
msgstr "执行以下操作可能非常慢："

msgid ""
"First of all, ``headline`` is not indexed, which will make the underlying "
"database fetch slower."
msgstr "首先，``headline`` 没有被索引，这将使得底层数据库获取变慢。"

msgid ""
"Second, the lookup doesn't guarantee that only one object will be returned. "
"If the query matches more than one object, it will retrieve and transfer all "
"of them from the database. This penalty could be substantial if hundreds or "
"thousands of records are returned. The penalty will be compounded if the "
"database lives on a separate server, where network overhead and latency also "
"play a factor."
msgstr ""
"其次，查找不保证只返回一个对象。如果查询匹配多于一个对象，它将从数据库中检索"
"并传递所有对象。如果数据库位于单独的服务器上，那这个损失将更复杂，网络开销和"
"延迟也是一个因素。"

msgid "Retrieve everything at once if you know you will need it"
msgstr "如果你明确需要它，那么立即检索所有内容。"

msgid ""
"Hitting the database multiple times for different parts of a single 'set' of "
"data that you will need all parts of is, in general, less efficient than "
"retrieving it all in one query. This is particularly important if you have a "
"query that is executed in a loop, and could therefore end up doing many "
"database queries, when only one was needed. So:"
msgstr ""
"对于你需要的所有部分的单个数据集的不同部分，多次访问数据库比单次查询所有内容"
"的效率低。如果有一个查找，它在循环中执行，这点就尤其重要，当只需要一个查询"
"时，最终会执行许多数据库查询。因此："

msgid "Use ``QuerySet.select_related()`` and ``prefetch_related()``"
msgstr "使用  ``QuerySet.select_related()`` 和 ``prefetch_related()``"

msgid ""
"Understand :meth:`~django.db.models.query.QuerySet.select_related` and :meth:"
"`~django.db.models.query.QuerySet.prefetch_related` thoroughly, and use them:"
msgstr ""
"深入理解 :meth:`~django.db.models.query.QuerySet.select_related` 和 :meth:"
"`~django.db.models.query.QuerySet.prefetch_related` ，并使用它们："

msgid ""
"in :doc:`managers and default managers </topics/db/managers>` where "
"appropriate. Be aware when your manager is and is not used; sometimes this "
"is tricky so don't make assumptions."
msgstr ""
"在 :doc:`管理器和默认管理器 </topics/db/managers>` 中使用。请注意管理器何时被"
"使用；有时这很棘手，所以不要做出假设。"

msgid ""
"in view code or other layers, possibly making use of :func:`~django.db."
"models.prefetch_related_objects` where needed."
msgstr ""
"在视图代码层或其他层中，可能在需要时使用 :func:`~django.db.models."
"prefetch_related_objects` 。"

msgid "Don't retrieve things you don't need"
msgstr "不要检索你不需要的东西"

msgid "Use ``QuerySet.values()`` and ``values_list()``"
msgstr "使用 ``QuerySet.values()`` 和 ``values_list()``"

msgid ""
"When you only want a ``dict`` or ``list`` of values, and don't need ORM "
"model objects, make appropriate usage of :meth:`~django.db.models.query."
"QuerySet.values()`. These can be useful for replacing model objects in "
"template code - as long as the dicts you supply have the same attributes as "
"those used in the template, you are fine."
msgstr ""
"当你只想得到字典或列表的值，并且不需要 ORM 模型对象时，可以适当使用 :meth:"
"`~django.db.models.query.QuerySet.values()` 。这些对于替换模板代码中的模型对"
"象非常有用——只要你提供的字典具有与模板中使用时相同的属性就行。"

msgid "Use ``QuerySet.defer()`` and ``only()``"
msgstr "使用 ``QuerySet.defer()`` 和 ``only()``"

msgid ""
"Use :meth:`~django.db.models.query.QuerySet.defer()` and :meth:`~django.db."
"models.query.QuerySet.only()` if there are database columns you know that "
"you won't need (or won't need in most cases) to avoid loading them. Note "
"that if you *do* use them, the ORM will have to go and get them in a "
"separate query, making this a pessimization if you use it inappropriately."
msgstr ""
"如果你明确不需要这个数据库列（或在大部分情况里不需要），使用 :meth:`~django."
"db.models.query.QuerySet.defer()` 和 :meth:`~django.db.models.query.QuerySet."
"only()` 来避免加载它们。注意如果你使用它们，ORM 将必须在单独的查询中获取它"
"们，如果你不恰当的使用，会让事情变得糟糕。"

msgid ""
"Don't be too aggressive in deferring fields without profiling as the "
"database has to read most of the non-text, non-VARCHAR data from the disk "
"for a single row in the results, even if it ends up only using a few "
"columns. The ``defer()`` and ``only()`` methods are most useful when you can "
"avoid loading a lot of text data or for fields that might take a lot of "
"processing to convert back to Python. As always, profile first, then "
"optimize."
msgstr ""
"不要在没有分析的情况下过分使用延迟字段，因为数据库必须从磁盘中读取结果中单行"
"的大部分非文本、非VARCHAR数据，即使它最终只使用的几列。当你不想加载许多文本数"
"据或需要大量处理来转换回 Python的字段， ``defer()`` 和 ``only()`` 方法最有"
"用。总之，先分析，再优化。"

msgid "Use ``QuerySet.contains(obj)``"
msgstr ""

msgid ""
"...if you only want to find out if ``obj`` is in the queryset, rather than "
"``if obj in queryset``."
msgstr ""

msgid "Use ``QuerySet.count()``"
msgstr "使用 ``QuerySet.count()``"

msgid "...if you only want the count, rather than doing ``len(queryset)``."
msgstr "……如果你只想计数，不要使用 ``len(queryset)``。"

msgid "Use ``QuerySet.exists()``"
msgstr "使用 ``QuerySet.exists()``"

msgid ""
"...if you only want to find out if at least one result exists, rather than "
"``if queryset``."
msgstr ""
"……若你只想要确认是否有至少存在一项满足条件的结果，而不是 ``if queryset``。"

msgid "But:"
msgstr "但是："

msgid "Don't overuse ``contains()``, ``count()``, and ``exists()``"
msgstr ""

msgid ""
"If you are going to need other data from the QuerySet, evaluate it "
"immediately."
msgstr "如果你需要查询集中的其他数据，请立即对其进行评估。"

msgid ""
"For example, assuming a ``Group`` model that has a many-to-many relation to "
"``User``, the following code is optimal::"
msgstr ""

msgid "It is optimal because:"
msgstr "这是最佳的，因为："

msgid ""
"Since QuerySets are lazy, this does no database queries if "
"``display_group_members`` is ``False``."
msgstr ""

msgid ""
"Storing ``group.members.all()`` in the ``members`` variable allows its "
"result cache to be re-used."
msgstr ""

msgid ""
"The line ``if members:`` causes ``QuerySet.__bool__()`` to be called, which "
"causes the ``group.members.all()`` query to be run on the database. If there "
"aren't any results, it will return ``False``, otherwise ``True``."
msgstr ""

msgid ""
"The line ``if current_user in members:`` checks if the user is in the result "
"cache, so no additional database queries are issued."
msgstr ""

msgid ""
"The use of ``len(members)`` calls ``QuerySet.__len__()``, reusing the result "
"cache, so again, no database queries are issued."
msgstr ""

msgid "The ``for member`` loop iterates over the result cache."
msgstr ""

msgid ""
"In total, this code does either one or zero database queries. The only "
"deliberate optimization performed is using the ``members`` variable. Using "
"``QuerySet.exists()`` for the ``if``, ``QuerySet.contains()`` for the "
"``in``, or ``QuerySet.count()`` for the count would each cause additional "
"queries."
msgstr ""

msgid "Use ``QuerySet.update()`` and ``delete()``"
msgstr "使用 ``QuerySet.update()`` 和 ``delete()``"

msgid ""
"Rather than retrieve a load of objects, set some values, and save them "
"individual, use a bulk SQL UPDATE statement, via :ref:`QuerySet.update() "
"<topics-db-queries-update>`. Similarly, do :ref:`bulk deletes <topics-db-"
"queries-delete>` where possible."
msgstr ""
"如果要设置一些值并单独保存它们，而不是检索对象，那么可以通过 :ref:`QuerySet."
"update() <topics-db-queries-update>` 使用批量 SQL UPDATE 语句。类似地，尽可能"
"使用批量删除（ :ref:`bulk deletes <topics-db-queries-delete>`  ）。"

msgid ""
"Note, however, that these bulk update methods cannot call the ``save()`` or "
"``delete()`` methods of individual instances, which means that any custom "
"behavior you have added for these methods will not be executed, including "
"anything driven from the normal database object :doc:`signals </ref/"
"signals>`."
msgstr ""
"注意，尽管这些批量更新方法不会调用单独实例的 ``save()`` 或 ``delete()`` 方"
"法，这意味着你为这些方法添加的任何自定义行为都不会执行，包括来自正常数据库对"
"象信号（ :doc:`signals </ref/signals>` ）的任何内容。"

msgid "Use foreign key values directly"
msgstr "直接使用外键值"

msgid ""
"If you only need a foreign key value, use the foreign key value that is "
"already on the object you've got, rather than getting the whole related "
"object and taking its primary key. i.e. do::"
msgstr ""
"如果只需要外键值，那么使用已有对象上的外键值，而不是获取所有相关对象并获取它"
"的主键。比如："

msgid "instead of::"
msgstr "替换成："

msgid "Don't order results if you don't care"
msgstr "如无需要，不要排序结果"

msgid ""
"Ordering is not free; each field to order by is an operation the database "
"must perform. If a model has a default ordering (:attr:`Meta.ordering "
"<django.db.models.Options.ordering>`) and you don't need it, remove it on a "
"``QuerySet`` by calling :meth:`~django.db.models.query.QuerySet.order_by()` "
"with no parameters."
msgstr ""
"排序是耗时的；对每个字段的排序是数据库必须执行的操作。如果模型有一个默认排序"
"（ :attr:`Meta.ordering <django.db.models.Options.ordering>` ）并且不需要它，"
"那么可以通过调用没有参数的 :meth:`~django.db.models.query.QuerySet."
"order_by()` 在查询集上删除它。"

msgid ""
"Adding an index to your database may help to improve ordering performance."
msgstr "添加索引到你的数据库上可以帮助改进排序性能。"

msgid "Use bulk methods"
msgstr "使用批量方法"

msgid "Use bulk methods to reduce the number of SQL statements."
msgstr "使用批量方法来减少 SQL 语句数量。"

msgid "Create in bulk"
msgstr "批量创建"

msgid ""
"When creating objects, where possible, use the :meth:`~django.db.models."
"query.QuerySet.bulk_create()` method to reduce the number of SQL queries. "
"For example::"
msgstr ""
"当创建对象时，尽可能使用 :meth:`~django.db.models.query.QuerySet."
"bulk_create()` 方法来减少 SQL 查询数量。比如："

msgid "...is preferable to::"
msgstr "要优于："

msgid ""
"Note that there are a number of :meth:`caveats to this method <django.db."
"models.query.QuerySet.bulk_create>`, so make sure it's appropriate for your "
"use case."
msgstr ""
"注意这个方法有一些注意事项（ :meth:`caveats to this method <django.db.models."
"query.QuerySet.bulk_create>` ），因此要确保它适用于你的情况。"

msgid "Update in bulk"
msgstr "批量更新"

msgid ""
"When updating objects, where possible, use the :meth:`~django.db.models."
"query.QuerySet.bulk_update()` method to reduce the number of SQL queries. "
"Given a list or queryset of objects::"
msgstr ""
"当更新对象时，尽可能使用 :meth:`~django.db.models.query.QuerySet."
"bulk_update()` 方法来减少 SQL 查询数。给定对象的列表或查询集："

msgid "The following example::"
msgstr "下面示例："

msgid ""
"Note that there are a number of :meth:`caveats to this method <django.db."
"models.query.QuerySet.bulk_update>`, so make sure it's appropriate for your "
"use case."
msgstr ""
"注意此方法有一些 :meth:`注意事项 <django.db.models.query.QuerySet."
"bulk_update>` ，因此确保它适合你的案例。"

msgid "Insert in bulk"
msgstr "批量插入"

msgid ""
"When inserting objects into :class:`ManyToManyFields <django.db.models."
"ManyToManyField>`, use :meth:`~django.db.models.fields.related."
"RelatedManager.add` with multiple objects to reduce the number of SQL "
"queries. For example::"
msgstr ""
"当插入对象到 :class:`ManyToManyFields <django.db.models.ManyToManyField>` "
"时，使用带有多个对象的 :meth:`~django.db.models.fields.related."
"RelatedManager.add` 来减少 SQL 查询的数量。举例："

msgid "...where ``Bands`` and ``Artists`` have a many-to-many relationship."
msgstr "其中 ``Bands`` 和 ``Artists`` 有多对多关系。"

msgid ""
"When inserting different pairs of objects into :class:`~django.db.models."
"ManyToManyField` or when the custom :attr:`~django.db.models.ManyToManyField."
"through` table is defined, use :meth:`~django.db.models.query.QuerySet."
"bulk_create()` method to reduce the number of SQL queries. For example::"
msgstr ""
"当不同的对象对插入到 :class:`~django.db.models.ManyToManyField` 或者自定义"
"的 :attr:`~django.db.models.ManyToManyField.through` 表被定义时，可以使用 :"
"meth:`~django.db.models.query.QuerySet.bulk_create()` 方法来减少 SQL 查询的数"
"量。比如："

msgid ""
"...where ``Pizza`` and ``Topping`` have a many-to-many relationship. Note "
"that there are a number of :meth:`caveats to this method <django.db.models."
"query.QuerySet.bulk_create>`, so make sure it's appropriate for your use "
"case."
msgstr ""
"...其中 ``Pizza`` 和 ``Topping`` 是多对多关系。注意这里有一些注意事项（ :"
"meth:`caveats to this method <django.db.models.query.QuerySet."
"bulk_create>` ），因此要确保它适用于你的案例。"

msgid "Remove in bulk"
msgstr "批量删除"

msgid ""
"When removing objects from :class:`ManyToManyFields <django.db.models."
"ManyToManyField>`, use :meth:`~django.db.models.fields.related."
"RelatedManager.remove` with multiple objects to reduce the number of SQL "
"queries. For example::"
msgstr ""
"当从 :class:`ManyToManyFields <django.db.models.ManyToManyField>` 删除对象"
"时，可以使用带有多个对象的 :meth:`~django.db.models.fields.related."
"RelatedManager.remove` 来减少 SQL 查询的数量。比如："

msgid ""
"When removing different pairs of objects from :class:`ManyToManyFields "
"<django.db.models.ManyToManyField>`, use :meth:`~django.db.models.query."
"QuerySet.delete` on a :class:`~django.db.models.Q` expression with multiple :"
"attr:`~django.db.models.ManyToManyField.through`  model instances to reduce "
"the number of SQL queries. For example::"
msgstr ""
"当从 :class:`ManyToManyFields <django.db.models.ManyToManyField>` 里删除不同"
"的对象对时，可以在带有多种 :attr:`~django.db.models.ManyToManyField.through` "
"模型实例的 :class:`~django.db.models.Q` 表达式上使用 :meth:`~django.db."
"models.query.QuerySet.delete` 来减少 SQL 查询的数量。比如："

msgid "...where ``Pizza`` and ``Topping`` have a many-to-many relationship."
msgstr "其中 ``Pizza`` 和 ``Topping`` 有多对多关系。"

msgid "Making queries"
msgstr "执行查询"

msgid ""
"Once you've created your :doc:`data models </topics/db/models>`, Django "
"automatically gives you a database-abstraction API that lets you create, "
"retrieve, update and delete objects. This document explains how to use this "
"API. Refer to the :doc:`data model reference </ref/models/index>` for full "
"details of all the various model lookup options."
msgstr ""
"一旦创建 :doc:`数据模型 </topics/db/models>` 后，Django 自动给予你一套数据库"
"抽象 API，允许你创建，检索，更新和删除对象。本页介绍如何使用这些 API。参考 :"
"doc:`数据模型参考 </ref/models/index>` 获取所有查询选项的完整细节。"

msgid ""
"Throughout this guide (and in the reference), we'll refer to the following "
"models, which comprise a blog application:"
msgstr ""
"在本指南中（以及在参考资料中），我们将提及以下模型，它们构成了一个博客应用程"
"序："

msgid "Creating objects"
msgstr "创建对象"

msgid ""
"To represent database-table data in Python objects, Django uses an intuitive "
"system: A model class represents a database table, and an instance of that "
"class represents a particular record in the database table."
msgstr ""
"为了用 Python 对象展示数据表对象，Django 使用了一套直观的系统：一个模型类代表"
"一张数据表，一个模型类的实例代表数据库表中的一行记录。"

msgid ""
"To create an object, instantiate it using keyword arguments to the model "
"class, then call :meth:`~django.db.models.Model.save` to save it to the "
"database."
msgstr ""
"要创建一个对象，用关键字参数初始化它，然后调用 :meth:`~django.db.models."
"Model.save` 将其存入数据库。"

msgid ""
"Assuming models live in a file ``mysite/blog/models.py``, here's an example::"
msgstr "假设模型都位于文件 ``mysite/blog/models.py`` 中，这是一个例子::"

msgid ""
"This performs an ``INSERT`` SQL statement behind the scenes. Django doesn't "
"hit the database until you explicitly call :meth:`~django.db.models.Model."
"save`."
msgstr ""
"这在幕后执行了 ``INSERT`` SQL 语句。Django 在你显式调用 :meth:`~django.db."
"models.Model.save` 才操作数据库。"

msgid "The :meth:`~django.db.models.Model.save` method has no return value."
msgstr ":meth:`~django.db.models.Model.save` 方法没有返回值。"

msgid ""
":meth:`~django.db.models.Model.save` takes a number of advanced options not "
"described here. See the documentation for :meth:`~django.db.models.Model."
"save` for complete details."
msgstr ""
":meth:`~django.db.models.Model.save` 接受很多此处未介绍的高级选项。参考文档 :"
"meth:`~django.db.models.Model.save` 获取完整细节。"

msgid ""
"To create and save an object in a single step, use the :meth:`~django.db."
"models.query.QuerySet.create()` method."
msgstr ""
"要一步创建并保存一个对象，使用 :meth:`~django.db.models.query.QuerySet."
"create()` 方法。"

msgid "Saving changes to objects"
msgstr "将修改保存至对象"

msgid ""
"To save changes to an object that's already in the database, use :meth:"
"`~django.db.models.Model.save`."
msgstr ""
"要将修改保存至数据库中已有的某个对象，使用 :meth:`~django.db.models.Model."
"save`。"

msgid ""
"Given a ``Blog`` instance ``b5`` that has already been saved to the "
"database, this example changes its name and updates its record in the "
"database::"
msgstr ""
"有一个已被存入数据库中的 ``Blog`` 实例 ``b5``，本例将其改名，并在数据库中更新"
"其记录::"

msgid ""
"This performs an ``UPDATE`` SQL statement behind the scenes. Django doesn't "
"hit the database until you explicitly call :meth:`~django.db.models.Model."
"save`."
msgstr ""
"这在幕后执行了 ``UPDATE`` SQL 语句。Django 在你显示调用 :meth:`~django.db."
"models.Model.save` 后才操作数据库。"

msgid "Saving ``ForeignKey`` and ``ManyToManyField`` fields"
msgstr "保存 ``ForeignKey`` 和 ``ManyToManyField`` 字段"

msgid ""
"Updating a :class:`~django.db.models.ForeignKey` field works exactly the "
"same way as saving a normal field -- assign an object of the right type to "
"the field in question. This example updates the ``blog`` attribute of an "
"``Entry`` instance ``entry``, assuming appropriate instances of ``Entry`` "
"and ``Blog`` are already saved to the database (so we can retrieve them "
"below)::"
msgstr ""
"更新 :class:`~django.db.models.ForeignKey` 字段的方式与保存普通字段的方式相同"
"——只需将正确类型的实例分配给相关字段。本例为 ``Entry`` 类的实例 ``entry`` 更"
"新了 ``blog`` 属性，假设 ``Entry`` 和 ``Blog`` 的实例均已保存在数据库中（因此"
"能在下面检索它们）："

msgid ""
"Updating a :class:`~django.db.models.ManyToManyField` works a little "
"differently -- use the :meth:`~django.db.models.fields.related."
"RelatedManager.add` method on the field to add a record to the relation. "
"This example adds the ``Author`` instance ``joe`` to the ``entry`` object::"
msgstr ""
"更新 :class:`~django.db.models.ManyToManyField` 字段有点不同——在字段上使用 :"
"meth:`~django.db.models.fields.related.RelatedManager.add` 方法为关联关系添加"
"一条记录。本例将 ``Author`` 实例 ``joe`` 添加至 ``entry`` 对象::"

msgid ""
"To add multiple records to a :class:`~django.db.models.ManyToManyField` in "
"one go, include multiple arguments in the call to :meth:`~django.db.models."
"fields.related.RelatedManager.add`, like this::"
msgstr ""
"要一次添加多行记录至 :class:`~django.db.models.ManyToManyField` 字段，在一次"
"调用 :meth:`~django.db.models.fields.related.RelatedManager.add` 时传入多个参"
"数，像这样::"

msgid ""
"Django will complain if you try to assign or add an object of the wrong type."
msgstr "Django 会在添加或指定错误类型的对象时报错。"

msgid "Retrieving objects"
msgstr "检索对象"

msgid ""
"To retrieve objects from your database, construct a :class:`~django.db."
"models.query.QuerySet` via a :class:`~django.db.models.Manager` on your "
"model class."
msgstr ""
"要从数据库检索对象，要通过模型类的 :class:`~django.db.models.Manager` 构建一"
"个 :class:`~django.db.models.query.QuerySet`。"

msgid ""
"A :class:`~django.db.models.query.QuerySet` represents a collection of "
"objects from your database. It can have zero, one or many *filters*. Filters "
"narrow down the query results based on the given parameters. In SQL terms, "
"a :class:`~django.db.models.query.QuerySet` equates to a ``SELECT`` "
"statement, and a filter is a limiting clause such as ``WHERE`` or ``LIMIT``."
msgstr ""
"一个 :class:`~django.db.models.query.QuerySet` 代表来自数据库中对象的一个集"
"合。它可以有 0 个，1 个或者多个 *filters*. Filters，可以根据给定参数缩小查询"
"结果量。在 SQL 的层面上， :class:`~django.db.models.query.QuerySet` 对应 "
"``SELECT`` 语句，而*filters*对应类似 ``WHERE`` 或 ``LIMIT`` 的限制子句。"

msgid ""
"You get a :class:`~django.db.models.query.QuerySet` by using your model's :"
"class:`~django.db.models.Manager`. Each model has at least one :class:"
"`~django.db.models.Manager`, and it's called :attr:`~django.db.models.Model."
"objects` by default. Access it directly via the model class, like so::"
msgstr ""
"你能通过模型的 :class:`~django.db.models.Manager` 获取 :class:`~django.db."
"models.query.QuerySet`。每个模型至少有一个 :class:`~django.db.models."
"Manager`，默认名称是 :attr:`~django.db.models.Model.objects`。像这样直接通过"
"模型类使用它::"

msgid ""
"``Managers`` are accessible only via model classes, rather than from model "
"instances, to enforce a separation between \"table-level\" operations and "
"\"record-level\" operations."
msgstr ""
"``Managers`` 只能通过模型类访问，而不是通过模型实例，目的是强制分离 “表级” 操"
"作和 “行级” 操作。"

msgid ""
"The :class:`~django.db.models.Manager` is the main source of ``QuerySets`` "
"for a model. For example, ``Blog.objects.all()`` returns a :class:`~django."
"db.models.query.QuerySet` that contains all ``Blog`` objects in the database."
msgstr ""
":class:`~django.db.models.Manager` 是模型的 ``QuerySets`` 主要来源。例如 "
"``Blog.objects.all()`` 返回了一个 :class:`~django.db.models.query.QuerySet`，"
"后者包含了数据库中所有的 ``Blog`` 对象。"

msgid "Retrieving all objects"
msgstr "检索全部对象"

msgid ""
"The simplest way to retrieve objects from a table is to get all of them. To "
"do this, use the :meth:`~django.db.models.query.QuerySet.all` method on a :"
"class:`~django.db.models.Manager`::"
msgstr ""
"从数据库中检索对象最简单的方式就是检索全部。为此，在 :class:`~django.db."
"models.Manager` 上调用 :meth:`~django.db.models.query.QuerySet.all` 方法::"

msgid ""
"The :meth:`~django.db.models.query.QuerySet.all` method returns a :class:"
"`~django.db.models.query.QuerySet` of all the objects in the database."
msgstr ""
"方法 :meth:`~django.db.models.query.QuerySet.all` 返回了一个包含数据库中所有"
"对象的 :class:`~django.db.models.query.QuerySet` 对象。"

msgid "Retrieving specific objects with filters"
msgstr "通过过滤器检索指定对象"

msgid ""
"The :class:`~django.db.models.query.QuerySet` returned by :meth:`~django.db."
"models.query.QuerySet.all` describes all objects in the database table. "
"Usually, though, you'll need to select only a subset of the complete set of "
"objects."
msgstr ""
":meth:`~django.db.models.query.QuerySet.all` 返回的 :class:`~django.db."
"models.query.QuerySet` 包含了数据表中所有的对象。虽然，大多数情况下，你只需要"
"完整对象集合的一个子集。"

msgid ""
"To create such a subset, you refine the initial :class:`~django.db.models."
"query.QuerySet`, adding filter conditions. The two most common ways to "
"refine a :class:`~django.db.models.query.QuerySet` are:"
msgstr ""
"要创建一个这样的子集，你需要通过添加过滤条件精炼原始 :class:`~django.db."
"models.query.QuerySet`。两种最常见的精炼 :class:`~django.db.models.query."
"QuerySet` 的方式是："

msgid "``filter(**kwargs)``"
msgstr "``filter(**kwargs)``"

msgid ""
"Returns a new :class:`~django.db.models.query.QuerySet` containing objects "
"that match the given lookup parameters."
msgstr ""
"返回一个新的 :class:`~django.db.models.query.QuerySet`，包含的对象满足给定查"
"询参数。"

msgid "``exclude(**kwargs)``"
msgstr "``exclude(**kwargs)``"

msgid ""
"Returns a new :class:`~django.db.models.query.QuerySet` containing objects "
"that do *not* match the given lookup parameters."
msgstr ""
"返回一个新的 :class:`~django.db.models.query.QuerySet`，包含的对象 *不* 满足"
"给定查询参数。"

msgid ""
"The lookup parameters (``**kwargs`` in the above function definitions) "
"should be in the format described in `Field lookups`_ below."
msgstr "查询参数（``**kwargs``）应该符合下面的 `Field lookups`_ 的要求。"

msgid ""
"For example, to get a :class:`~django.db.models.query.QuerySet` of blog "
"entries from the year 2006, use :meth:`~django.db.models.query.QuerySet."
"filter` like so::"
msgstr ""
"例如，要包含获取 2006 年的博客条目（entries blog）的 :class:`~django.db."
"models.query.QuerySet`，像这样使用 :meth:`~django.db.models.query.QuerySet."
"filter`::"

msgid "With the default manager class, it is the same as::"
msgstr "通过默认管理器类也一样::"

msgid "Chaining filters"
msgstr "链式过滤器"

msgid ""
"The result of refining a :class:`~django.db.models.query.QuerySet` is itself "
"a :class:`~django.db.models.query.QuerySet`, so it's possible to chain "
"refinements together. For example::"
msgstr ""
"精炼 :class:`~django.db.models.query.QuerySet` 的结果本身还是一个 :class:"
"`~django.db.models.query.QuerySet`，所以能串联精炼过程。例子::"

msgid ""
"This takes the initial :class:`~django.db.models.query.QuerySet` of all "
"entries in the database, adds a filter, then an exclusion, then another "
"filter. The final result is a :class:`~django.db.models.query.QuerySet` "
"containing all entries with a headline that starts with \"What\", that were "
"published between January 30, 2005, and the current day."
msgstr ""
"这个先获取包含数据库所有条目（entry）的 :class:`~django.db.models.query."
"QuerySet`，然后排除一些，再进入另一个过滤器。最终的 :class:`~django.db."
"models.query.QuerySet` 包含标题以 \"What\" 开头的，发布日期介于 2005 年 1 月 "
"30 日与今天之间的所有条目。"

msgid "Filtered ``QuerySet``\\s are unique"
msgstr "每个 ``QuerySet`` 都是唯一的"

msgid ""
"Each time you refine a :class:`~django.db.models.query.QuerySet`, you get a "
"brand-new :class:`~django.db.models.query.QuerySet` that is in no way bound "
"to the previous :class:`~django.db.models.query.QuerySet`. Each refinement "
"creates a separate and distinct :class:`~django.db.models.query.QuerySet` "
"that can be stored, used and reused."
msgstr ""
"每次精炼一个 :class:`~django.db.models.query.QuerySet`，你就会获得一个全新"
"的 :class:`~django.db.models.query.QuerySet`，后者与前者毫无关联。每次精炼都"
"会创建一个单独的、不同的 :class:`~django.db.models.query.QuerySet`，能被存"
"储，使用和复用。"

msgid ""
"These three ``QuerySets`` are separate. The first is a base :class:`~django."
"db.models.query.QuerySet` containing all entries that contain a headline "
"starting with \"What\". The second is a subset of the first, with an "
"additional criteria that excludes records whose ``pub_date`` is today or in "
"the future. The third is a subset of the first, with an additional criteria "
"that selects only the records whose ``pub_date`` is today or in the future. "
"The initial :class:`~django.db.models.query.QuerySet` (``q1``) is unaffected "
"by the refinement process."
msgstr ""
"这三个 ``QuerySets`` 是独立的。第一个是基础 :class:`~django.db.models.query."
"QuerySet`，包含了所有标题以 \"What\" 开头的条目。第二个是第一个的子集，带有额"
"外条件，排除了 ``pub_date`` 是今天和今天之后的所有记录。第三个是第一个的子"
"集，带有额外条件，只筛选 ``pub_date`` 是今天或未来的所有记录。最初的 :class:"
"`~django.db.models.query.QuerySet` (``q1``) 不受筛选操作影响。"

msgid "``QuerySet``\\s are lazy"
msgstr "``QuerySet`` 是惰性的"

msgid ""
"``QuerySets`` are lazy -- the act of creating a :class:`~django.db.models."
"query.QuerySet` doesn't involve any database activity. You can stack filters "
"together all day long, and Django won't actually run the query until the :"
"class:`~django.db.models.query.QuerySet` is *evaluated*. Take a look at this "
"example::"
msgstr ""
"``QuerySet`` 是惰性的 —— 创建 :class:`~django.db.models.query.QuerySet` 并不"
"会引发任何数据库活动。你可以将一整天的过滤器都堆积在一起，Django 只会在 :"
"class:`~django.db.models.query.QuerySet` 被 *计算* 时执行查询操作。来瞄一眼这"
"个例子::"

msgid ""
"Though this looks like three database hits, in fact it hits the database "
"only once, at the last line (``print(q)``). In general, the results of a :"
"class:`~django.db.models.query.QuerySet` aren't fetched from the database "
"until you \"ask\" for them. When you do, the :class:`~django.db.models.query."
"QuerySet` is *evaluated* by accessing the database. For more details on "
"exactly when evaluation takes place, see :ref:`when-querysets-are-evaluated`."
msgstr ""
"虽然这看起来像是三次数据库操作，实际上只在最后一行 (``print(q)``) 做了一次。"
"一般来说， :class:`~django.db.models.query.QuerySet` 的结果直到你 “要使用” 时"
"才会从数据库中拿出。当你要用时，才通过数据库 *计算* 出 :class:`~django.db."
"models.query.QuerySet`。关于何时才真的执行计算的更多细节，参考 :ref:`when-"
"querysets-are-evaluated`。"

msgid "Retrieving a single object with ``get()``"
msgstr "用 ``get()`` 检索单个对象"

msgid ""
":meth:`~django.db.models.query.QuerySet.filter` will always give you a :"
"class:`~django.db.models.query.QuerySet`, even if only a single object "
"matches the query - in this case, it will be a :class:`~django.db.models."
"query.QuerySet` containing a single element."
msgstr ""
":meth:`~django.db.models.query.QuerySet.filter` 总是返回一个 :class:`~django."
"db.models.query.QuerySet`，即便只有一个对象满足查询条件 —— 这种情况下， :"
"class:`~django.db.models.query.QuerySet` 只包含了一个元素。"

msgid ""
"If you know there is only one object that matches your query, you can use "
"the :meth:`~django.db.models.query.QuerySet.get` method on a :class:`~django."
"db.models.Manager` which returns the object directly::"
msgstr ""
"若你知道只会有一个对象满足查询条件，你可以在 :class:`~django.db.models."
"Manager` 上使用 :meth:`~django.db.models.query.QuerySet.get` 方法，它会直接返"
"回这个对象::"

msgid ""
"You can use any query expression with :meth:`~django.db.models.query."
"QuerySet.get`, just like with :meth:`~django.db.models.query.QuerySet."
"filter` - again, see `Field lookups`_ below."
msgstr ""
"你可以对 :meth:`~django.db.models.query.QuerySet.get` 使用与 :meth:`~django."
"db.models.query.QuerySet.filter` 类似的所有查询表达式 —— 同样的，参考下面的 "
"`Field lookups`_。"

msgid ""
"Note that there is a difference between using :meth:`~django.db.models.query."
"QuerySet.get`, and using :meth:`~django.db.models.query.QuerySet.filter` "
"with a slice of ``[0]``. If there are no results that match the query, :meth:"
"`~django.db.models.query.QuerySet.get` will raise a ``DoesNotExist`` "
"exception. This exception is an attribute of the model class that the query "
"is being performed on - so in the code above, if there is no ``Entry`` "
"object with a primary key of 1, Django will raise ``Entry.DoesNotExist``."
msgstr ""
"注意， 使用切片 ``[0]`` 时的 :meth:`~django.db.models.query.QuerySet.get` "
"和 :meth:`~django.db.models.query.QuerySet.filter` 有点不同。如果没有满足查询"
"条件的结果， :meth:`~django.db.models.query.QuerySet.get` 会抛出一个 "
"``DoesNotExist`` 异常。该异常是执行查询的模型类的一个属性 —— 所有，上述代码"
"中，若没有哪个 ``Entry`` 对象的主键是 1，Django 会抛出 ``Entry."
"DoesNotExist``。"

msgid ""
"Similarly, Django will complain if more than one item matches the :meth:"
"`~django.db.models.query.QuerySet.get` query. In this case, it will raise :"
"exc:`~django.core.exceptions.MultipleObjectsReturned`, which again is an "
"attribute of the model class itself."
msgstr ""
"类似了，Django 会在有不止一个记录满足 :meth:`~django.db.models.query."
"QuerySet.get` 查询条件时发出警告。这时，Django 会抛出 :exc:`~django.core."
"exceptions.MultipleObjectsReturned`，这同样也是模型类的一个属性。"

msgid "Other ``QuerySet`` methods"
msgstr "其它 ``QuerySet`` 方法"

msgid ""
"Most of the time you'll use :meth:`~django.db.models.query.QuerySet.all`, :"
"meth:`~django.db.models.query.QuerySet.get`, :meth:`~django.db.models.query."
"QuerySet.filter` and :meth:`~django.db.models.query.QuerySet.exclude` when "
"you need to look up objects from the database. However, that's far from all "
"there is; see the :ref:`QuerySet API Reference <queryset-api>` for a "
"complete list of all the various :class:`~django.db.models.query.QuerySet` "
"methods."
msgstr ""
"大多数情况下，你会在需要从数据库中检索对象时使用 :meth:`~django.db.models."
"query.QuerySet.all`， :meth:`~django.db.models.query.QuerySet.get`， :meth:"
"`~django.db.models.query.QuerySet.filter` 和 :meth:`~django.db.models.query."
"QuerySet.exclude`。然而，这样远远不够；完整的各种 :class:`~django.db.models."
"query.QuerySet` 方法请参阅 :ref:`QuerySet API 参考 <queryset-api>`。"

msgid "Limiting ``QuerySet``\\s"
msgstr "限制 ``QuerySet`` 条目数"

msgid ""
"Use a subset of Python's array-slicing syntax to limit your :class:`~django."
"db.models.query.QuerySet` to a certain number of results. This is the "
"equivalent of SQL's ``LIMIT`` and ``OFFSET`` clauses."
msgstr ""
"利用 Python 的数组切片语法将 :class:`~django.db.models.query.QuerySet` 切成指"
"定长度。这等价于 SQL 的 ``LIMIT`` 和 ``OFFSET`` 子句。"

msgid "For example, this returns the first 5 objects (``LIMIT 5``)::"
msgstr "例如，这将返回前 5 个对象 (``LIMIT 5``)::"

msgid "This returns the sixth through tenth objects (``OFFSET 5 LIMIT 5``)::"
msgstr "这会返回第 6 至第 10 个对象 (``OFFSET 5 LIMIT 5``)::"

msgid "Negative indexing (i.e. ``Entry.objects.all()[-1]``) is not supported."
msgstr "不支持负索引 (例如 ``Entry.objects.all()[-1]``)"

msgid ""
"Generally, slicing a :class:`~django.db.models.query.QuerySet` returns a "
"new :class:`~django.db.models.query.QuerySet` -- it doesn't evaluate the "
"query. An exception is if you use the \"step\" parameter of Python slice "
"syntax. For example, this would actually execute the query in order to "
"return a list of every *second* object of the first 10::"
msgstr ""
"一般情况下， :class:`~django.db.models.query.QuerySet` 的切片返回一个新的 :"
"class:`~django.db.models.query.QuerySet` —— 其并未执行查询。一个特殊情况是使"
"用了的 Python 切片语法的 “步长”。例如，这将会实际的执行查询命令，为了获取从"
"前 10 个对象中，每隔一个抽取的对象组成的列表::"

msgid ""
"Further filtering or ordering of a sliced queryset is prohibited due to the "
"ambiguous nature of how that might work."
msgstr "由于对 queryset 切片工作方式的模糊性，禁止对其进行进一步的排序或过滤。"

msgid ""
"To retrieve a *single* object rather than a list (e.g. ``SELECT foo FROM bar "
"LIMIT 1``), use an index instead of a slice. For example, this returns the "
"first ``Entry`` in the database, after ordering entries alphabetically by "
"headline::"
msgstr ""
"要检索 *单个* 对象而不是一个列表时（例如 ``SELECT foo FROM bar LIMIT 1``），"
"请使用索引，而不是切片。例如，这会返回按标题字母排序后的第一个 ``Entry``::"

msgid "This is roughly equivalent to::"
msgstr "这大致等价于::"

msgid ""
"Note, however, that the first of these will raise ``IndexError`` while the "
"second will raise ``DoesNotExist`` if no objects match the given criteria. "
"See :meth:`~django.db.models.query.QuerySet.get` for more details."
msgstr ""
"然而，注意一下，若没有对象满足给定条件，前者会抛出 ``IndexError``，而后者会抛"
"出 ``DoesNotExist``。参考 :meth:`~django.db.models.query.QuerySet.get` 获取更"
"多细节。"

msgid "Field lookups"
msgstr "字段查询"

msgid ""
"Field lookups are how you specify the meat of an SQL ``WHERE`` clause. "
"They're specified as keyword arguments to the :class:`~django.db.models."
"query.QuerySet` methods :meth:`~django.db.models.query.QuerySet.filter`, :"
"meth:`~django.db.models.query.QuerySet.exclude` and :meth:`~django.db.models."
"query.QuerySet.get`."
msgstr ""
"字段查询即你如何制定 SQL ``WHERE`` 子句。它们以关键字参数的形式传递给 :class:"
"`~django.db.models.query.QuerySet` 方法 :meth:`~django.db.models.query."
"QuerySet.filter`， :meth:`~django.db.models.query.QuerySet.exclude` 和 :meth:"
"`~django.db.models.query.QuerySet.get`。"

msgid ""
"Basic lookups keyword arguments take the form ``field__lookuptype=value``. "
"(That's a double-underscore). For example::"
msgstr ""
"基本的查询关键字参数遵照 ``field__lookuptype=value``。（有个双下划线）。例"
"如::"

msgid "translates (roughly) into the following SQL:"
msgstr "转换为 SQL 语句大致如下："

msgid "How this is possible"
msgstr "这是怎么做到的"

msgid ""
"Python has the ability to define functions that accept arbitrary name-value "
"arguments whose names and values are evaluated at runtime. For more "
"information, see :ref:`tut-keywordargs` in the official Python tutorial."
msgstr ""
"Python 能定义可接受任意数量 name-value 参数的函数，参数名和值均在运行时计算。"
"更多信息，请参考官方 Python 教程中的 :ref:`tut-keywordargs`。"

msgid ""
"The field specified in a lookup has to be the name of a model field. There's "
"one exception though, in case of a :class:`~django.db.models.ForeignKey` you "
"can specify the field name suffixed with ``_id``. In this case, the value "
"parameter is expected to contain the raw value of the foreign model's "
"primary key. For example:"
msgstr ""
"查询子句中指定的字段必须是模型的一个字段名。不过也有个例外，在 :class:"
"`~django.db.models.ForeignKey` 中，你可以指定以 ``_id`` 为后缀的字段名。这种"
"情况下，value 参数需要包含 foreign 模型的主键的原始值。例子："

msgid ""
"If you pass an invalid keyword argument, a lookup function will raise "
"``TypeError``."
msgstr "若你传入了无效的关键字参数，查询函数会抛出 ``TypeError``。"

msgid ""
"The database API supports about two dozen lookup types; a complete reference "
"can be found in the :ref:`field lookup reference <field-lookups>`. To give "
"you a taste of what's available, here's some of the more common lookups "
"you'll probably use:"
msgstr ""
"数据库 API 支持两套查询类型；完整参考文档位于 :ref:`字段查询参考 <field-"
"lookups>`。为了让你了解能干啥，以下是一些常见的查询："

msgid ":lookup:`exact`"
msgstr ":lookup:`exact`"

msgid "An \"exact\" match. For example::"
msgstr "一个 \"exact\" 匹配的例子::"

msgid "Would generate SQL along these lines:"
msgstr "会生成这些 SQL："

msgid ""
"If you don't provide a lookup type -- that is, if your keyword argument "
"doesn't contain a double underscore -- the lookup type is assumed to be "
"``exact``."
msgstr ""
"若你为提供查询类型 —— 也就说，若关键字参数未包含双下划线 —— 查询类型会被指定"
"为 ``exact``。"

msgid "For example, the following two statements are equivalent::"
msgstr "例如，以下两条语句是等价的::"

msgid "This is for convenience, because ``exact`` lookups are the common case."
msgstr "这是为了方便，因为 ``exact`` 查询是最常见的。"

msgid ":lookup:`iexact`"
msgstr ":lookup:`iexact`"

msgid "A case-insensitive match. So, the query::"
msgstr "不分大小写的匹配，查询语句::"

msgid ""
"Would match a ``Blog`` titled ``\"Beatles Blog\"``, ``\"beatles blog\"``, or "
"even ``\"BeAtlES blOG\"``."
msgstr ""
"会匹配标题为 ``\"Beatles Blog\"``， ``\"beatles blog\"``， 甚至 ``\"BeAtlES "
"blOG\"`` 的 ``Blog``。"

msgid ":lookup:`contains`"
msgstr ":lookup:`contains`"

msgid "Case-sensitive containment test. For example::"
msgstr "大小写敏感的包含测试。例子::"

msgid "Roughly translates to this SQL:"
msgstr "粗略地转为 SQL："

msgid ""
"Note this will match the headline ``'Today Lennon honored'`` but not "
"``'today lennon honored'``."
msgstr ""
"注意这将匹配标题 ``'Today Lennon honored'``，而不是 ``'today lennon "
"honored'``。"

msgid "There's also a case-insensitive version, :lookup:`icontains`."
msgstr "这也有个大小写不敏感的版本， :lookup:`icontains`。"

msgid ":lookup:`startswith`, :lookup:`endswith`"
msgstr ":lookup:`startswith`, :lookup:`endswith`"

msgid ""
"Starts-with and ends-with search, respectively. There are also case-"
"insensitive versions called :lookup:`istartswith` and :lookup:`iendswith`."
msgstr ""
"以……开头和以……结尾的查找。当然也有大小写不敏感的版本，名为 :lookup:"
"`istartswith` 和 :lookup:`iendswith`。"

msgid ""
"Again, this only scratches the surface. A complete reference can be found in "
"the :ref:`field lookup reference <field-lookups>`."
msgstr ""
"同样，这只介绍了皮毛。完整的参考能在 :ref:`field 查询参考 <field-lookups>` 找"
"到。"

msgid "Lookups that span relationships"
msgstr "跨关系查询"

msgid ""
"Django offers a powerful and intuitive way to \"follow\" relationships in "
"lookups, taking care of the SQL ``JOIN``\\s for you automatically, behind "
"the scenes. To span a relationship, use the field name of related fields "
"across models, separated by double underscores, until you get to the field "
"you want."
msgstr ""
"Django 提供了一种强大而直观的方式来“追踪”查询中的关系，在幕后自动为你处理 "
"SQL ``JOIN`` 关系。为了跨越关系，跨模型使用关联字段名，字段名由双下划线分割，"
"直到拿到想要的字段。"

msgid ""
"This example retrieves all ``Entry`` objects with a ``Blog`` whose ``name`` "
"is ``'Beatles Blog'``::"
msgstr ""
"本例检索出所有的 ``Entry`` 对象，其 ``Blog`` 的 ``name`` 为 ``'Beatles "
"Blog'`` ："

msgid "This spanning can be as deep as you'd like."
msgstr "跨域的深度随你所想。"

msgid ""
"It works backwards, too. While it :attr:`can be customized <.ForeignKey."
"related_query_name>`, by default you refer to a \"reverse\" relationship in "
"a lookup using the lowercase name of the model."
msgstr ""
"它也可以反向工作。虽然它 :attr:`可以自定义 <.ForeignKey."
"related_query_name>`，默认情况下，你在查找中使用模型的小写名称来引用一个 “反"
"向” 关系。"

msgid ""
"This example retrieves all ``Blog`` objects which have at least one "
"``Entry`` whose ``headline`` contains ``'Lennon'``::"
msgstr ""
"本例检索的所有 ``Blog`` 对象均拥有少一个 ``标题`` 含有 ``'Lennon'`` 的条目::"

msgid ""
"If you are filtering across multiple relationships and one of the "
"intermediate models doesn't have a value that meets the filter condition, "
"Django will treat it as if there is an empty (all values are ``NULL``), but "
"valid, object there. All this means is that no error will be raised. For "
"example, in this filter::"
msgstr ""
"如果你在跨多个关系进行筛选，而某个中间模型的没有满足筛选条件的值，Django  会"
"将它当做一个空的（所有值都是 ``NULL``）但是有效的对象。这样就意味着不会抛出错"
"误。例如，在这个过滤器中::"

msgid ""
"(if there was a related ``Author`` model), if there was no ``author`` "
"associated with an entry, it would be treated as if there was also no "
"``name`` attached, rather than raising an error because of the missing "
"``author``. Usually this is exactly what you want to have happen. The only "
"case where it might be confusing is if you are using :lookup:`isnull`. Thus::"
msgstr ""
"（假设有个关联的 ``Author`` 模型），若某项条目没有任何关联的 ``author``，它会"
"被视作没有关联的 ``name``，而不是因为缺失 ``author`` 而抛出错误。大多数情况"
"下，这就是你期望的。唯一可能使你迷惑的场景是在使用 :lookup:`isnull` 时。因"
"此::"

msgid ""
"will return ``Blog`` objects that have an empty ``name`` on the ``author`` "
"and also those which have an empty ``author`` on the ``entry``. If you don't "
"want those latter objects, you could write::"
msgstr ""
"将会返回 ``Blog`` 对象，包含 ``author`` 的 ``name`` 为空的对象，以及那些 "
"``entry`` 的 ``author`` 为空的对象。若你不想要后面的对象，你可以这样写::"

msgid "Spanning multi-valued relationships"
msgstr "跨多值关联"

msgid ""
"When spanning a :class:`~django.db.models.ManyToManyField` or a reverse :"
"class:`~django.db.models.ForeignKey` (such as from ``Blog`` to ``Entry``), "
"filtering on multiple attributes raises the question of whether to require "
"each attribute to coincide in the same related object. We might seek blogs "
"that have an entry from 2008 with *“Lennon”* in its headline, or we might "
"seek blogs that merely have any entry from 2008 as well as some newer or "
"older entry with *“Lennon”* in its headline."
msgstr ""
"当跨越 :class:`~django.db.models.ManyToManyField` 或反查 :class:`~django.db."
"models.ForeignKey` （例如从 ``Blog`` 到 ``Entry`` ）时，对多个属性进行过滤会"
"产生这样的问题：是否要求每个属性都在同一个相关对象中重合。我们可能会寻找那些"
"在标题中含有 *“Lennon”* 的 2008 年的博客，或者我们可能会寻找那些仅有 2008 年"
"的任何条目以及一些在标题中含有 *“Lennon”* 的较新或较早的条目。"

msgid ""
"To select all blogs containing at least one entry from 2008 having *\"Lennon"
"\"* in its headline (the same entry satisfying both conditions), we would "
"write::"
msgstr ""
"要选择所有包含 2008 年至少一个标题中有 *\"Lennon\"* 的条目的博客（满足两个条"
"件的同一条目），我们要写："

msgid ""
"Otherwise, to perform a more permissive query selecting any blogs with "
"merely *some* entry with *\"Lennon\"* in its headline and *some* entry from "
"2008, we would write::"
msgstr ""
"否则，如果要执行一个更为宽松的查询，选择任何只在标题中带有 *\"Lennon\"* 的条"
"目和 2008 年的条目的博客，我们将写："

msgid ""
"Suppose there is only one blog that has both entries containing *\"Lennon\"* "
"and entries from 2008, but that none of the entries from 2008 contained *"
"\"Lennon\"*. The first query would not return any blogs, but the second "
"query would return that one blog. (This is because the entries selected by "
"the second filter may or may not be the same as the entries in the first "
"filter. We are filtering the ``Blog`` items with each filter statement, not "
"the ``Entry`` items.) In short, if each condition needs to match the same "
"related object, then each should be contained in a single :meth:`~django.db."
"models.query.QuerySet.filter` call."
msgstr ""
"假设只有一个博客既有包含 *\"Lennon\"* 的条目又有 2008 年的条目，但 2008 年的"
"条目中没有包含 *\"Lennon\"* 。第一个查询不会返回任何博客，但第二个查询会返回"
"那一个博客。（这是因为第二个过滤器选择的条目可能与第一个过滤器中的条目相同，"
"也可能不相同）。我们是用每个过滤器语句来过滤 ``Blog`` 项，而不是 ``Entry`` "
"项）。简而言之，如果每个条件需要匹配相同的相关对象，那么每个条件应该包含在一"
"个 :meth:`~django.db.models.querySet.filter` 调用中。"

msgid ""
"As the second (more permissive) query chains multiple filters, it performs "
"multiple joins to the primary model, potentially yielding duplicates."
msgstr ""
"由于第二个（更宽松的）查询链接了多个过滤器，它对主模型进行了多次连接，可能会"
"产生重复的结果。"

msgid ""
"The behavior of :meth:`~django.db.models.query.QuerySet.filter` for queries "
"that span multi-value relationships, as described above, is not implemented "
"equivalently for :meth:`~django.db.models.query.QuerySet.exclude`. Instead, "
"the conditions in a single :meth:`~django.db.models.query.QuerySet.exclude` "
"call will not necessarily refer to the same item."
msgstr ""
":meth:`~django.db.models.query.QuerySet.filter` 的查询行为会跨越多值关联，就"
"像前文说的那样，并不与 :meth:`~django.db.models.query.QuerySet.exclude` 相"
"同。相反，一次 :meth:`~django.db.models.query.QuerySet.exclude` 调用的条件并"
"不需要指向同一项目。"

msgid ""
"For example, the following query would exclude blogs that contain *both* "
"entries with *\"Lennon\"* in the headline *and* entries published in 2008::"
msgstr ""
"例如，以下查询会排除那些关联条目标题包含 *\"Lennon\"* 且发布于 2008 年的博"
"客::"

msgid ""
"However, unlike the behavior when using :meth:`~django.db.models.query."
"QuerySet.filter`, this will not limit blogs based on entries that satisfy "
"both conditions. In order to do that, i.e. to select all blogs that do not "
"contain entries published with *\"Lennon\"* that were published in 2008, you "
"need to make two queries::"
msgstr ""
"但是，与 :meth:`~django.db.models.query.QuerySet.filter` 的行为不同，其并不会"
"限制博客同时满足这两种条件。要这么做的话，也就是筛选出所有条目标题不带 *"
"\"Lennon\"* 且发布年不是 2008 的博客，你需要做两次查询::"

msgid "Filters can reference fields on the model"
msgstr "过滤器可以为模型指定字段"

msgid ""
"In the examples given so far, we have constructed filters that compare the "
"value of a model field with a constant. But what if you want to compare the "
"value of a model field with another field on the same model?"
msgstr ""
"在之前的例子中，我们已经构建过的 ``filter`` 都是将模型字段值与常量做比较。但"
"是，要怎么做才能将模型字段值与同一模型中的另一字段做比较呢？"

msgid ""
"Django provides :class:`F expressions <django.db.models.F>` to allow such "
"comparisons. Instances of ``F()`` act as a reference to a model field within "
"a query. These references can then be used in query filters to compare the "
"values of two different fields on the same model instance."
msgstr ""
"Django 提供了 :class:`F 表达式 <django.db.models.F>` 实现这种比较。 ``F()`` "
"的实例充当查询中的模型字段的引用。这些引用可在查询过滤器中用于在同一模型实例"
"中比较两个不同的字段。"

msgid ""
"For example, to find a list of all blog entries that have had more comments "
"than pingbacks, we construct an ``F()`` object to reference the pingback "
"count, and use that ``F()`` object in the query::"
msgstr ""
"例如，要查出所有评论数大于 pingbacks 的博客条目，我们构建了一个 ``F()`` 对"
"象，指代 pingback 的数量，然后在查询中使用该 ``F()`` 对象::"

msgid ""
"Django supports the use of addition, subtraction, multiplication, division, "
"modulo, and power arithmetic with ``F()`` objects, both with constants and "
"with other ``F()`` objects. To find all the blog entries with more than "
"*twice* as many comments as pingbacks, we modify the query::"
msgstr ""
"Django 支持对 ``F()`` 对象进行加、减、乘、除、求余和次方，另一操作数既可以是"
"常量，也可以是其它 ``F()`` 对象。要找到那些评论数两倍于 pingbacks 的博客条"
"目，我们这样修改查询条件::"

msgid ""
"To find all the entries where the rating of the entry is less than the sum "
"of the pingback count and comment count, we would issue the query::"
msgstr "要找出所有评分低于 pingback 和评论总数之和的条目，修改查询条件::"

msgid ""
"You can also use the double underscore notation to span relationships in an "
"``F()`` object. An ``F()`` object with a double underscore will introduce "
"any joins needed to access the related object. For example, to retrieve all "
"the entries where the author's name is the same as the blog name, we could "
"issue the query::"
msgstr ""
"你也能用双下划线在 ``F()`` 对象中通过关联关系查询。带有双下划线的 ``F()`` 对"
"象将引入访问关联对象所需的任何连接。例如，要检索出所有作者名与博客名相同的博"
"客，这样修改查询条件::"

msgid ""
"For date and date/time fields, you can add or subtract a :class:`~datetime."
"timedelta` object. The following would return all entries that were modified "
"more than 3 days after they were published::"
msgstr ""
"对于 date 和 date/time 字段，你可以加上或减去一个 :class:`~datetime."
"timedelta` 对象。以下会返回所有发布 3 天后被修改的条目::"

msgid ""
"The ``F()`` objects support bitwise operations by ``.bitand()``, ``."
"bitor()``, ``.bitxor()``, ``.bitrightshift()``, and ``.bitleftshift()``. For "
"example::"
msgstr ""
"``F()`` 对象通过 ``.bitand()``， ``.bitor()``， ``.bitxor()``，``."
"bitrightshift()`` 和 ``.bitleftshift()`` 支持位操作。例子::"

msgid "Oracle"
msgstr "Oracle"

msgid "Oracle doesn't support bitwise XOR operation."
msgstr "Oracle 不支持按位 XOR 操作。"

msgid "Expressions can reference transforms"
msgstr ""

msgid "Django supports using transforms in expressions."
msgstr ""

msgid ""
"For example, to find all ``Entry`` objects published in the same year as "
"they were last modified::"
msgstr ""

msgid ""
"To find the earliest year an entry was published, we can issue the query::"
msgstr ""

msgid ""
"This example finds the value of the highest rated entry and the total number "
"of comments on all entries for each year::"
msgstr ""

msgid "The ``pk`` lookup shortcut"
msgstr "主键 (``pk``) 查询快捷方式"

msgid ""
"For convenience, Django provides a ``pk`` lookup shortcut, which stands for "
"\"primary key\"."
msgstr ""
"出于方便的目的，Django 提供了一种 ``pk`` 查询快捷方式， ``pk`` 表示主键 "
"\"primary key\"。"

msgid ""
"In the example ``Blog`` model, the primary key is the ``id`` field, so these "
"three statements are equivalent::"
msgstr "示例 ``Blog`` 模型中，主键是 ``id`` 字段，所以这 3 个语句是等效的::"

msgid ""
"The use of ``pk`` isn't limited to ``__exact`` queries -- any query term can "
"be combined with ``pk`` to perform a query on the primary key of a model::"
msgstr ""
"``pk`` 的使用并不仅限于 ``__exact`` 查询——任何的查询项都能接在 ``pk`` 后面，"
"执行对模型主键的查询::"

msgid ""
"``pk`` lookups also work across joins. For example, these three statements "
"are equivalent::"
msgstr "``pk`` 查找也支持跨连接。例如，以下 3 个语句是等效的::"

msgid "Escaping percent signs and underscores in ``LIKE`` statements"
msgstr "在 ``LIKE`` 语句中转义百分号和下划线"

msgid ""
"The field lookups that equate to ``LIKE`` SQL statements (``iexact``, "
"``contains``, ``icontains``, ``startswith``, ``istartswith``, ``endswith`` "
"and ``iendswith``) will automatically escape the two special characters used "
"in ``LIKE`` statements -- the percent sign and the underscore. (In a "
"``LIKE`` statement, the percent sign signifies a multiple-character wildcard "
"and the underscore signifies a single-character wildcard.)"
msgstr ""
"等效于 ``LIKE`` SQL 语句的字段查询子句 (``iexact``， ``contains``， "
"``icontains``， ``startswith``， ``istartswith``， ``endswith`` 和 "
"``iendswith``) 会将 ``LIKE`` 语句中有特殊用途的两个符号，即百分号和下划线自动"
"转义。（在 ``LIKE`` 语句中，百分号匹配多个任意字符，而下划线匹配一个任意字"
"符。）"

msgid ""
"This means things should work intuitively, so the abstraction doesn't leak. "
"For example, to retrieve all the entries that contain a percent sign, use "
"the percent sign as any other character::"
msgstr ""
"这意味着事情应该直观地工作，这样抽象就不会泄露。例如，要检索所有包含百分号的"
"条目，就像对待其它字符一样使用百分号："

msgid ""
"Django takes care of the quoting for you; the resulting SQL will look "
"something like this:"
msgstr "Django 为你小心处理了引号；生成的 SQL 语句看起来像这样："

msgid ""
"Same goes for underscores. Both percentage signs and underscores are handled "
"for you transparently."
msgstr "同样的处理也包括下划线。百分号和下划线都为你自动处理，你无需担心。"

msgid "Caching and ``QuerySet``\\s"
msgstr "缓存和 ``QuerySet``"

msgid ""
"Each :class:`~django.db.models.query.QuerySet` contains a cache to minimize "
"database access. Understanding how it works will allow you to write the most "
"efficient code."
msgstr ""
"每个 :class:`~django.db.models.query.QuerySet` 都带有缓存，尽量减少数据库访"
"问。理解它是如何工作的能让你编写更高效的代码。"

msgid ""
"In a newly created :class:`~django.db.models.query.QuerySet`, the cache is "
"empty. The first time a :class:`~django.db.models.query.QuerySet` is "
"evaluated -- and, hence, a database query happens -- Django saves the query "
"results in the :class:`~django.db.models.query.QuerySet`’s cache and returns "
"the results that have been explicitly requested (e.g., the next element, if "
"the :class:`~django.db.models.query.QuerySet` is being iterated over). "
"Subsequent evaluations of the :class:`~django.db.models.query.QuerySet` "
"reuse the cached results."
msgstr ""
"新创建的 :class:`~django.db.models.query.QuerySet` 缓存是空的。一旦要计算 :"
"class:`~django.db.models.query.QuerySet` 的值，就会执行数据查询，随后，"
"Django 就会将查询结果保存在 :class:`~django.db.models.query.QuerySet` 的缓存"
"中，并返回这些显式请求的缓存（例如，下一个元素，若 :class:`~django.db.models."
"query.QuerySet` 正在被迭代）。后续针对 :class:`~django.db.models.query."
"QuerySet` 的计算会复用缓存结果。"

msgid ""
"Keep this caching behavior in mind, because it may bite you if you don't use "
"your :class:`~django.db.models.query.QuerySet`\\s correctly. For example, "
"the following will create two :class:`~django.db.models.query.QuerySet`\\s, "
"evaluate them, and throw them away::"
msgstr ""
"牢记这种缓存行为，在你错误使用 :class:`~django.db.models.query.QuerySet` 时可"
"能会被它咬一下。例如，以下会创建两个 :class:`~django.db.models.query."
"QuerySet`，计算它们，丢掉它们::"

msgid ""
"That means the same database query will be executed twice, effectively "
"doubling your database load. Also, there's a possibility the two lists may "
"not include the same database records, because an ``Entry`` may have been "
"added or deleted in the split second between the two requests."
msgstr ""
"这意味着同样的数据库查询会被执行两次，实际加倍了数据库负载。同时，有可能这两"
"个列表不包含同样的记录，因为在两次请求间，可能有 ``Entry`` 被添加或删除了。"

msgid ""
"To avoid this problem, save the :class:`~django.db.models.query.QuerySet` "
"and reuse it::"
msgstr ""
"要避免此问题，保存 :class:`~django.db.models.query.QuerySet` 并复用它::"

msgid "When ``QuerySet``\\s are not cached"
msgstr "当 ``QuerySet`` 未被缓存时"

msgid ""
"Querysets do not always cache their results.  When evaluating only *part* of "
"the queryset, the cache is checked, but if it is not populated then the "
"items returned by the subsequent query are not cached. Specifically, this "
"means that :ref:`limiting the queryset <limiting-querysets>` using an array "
"slice or an index will not populate the cache."
msgstr ""
"查询结果集并不总是缓存结果。当仅计算查询结果集的 *部分* 时，会校验缓存，若没"
"有填充缓存，则后续查询返回的项目不会被缓存。特别地说，这意味着使用数组切片或"
"索引的 :ref:`限制查询结果集 <limiting-querysets>` 不会填充缓存。"

msgid ""
"For example, repeatedly getting a certain index in a queryset object will "
"query the database each time::"
msgstr "例如，重复的从某个查询结果集对象中取指定索引的对象会每次都查询数据库::"

msgid ""
"However, if the entire queryset has already been evaluated, the cache will "
"be checked instead::"
msgstr "不过，若全部查询结果集已被检出，就会去检查缓存::"

msgid ""
"Here are some examples of other actions that will result in the entire "
"queryset being evaluated and therefore populate the cache::"
msgstr ""
"以下展示一些例子，这些动作会触发计算全部的查询结果集，并填充缓存的过程::"

msgid ""
"Simply printing the queryset will not populate the cache. This is because "
"the call to ``__repr__()`` only returns a slice of the entire queryset."
msgstr ""
"只是打印查询结果集不会填充缓存。因为调用 ``__repr__()`` 仅返回了完整结果集的"
"一个切片。"

msgid "Querying ``JSONField``"
msgstr "查询 ``JSONField``"

msgid ""
"Lookups implementation is different in :class:`~django.db.models.JSONField`, "
"mainly due to the existence of key transformations. To demonstrate, we will "
"use the following example model::"
msgstr ""
":class:`~django.db.models.JSONField` 里的查找实现是不一样的，主要因为存在键转"
"换。为了演示，我们将使用下面这个例子："

msgid "Storing and querying for ``None``"
msgstr "保存和查询 ``None`` 值"

msgid ""
"As with other fields, storing ``None`` as the field's value will store it as "
"SQL ``NULL``. While not recommended, it is possible to store JSON scalar "
"``null`` instead of SQL ``NULL`` by using :class:`Value('null') <django.db."
"models.Value>`."
msgstr ""
"与其他字段一样，将 ``None`` 作为字段的值存储为 SQL 的 ``NULL``。虽然不建议这"
"样做，但可以使用 :class:`Value('null') <django.db.models.Value>` 来存储 JSON "
"的 ``null`` 值。"

msgid ""
"Whichever of the values is stored, when retrieved from the database, the "
"Python representation of the JSON scalar ``null`` is the same as SQL "
"``NULL``, i.e. ``None``. Therefore, it can be hard to distinguish between "
"them."
msgstr ""
"无论存储哪种值，当从数据库检索时，JSON 标量 ``null`` 的 Python 表示法与 SQL "
"的 ``NULL`` 相同，即 ``None``。因此，可能很难区分它们。"

msgid ""
"This only applies to ``None`` as the top-level value of the field. If "
"``None`` is inside a :py:class:`list` or :py:class:`dict`, it will always be "
"interpreted as JSON ``null``."
msgstr ""
"这只适用于 ``None`` 值作为字段的顶级值。如果 ``None`` 被保存在列表或字典中，"
"它将始终被解释为 JSON 的 ``null`` 值。"

msgid ""
"When querying, ``None`` value will always be interpreted as JSON ``null``. "
"To query for SQL ``NULL``, use :lookup:`isnull`::"
msgstr ""
"当查询时，``None`` 值将一直被解释为 JSON 的 ``null``。要查询 SQL 的 "
"``NULL``，请使用 :lookup:`isnull` ："

msgid ""
"Unless you are sure you wish to work with SQL ``NULL`` values, consider "
"setting ``null=False`` and providing a suitable default for empty values, "
"such as ``default=dict``."
msgstr ""
"除非你确定要使用 SQL 的 ``NULL`` 值，否则请考虑设置 ``null=False`` 并为空值提"
"供合适的默认值，例如 ``default=dict`` 。"

msgid ""
"Storing JSON scalar ``null`` does not violate :attr:`null=False <django.db."
"models.Field.null>`."
msgstr ""
"保存 JSON 的 ``null`` 值不违反 Django 的 :attr:`null=False <django.db.models."
"Field.null>` 。"

msgid "Key, index, and path transforms"
msgstr "键、索引和路径转换"

msgid ""
"To query based on a given dictionary key, use that key as the lookup name::"
msgstr "为了查询给定的字典键，请将该键作为查询名："

msgid "Multiple keys can be chained together to form a path lookup::"
msgstr "可以将多个键链接起来形成一个路径查询："

msgid ""
"If the key is an integer, it will be interpreted as an index transform in an "
"array::"
msgstr "如果键是个整型，那么它将在数组中被解释成一个索引："

msgid ""
"If the key you wish to query by clashes with the name of another lookup, use "
"the :lookup:`contains <jsonfield.contains>` lookup instead."
msgstr ""
"如果要查询的键与另一个查询的键名冲突，请改用 :lookup:`contains <jsonfield."
"contains>` 来查询。"

msgid "To query for missing keys, use the ``isnull`` lookup::"
msgstr "如果查询时缺少键名，请使用 ``isnull`` 查询："

msgid ""
"The lookup examples given above implicitly use the :lookup:`exact` lookup. "
"Key, index, and path transforms can also be chained with: :lookup:"
"`icontains`, :lookup:`endswith`, :lookup:`iendswith`, :lookup:`iexact`, :"
"lookup:`regex`, :lookup:`iregex`, :lookup:`startswith`, :lookup:"
"`istartswith`, :lookup:`lt`, :lookup:`lte`, :lookup:`gt`, and :lookup:`gte`, "
"as well as with :ref:`containment-and-key-lookups`."
msgstr ""
"上面给出的例子隐式地使用了 :lookup:`exact` 查找。Key，索引和路径转换也可以"
"用：:lookup:`icontains`、:lookup:`endswith`、:lookup:`iendswith`、:lookup:"
"`iexact`、:lookup:`regex`、:lookup:`iregex`、:lookup:`startswith`、:lookup:"
"`istartswith`、:lookup:`lt`、:lookup:`lte`、:lookup:`gt`、:lookup:`gte` 以"
"及 :ref:`containment-and-key-lookups` 。"

msgid ""
"Due to the way in which key-path queries work, :meth:`~django.db.models."
"query.QuerySet.exclude` and :meth:`~django.db.models.query.QuerySet.filter` "
"are not guaranteed to produce exhaustive sets. If you want to include "
"objects that do not have the path, add the ``isnull`` lookup."
msgstr ""
"由于键-路径查询的工作方式，:meth:`~django.db.models.querySet.exclude` 和 :"
"meth:`~django.db.models.querySet.filter` 不能保证产生详尽的集合。如果你想包含"
"没有路径的对象，请添加 ``isnull`` 查找。"

msgid ""
"Since any string could be a key in a JSON object, any lookup other than "
"those listed below will be interpreted as a key lookup. No errors are "
"raised. Be extra careful for typing mistakes, and always check your queries "
"work as you intend."
msgstr ""
"由于任何字符串都可以成为 JSON 对象中的一个键，除了下面列出的那些之外，任何查"
"询都将被解释为一个键查询。不会出现错误。要格外小心打字错误，并经常检查你的查"
"询是否按你的意图进行。"

msgid "MariaDB and Oracle users"
msgstr "MariaDB 和 Oracle 用户"

msgid ""
"Using :meth:`~django.db.models.query.QuerySet.order_by` on key, index, or "
"path transforms will sort the objects using the string representation of the "
"values. This is because MariaDB and Oracle Database do not provide a "
"function that converts JSON values into their equivalent SQL values."
msgstr ""
"在键、索引或路径转换上使用 :meth:`~django.db.models.querySet.order_by` 将使用"
"值的字符串表示法对对象进行排序。这是因为 MariaDB 和 Oracle 数据库没有提供将 "
"JSON 值转换为其等价的 SQL 值的函数。"

msgid "Oracle users"
msgstr "Oracle 用户"

msgid ""
"On Oracle Database, using ``None`` as the lookup value in an :meth:`~django."
"db.models.query.QuerySet.exclude` query will return objects that do not have "
"``null`` as the value at the given path, including objects that do not have "
"the path. On other database backends, the query will return objects that "
"have the path and the value is not ``null``."
msgstr ""
"在 Oracle 数据库中，在 :meth:`~django.db.models.querySet.exclude` 查询中使用 "
"``None`` 作为查询值，将返回没有 ``null`` 作为指定路径的对象，包括没有路径的对"
"象。在其他数据库后端，该查询将返回具有该路径且其值不是 ``null`` 的对象。"

msgid "PostgreSQL users"
msgstr "PostgreSQL 用户"

msgid ""
"On PostgreSQL, if only one key or index is used, the SQL operator ``->`` is "
"used. If multiple operators are used then the ``#>`` operator is used."
msgstr ""
"在 PostgreSQL 上，如果只使用一个键或索引，那么会使用 SQL 运算符 ``->`` 。如果"
"使用多个操作符，则会使用 ``#>`` 运算符。"

msgid "Containment and key lookups"
msgstr "包含与键查找"

msgid "``contains``"
msgstr "``contains``"

msgid ""
"The :lookup:`contains` lookup is overridden on ``JSONField``. The returned "
"objects are those where the given ``dict`` of key-value pairs are all "
"contained in the top-level of the field. For example::"
msgstr ""
"``JSONField`` 上的 :lookup:`contains` 查找已被覆盖。返回的对象是那些给定的键"
"值对都包含在顶级字段中的对象。例如："

msgid "Oracle and SQLite"
msgstr "Oracle 和 SQLite"

msgid "``contains`` is not supported on Oracle and SQLite."
msgstr "Oracle 和 SQLite 不支持 ``contains`` 。"

msgid "``contained_by``"
msgstr "``contained_by``"

msgid ""
"This is the inverse of the :lookup:`contains <jsonfield.contains>` lookup - "
"the objects returned will be those where the key-value pairs on the object "
"are a subset of those in the value passed. For example::"
msgstr ""
"这是 :lookup:`contains <jsonfield.contains>` 查找逆过程——返回的对象将是那些传"
"递的值中的子集在对象上的键值对。例如："

msgid "``contained_by`` is not supported on Oracle and SQLite."
msgstr "Oracle 和 SQLite 不支持 ``contained_by`` 。"

msgid "``has_key``"
msgstr "``has_key``"

msgid ""
"Returns objects where the given key is in the top-level of the data. For "
"example::"
msgstr "返回给定的键位于数据顶层的对象。例如："

msgid "``has_keys``"
msgstr "``has_keys``"

msgid ""
"Returns objects where all of the given keys are in the top-level of the "
"data. For example::"
msgstr "返回所有给定的键位于数据顶层的对象。例如："

msgid "``has_any_keys``"
msgstr "``has_any_keys``"

msgid ""
"Returns objects where any of the given keys are in the top-level of the "
"data. For example::"
msgstr "返回任何给定的键位于数据顶层的对象。例如："

msgid "Complex lookups with ``Q`` objects"
msgstr "通过 ``Q`` 对象完成复杂查询"

msgid ""
"Keyword argument queries -- in :meth:`~django.db.models.query.QuerySet."
"filter`, etc. -- are \"AND\"ed together. If you need to execute more complex "
"queries (for example, queries with ``OR`` statements), you can use :class:`Q "
"objects <django.db.models.Q>`."
msgstr ""
"在类似 :meth:`~django.db.models.query.QuerySet.filter` 中，查询使用的关键字参"
"数是通过 \"AND\" 连接起来的。如果你要执行更复杂的查询（例如，由 ``OR`` 语句连"
"接的查询），你可以使用 :class:`Q 对象 <django.db.models.Q>`。"

msgid ""
"A :class:`Q object <django.db.models.Q>` (``django.db.models.Q``) is an "
"object used to encapsulate a collection of keyword arguments. These keyword "
"arguments are specified as in \"Field lookups\" above."
msgstr ""
"一个 :class:`Q 对象 <django.db.models.Q>` (``django.db.models.Q``) 用于压缩关"
"键字参数集合。这些关键字参数由前文 \"Field lookups\" 指定。"

msgid "For example, this ``Q`` object encapsulates a single ``LIKE`` query::"
msgstr "例如，该 ``Q`` 对象压缩了一个 ``LIKE`` 查询::"

msgid ""
"``Q`` objects can be combined using the ``&`` and ``|`` operators. When an "
"operator is used on two ``Q`` objects, it yields a new ``Q`` object."
msgstr ""
"``Q`` 对象能通过 ``&`` 和 ``|`` 操作符连接起来。当操作符被用于两个 ``Q`` 对象"
"之间时会生成一个新的 ``Q`` 对象。"

msgid ""
"For example, this statement yields a single ``Q`` object that represents the "
"\"OR\" of two ``\"question__startswith\"`` queries::"
msgstr ""
"例如，该语句生成一个 ``Q`` 对象，表示两个 ``\"question_startswith\"`` 查询语"
"句之间的 \"OR\" 关系::"

msgid "This is equivalent to the following SQL ``WHERE`` clause::"
msgstr "这等价于以下 SQL ``WHERE`` 字句::"

msgid ""
"You can compose statements of arbitrary complexity by combining ``Q`` "
"objects with the ``&`` and ``|`` operators and use parenthetical grouping. "
"Also, ``Q`` objects can be negated using the ``~`` operator, allowing for "
"combined lookups that combine both a normal query and a negated (``NOT``) "
"query::"
msgstr ""
"你能通过 ``&`` 和 ``|`` 操作符和括号分组，组合任意复杂度的语句。当然， ``Q`` "
"对象也可通过 ``~`` 操作符反转，允许在组合查询中组合普通查询或反向 (``NOT``) "
"查询::"

msgid ""
"Each lookup function that takes keyword-arguments (e.g. :meth:`~django.db."
"models.query.QuerySet.filter`, :meth:`~django.db.models.query.QuerySet."
"exclude`, :meth:`~django.db.models.query.QuerySet.get`) can also be passed "
"one or more ``Q`` objects as positional (not-named) arguments. If you "
"provide multiple ``Q`` object arguments to a lookup function, the arguments "
"will be \"AND\"ed together. For example::"
msgstr ""
"每个接受关键字参数的查询函数 (例如 :meth:`~django.db.models.query.QuerySet."
"filter`， :meth:`~django.db.models.query.QuerySet.exclude`， :meth:`~django."
"db.models.query.QuerySet.get`) 也同时接受一个或多个 ``Q`` 对象作为位置（未命"
"名的）参数。若你为查询函数提供了多个 ``Q`` 对象参数，这些参数会通过 \"AND\" "
"连接。例子::"

msgid "... roughly translates into the SQL:"
msgstr "...粗略地转为 SQL："

msgid ""
"Lookup functions can mix the use of ``Q`` objects and keyword arguments. All "
"arguments provided to a lookup function (be they keyword arguments or ``Q`` "
"objects) are \"AND\"ed together. However, if a ``Q`` object is provided, it "
"must precede the definition of any keyword arguments. For example::"
msgstr ""
"查询函数能混合使用 ``Q`` 对象和关键字参数。所有提供给查询函数的参数（即关键字"
"参数或 ``Q`` 对象）均通过 \"AND\" 连接。然而，若提供了 ``Q`` 对象，那么它必须"
"位于所有关键字参数之前。例子::"

msgid "... would be a valid query, equivalent to the previous example; but::"
msgstr "……会是一个有效的查询，等效于前文的例子；但是::"

msgid "... would not be valid."
msgstr "……却是无效的。"

msgid ""
"The :source:`OR lookups examples <tests/or_lookups/tests.py>` in Django's "
"unit tests show some possible uses of ``Q``."
msgstr ""
"Django 单元测试中的 :source:`OR 查询实例 <tests/or_lookups/tests.py>` 展示了 "
"``Q`` 的用法。"

msgid "Comparing objects"
msgstr "比较对象"

msgid ""
"To compare two model instances, use the standard Python comparison operator, "
"the double equals sign: ``==``. Behind the scenes, that compares the primary "
"key values of two models."
msgstr ""
"要比较两个模型实例，使用标准的 Python 比较操作符，两个等号： ``==``。实际上，"
"这比较了两个模型实例的主键值。"

msgid ""
"Using the ``Entry`` example above, the following two statements are "
"equivalent::"
msgstr "使用前文的 ``Entry``，以下的两个语句是等效的::"

msgid ""
"If a model's primary key isn't called ``id``, no problem. Comparisons will "
"always use the primary key, whatever it's called. For example, if a model's "
"primary key field is called ``name``, these two statements are equivalent::"
msgstr ""
"若模型主键名不是 ``id``，没问题。比较时总会使用主键，不管它叫啥。例如，若模型"
"的主键字段名为 ``name``，以下两个语句是等效的::"

msgid "Deleting objects"
msgstr "删除对象"

msgid ""
"The delete method, conveniently, is named :meth:`~django.db.models.Model."
"delete`. This method immediately deletes the object and returns the number "
"of objects deleted and a dictionary with the number of deletions per object "
"type. Example::"
msgstr ""
"通常，删除方法被命名为 :meth:`~django.db.models.Model.delete`。该方法立刻删除"
"对象，并返回被删除的对象数量和一个包含了每个被删除对象类型的数量的字典。例"
"子::"

msgid ""
"You can also delete objects in bulk. Every :class:`~django.db.models.query."
"QuerySet` has a :meth:`~django.db.models.query.QuerySet.delete` method, "
"which deletes all members of that :class:`~django.db.models.query.QuerySet`."
msgstr ""
"你也能批量删除对象。所有 :class:`~django.db.models.query.QuerySet` 都有个 :"
"meth:`~django.db.models.query.QuerySet.delete` 方法，它会删除 :class:"
"`~django.db.models.query.QuerySet` 中的所有成员。"

msgid ""
"For example, this deletes all ``Entry`` objects with a ``pub_date`` year of "
"2005::"
msgstr "例如，这会删除 2005 发布的所有 ``Entry`` 对象::"

msgid ""
"Keep in mind that this will, whenever possible, be executed purely in SQL, "
"and so the ``delete()`` methods of individual object instances will not "
"necessarily be called during the process. If you've provided a custom "
"``delete()`` method on a model class and want to ensure that it is called, "
"you will need to \"manually\" delete instances of that model (e.g., by "
"iterating over a :class:`~django.db.models.query.QuerySet` and calling "
"``delete()`` on each object individually) rather than using the bulk :meth:"
"`~django.db.models.query.QuerySet.delete` method of a :class:`~django.db."
"models.query.QuerySet`."
msgstr ""
"请记住，只要有机会的话，这会通过纯 SQL 语句执行，所以就无需在过程中调用每个对"
"象的删除方法了。若你为模型类提供了自定义的 ``delete()`` 方法，且希望确保调用"
"了该方法，你需要 “手动” 删除该模型的实例（例如，如，遍历 :class:`~django.db."
"models.query.QuerySet`，在每个对象上分别调用 ``delete()`` 方法），而不是使"
"用 :class:`~django.db.models.query.QuerySet` 的批量删除方法 :meth:`~django."
"db.models.query.QuerySet.delete`。"

msgid ""
"When Django deletes an object, by default it emulates the behavior of the "
"SQL constraint ``ON DELETE CASCADE`` -- in other words, any objects which "
"had foreign keys pointing at the object to be deleted will be deleted along "
"with it. For example::"
msgstr ""
"当 Django 删除某个对象时，默认会模仿 SQL 约束 ``ON DELETE CASCADE`` 的行为——"
"换而言之，某个对象被删除时，关联对象也会被删除。例子::"

msgid ""
"This cascade behavior is customizable via the :attr:`~django.db.models."
"ForeignKey.on_delete` argument to the :class:`~django.db.models.ForeignKey`."
msgstr ""
"这种约束行为由 :class:`~django.db.models.ForeignKey` 的 :attr:`~django.db."
"models.ForeignKey.on_delete` 参数指定。"

msgid ""
"Note that :meth:`~django.db.models.query.QuerySet.delete` is the only :class:"
"`~django.db.models.query.QuerySet` method that is not exposed on a :class:"
"`~django.db.models.Manager` itself. This is a safety mechanism to prevent "
"you from accidentally requesting ``Entry.objects.delete()``, and deleting "
"*all* the entries. If you *do* want to delete all the objects, then you have "
"to explicitly request a complete query set::"
msgstr ""
"注意 :meth:`~django.db.models.query.QuerySet.delete` 是唯一未在 :class:"
"`~django.db.models.Manager` 上暴漏的 :class:`~django.db.models.query."
"QuerySet` 方法。这是一种安全机制，避免你不小心调用了 ``Entry.objects."
"delete()``，删除了 *所有的* 条目。若你 *确实* 想要删除所有对象，你必须显示请"
"求完整结果集合::"

msgid "Copying model instances"
msgstr "复制模型实例"

msgid ""
"Although there is no built-in method for copying model instances, it is "
"possible to easily create new instance with all fields' values copied. In "
"the simplest case, you can set ``pk`` to ``None`` and :attr:`_state.adding "
"<django.db.models.Model._state>` to ``True``. Using our blog example::"
msgstr ""

msgid ""
"Things get more complicated if you use inheritance. Consider a subclass of "
"``Blog``::"
msgstr "若你使用了集成，事情会更复杂。考虑下 ``Blog`` 的一个子类::"

msgid ""
"Due to how inheritance works, you have to set both ``pk`` and ``id`` to "
"``None``, and ``_state.adding`` to ``True``::"
msgstr ""

msgid ""
"This process doesn't copy relations that aren't part of the model's database "
"table. For example, ``Entry`` has a ``ManyToManyField`` to ``Author``. After "
"duplicating an entry, you must set the many-to-many relations for the new "
"entry::"
msgstr ""
"该方法不会拷贝不是模型数据表中的关联关系。例如， ``Entry`` 有一个对 "
"``Author`` 的 ``ManyToManyField`` 关联关系。在复制条目后，你必须为新条目设置"
"多对多关联关系。"

msgid ""
"For a ``OneToOneField``, you must duplicate the related object and assign it "
"to the new object's field to avoid violating the one-to-one unique "
"constraint. For example, assuming ``entry`` is already duplicated as above::"
msgstr ""
"对于 ``OneToOneField`` 关联，你必须拷贝关联对象，并将其指定给新对象的关联字"
"段，避免违反一对一唯一性约束。例如，指定前文复制的 ``entry``::"

msgid "Updating multiple objects at once"
msgstr "一次修改多个对象"

msgid ""
"Sometimes you want to set a field to a particular value for all the objects "
"in a :class:`~django.db.models.query.QuerySet`. You can do this with the :"
"meth:`~django.db.models.query.QuerySet.update` method. For example::"
msgstr ""
"有时候，你想统一设置 :class:`~django.db.models.query.QuerySet` 中的所有对象的"
"某个字段。你可以通过 :meth:`~django.db.models.query.QuerySet.update` 达到目"
"的。例子::"

msgid ""
"You can only set non-relation fields and :class:`~django.db.models."
"ForeignKey` fields using this method. To update a non-relation field, "
"provide the new value as a constant. To update :class:`~django.db.models."
"ForeignKey` fields, set the new value to be the new model instance you want "
"to point to. For example::"
msgstr ""
"你仅能用此方法设置非关联字段和 :class:`~django.db.models.ForeignKey` 字段。要"
"修改非关联字段，需要用常量提供新值。要修改 :class:`~django.db.models."
"ForeignKey` 字段，将新值置为目标模型的新实例。例子::"

msgid ""
"The ``update()`` method is applied instantly and returns the number of rows "
"matched by the query (which may not be equal to the number of rows updated "
"if some rows already have the new value). The only restriction on the :class:"
"`~django.db.models.query.QuerySet` being updated is that it can only access "
"one database table: the model's main table. You can filter based on related "
"fields, but you can only update columns in the model's main table. Example::"
msgstr ""
"方法 ``update()`` 立刻被运行，并返回匹配查询调节的行数（若某些行早已是新值，"
"则可能不等于实际匹配的行数）。更新 :class:`~django.db.models.query.QuerySet` "
"的唯一限制即它只能操作一个数据表：该模型的主表。你可以基于关联字段进行筛选，"
"但你只能更新模型主表中的列。例子::"

msgid ""
"Be aware that the ``update()`` method is converted directly to an SQL "
"statement. It is a bulk operation for direct updates. It doesn't run any :"
"meth:`~django.db.models.Model.save` methods on your models, or emit the "
"``pre_save`` or ``post_save`` signals (which are a consequence of calling :"
"meth:`~django.db.models.Model.save`), or honor the :attr:`~django.db.models."
"DateField.auto_now` field option. If you want to save every item in a :class:"
"`~django.db.models.query.QuerySet` and make sure that the :meth:`~django.db."
"models.Model.save` method is called on each instance, you don't need any "
"special function to handle that. Loop over them and call :meth:`~django.db."
"models.Model.save`::"
msgstr ""
"要认识到 ``update()`` 方法是直接转为 SQL 语句的。这是一种用于直接更新的批量操"
"作。它并不会调用模型的 :meth:`~django.db.models.Model.save` 方法，或发射 "
"``pre_save`` 或 ``post_save`` 信号（调用 :meth:`~django.db.models.Model."
"save` 会触发信号），或使用 :attr:`~django.db.models.DateField.auto_now` 字段"
"选项。若想保存 :class:`~django.db.models.query.QuerySet` 中的每项，并确保调用"
"了每个实例的 :meth:`~django.db.models.Model.save` 方法，你并不需要任何特殊的"
"函数来处理此问题。迭代它们，并调用它们的 :meth:`~django.db.models.Model."
"save` 方法::"

msgid ""
"Calls to update can also use :class:`F expressions <django.db.models.F>` to "
"update one field based on the value of another field in the model. This is "
"especially useful for incrementing counters based upon their current value. "
"For example, to increment the pingback count for every entry in the blog::"
msgstr ""
"调用更新方法时也能使用 :class:`F 表达式 <django.db.models.F>` 基于同一模型另"
"一个字段的值更新某个字段。这在基于计数器的当前值增加其值时特别有用。例如，要"
"增加针对博客中每项条目的 pingback 技术::"

msgid ""
"However, unlike ``F()`` objects in filter and exclude clauses, you can't "
"introduce joins when you use ``F()`` objects in an update -- you can only "
"reference fields local to the model being updated. If you attempt to "
"introduce a join with an ``F()`` object, a ``FieldError`` will be raised::"
msgstr ""
"然而，与过滤器中的 ``F()`` 对象和排除字句不同，你不能在更新方法中使用 "
"``F()`` 对象的同时使用 join——你只能引用被更新模型的内部字段。若你试着在使用 "
"join 字句时使用 ``F()`` 对象，会抛出一个 ``FieldError()``::"

msgid "Related objects"
msgstr "关联对象"

msgid ""
"When you define a relationship in a model (i.e., a :class:`~django.db.models."
"ForeignKey`, :class:`~django.db.models.OneToOneField`, or :class:`~django.db."
"models.ManyToManyField`), instances of that model will have a convenient API "
"to access the related object(s)."
msgstr ""
"当你在模型中定义了关联关系（如 :class:`~django.db.models.ForeignKey`， :"
"class:`~django.db.models.OneToOneField`， 或 :class:`~django.db.models."
"ManyToManyField`），该模型的实例将会自动获取一套 API，能快捷地访问关联对象。"

msgid ""
"Using the models at the top of this page, for example, an ``Entry`` object "
"``e`` can get its associated ``Blog`` object by accessing the ``blog`` "
"attribute: ``e.blog``."
msgstr ""
"拿本文开始的模型做例子，一个 ``Entry`` 对象 ``e`` 通过 ``blog`` 属性获取其关"
"联的 ``Blog`` 对象： ``e.blog``。"

msgid ""
"(Behind the scenes, this functionality is implemented by Python :doc:"
"`descriptors <python:howto/descriptor>`. This shouldn't really matter to "
"you, but we point it out here for the curious.)"
msgstr ""
"（在幕后，这个函数是由  Python :doc:`descriptors <python:howto/descriptor>` "
"实现的。这玩意一般不会麻烦你，但是我们为你指出了注意点。）"

msgid ""
"Django also creates API accessors for the \"other\" side of the relationship "
"-- the link from the related model to the model that defines the "
"relationship. For example, a ``Blog`` object ``b`` has access to a list of "
"all related ``Entry`` objects via the ``entry_set`` attribute: ``b.entry_set."
"all()``."
msgstr ""
"Django 也提供了从关联关系 *另一边* 访问的 API —— 从被关联模型到定义关联关系的"
"模型的连接。例如，一个 ``Blog`` 对象 ``b`` 能通过 ``entry_set`` 属性 ``b."
"entry_set.all()`` 访问包含所有关联 ``Entry`` 对象的列表。"

msgid ""
"All examples in this section use the sample ``Blog``, ``Author`` and "
"``Entry`` models defined at the top of this page."
msgstr ""
"本章节中的所有例子都是用了本页开头定义的 ``Blog``， ``Author`` 和 ``Entry`` "
"模型。"

msgid "One-to-many relationships"
msgstr "一对多关联"

msgid "Forward"
msgstr "正向访问"

msgid ""
"If a model has a :class:`~django.db.models.ForeignKey`, instances of that "
"model will have access to the related (foreign) object via an attribute of "
"the model."
msgstr ""
"若模型有个 :class:`~django.db.models.ForeignKey`，该模型的实例能通过其属性访"
"问关联（外部的）对象。"

msgid ""
"You can get and set via a foreign-key attribute. As you may expect, changes "
"to the foreign key aren't saved to the database until you call :meth:"
"`~django.db.models.Model.save`. Example::"
msgstr ""
"你可以通过 foreign-key 属性获取和设置值。如你所想，对外键的修改直到你调用 :"
"meth:`~django.db.models.Model.save` 后才会被存入数据库。例子::"

msgid ""
"If a :class:`~django.db.models.ForeignKey` field has ``null=True`` set (i."
"e., it allows ``NULL`` values), you can assign ``None`` to remove the "
"relation. Example::"
msgstr ""
"若 :class:`~django.db.models.ForeignKey` 字段配置了 ``null=True`` （即其允许 "
"``NULL`` 值），你可以指定值为 ``None`` 移除关联。例子::"

msgid ""
"Forward access to one-to-many relationships is cached the first time the "
"related object is accessed. Subsequent accesses to the foreign key on the "
"same object instance are cached. Example::"
msgstr ""
"首次通过正向一对多关联访问关联对象时会缓存关联关系。后续在同一对象上通过外键"
"的访问也会被缓存。例子::"

msgid ""
"Note that the :meth:`~django.db.models.query.QuerySet.select_related` :class:"
"`~django.db.models.query.QuerySet` method recursively prepopulates the cache "
"of all one-to-many relationships ahead of time. Example::"
msgstr ""
"注意 :meth:`~django.db.models.query.QuerySet.select_related`  :class:"
"`~django.db.models.query.QuerySet` 方法会预先用所有一对多关联对象填充缓存。例"
"子::"

msgid "Following relationships \"backward\""
msgstr "“反向” 关联"

msgid ""
"If a model has a :class:`~django.db.models.ForeignKey`, instances of the "
"foreign-key model will have access to a :class:`~django.db.models.Manager` "
"that returns all instances of the first model. By default, this :class:"
"`~django.db.models.Manager` is named ``FOO_set``, where ``FOO`` is the "
"source model name, lowercased. This :class:`~django.db.models.Manager` "
"returns ``QuerySets``, which can be filtered and manipulated as described in "
"the \"Retrieving objects\" section above."
msgstr ""
"若模型有 :class:`~django.db.models.ForeignKey`，外键关联的模型实例将能访问 :"
"class:`~django.db.models.Manager`，后者会返回第一个模型的所有实例。默认情况"
"下，该 :class:`~django.db.models.Manager` 名为 ``FOO_set``， ``FOO`` 即源模型"
"名的小写形式。 :class:`~django.db.models.Manager` 返回 ``QuerySets``，后者能"
"以 “检索对象” 章节介绍的方式进行筛选和操作。"

msgid ""
"You can override the ``FOO_set`` name by setting the :attr:`~django.db."
"models.ForeignKey.related_name` parameter in the :class:`~django.db.models."
"ForeignKey` definition. For example, if the ``Entry`` model was altered to "
"``blog = ForeignKey(Blog, on_delete=models.CASCADE, "
"related_name='entries')``, the above example code would look like this::"
msgstr ""
"你可以在定义 :class:`~django.db.models.ForeignKey` 时设置 :attr:`~django.db."
"models.ForeignKey.related_name` 参数重写这个 ``FOO_set`` 名。例如，若修改 "
"``Entry`` 模型为 ``blog = ForeignKey(Blog, on_delete=models.CASCADE, "
"related_name='entries')``，前文示例代码会看起来像这样::"

msgid "Using a custom reverse manager"
msgstr "使用自定义反向管理器"

msgid ""
"By default the :class:`~django.db.models.fields.related.RelatedManager` used "
"for reverse relations is a subclass of the :ref:`default manager <manager-"
"names>` for that model. If you would like to specify a different manager for "
"a given query you can use the following syntax::"
msgstr ""
":class:`~django.db.models.fields.related.RelatedManager` 反向关联的默认实现是"
"该模型 :ref:`默认管理器 <manager-names>` 一个实例。若你想为某个查询指定一个不"
"同的管理器，可以使用如下语法::"

msgid ""
"If ``EntryManager`` performed default filtering in its ``get_queryset()`` "
"method, that filtering would apply to the ``all()`` call."
msgstr ""
"若 ``EntryManager`` 在其 ``get_queryset()`` 方法执行了默认过滤行为，改行为会"
"应用到 ``all()`` 调用中。"

msgid ""
"Specifying a custom reverse manager also enables you to call its custom "
"methods::"
msgstr "指定一个自定义反向管理也允许你调用模型自定义方法::"

msgid "Additional methods to handle related objects"
msgstr "管理关联对象的额外方法"

msgid ""
"In addition to the :class:`~django.db.models.query.QuerySet` methods defined "
"in \"Retrieving objects\" above, the :class:`~django.db.models.ForeignKey` :"
"class:`~django.db.models.Manager` has additional methods used to handle the "
"set of related objects. A synopsis of each is below, and complete details "
"can be found in the :doc:`related objects reference </ref/models/relations>`."
msgstr ""
":class:`~django.db.models.ForeignKey` :class:`~django.db.models.Manager` 还有"
"方法能处理关联对象集合。除了上面的 “检索对象” 中定义的 :class:`~django.db."
"models.query.QuerySet` 方法以外，以下是每项的简要介绍，而完整的细节能在 :doc:"
"`关联对象参考 </ref/models/relations>` 中找到。"

msgid "``add(obj1, obj2, ...)``"
msgstr "``add(obj1, obj2, ...)``"

msgid "Adds the specified model objects to the related object set."
msgstr "将特定的模型对象加入关联对象集合。"

msgid "``create(**kwargs)``"
msgstr "``create(**kwargs)``"

msgid ""
"Creates a new object, saves it and puts it in the related object set. "
"Returns the newly created object."
msgstr "创建一个新对象，保存，并将其放入关联对象集合中。返回新创建的对象。"

msgid "``remove(obj1, obj2, ...)``"
msgstr "``remove(obj1, obj2, ...)``"

msgid "Removes the specified model objects from the related object set."
msgstr "从关联对象集合删除指定模型对象。"

msgid "``clear()``"
msgstr "``clear()``"

msgid "Removes all objects from the related object set."
msgstr "从关联对象集合删除所有对象。"

msgid "``set(objs)``"
msgstr "``set(objs)``"

msgid "Replace the set of related objects."
msgstr "替换关联对象集合"

msgid ""
"To assign the members of a related set, use the ``set()`` method with an "
"iterable of object instances. For example, if ``e1`` and ``e2`` are "
"``Entry`` instances::"
msgstr ""
"要指定关联集合的成员，调用 ``set()`` 方法，并传入可迭代的对象实例集合。例如，"
"若 ``e1`` 和 ``e2`` 都是 ``Entry`` 实例::"

msgid ""
"If the ``clear()`` method is available, any pre-existing objects will be "
"removed from the ``entry_set`` before all objects in the iterable (in this "
"case, a list) are added to the set. If the ``clear()`` method is *not* "
"available, all objects in the iterable will be added without removing any "
"existing elements."
msgstr ""
"若能使用 ``clear()`` 方法， ``entry_set`` 中所有旧对象会在将可迭代集合（本例"
"中是个列表）中的对象加入其中之前被删除。若 *不能* 使用 ``clear()`` 方法，添加"
"新对象时不会删除旧对象。"

msgid ""
"Each \"reverse\" operation described in this section has an immediate effect "
"on the database. Every addition, creation and deletion is immediately and "
"automatically saved to the database."
msgstr ""
"本节介绍的所有 “反向” 操作对数据库都是立刻生效的。每次的增加，创建和删除都是"
"及时自动地保存至数据库。"

msgid ""
"Both ends of a many-to-many relationship get automatic API access to the "
"other end. The API works similar to a \"backward\" one-to-many relationship, "
"above."
msgstr ""
"多对多关联的两端均自动获取访问另一端的 API。该 API 的工作方式类似上面的 “反"
"向” 一对多关联。"

msgid ""
"One difference is in the attribute naming: The model that defines the :class:"
"`~django.db.models.ManyToManyField` uses the attribute name of that field "
"itself, whereas the \"reverse\" model uses the lowercased model name of the "
"original model, plus ``'_set'`` (just like reverse one-to-many "
"relationships)."
msgstr ""
"不同点在为属性命名上：定义了 :class:`~django.db.models.ManyToManyField` 的模"
"型使用字段名作为属性名，而 “反向” 模型使用源模型名的小写形式，加上 "
"``'_set'`` （就像反向一对多关联一样）。"

msgid "An example makes this easier to understand::"
msgstr "一个更易理解的例子::"

msgid ""
"Like :class:`~django.db.models.ForeignKey`, :class:`~django.db.models."
"ManyToManyField` can specify :attr:`~django.db.models.ManyToManyField."
"related_name`. In the above example, if the :class:`~django.db.models."
"ManyToManyField` in ``Entry`` had specified ``related_name='entries'``, then "
"each ``Author`` instance would have an ``entries`` attribute instead of "
"``entry_set``."
msgstr ""
"和 :class:`~django.db.models.ForeignKey` 一样， :class:`~django.db.models."
"ManyToManyField` 能指定 :attr:`~django.db.models.ManyToManyField."
"related_name`。在上面的例子中，若 ``Entry`` 中的 :class:`~django.db.models."
"ManyToManyField` 已指定了 ``related_name='entries'``，随后每个 ``Author`` 实"
"例会拥有一个 ``entries`` 属性，而不是 ``entry_set``。"

msgid ""
"Another difference from one-to-many relationships is that in addition to "
"model instances,  the ``add()``, ``set()``, and ``remove()`` methods on many-"
"to-many relationships accept primary key values. For example, if ``e1`` and "
"``e2`` are ``Entry`` instances, then these ``set()`` calls work identically::"
msgstr ""
"另一个与一对多关联不同的地方是，除了模型实例以外，多对多关联中的 ``add()``， "
"``set()`` 和 ``remove()`` 方法能接收主键值。例如，若 ``e`` 和 ``e2`` 是 "
"``Entry`` 的实例，以下两种 ``set()`` 调用结果一致::"

msgid ""
"One-to-one relationships are very similar to many-to-one relationships. If "
"you define a :class:`~django.db.models.OneToOneField` on your model, "
"instances of that model will have access to the related object via an "
"attribute of the model."
msgstr ""
"一对一关联与多对一关联非常类似。若在模型中定义了 :class:`~django.db.models."
"OneToOneField`，该模型的实例只需通过其属性就能访问关联对象。"

msgid ""
"The difference comes in \"reverse\" queries. The related model in a one-to-"
"one relationship also has access to a :class:`~django.db.models.Manager` "
"object, but that :class:`~django.db.models.Manager` represents a single "
"object, rather than a collection of objects::"
msgstr ""
"不同点在于 “反向” 查询。一对一关联所关联的对象也能访问 :class:`~django.db."
"models.Manager` 对象，但这个 :class:`~django.db.models.Manager` 仅代表一个对"
"象，而不是对象的集合::"

msgid ""
"If no object has been assigned to this relationship, Django will raise a "
"``DoesNotExist`` exception."
msgstr "若未为关联关系指定对象，Django 会抛出 ``DoesNotExist`` 异常。"

msgid ""
"Instances can be assigned to the reverse relationship in the same way as you "
"would assign the forward relationship::"
msgstr "实例能通过为正向关联指定关联对象一样的方式指定给反向关联::"

msgid "How are the backward relationships possible?"
msgstr "反向关联是如何实现的？"

msgid ""
"Other object-relational mappers require you to define relationships on both "
"sides. The Django developers believe this is a violation of the DRY (Don't "
"Repeat Yourself) principle, so Django only requires you to define the "
"relationship on one end."
msgstr ""
"其它对象关联映射实现要求你在两边都定义关联关系。而 Django 开发者坚信这违反了 "
"DRY 原则（不要自我重复），故 Django 仅要求你在一端定义关联关系。"

msgid ""
"But how is this possible, given that a model class doesn't know which other "
"model classes are related to it until those other model classes are loaded?"
msgstr ""
"但这是如何实现的呢，给你一个模型类，模型类并不知道是否有其它模型类关联它，直"
"到其它模型类被加载？"

msgid ""
"The answer lies in the :data:`app registry <django.apps.apps>`. When Django "
"starts, it imports each application listed in :setting:`INSTALLED_APPS`, and "
"then the ``models`` module inside each application. Whenever a new model "
"class is created, Django adds backward-relationships to any related models. "
"If the related models haven't been imported yet, Django keeps tracks of the "
"relationships and adds them when the related models eventually are imported."
msgstr ""
"答案位于 :data:`应用注册 <django.apps.apps>`。 Django 启动时，它会导入 :"
"setting:`INSTALLED_APPS` 列出的每个应用，和每个应用中的 ``model`` 模块。无论"
"何时创建了一个新模型类，Django 为每个关联模型添加反向关联。若被关联的模型未被"
"导入，Django 会持续追踪这些关联，并在关联模型被导入时添加关联关系。"

msgid ""
"For this reason, it's particularly important that all the models you're "
"using be defined in applications listed in :setting:`INSTALLED_APPS`. "
"Otherwise, backwards relations may not work properly."
msgstr ""
"出于这个原因，包含你所使用的所有模型的应用必须列在 :setting:`INSTALLED_APPS` "
"中。否则，反向关联可能不会正常工作。"

msgid "Queries over related objects"
msgstr "查询关联对象"

msgid ""
"Queries involving related objects follow the same rules as queries involving "
"normal value fields. When specifying the value for a query to match, you may "
"use either an object instance itself, or the primary key value for the "
"object."
msgstr ""
"涉及关联对象的查询与涉及普通字段的查询遵守同样的规则。未查询条件指定值时，你"
"可以使用对象实例，或该实例的主键。"

msgid ""
"For example, if you have a Blog object ``b`` with ``id=5``, the following "
"three queries would be identical::"
msgstr "例如，若有个博客对象 ``b``，其 ``id=5``，以下三种查询是一样的::"

msgid "Falling back to raw SQL"
msgstr "回归原生 SQL"

msgid ""
"If you find yourself needing to write an SQL query that is too complex for "
"Django's database-mapper to handle, you can fall back on writing SQL by "
"hand. Django has a couple of options for writing raw SQL queries; see :doc:`/"
"topics/db/sql`."
msgstr ""
"若你发现需要编写的 SQL 查询语句太过复杂，以至于 Django 的数据库映射无法处理，"
"你可以回归手动编写 SQL。Django 针对编写原生 SQL 有几个选项；参考 :doc:`/"
"topics/db/sql`。"

msgid ""
"Finally, it's important to note that the Django database layer is merely an "
"interface to your database. You can access your database via other tools, "
"programming languages or database frameworks; there's nothing Django-"
"specific about your database."
msgstr ""
"最后，Django 数据库层只是一种访问数据库的接口，理解这点非常重要。你也可以通过"
"其它工具，编程语言或数据库框架访问数据库；Django 并没有对数据库数据库做啥独有"
"的操作。"

msgid "Search"
msgstr "搜索"

msgid ""
"A common task for web applications is to search some data in the database "
"with user input. In a simple case, this could be filtering a list of objects "
"by a category. A more complex use case might require searching with "
"weighting, categorization, highlighting, multiple languages, and so on. This "
"document explains some of the possible use cases and the tools you can use."
msgstr ""
"Web 应用的常见任务是根据用户输入查出数据库中的数据。在一个简单例子中，会是通"
"过分类筛选一个对象列表。一个更复杂的用例可能会要求根据重量，分类，多语言等筛"
"选对象。本文介绍了一些常见用例和你能使用的工具。"

msgid "We'll refer to the same models used in :doc:`/topics/db/queries`."
msgstr "我们会引用与 :doc:`/topics/db/queries` 中一样的模型。"

msgid "Use Cases"
msgstr "用例"

msgid "Standard textual queries"
msgstr "标准文本查询"

msgid ""
"Text-based fields have a selection of matching operations. For example, you "
"may wish to allow lookup up an author like so::"
msgstr "文本字段能通过匹配运算进行筛选。例如，你可能会这样查找一个作者::"

msgid ""
"This is a very fragile solution as it requires the user to know an exact "
"substring of the author's name. A better approach could be a case-"
"insensitive match (:lookup:`icontains`), but this is only marginally better."
msgstr ""
"这是一种非常简陋的方案，因为它要求用户必须知道用户名中包含的字符串。大小写不"
"敏感的匹配 (:lookup:`icontains`) 不失为一种更好的方案，但优化的程度有限。"

msgid "A database's more advanced comparison functions"
msgstr "一个更高级的数据库比较函数"

msgid ""
"If you're using PostgreSQL, Django provides :doc:`a selection of database "
"specific tools </ref/contrib/postgres/search>` to allow you to leverage more "
"complex querying options. Other databases have different selections of "
"tools, possibly via plugins or user-defined functions. Django doesn't "
"include any support for them at this time. We'll use some examples from "
"PostgreSQL to demonstrate the kind of functionality databases may have."
msgstr ""
"若你使用的是 PostgreSQL，Django 提供了 :doc:`数据特殊筛选工具 </ref/contrib/"
"postgres/search>` 帮助你巧妙利用更复杂的查询条件。其它数据库也有不同的筛选工"
"具，可能是通过插件或用户自定义函数实现的。Django 此时还没有为他们提供任何支"
"持。我们会用来自 PostgreSQL 的实例来证明其包含的功能函数。"

msgid "Searching in other databases"
msgstr "在其它数据库中搜索"

msgid ""
"All of the searching tools provided by :mod:`django.contrib.postgres` are "
"constructed entirely on public APIs such as :doc:`custom lookups </ref/"
"models/lookups>` and :doc:`database functions </ref/models/database-"
"functions>`. Depending on your database, you should be able to construct "
"queries to allow similar APIs. If there are specific things which cannot be "
"achieved this way, please open a ticket."
msgstr ""
"所有由 :mod:`django.contrib.postgres` 提供的筛选工具均基于 :doc:`自定义查询 "
"</ref/models/lookups>` 和 :doc:`数据库函数 </ref/models/database-functions>` "
"实现。根据你使用的数据库，你应该构建响应的查询，实现类似的 API。若有某个东西"
"无法以这种方式实现，请新建一个工单。"

msgid ""
"In the above example, we determined that a case insensitive lookup would be "
"more useful. When dealing with non-English names, a further improvement is "
"to use :lookup:`unaccented comparison <unaccent>`::"
msgstr ""
"在上面的例子中，我们可以确认大小写不敏感的查询会更实用一些。当处理英文以外的"
"名字时，可以用 :lookup:`无重音比较 <unaccent>` 来优化::"

msgid ""
"This shows another issue, where we are matching against a different spelling "
"of the name. In this case we have an asymmetry though - a search for "
"``Helen`` will pick up ``Helena`` or ``Hélène``, but not the reverse. "
"Another option would be to use a :lookup:`trigram_similar` comparison, which "
"compares sequences of letters."
msgstr ""
"这展开了另一个关于通过名字的不同拼写进行比较的讨论。但这种比较是不对称的 —— "
"筛选 ``Helen`` 能拿到 ``Helena`` 或 ``Hélène``，但反着来却不行。还有一个选项"
"允许使用 :lookup:`trigram_similar` 比较，这回比较字母的序列。"

msgid ""
"Now we have a different problem - the longer name of \"Helena Bonham Carter"
"\" doesn't show up as it is much longer. Trigram searches consider all "
"combinations of three letters, and compares how many appear in both search "
"and source strings. For the longer name, there are more combinations that "
"don't appear in the source string, so it is no longer considered a close "
"match."
msgstr ""
"现在还有一个问题 —— 名字 \"Helena Bonham Carter\" 有点太长了，以至于没有显"
"示。三元搜索综合考虑了三种字母的所有组合形式，并同时再查询和源字符串中比较了"
"出现的次数。对于长名字，源字符串中包含了更多的组合方式，所以其不再被认为是一"
"种近似匹配。"

msgid ""
"The correct choice of comparison functions here depends on your particular "
"data set, for example the language(s) used and the type of text being "
"searched. All of the examples we've seen are on short strings where the user "
"is likely to enter something close (by varying definitions) to the source "
"data."
msgstr ""
"要基于你提供的特定数据集合选择一个合适的比较函数，例如依据使用的语言和待搜索"
"的文本。我们见过的所有例子都是关于短字符串的，这使得用户可以输入与源数据关联"
"较大（根据不同的定义）的内容。"

msgid "Document-based search"
msgstr "文档搜索"

msgid ""
"Standard database operations stop being a useful approach when you start "
"considering large blocks of text. Whereas the examples above can be thought "
"of as operations on a string of characters, full text search looks at the "
"actual words. Depending on the system used, it's likely to use some of the "
"following ideas:"
msgstr ""
"标准数据库操作对于大量文本搜索来说太过简陋了。虽然上面的示例可以看作是对字符"
"串的操作，但是全文搜索查看的是实际的单词。依据所使用的系统，可以采用下面的某"
"些方法："

msgid "Ignoring \"stop words\" such as \"a\", \"the\", \"and\"."
msgstr "忽略 “停止单词”，例如 \"a\"，\"the\"，\"and\"。"

msgid "Stemming words, so that \"pony\" and \"ponies\" are considered similar."
msgstr "词干化，这样 \"pony\" 和 \"ponies\" 会被认为是一样的。"

msgid ""
"Weighting words based on different criteria such as how frequently they "
"appear in the text, or the importance of the fields, such as the title or "
"keywords, that they appear in."
msgstr ""
"根据不同的标准为单词设置权重，例如其在文本中出现的频率，或所属字段（如标题或"
"关键字）的重要性。"

msgid ""
"There are many alternatives for using searching software, some of the most "
"prominent are Elastic_ and Solr_. These are full document-based search "
"solutions. To use them with data from Django models, you'll need a layer "
"which translates your data into a textual document, including back-"
"references to the database ids. When a search using the engine returns a "
"certain document, you can then look it up in the database. There are a "
"variety of third-party libraries which are designed to help with this "
"process."
msgstr ""
"使用搜索软件有很多选项，最常见的有 Elastic_ 和 Solr_。它们都是基于全文搜索的"
"解决方案。要用它们搜索来自 Django 模型的数据，你需要一个抽象层，将数据（包括"
"对数据库 id 的指针）转换为文本文档。当使用该引擎的某次搜索返回了一份文档，你"
"可以在数据库中查看它。有很多第三方库被设计为处理这种问题。"

msgid "PostgreSQL support"
msgstr "PostgreSQL 支持"

msgid ""
"PostgreSQL has its own full text search implementation built-in. While not "
"as powerful as some other search engines, it has the advantage of being "
"inside your database and so can easily be combined with other relational "
"queries such as categorization."
msgstr ""
"PostgreSQL 内置了其专属的全文本搜索实现。虽然并不像其它搜索引擎那样强大，但它"
"的优点是内置在数据库中，所以它能很方便的与其它关联查询条件进行联合查询，如按"
"分类查询。"

msgid ""
"The :mod:`django.contrib.postgres` module provides some helpers to make "
"these queries. For example, a query might select all the blog entries which "
"mention \"cheese\"::"
msgstr ""
":mod:`django.contrib.postgres` 模块提供了一些助手函数来执行这些查询。例如，查"
"询可能筛选出所有提到了 \"cheese\" 的博客条目::"

msgid "You can also filter on a combination of fields and on related models::"
msgstr "你也可以在联合字段或关联模型上进行筛选::"

msgid ""
"See the ``contrib.postgres`` :doc:`/ref/contrib/postgres/search` document "
"for complete details."
msgstr ""
"参阅 ``contrib.postgres`` :doc:`/ref/contrib/postgres/search` 文档获取全部细"
"节。"

msgid "Performing raw SQL queries"
msgstr "执行原生 SQL 查询"

msgid ""
"Django gives you two ways of performing raw SQL queries: you can use :meth:"
"`Manager.raw()` to `perform raw queries and return model instances`__, or "
"you can avoid the model layer entirely and `execute custom SQL directly`__."
msgstr ""
"Django 允许你用两种方式执行原生 SQL 查询：你可以使用 :meth:`Manager.raw()` "
"来 `执行原生查询并返回模型实例`__，或者完全不用模型层  `直接执行自定义 "
"SQL`__。"

msgid "Explore the ORM before using raw SQL!"
msgstr "在使用原生 SQL 之前探索 ORM！"

msgid ""
"The Django ORM provides many tools to express queries without writing raw "
"SQL. For example:"
msgstr ""
"Django ORM 提供了很多工具，允许你在不编写原生 SQL 的情况下表达查询。例如："

msgid "The :doc:`QuerySet API </ref/models/querysets>` is extensive."
msgstr ":doc:`QuerySet API </ref/models/querysets>` 覆盖面很广。"

msgid ""
"You can :meth:`annotate <.QuerySet.annotate>` and :doc:`aggregate </topics/"
"db/aggregation>` using many built-in :doc:`database functions </ref/models/"
"database-functions>`. Beyond those, you can create :doc:`custom query "
"expressions </ref/models/expressions/>`."
msgstr ""
"你可以用很多内置的 :doc:`数据库函数 </ref/models/database-functions>` 进行 :"
"meth:`annotate <.QuerySet.annotate>` 和 :doc:`aggregate </topics/db/"
"aggregation>`。除此之外，你还可以创建 :doc:`查询表达式 </ref/models/"
"expressions/>`。"

msgid ""
"Before using raw SQL, explore :doc:`the ORM </topics/db/index>`. Ask on one "
"of :doc:`the support channels </faq/help>` to see if the ORM supports your "
"use case."
msgstr ""

msgid ""
"You should be very careful whenever you write raw SQL. Every time you use "
"it, you should properly escape any parameters that the user can control by "
"using ``params`` in order to protect against SQL injection attacks. Please "
"read more about :ref:`SQL injection protection <sql-injection-protection>`."
msgstr ""
"无论何时编写原生 SQL 都要万分小心。使用时，你要用 ``params`` 将任何用户传入的"
"参数进行安全转义，避免 SQL 注入攻击。阅读 :ref:`SQL 注入保护 <sql-injection-"
"protection>` 了解更多。"

msgid "Performing raw queries"
msgstr "执行原生查询"

msgid ""
"The ``raw()`` manager method can be used to perform raw SQL queries that "
"return model instances:"
msgstr "若管理器方法 ``raw()`` 能用于执行原生 SQL 查询，就会返回模型实例："

msgid ""
"This method takes a raw SQL query, executes it, and returns a ``django.db."
"models.query.RawQuerySet`` instance. This ``RawQuerySet`` instance can be "
"iterated over like a normal :class:`~django.db.models.query.QuerySet` to "
"provide object instances."
msgstr ""
"该方法接受一个原生 SQL 查询语句，执行它，并返回一个 ``django.db.models.query."
"RawQuerySet`` 实例。这个 ``RawQuerySet`` 能像普通的 :class:`~django.db."
"models.query.QuerySet` 一样被迭代获取对象实例。"

msgid ""
"This is best illustrated with an example. Suppose you have the following "
"model::"
msgstr "最好用例子来解释。假设你有以下模型::"

msgid "You could then execute custom SQL like so::"
msgstr "然后你可以像这样执行自定义 SQL::"

msgid ""
"This example isn't very exciting -- it's exactly the same as running "
"``Person.objects.all()``. However, ``raw()`` has a bunch of other options "
"that make it very powerful."
msgstr ""
"这个例子并不令人激动——它与运行 ``Person.objects.all()`` 完全相同。然而， "
"``raw()`` 有很多额外选项，使得它非常强大。"

msgid "Model table names"
msgstr "模型表名"

msgid "Where did the name of the ``Person`` table come from in that example?"
msgstr "在本例中， ``Person`` 表的名称是从哪来的？"

msgid ""
"By default, Django figures out a database table name by joining the model's "
"\"app label\" -- the name you used in ``manage.py startapp`` -- to the "
"model's class name, with an underscore between them. In the example we've "
"assumed that the ``Person`` model lives in an app named ``myapp``, so its "
"table would be ``myapp_person``."
msgstr ""
"默认情况下，Django 通过拼接模型的 \"app label\" 和模型类名推算出数据表名 —— "
"即你在 ``manage.py startapp`` 中使用的名称，二者以一个下划线分割。在本例中，"
"我们假定 ``Person`` 模型位于一个叫做 ``myapp`` 的应用中，这样，模型的表名就"
"是 ``myapp_person``。"

msgid ""
"For more details check out the documentation for the :attr:`~Options."
"db_table` option, which also lets you manually set the database table name."
msgstr ""
"更多细节请查阅关于 :attr:`~Options.db_table` 选项的文档，它也允许你手动指定数"
"据库的表名。"

msgid ""
"No checking is done on the SQL statement that is passed in to ``.raw()``. "
"Django expects that the statement will return a set of rows from the "
"database, but does nothing to enforce that. If the query does not return "
"rows, a (possibly cryptic) error will result."
msgstr ""
"不会对传给 ``.raw()`` 的 SQL 语句做任何检查。Django 期望该语句会从数据库中返"
"回一个集合，但并不强制如此。若该查询没有返回一些记录，会导致一个（含糊）的错"
"误。"

msgid ""
"If you are performing queries on MySQL, note that MySQL's silent type "
"coercion may cause unexpected results when mixing types. If you query on a "
"string type column, but with an integer value, MySQL will coerce the types "
"of all values in the table to an integer before performing the comparison. "
"For example, if your table contains the values ``'abc'``, ``'def'`` and you "
"query for ``WHERE mycolumn=0``, both rows will match. To prevent this, "
"perform the correct typecasting before using the value in a query."
msgstr ""
"若你在 MySQL 上执行查询，至于其无声的强制类型可能会弄混类型时导致不可预料的后"
"果。若你用一个整数值查询一个字符串列，MySQL 会执行比较前将表中所有数据强制转"
"为整数。例如，若数据表包含的值有 ``'abc'`` 和 ``'def'``，而查询语句为 "
"``WHERE mycolumn=0``，这两行都会匹配上。要避免这种情况，在将值传给查询语句前"
"进行合适的类型转换。"

msgid ""
"The default value of the ``params`` argument was changed from ``None`` to an "
"empty tuple."
msgstr "参数 ``params`` 的默认值从 ``None`` 改为空元组。"

msgid "Mapping query fields to model fields"
msgstr "将查询字段映射为模型字段"

msgid ""
"``raw()`` automatically maps fields in the query to fields on the model."
msgstr "``raw()`` 字段将查询语句中的字段映射至模型中的字段。"

msgid ""
"The order of fields in your query doesn't matter. In other words, both of "
"the following queries work identically::"
msgstr "查询语句中的字段排序并不重要。换而言之，以下两种查询是一致的::"

msgid ""
"Matching is done by name. This means that you can use SQL's ``AS`` clauses "
"to map fields in the query to model fields. So if you had some other table "
"that had ``Person`` data in it, you could easily map it into ``Person`` "
"instances::"
msgstr ""
"匹配是根据名字来的。这意味着你可以使用 SQL 的 ``AS`` 子句将查询语句中的字段映"
"射至模型中的字段。所以，若你还有一些数据表包含了 ``Person`` 数据，你可以很方"
"便的将其映射至 ``Person`` 实例::"

msgid ""
"As long as the names match, the model instances will be created correctly."
msgstr "只要名字对上了，模型实例就会被正确创建。"

msgid ""
"Alternatively, you can map fields in the query to model fields using the "
"``translations`` argument to ``raw()``. This is a dictionary mapping names "
"of fields in the query to names of fields on the model. For example, the "
"above query could also be written::"
msgstr ""
"或者，你可以用 ``raw()`` 的 ``translations`` 参数将查询语句中的字段映射至模型"
"中的字段。这是一个字典，将查询语句中的字段名映射至模型中的字段名。例如，上面"
"的查询也能这样写::"

msgid "Index lookups"
msgstr "索引查询"

msgid ""
"``raw()`` supports indexing, so if you need only the first result you can "
"write::"
msgstr "``raw()`` 支持索引，所以，若你只需要第一个结果就这样写::"

msgid ""
"However, the indexing and slicing are not performed at the database level. "
"If you have a large number of ``Person`` objects in your database, it is "
"more efficient to limit the query at the SQL level::"
msgstr ""
"不过，索引和切片不是在数据库层面上实现的。若数据库中有非常多的 ``Person`` 对"
"象，更搞笑的方式是在 SQL 层面使用 limit 子句::"

msgid "Deferring model fields"
msgstr "延迟模型字段"

msgid "Fields may also be left out::"
msgstr "也可以省略字段::"

msgid ""
"The ``Person`` objects returned by this query will be deferred model "
"instances (see :meth:`~django.db.models.query.QuerySet.defer()`). This means "
"that the fields that are omitted from the query will be loaded on demand. "
"For example::"
msgstr ""
"该查询返回的 ``Person`` 对象即延迟模型实例（参考 :meth:`~django.db.models."
"query.QuerySet.defer()`）。这意味着查询语句中省略的字段按需加载。例子::"

msgid ""
"From outward appearances, this looks like the query has retrieved both the "
"first name and last name. However, this example actually issued 3 queries. "
"Only the first names were retrieved by the raw() query -- the last names "
"were both retrieved on demand when they were printed."
msgstr ""
"表面上，看起来该查询同时检出了 first name 和 last name。然而，这个例子实际上"
"执行了三次查询。只有 first names 是由 raw() 查询检出的 —— last names 是在它们"
"被打印时按需检出。"

msgid ""
"There is only one field that you can't leave out - the primary key field. "
"Django uses the primary key to identify model instances, so it must always "
"be included in a raw query. A :class:`~django.core.exceptions."
"FieldDoesNotExist` exception will be raised if you forget to include the "
"primary key."
msgstr ""
"只有一个字段你不能省略 —— 主键字段。Django 用主键来区分模型实例，所以必须在原"
"生查询语句中包含主键。若你忘了包含主键会抛出 :class:`~django.core.exceptions."
"FieldDoesNotExist`  异常。"

msgid "Adding annotations"
msgstr "添加注释"

msgid ""
"You can also execute queries containing fields that aren't defined on the "
"model. For example, we could use `PostgreSQL's age() function`__ to get a "
"list of people with their ages calculated by the database::"
msgstr ""
"你可以执行带有模型中未定义字段的查询语句。例如，我们能用 `PostgreSQL 的 "
"age() 函数`__ 获取用户列表，他们的年龄已由数据库计算::"

msgid ""
"You can often avoid using raw SQL to compute annotations by instead using a :"
"ref:`Func() expression <func-expressions>`."
msgstr ""
"你总是可以用 :ref:`Func() 表达式 <func-expressions>` 避免使用原生 SQL 去计算"
"注释。"

msgid "Passing parameters into ``raw()``"
msgstr "将参数传给 ``raw()``"

msgid ""
"If you need to perform parameterized queries, you can use the ``params`` "
"argument to ``raw()``::"
msgstr "如果你需要执行参数化的查询，可以使用 ``raw()`` 的 ``params`` 参数::"

msgid ""
"``params`` is a list or dictionary of parameters. You'll use ``%s`` "
"placeholders in the query string for a list, or ``%(key)s`` placeholders for "
"a dictionary (where ``key`` is replaced by a dictionary key), regardless of "
"your database engine. Such placeholders will be replaced with parameters "
"from the ``params`` argument."
msgstr ""
"``params`` 是一个参数字典。你将用一个列表替换查询字符串中 ``%s`` 占位符，或用"
"字典替换 ``%(key)s`` 占位符（``key`` 被字典 key 替换），不论你使用哪个数据库"
"引擎。这些占位符会被 ``params`` 参数的值替换。"

msgid ""
"Dictionary params are not supported with the SQLite backend; with this "
"backend, you must pass parameters as a list."
msgstr ""
"使用 SQLite 后端时不支持字典参数；使用此后端时，你必须以列表形式传入参数。"

msgid ""
"**Do not use string formatting on raw queries or quote placeholders in your "
"SQL strings!**"
msgstr "**不要对原生查询或 SQL 字符串中的引号占位符使用字符串格式化！**"

msgid "It's tempting to write the above query as::"
msgstr "临时将上述查询写作::"

msgid ""
"You might also think you should write your query like this (with quotes "
"around ``%s``)::"
msgstr "你可能认为你需要将查询写成这样（用单引号包裹 ``%s``）::"

msgid "**Don't make either of these mistakes.**"
msgstr "**不要犯其它错误。**"

msgid ""
"As discussed in :ref:`sql-injection-protection`, using the ``params`` "
"argument and leaving the placeholders unquoted protects you from `SQL "
"injection attacks`__, a common exploit where attackers inject arbitrary SQL "
"into your database. If you use string interpolation or quote the "
"placeholder, you're at risk for SQL injection."
msgstr ""
"正如 :ref:`sql-injection-protection` 介绍的，使用 ``params`` 参数和不用引号包"
"裹占位符使你免受 `SQL 注入攻击`__，这是一个攻击者常用的漏洞，将任意 SQL 注入"
"你的数据库。若你使用了字符串插入或用引号包裹占位符，你正处于 SQL 注入的风险"
"中。"

msgid "Executing custom SQL directly"
msgstr "直接执行自定义 SQL"

msgid ""
"Sometimes even :meth:`Manager.raw` isn't quite enough: you might need to "
"perform queries that don't map cleanly to models, or directly execute "
"``UPDATE``, ``INSERT``, or ``DELETE`` queries."
msgstr ""
"有时候，甚至 :meth:`Manager.raw` 都无法满足需求：你可能要执行不明确映射至模型"
"的查询语句，或者就是直接执行 ``UPDATE``， ``INSERT`` 或 ``DELETE`` 语句。"

msgid ""
"In these cases, you can always access the database directly, routing around "
"the model layer entirely."
msgstr "这些情况下，你总是能直接访问数据库，完全绕过模型层。"

msgid ""
"The object ``django.db.connection`` represents the default database "
"connection. To use the database connection, call ``connection.cursor()`` to "
"get a cursor object. Then, call ``cursor.execute(sql, [params])`` to execute "
"the SQL and ``cursor.fetchone()`` or ``cursor.fetchall()`` to return the "
"resulting rows."
msgstr ""
"对象 ``django.db.connection`` 代表默认数据库连接。要使用这个数据库连接，调用 "
"``connection.cursor()`` 来获取一个指针对象。然后，调用 ``cursor.execute(sql, "
"[params])`` 来执行该 SQL 和 ``cursor.fetchone()``，或 ``cursor.fetchall()`` "
"获取结果数据。"

msgid ""
"To protect against SQL injection, you must not include quotes around the ``"
"%s`` placeholders in the SQL string."
msgstr "要避免 SQL 注入，你绝对不能在 SQL 字符串中用引号包裹  ``%s`` 占位符。"

msgid ""
"Note that if you want to include literal percent signs in the query, you "
"have to double them in the case you are passing parameters::"
msgstr "注意，若要在查询中包含文本的百分号，你需要在传入参数使用两个百分号::"

msgid ""
"If you are using :doc:`more than one database </topics/db/multi-db>`, you "
"can use ``django.db.connections`` to obtain the connection (and cursor) for "
"a specific database. ``django.db.connections`` is a dictionary-like object "
"that allows you to retrieve a specific connection using its alias::"
msgstr ""
"若你同时使用 :doc:`不止一个数据库 </topics/db/multi-db>`，你可以使用 "
"``django.db.connections`` 获取指定数据库的连接（和指针）。 ``django.db."
"connections`` 是一个类字典对象，它允许你通过连接别名获取指定连接::"

msgid ""
"By default, the Python DB API will return results without their field names, "
"which means you end up with a ``list`` of values, rather than a ``dict``. At "
"a small performance and memory cost, you can return results as a ``dict`` by "
"using something like this::"
msgstr ""
"默认情况下，Python DB API 返回的结果不会包含字段名，这意味着你最终会收到一个 "
"``list``，而不是一个 ``dict``。要追求较少的运算和内存消耗，你可以以 ``dict`` "
"返回结果，通过使用如下的玩意::"

msgid ""
"Another option is to use :func:`collections.namedtuple` from the Python "
"standard library. A ``namedtuple`` is a tuple-like object that has fields "
"accessible by attribute lookup; it's also indexable and iterable. Results "
"are immutable and accessible by field names or indices, which might be "
"useful::"
msgstr ""
"另一个选项是使用来自 Python 标准库的 :func:`collections.namedtuple`。 "
"``namedtuple`` 是一个类元组对象，可以通过属性查找来访问其包含的字段；也能通过"
"索引和迭代。结果都是不可变的，但能通过字段名或索引访问，这很实用::"

msgid "Here is an example of the difference between the three::"
msgstr "这有个例子，介绍了三者之间的不同::"

msgid "Connections and cursors"
msgstr "连接和指针"

msgid ""
"``connection`` and ``cursor`` mostly implement the standard Python DB-API "
"described in :pep:`249` — except when it comes to :doc:`transaction handling "
"</topics/db/transactions>`."
msgstr ""
"``connection`` 和 ``cursor`` 实现了 :pep:`249` 中介绍的大部分标准 Python DB-"
"API —— 除了 :doc:`事务处理 </topics/db/transactions>` 之外。"

msgid ""
"If you're not familiar with the Python DB-API, note that the SQL statement "
"in ``cursor.execute()`` uses placeholders, ``\"%s\"``, rather than adding "
"parameters directly within the SQL. If you use this technique, the "
"underlying database library will automatically escape your parameters as "
"necessary."
msgstr ""
"若你并不熟悉 Python DB-API，要注意 ``cursor.execute()`` 中的 SQL 语句使用了占"
"位符 ``\"%s\"``，而不是直接在 SQL 中添加参数。若你使用这个技巧，潜在的数据库"
"库会自动在需要时转义参数。"

msgid ""
"Also note that Django expects the ``\"%s\"`` placeholder, *not* the ``\"?"
"\"`` placeholder, which is used by the SQLite Python bindings. This is for "
"the sake of consistency and sanity."
msgstr ""
"也要注意，Django 期望 ``\"%s\"`` 占位符，而 *不是* ``\"?\"`` 占位符，后者由 "
"SQLite Python 绑定使用。这是为了一致性和正确性。"

msgid "Using a cursor as a context manager::"
msgstr "将指针作为上下文的管理器::"

msgid "is equivalent to::"
msgstr "相当于::"

msgid "Calling stored procedures"
msgstr "调用存储流程"

msgid ""
"Calls a database stored procedure with the given name. A sequence "
"(``params``) or dictionary (``kparams``) of input parameters may be "
"provided. Most databases don't support ``kparams``. Of Django's built-in "
"backends, only Oracle supports it."
msgstr ""
"以给定名称调用数据库存储流程。要提供一个序列 (``params``) 或字典 "
"(``kparams``) 作为输入参数。大多数数据库不支持 ``kparams``。对于 Django 内置"
"后端来说，只有 Oracle 支持。"

msgid "For example, given this stored procedure in an Oracle database:"
msgstr "例如，在一个 Oracle 数据库中指定存储流程："

msgid "This will call it::"
msgstr "这将调用该存储流程::"

msgid "Tablespaces"
msgstr "表空间（Tablespaces）"

msgid ""
"A common paradigm for optimizing performance in database systems is the use "
"of `tablespaces`_ to organize disk layout."
msgstr "优化数据库表现的常见方式是利用 `表空间`_ 来组织磁盘布局。"

msgid ""
"Django does not create the tablespaces for you. Please refer to your "
"database engine's documentation for details on creating and managing "
"tablespaces."
msgstr ""
"Django 没有为你创建表空间。请参考你使用的数据库引擎的文档了解如何创建和管理表"
"空间。"

msgid "Declaring tablespaces for tables"
msgstr "为表格申明表空间"

msgid ""
"A tablespace can be specified for the table generated by a model by "
"supplying the :attr:`~django.db.models.Options.db_tablespace` option inside "
"the model's ``class Meta``. This option also affects tables automatically "
"created for :class:`~django.db.models.ManyToManyField`\\ s in the model."
msgstr ""
"表空间可被指定给特定模型生成的数据表，通过在该模型的 ``class Meta`` 中提供 :"
"attr:`~django.db.models.Options.db_tablespace`  选项。该选项也影响此模型中"
"为 :class:`~django.db.models.ManyToManyField` 自动创建的数据表。"

msgid ""
"You can use the :setting:`DEFAULT_TABLESPACE` setting to specify a default "
"value for :attr:`~django.db.models.Options.db_tablespace`. This is useful "
"for setting a tablespace for the built-in Django apps and other applications "
"whose code you cannot control."
msgstr ""
"你可以用 :setting:`DEFAULT_TABLESPACE` 配置为 :attr:`~django.db.models."
"Options.db_tablespace` 指定一个默认值。这在配置内置的 Django 应用或其它你无法"
"修改代码的应用的表空间时非常有用。"

msgid "Declaring tablespaces for indexes"
msgstr "为索引申明表空间"

msgid ""
"You can pass the :attr:`~django.db.models.Index.db_tablespace` option to an "
"``Index`` constructor to specify the name of a tablespace to use for the "
"index. For single field indexes, you can pass the :attr:`~django.db.models."
"Field.db_tablespace` option to a ``Field`` constructor to specify an "
"alternate tablespace for the field's column index. If the column doesn't "
"have an index, the option is ignored."
msgstr ""
"你可以为 ``Index`` 构造器传入 :attr:`~django.db.models.Index.db_tablespace` "
"选项指定索引使用的表空间名。对于单个字段的索引，你可以向 ``Field`` 构造器传"
"入 :attr:`~django.db.models.Field.db_tablespace` 选项，为字段列索引指定可选的"
"表空间。若此列没有索引，会忽略该选项。"

msgid ""
"You can use the :setting:`DEFAULT_INDEX_TABLESPACE` setting to specify a "
"default value for :attr:`~django.db.models.Field.db_tablespace`."
msgstr ""
"你可以用 :setting:`DEFAULT_INDEX_TABLESPACE` 配置项为 :attr:`~django.db."
"models.Field.db_tablespace` 指定一个默认值。"

msgid ""
"If :attr:`~django.db.models.Field.db_tablespace` isn't specified and you "
"didn't set :setting:`DEFAULT_INDEX_TABLESPACE`, the index is created in the "
"same tablespace as the tables."
msgstr ""
"若未指定 :attr:`~django.db.models.Field.db_tablespace` 和 :setting:"
"`DEFAULT_INDEX_TABLESPACE`，索引会在与数据表相同的表空间中创建。"

msgid ""
"In this example, the tables generated by the ``TablespaceExample`` model (i."
"e. the model table and the many-to-many table) would be stored in the "
"``tables`` tablespace. The index for the name field and the indexes on the "
"many-to-many table would be stored in the ``indexes`` tablespace. The "
"``data`` field would also generate an index, but no tablespace for it is "
"specified, so it would be stored in the model tablespace ``tables`` by "
"default. The index for the ``shortcut`` field would be stored in the "
"``other_indexes`` tablespace."
msgstr ""
"本例中， ``TablespaceExample`` 模型（即模型表和多对多表）创建的表会被存在 "
"``tables`` 表空间。名称字段和多对多表的索引会被存在该 ``indexes`` 表空间中。 "
"``data`` 字段也会生成一个索引，但因为并未为其指定表空间，所以它会被默认存入模"
"型的表空间 ``tables`` 中。 ``shortcut`` 字段的索引会被存入 ``other_indexes`` "
"表空间。"

msgid "Database support"
msgstr "数据库支持"

msgid ""
"PostgreSQL and Oracle support tablespaces. SQLite, MariaDB and MySQL don't."
msgstr "PostgreSQL 和 Oracle 支持表空间。而 SQLite， MariaDB 和 MySQL 不支持。"

msgid ""
"When you use a backend that lacks support for tablespaces, Django ignores "
"all tablespace-related options."
msgstr "若你使用的后端不支持表空间，Django 会忽略所有与表空间相关的选项。"

msgid "Database transactions"
msgstr "数据库事务"

msgid ""
"Django gives you a few ways to control how database transactions are managed."
msgstr "Django 提供多种方式控制数据库事务。"

msgid "Managing database transactions"
msgstr "管理数据库事务"

msgid "Django's default transaction behavior"
msgstr "Django 默认的事务行为"

msgid ""
"Django's default behavior is to run in autocommit mode. Each query is "
"immediately committed to the database, unless a transaction is active. :ref:"
"`See below for details <autocommit-details>`."
msgstr ""
"Django 默认的事务行为是自动提交。除非事务正在执行，每个查询将会马上自动提交到"
"数据库， :ref:`详见下文 <autocommit-details>`。"

msgid ""
"Django uses transactions or savepoints automatically to guarantee the "
"integrity of ORM operations that require multiple queries, especially :ref:"
"`delete() <topics-db-queries-delete>` and :ref:`update() <topics-db-queries-"
"update>` queries."
msgstr ""
"Django 自动使用事务或还原点，以确保需多次查询的 ORM 操作的一致性，特别是 :"
"ref:`delete() <topics-db-queries-delete>` 和 :ref:`update() <topics-db-"
"queries-update>` 操作。"

msgid ""
"Django's :class:`~django.test.TestCase` class also wraps each test in a "
"transaction for performance reasons."
msgstr ""
"由于性能原因，Django 的 :class:`~django.test.TestCase` 类同样将每个测试用事务"
"封装起来。"

msgid "Tying transactions to HTTP requests"
msgstr "连结事务与 HTTP 请求"

msgid ""
"A common way to handle transactions on the web is to wrap each request in a "
"transaction. Set :setting:`ATOMIC_REQUESTS <DATABASE-ATOMIC_REQUESTS>` to "
"``True`` in the configuration of each database for which you want to enable "
"this behavior."
msgstr ""
"在 Web 里，处理事务比较常用的方式是将每个请求封装在一个事务中。 在你想启用该"
"行为的数据库中，把配置中的参数 :setting:`ATOMIC_REQUESTS <DATABASE-"
"ATOMIC_REQUESTS>` 设置为 ``True``。"

msgid ""
"It works like this. Before calling a view function, Django starts a "
"transaction. If the response is produced without problems, Django commits "
"the transaction. If the view produces an exception, Django rolls back the "
"transaction."
msgstr ""
"它是这样工作的：在调用视图方法前，Django 先生成一个事务。如果响应能正常生成，"
"Django 会提交该事务。而如果视图出现异常，Django 则会回滚该事务。"

msgid ""
"You may perform subtransactions using savepoints in your view code, "
"typically with the :func:`atomic` context manager. However, at the end of "
"the view, either all or none of the changes will be committed."
msgstr ""
"你可以在你的视图代码中使用还原点执行子事务，一般会使用 :func:`atomic` 上下文"
"管理器。但是，在视图结束时，要么所有的更改都被提交，要么所有的更改都不被提"
"交。"

msgid ""
"While the simplicity of this transaction model is appealing, it also makes "
"it inefficient when traffic increases. Opening a transaction for every view "
"has some overhead. The impact on performance depends on the query patterns "
"of your application and on how well your database handles locking."
msgstr ""
"虽然这种简洁的事务模型很吸引人，但在流量增加时，也会降低效率。为每个视图打开"
"一个事务都会带来一些开销。对性能的影响程度取决于应用执行的查询语句和数据库处"
"理锁的能力。"

msgid "Per-request transactions and streaming responses"
msgstr "每次请求的事务和流式响应"

msgid ""
"When a view returns a :class:`~django.http.StreamingHttpResponse`, reading "
"the contents of the response will often execute code to generate the "
"content. Since the view has already returned, such code runs outside of the "
"transaction."
msgstr ""
"当视图返回一个 :class:`~django.http.StreamingHttpResponse` 时，获取该响应的内"
"容总会执行代码，生成内容。由于早就返回了该视图，某些代码会在事务外执行。"

msgid ""
"Generally speaking, it isn't advisable to write to the database while "
"generating a streaming response, since there's no sensible way to handle "
"errors after starting to send the response."
msgstr ""
"一般来说，不建议在生成流式响应时写入数据库，因为在开始发送响应后，就没有能有"
"效处理错误的方法了。"

msgid ""
"In practice, this feature wraps every view function in the :func:`atomic` "
"decorator described below."
msgstr ""
"实际上，此功能只是简单地用下文介绍的 :func:`atomic` 装饰器装饰了每个视图函"
"数。"

msgid ""
"Note that only the execution of your view is enclosed in the transactions. "
"Middleware runs outside of the transaction, and so does the rendering of "
"template responses."
msgstr ""
"注意，只有视图被限制在事务中执行。中间件在事务之外运行，同理，渲染模板响应也"
"是在事务之外运行的。"

msgid ""
"When :setting:`ATOMIC_REQUESTS <DATABASE-ATOMIC_REQUESTS>` is enabled, it's "
"still possible to prevent views from running in a transaction."
msgstr ""
"即便启用了 :setting:`ATOMIC_REQUESTS <DATABASE-ATOMIC_REQUESTS>`，仍能避免视"
"图在事务中运行。"

msgid ""
"This decorator will negate the effect of :setting:`ATOMIC_REQUESTS <DATABASE-"
"ATOMIC_REQUESTS>` for a given view::"
msgstr ""
"该装饰器会为指定视图取消 :setting:`ATOMIC_REQUESTS <DATABASE-"
"ATOMIC_REQUESTS>` 的影响。"

msgid "It only works if it's applied to the view itself."
msgstr "只有在它被应用到视图时才会生效。"

msgid "Controlling transactions explicitly"
msgstr "显式控制事务"

msgid "Django provides a single API to control database transactions."
msgstr "Django 提供了一个 API 控制数据库事务。"

msgid ""
"Atomicity is the defining property of database transactions. ``atomic`` "
"allows us to create a block of code within which the atomicity on the "
"database is guaranteed. If the block of code is successfully completed, the "
"changes are committed to the database. If there is an exception, the changes "
"are rolled back."
msgstr ""
"原子性是数据库事务的定义属性。 ``atomic`` 允许创建代码块来保证数据库的原子"
"性。如果代码块成功创建，这个变动会提交到数据库。如果有异常，变动会回滚。"

msgid ""
"``atomic`` blocks can be nested. In this case, when an inner block completes "
"successfully, its effects can still be rolled back if an exception is raised "
"in the outer block at a later point."
msgstr ""
"``atomic`` 块可以嵌套。在这个例子里，当内部块成功完成时，如果在稍后外部块里引"
"发了异常，则仍可回滚到最初效果。"

msgid ""
"It is sometimes useful to ensure an ``atomic`` block is always the outermost "
"``atomic`` block, ensuring that any database changes are committed when the "
"block is exited without errors. This is known as durability and can be "
"achieved by setting ``durable=True``. If the ``atomic`` block is nested "
"within another it raises a ``RuntimeError``."
msgstr ""

msgid "``atomic`` is usable both as a :py:term:`decorator`::"
msgstr "``atomic`` 既可用作 :py:term:`decorator`:: ："

msgid "and as a :py:term:`context manager`::"
msgstr "也可用作 :py:term:`context manager`:: ："

msgid ""
"Wrapping ``atomic`` in a try/except block allows for natural handling of "
"integrity errors::"
msgstr "在 try/except 块中使用装饰器 ``atomic`` 来允许自然处理完整性错误："

msgid ""
"In this example, even if ``generate_relationships()`` causes a database "
"error by breaking an integrity constraint, you can execute queries in "
"``add_children()``, and the changes from ``create_parent()`` are still there "
"and bound to the same transaction. Note that any operations attempted in "
"``generate_relationships()`` will already have been rolled back safely when "
"``handle_exception()`` is called, so the exception handler can also operate "
"on the database if necessary."
msgstr ""
"在这个例子里，虽然 ``generate_relationships()`` 会通过破坏完整性约束导致数据"
"库错误，但你可以 ``add_children()`` 中执行查找，来自 ``create_parent()`` 的变"
"化也会在这里，并且绑定到相同的事务。注意，任何试图在 "
"``generate_relationships()`` 中执行的操作在 ``handle_exception()`` 被调用的时"
"候也会安全的回滚，因此异常处理也会在必要的时候在数据库上操作。"

msgid "Avoid catching exceptions inside ``atomic``!"
msgstr "要避免在 ``atomic`` 内部捕捉异常！"

msgid ""
"When exiting an ``atomic`` block, Django looks at whether it's exited "
"normally or with an exception to determine whether to commit or roll back. "
"If you catch and handle exceptions inside an ``atomic`` block, you may hide "
"from Django the fact that a problem has happened. This can result in "
"unexpected behavior."
msgstr ""
"当存在 ``atomic`` 块时， Django 查看它是否正常退出或存在异常来决定是提交还是"
"正常回滚。如果你在 ``atomic`` 内部捕捉并且处理异常，你可以对 Django 隐藏问题"
"代码。这会导致一些意外的行为。"

msgid ""
"This is mostly a concern for :exc:`~django.db.DatabaseError` and its "
"subclasses such as :exc:`~django.db.IntegrityError`. After such an error, "
"the transaction is broken and Django will perform a rollback at the end of "
"the ``atomic`` block. If you attempt to run database queries before the "
"rollback happens, Django will raise a :class:`~django.db.transaction."
"TransactionManagementError`. You may also encounter this behavior when an "
"ORM-related signal handler raises an exception."
msgstr ""
"这主要是 :exc:`~django.db.DatabaseError` 和它的子类的一个问题（比如 :exc:"
"`~django.db.IntegrityError` ）。出现这样的错误之后，事务会奔溃，并且 Django "
"将在 ``atomic``  块的末尾执行回滚。如果你打算在回滚发生的时候运行数据库查询，"
"Django 将引发 :class:`~django.db.transaction.TransactionManagementError` 错"
"误。当 ORM 相关的信号处理程序引发异常时，你也可能遇到这个问题。"

msgid ""
"The correct way to catch database errors is around an ``atomic`` block as "
"shown above. If necessary, add an extra ``atomic`` block for this purpose. "
"This pattern has another advantage: it delimits explicitly which operations "
"will be rolled back if an exception occurs."
msgstr ""
"捕捉数据库错误的正确的方法是像上方所示那样围绕 ``atomic`` 块。如有需要，为此"
"目的可以添加额外的 ``atomic`` 块。这个模式有别的优势：如果异常发生，它会明确"
"界定哪些操作将回滚。"

msgid ""
"If you catch exceptions raised by raw SQL queries, Django's behavior is "
"unspecified and database-dependent."
msgstr ""
"如果捕获由原始SQL查询引发的异常，那么Django的行为是未指定的，并且依赖于数据"
"库。"

msgid ""
"You may need to manually revert model state when rolling back a transaction."
msgstr "当回滚事务时，你可能需要手工恢复模型状态。"

msgid ""
"The values of a model's fields won't be reverted when a transaction rollback "
"happens. This could lead to an inconsistent model state unless you manually "
"restore the original field values."
msgstr ""
"当事务回滚时，模型字段的值不会被恢复。除非你手工恢复初始的字段值，否则这会导"
"致模型状态不一致。"

msgid ""
"For example, given ``MyModel`` with an ``active`` field, this snippet "
"ensures that the ``if obj.active`` check at the end uses the correct value "
"if updating ``active`` to ``True`` fails in the transaction::"
msgstr ""
"例如，给定带有 ``active`` 字段的 ``MyModel`` 模型，如果在事务中更新 "
"``active`` 到 ``True`` 失败，那么这个片段确保最后的 ``if obj.active`` 检查使"
"用正确的值："

msgid ""
"In order to guarantee atomicity, ``atomic`` disables some APIs. Attempting "
"to commit, roll back, or change the autocommit state of the database "
"connection within an ``atomic`` block will raise an exception."
msgstr ""
"为了保证原子性，``atomic`` 禁用了一些API。在 ``atomic`` 块中试图提交、回滚或"
"改变数据库连接的自动提交状态将引发异常。"

msgid ""
"``atomic`` takes a ``using`` argument which should be the name of a "
"database. If this argument isn't provided, Django uses the ``\"default\"`` "
"database."
msgstr ""
"``atomic`` 带有 ``using`` 参数，这个参数是数据库名字。如果这个参数没有提供，"
"Django 会使用默认数据库。"

msgid "Under the hood, Django's transaction management code:"
msgstr "在后台，Django 的事务管理代码："

msgid "opens a transaction when entering the outermost ``atomic`` block;"
msgstr "当进入最外面的 ``atomic`` 块时打开事务；"

msgid "creates a savepoint when entering an inner ``atomic`` block;"
msgstr "当进入 ``atomic`` 块内部时创建一个保存点；"

msgid "releases or rolls back to the savepoint when exiting an inner block;"
msgstr "从块内部退出时释放或回滚保存点；"

msgid "commits or rolls back the transaction when exiting the outermost block."
msgstr "离开块的最外层时提交或回滚事务。"

msgid ""
"You can disable the creation of savepoints for inner blocks by setting the "
"``savepoint`` argument to ``False``. If an exception occurs, Django will "
"perform the rollback when exiting the first parent block with a savepoint if "
"there is one, and the outermost block otherwise. Atomicity is still "
"guaranteed by the outer transaction. This option should only be used if the "
"overhead of savepoints is noticeable. It has the drawback of breaking the "
"error handling described above."
msgstr ""
"你可以通过设置 ``savepoint`` 参数为 ``False`` 来为内部块禁用保存点的创建。如"
"果发生异常，Django将在退出带有保存点的第一个父块（如果有的话）时执行回滚，否"
"则退出最外面的块。外部事物仍保证了原子性。仅当保存点开销明显时，才应使用此选"
"项。它的缺点是破坏了上述错误处理。"

msgid ""
"You may use ``atomic`` when autocommit is turned off. It will only use "
"savepoints, even for the outermost block."
msgstr ""
"当自动提交关闭时，可以使用 ``atomic`` 。它将只使用保存点，即使对于最外面的块"
"也是如此。"

msgid "Performance considerations"
msgstr "性能考虑因素"

msgid ""
"Open transactions have a performance cost for your database server. To "
"minimize this overhead, keep your transactions as short as possible. This is "
"especially important if you're using :func:`atomic` in long-running "
"processes, outside of Django's request / response cycle."
msgstr ""
"打开事务会对数据库服务器有性能成本。尽量减少这种开销，要保持事务尽可能简短。"
"如果正在 Django 的请求 / 响应周期之外，在长时间运行的进程中使用 :func:"
"`atomic` ，这点尤其重要。"

msgid ""
":class:`django.test.TestCase` disables the durability check to allow testing "
"durable atomic blocks in a transaction for performance reasons. Use :class:"
"`django.test.TransactionTestCase` for testing durability."
msgstr ""

msgid "The ``durable`` argument was added."
msgstr ""

msgid "Autocommit"
msgstr "自动提交"

msgid "Why Django uses autocommit"
msgstr "为什么 Django 使用自动提交"

msgid ""
"In the SQL standards, each SQL query starts a transaction, unless one is "
"already active. Such transactions must then be explicitly committed or "
"rolled back."
msgstr ""
"在 SQL 规范中，每一个 SQL 查询会启动事务，除非一个事务已经处于活动状态。然后"
"必须显式地提交或回滚此事务。"

msgid ""
"This isn't always convenient for application developers. To alleviate this "
"problem, most databases provide an autocommit mode. When autocommit is "
"turned on and no transaction is active, each SQL query gets wrapped in its "
"own transaction. In other words, not only does each such query start a "
"transaction, but the transaction also gets automatically committed or rolled "
"back, depending on whether the query succeeded."
msgstr ""
"这对开发者来说一直很头疼。为了减轻这个问题，大部分数据库提供了自动提交模式。"
"当打开了自动提交，并且没有事务活动时，每一个 SQL 查询将被包含在自己的事务中。"
"换句话说，每一个这种查询不仅会启动一个事务，而且事务也会被自动提交或回滚，这"
"取决于查询是否成功。"

msgid ""
":pep:`249`, the Python Database API Specification v2.0, requires autocommit "
"to be initially turned off. Django overrides this default and turns "
"autocommit on."
msgstr ""
":pep:`249` （Python 数据库接口规范 v2.0）要求自动提交在初始时是关闭的。"
"Django 会覆盖这个默认值并开启自动提交。"

msgid ""
"To avoid this, you can :ref:`deactivate the transaction management "
"<deactivate-transaction-management>`, but it isn't recommended."
msgstr ""
"为了避免这种情况，你可以参考 deactivate the transaction "
"management<deactivate-transaction-management> ，但并不推荐这样做。"

msgid "Deactivating transaction management"
msgstr "停用事务管理"

msgid ""
"You can totally disable Django's transaction management for a given database "
"by setting :setting:`AUTOCOMMIT <DATABASE-AUTOCOMMIT>` to ``False`` in its "
"configuration. If you do this, Django won't enable autocommit, and won't "
"perform any commits. You'll get the regular behavior of the underlying "
"database library."
msgstr ""
"你可以通过设置 :setting:`AUTOCOMMIT <DATABASE-AUTOCOMMIT>` 为 ``False`` 来对"
"数据库完全禁用 Django 事务管理。如果你这么做了，Django 将不会启动自动提交，而"
"且不会执行任何提交。你将获得底层数据库的常规行为。"

msgid ""
"This requires you to commit explicitly every transaction, even those started "
"by Django or by third-party libraries. Thus, this is best used in situations "
"where you want to run your own transaction-controlling middleware or do "
"something really strange."
msgstr ""
"这要求你显式地提交每一个事务，即使它们通过 Django 或第三方库启动。因此，这适"
"用于当你想运行事务控制中间件或做一些非常奇怪的事情的情形。"

msgid "Performing actions after commit"
msgstr "提交后"

msgid ""
"Sometimes you need to perform an action related to the current database "
"transaction, but only if the transaction successfully commits. Examples "
"might include a `Celery`_ task, an email notification, or a cache "
"invalidation."
msgstr ""
"有时你需要执行与当前数据库事务相关的操作，但前提是事务成功提交。例子可能包含 "
"`Celery`_  任务，邮件提醒或缓存失效。"

msgid ""
"Django provides the :func:`on_commit` function to register callback "
"functions that should be executed after a transaction is successfully "
"committed:"
msgstr ""
" Django 提供了函数  :func:`on_commit` ，允许注册一个回调函数，以便事务成功提"
"交后执行。"

msgid "Pass any function (that takes no arguments) to :func:`on_commit`::"
msgstr "将任意函数（无参数）传递给 :func:`on_commit`::"

msgid "You can also wrap your function in a lambda::"
msgstr "你也可以使用 lambda:: 包装函数"

msgid ""
"The function you pass in will be called immediately after a hypothetical "
"database write made where ``on_commit()`` is called would be successfully "
"committed."
msgstr ""
"传入的函数将在成功提交调用“on_commit()”的假设数据库写操作后立即被调用。"

msgid ""
"If you call ``on_commit()`` while there isn't an active transaction, the "
"callback will be executed immediately."
msgstr "无任何活动事务时调用 ``on_commit()`` ，则回调函数会立即执行。"

msgid ""
"If that hypothetical database write is instead rolled back (typically when "
"an unhandled exception is raised in an :func:`atomic` block), your function "
"will be discarded and never called."
msgstr ""
"如果假设的数据库写入被回滚（尤其是在 :func:`atomic` 块里引发了一个未处理异"
"常），函数将被丢弃且永远不会被调用。"

msgid "Savepoints"
msgstr "保存点"

msgid ""
"Savepoints (i.e. nested :func:`atomic` blocks) are handled correctly. That "
"is, an :func:`on_commit` callable registered after a savepoint (in a nested :"
"func:`atomic` block) will be called after the outer transaction is "
"committed, but not if a rollback to that savepoint or any previous savepoint "
"occurred during the transaction::"
msgstr ""
"正确处理保存点（即嵌套了 :func:`atomic` 块）。也就是说，注册在保存点后的 :"
"func:`on_commit`  的调用（嵌套在 :func:`atomic`  块）将在外部事务被提交之后调"
"用，但如果在事务期间回滚到保存点或任何之前的保存点之前，则不会调用："

msgid ""
"On the other hand, when a savepoint is rolled back (due to an exception "
"being raised), the inner callable will not be called::"
msgstr "另一方面，当保存点回滚时（因引发异常），内部调用不会被调用："

msgid "Order of execution"
msgstr "执行顺序"

msgid ""
"On-commit functions for a given transaction are executed in the order they "
"were registered."
msgstr "事务提交后的的回调函数执行顺序与当初注册时的顺序一致。"

msgid "Exception handling"
msgstr "异常处理"

msgid ""
"If one on-commit function within a given transaction raises an uncaught "
"exception, no later registered functions in that same transaction will run. "
"This is the same behavior as if you'd executed the functions sequentially "
"yourself without :func:`on_commit`."
msgstr ""
"如果一个带有给定事务的 on-commit 函数引发了未捕获的异常，那么同一个事务里的后"
"续注册函数不会被运行。这与你在没有 :func:`on_commit` 的情况下顺序执行函数的行"
"为是一样的。"

msgid "Timing of execution"
msgstr "执行时间"

msgid ""
"Your callbacks are executed *after* a successful commit, so a failure in a "
"callback will not cause the transaction to roll back. They are executed "
"conditionally upon the success of the transaction, but they are not *part* "
"of the transaction. For the intended use cases (mail notifications, Celery "
"tasks, etc.), this should be fine. If it's not (if your follow-up action is "
"so critical that its failure should mean the failure of the transaction "
"itself), then you don't want to use the :func:`on_commit` hook. Instead, you "
"may want `two-phase commit`_ such as the :ref:`psycopg Two-Phase Commit "
"protocol support <psycopg2:tpc>` and the :pep:`optional Two-Phase Commit "
"Extensions in the Python DB-API specification <249#optional-two-phase-commit-"
"extensions>`."
msgstr ""
"你的回调会在成功提交之后执行，因此回调里的错误引发事务回滚。它们在事务成功时"
"有条件的执行，但它们不是事务的一部分。对于有预期的用例（邮件提醒，Celery 任务"
"等），这样应该没啥问题。如果它不是这样的用例（如果你的后续操作很关键，以至于"
"它的错误意味着事务失败），那么你可能不需要使用 :func:`on_commit` 钩子。相反，"
"你可能需要两阶段提交——比如两阶段提交协议支持（ :ref:`psycopg Two-Phase "
"Commit protocol support <psycopg2:tpc>` ）和在 Python DB-API 里说明的可选两阶"
"段提交扩展（ :pep:`optional Two-Phase Commit Extensions in the Python DB-API "
"specification <249#optional-two-phase-commit-extensions>` ） 。"

msgid ""
"Callbacks are not run until autocommit is restored on the connection "
"following the commit (because otherwise any queries done in a callback would "
"open an implicit transaction, preventing the connection from going back into "
"autocommit mode)."
msgstr ""
"直到在提交后的连接上恢复自动提交，调用才会运行。（因为否则在回调中完成的任何"
"查询都会打开一个隐式事务，防止连接返回自动提交模式）"

msgid ""
"When in autocommit mode and outside of an :func:`atomic` block, the function "
"will run immediately, not on commit."
msgstr ""
"当在自动提交模式并且在 :func:`atomic` 块外时，函数会立即自动运行，而不会提"
"交。"

msgid ""
"On-commit functions only work with :ref:`autocommit mode <managing-"
"autocommit>` and the :func:`atomic` (or :setting:`ATOMIC_REQUESTS <DATABASE-"
"ATOMIC_REQUESTS>`) transaction API. Calling :func:`on_commit` when "
"autocommit is disabled and you are not within an atomic block will result in "
"an error."
msgstr ""
"on-commit 函数仅适用于自动提交模式（ :ref:`autocommit mode <managing-"
"autocommit>` ），并且 :func:`atomic` （或 :setting:`ATOMIC_REQUESTS "
"<DATABASE-ATOMIC_REQUESTS>` ）事务API。当禁用自动提交并且当前不在原子块中时，"
"调用 :func:`on_commit` 将导致错误。"

msgid "Use in tests"
msgstr "在测试中使用"

msgid ""
"Django's :class:`~django.test.TestCase` class wraps each test in a "
"transaction and rolls back that transaction after each test, in order to "
"provide test isolation. This means that no transaction is ever actually "
"committed, thus your :func:`on_commit` callbacks will never be run."
msgstr ""

msgid ""
"You can overcome this limitation by using :meth:`.TestCase."
"captureOnCommitCallbacks`. This captures your :func:`on_commit` callbacks in "
"a list, allowing you to make assertions on them, or emulate the transaction "
"committing by calling them."
msgstr ""

msgid ""
"Another way to overcome the limitation is to use :class:`~django.test."
"TransactionTestCase` instead of :class:`~django.test.TestCase`. This will "
"mean your transactions are committed, and the callbacks will run. However :"
"class:`~django.test.TransactionTestCase` flushes the database between tests, "
"which is significantly slower than :class:`~django.test.TestCase`\\'s "
"isolation."
msgstr ""

msgid "Why no rollback hook?"
msgstr "为什么没有事务回滚钩子？"

msgid ""
"A rollback hook is harder to implement robustly than a commit hook, since a "
"variety of things can cause an implicit rollback."
msgstr ""
"事务回滚钩子相比事务提交钩子更难实现，因为各种各样的情况都可能造成隐式回滚。"

msgid ""
"For instance, if your database connection is dropped because your process "
"was killed without a chance to shut down gracefully, your rollback hook will "
"never run."
msgstr ""
"比如，如果数据库连接被删除，因为进程被杀而没有机会正常关闭，回滚钩子将不会运"
"行。"

msgid ""
"But there is a solution: instead of doing something during the atomic block "
"(transaction) and then undoing it if the transaction fails, use :func:"
"`on_commit` to delay doing it in the first place until after the transaction "
"succeeds. It's a lot easier to undo something you never did in the first "
"place!"
msgstr ""
"解决方法是：与其在执行事务时（原子操作）进行某项操作，当事务执行失败后再取消"
"这项操作，不如使用 :func:`on_commit` 来延迟该项操作，直到事务成功后再进行操"
"作。毕竟事务成功后你才能确保之后的操作是有意义的。"

msgid "Low-level APIs"
msgstr "底层API"

msgid ""
"Always prefer :func:`atomic` if possible at all. It accounts for the "
"idiosyncrasies of each database and prevents invalid operations."
msgstr ""
"应该尽可能使用 :func:`atomic` 。它说明了每个数据库的特性，并防止了无效操作。"

msgid ""
"The low level APIs are only useful if you're implementing your own "
"transaction management."
msgstr "底层API只在实现事务管理时有用。"

msgid ""
"Django provides an API in the :mod:`django.db.transaction` module to manage "
"the autocommit state of each database connection."
msgstr ""
" Django 在模块 :mod:`django.db.transaction` 中提供了一个 API 去管理不同数据库"
"的自动提交情况。"

msgid ""
"These functions take a ``using`` argument which should be the name of a "
"database. If it isn't provided, Django uses the ``\"default\"`` database."
msgstr ""
"这些函数使接受一个  ``using`` 参数表示所要操作的数据库。如果未提供，则   "
"Django 使用 ``\"default\"`` 数据库。"

msgid ""
"Autocommit is initially turned on. If you turn it off, it's your "
"responsibility to restore it."
msgstr "自动提交默认为开启，如果你将它关闭，自己承担后果。"

msgid ""
"Once you turn autocommit off, you get the default behavior of your database "
"adapter, and Django won't help you. Although that behavior is specified in :"
"pep:`249`, implementations of adapters aren't always consistent with one "
"another. Review the documentation of the adapter you're using carefully."
msgstr ""
"一旦你关闭了自动提交， Django 将无法帮助你，数据库将会按照你使用的数据库适配"
"器的默认行为进行操作。虽然适配器的标准经过了 :pep:`249` 详细规定，但不同适配"
"器的实现方式并不总是一致的。你需要谨慎地查看你所使用的适配器的文档。"

msgid ""
"You must ensure that no transaction is active, usually by issuing a :func:"
"`commit` or a :func:`rollback`, before turning autocommit back on."
msgstr ""
"在关闭自动提交之前，你必须确保当前没有活动的事务，通常你可以执行 :func:"
"`commit` 或者 :func:`rollback` 函数以达到该条件。"

msgid ""
"Django will refuse to turn autocommit off when an :func:`atomic` block is "
"active, because that would break atomicity."
msgstr ""
"当一个原子 :func:`atomic` 事务处于活动状态时， Django 将会拒绝关闭自动提交的"
"请求，因为这样会破坏原子性。"

msgid "Transactions"
msgstr "事务"

msgid ""
"A transaction is an atomic set of database queries. Even if your program "
"crashes, the database guarantees that either all the changes will be "
"applied, or none of them."
msgstr ""
"事务是指具有原子性的一系列数据库操作。即使你的程序崩溃，数据库也会确保这些操"
"作要么全部完成要么全部都未执行。"

msgid ""
"Django doesn't provide an API to start a transaction. The expected way to "
"start a transaction is to disable autocommit with :func:`set_autocommit`."
msgstr ""
" Django 并没有提供一个直接的 API 来创建一个事务，如果需要手动创建一个事务必须"
"通过 :func:`set_autocommit` 函数关闭自动提交。"

msgid ""
"Once you're in a transaction, you can choose either to apply the changes "
"you've performed until this point with :func:`commit`, or to cancel them "
"with :func:`rollback`. These functions are defined in :mod:`django.db."
"transaction`."
msgstr ""
"进入事务后，你可以选择在 :func:`commit` 之前应用执行的更改，或者使用 :func:"
"`rollback` 取消它们。这些函数在 :mod:`django.db.transaction` 中定义。"

msgid ""
"Django will refuse to commit or to rollback when an :func:`atomic` block is "
"active, because that would break atomicity."
msgstr ""
"当一个原子 :func:`atomic` 事务处于活动状态时， Django 将会拒绝进行事务提交或"
"者事务回滚，因为这样会破坏原子性。"

msgid ""
"A savepoint is a marker within a transaction that enables you to roll back "
"part of a transaction, rather than the full transaction. Savepoints are "
"available with the SQLite, PostgreSQL, Oracle, and MySQL (when using the "
"InnoDB storage engine) backends. Other backends provide the savepoint "
"functions, but they're empty operations -- they don't actually do anything."
msgstr ""
"保存点在事务中是标记物，它可以使得回滚部分乌市，而不是所有事务。 SQLite, "
"PostgreSQL, Oracle, 和 MySQL (当使用 InnoDB 存储引擎) 后端提供了保存点。其他"
"后端提供了保存点函数，但它们是空操作——它们实际上没有做任何事情。"

msgid ""
"Savepoints aren't especially useful if you are using autocommit, the default "
"behavior of Django. However, once you open a transaction with :func:"
"`atomic`, you build up a series of database operations awaiting a commit or "
"rollback. If you issue a rollback, the entire transaction is rolled back. "
"Savepoints provide the ability to perform a fine-grained rollback, rather "
"than the full rollback that would be performed by ``transaction.rollback()``."
msgstr ""
"如果你正在使用 Django 的默认行为——自动提交，保存点并不特别有用。尽管，一旦你"
"用 :func:`atomic` 打开了一个事务，那么需要构建一系列的等待提交或回滚的数据库"
"操作。如果发出回滚，那么会回滚整个事务。保存点有能力执行颗粒度级别的回滚，而"
"不是由 ``transaction.rollback()`` 执行的完全回滚。"

msgid ""
"When the :func:`atomic` decorator is nested, it creates a savepoint to allow "
"partial commit or rollback. You're strongly encouraged to use :func:`atomic` "
"rather than the functions described below, but they're still part of the "
"public API, and there's no plan to deprecate them."
msgstr ""
"当嵌套了 :func:`atomic` 装饰器，它会创建一个保存点来允许部分提交或回滚。强烈"
"推荐只使用 :func:`atomic` 而不是下面描述的函数，但它们仍然是公共 API 的一部"
"分，而且没计划要弃用它们。"

msgid ""
"Each of these functions takes a ``using`` argument which should be the name "
"of a database for which the behavior applies.  If no ``using`` argument is "
"provided then the ``\"default\"`` database is used."
msgstr ""
"这里的每一个函数使用 ``using`` 参数，这个参数为应用的数据库名。如果没有 "
"``using`` 参数，那么会使用 ``\"default\"`` 数据库。"

msgid ""
"Savepoints are controlled by three functions in :mod:`django.db.transaction`:"
msgstr "保存点由 :mod:`django.db.transaction`: 中的三个函数来控制："

msgid ""
"Creates a new savepoint. This marks a point in the transaction that is known "
"to be in a \"good\" state. Returns the savepoint ID (``sid``)."
msgstr ""
"创建新的保存点。这标志着事务中已知处于“良好”状态的一个点。返回保存点ID "
"(``sid``) 。"

msgid ""
"Releases savepoint ``sid``. The changes performed since the savepoint was "
"created become part of the transaction."
msgstr "释放保存点 ``sid`` 。自保存点被创建依赖执行的更改成为事务的一部分。"

msgid "Rolls back the transaction to savepoint ``sid``."
msgstr "回滚事务来保存 ``sid`` 。"

msgid ""
"These functions do nothing if savepoints aren't supported or if the database "
"is in autocommit mode."
msgstr "如果不支持保存点或数据库在自动模式时，这些函数不执行操作。"

msgid "In addition, there's a utility function:"
msgstr "另外，还有一个实用功能："

msgid "Resets the counter used to generate unique savepoint IDs."
msgstr "重置用于生成唯一保存点ID的计数器。"

msgid "The following example demonstrates the use of savepoints::"
msgstr "下面的例子演示保存点的用法："

msgid ""
"Savepoints may be used to recover from a database error by performing a "
"partial rollback. If you're doing this inside an :func:`atomic` block, the "
"entire block will still be rolled back, because it doesn't know you've "
"handled the situation at a lower level! To prevent this, you can control the "
"rollback behavior with the following functions."
msgstr ""
"保存点可能通过执行部分回滚来恢复数据库错误。如果你在 :func:`atomic` 块中执行"
"此操作，那么整个块将仍然被回滚，因为它不知道你已经处理了较低级别的情况。为了"
"防止此发生，你可以使用下面的函数控制回滚行为。"

msgid ""
"Setting the rollback flag to ``True`` forces a rollback when exiting the "
"innermost atomic block. This may be useful to trigger a rollback without "
"raising an exception."
msgstr ""
"当存在内部原子块时，设置回滚标记为 ``True`` 将强制回滚。这对于触发回滚而不引"
"发异常可能很有用。"

msgid ""
"Setting it to ``False`` prevents such a rollback. Before doing that, make "
"sure you've rolled back the transaction to a known-good savepoint within the "
"current atomic block! Otherwise you're breaking atomicity and data "
"corruption may occur."
msgstr ""
"将它设置为 ``False`` 会防止这样的回滚。在这样做之前，确保你已经将事务回滚到当"
"前原子块中一个正常的保存点。否则你会破坏原子性并且可能发生数据损坏。"

msgid "Database-specific notes"
msgstr "特定于数据库的注释"

msgid "Savepoints in SQLite"
msgstr "SQLite 中的保存点"

msgid ""
"While SQLite supports savepoints, a flaw in the design of the :mod:`sqlite3` "
"module makes them hardly usable."
msgstr ""
"虽然 SQLite 支持保存点时，但 :mod:`sqlite3` 模块中的一个设计缺陷使得它们几乎"
"无法使用。"

msgid ""
"When autocommit is enabled, savepoints don't make sense. When it's "
"disabled, :mod:`sqlite3` commits implicitly before savepoint statements. (In "
"fact, it commits before any statement other than ``SELECT``, ``INSERT``, "
"``UPDATE``, ``DELETE`` and ``REPLACE``.) This bug has two consequences:"
msgstr ""
"当启用自动提交时，保存点没有意义。当关闭时，:mod:`sqlite3` 会在保存点语句之前"
"隐式提交。（事实上，它会在除了 ``SELECT``, ``INSERT``, ``UPDATE``, "
"``DELETE`` and ``REPLACE`` 之前的任何语句之前提交）这个 Bug 有两个后果："

msgid ""
"The low level APIs for savepoints are only usable inside a transaction ie. "
"inside an :func:`atomic` block."
msgstr "保存点的底层API只能在事务中可用，即在 :func:`atomic` 块中。"

msgid "It's impossible to use :func:`atomic` when autocommit is turned off."
msgstr "当关闭自动提交时，不能使用 :func:`atomic` 。"

msgid "Transactions in MySQL"
msgstr "MySQL 中的事务"

msgid ""
"If you're using MySQL, your tables may or may not support transactions; it "
"depends on your MySQL version and the table types you're using. (By \"table "
"types,\" we mean something like \"InnoDB\" or \"MyISAM\".) MySQL transaction "
"peculiarities are outside the scope of this article, but the MySQL site has "
"`information on MySQL transactions`_."
msgstr ""
"如果你正在使用 MySQL，表可能支持或不支持事务；它取决于 MySQL 版本和表的类型。"
"（表类型是指 \"InnoDB\" 或 \"MyISAM\" 之类的东西）MySQL 事务的特性超出了本文"
"的范围，但 MySQL 站点有 MySQL 事务的相关信息。"

msgid ""
"If your MySQL setup does *not* support transactions, then Django will always "
"function in autocommit mode: statements will be executed and committed as "
"soon as they're called. If your MySQL setup *does* support transactions, "
"Django will handle transactions as explained in this document."
msgstr ""
"如果 MySQL 安装时没有支持事务，然后 Django 将始终在自动提交模式中运行：语句将"
"在它们调用的时候被执行和提交。如果 MySQL 安装时支持了事务，Django 将像本文说"
"的那样处理事务。"

msgid "Handling exceptions within PostgreSQL transactions"
msgstr "处理 PostgreSQL 事务中的异常"

msgid ""
"This section is relevant only if you're implementing your own transaction "
"management. This problem cannot occur in Django's default mode and :func:"
"`atomic` handles it automatically."
msgstr ""
"只有在实现自有的事务管理时，这部分才有用。这个问题不会发生在 Django 默认模式"
"里，并且 :func:`atomic`  会自动处理它。"

msgid ""
"Inside a transaction, when a call to a PostgreSQL cursor raises an exception "
"(typically ``IntegrityError``), all subsequent SQL in the same transaction "
"will fail with the error \"current transaction is aborted, queries ignored "
"until end of transaction block\". While the basic use of ``save()`` is "
"unlikely to raise an exception in PostgreSQL, there are more advanced usage "
"patterns which might, such as saving objects with unique fields, saving "
"using the force_insert/force_update flag, or invoking custom SQL."
msgstr ""
"在一个事务里，当对 PostgreSQL 游标的调用引发了异常（通常是 "
"``IntegrityError``），在同一事务中的随后的 SQL 将会出现 \"当前事务中止，查询"
"被忽略，直到事务块结束\" 的错误 。虽然 ``save()`` 的基本用法不太可能在 "
"PostgreSQL 中引发异常，但还有更高级的用法模式，比如保存具有唯一字段的对象，保"
"存使用 force_insert/force_update 标记，或调用自定义的 SQL。"

msgid "There are several ways to recover from this sort of error."
msgstr "有几种方法来从这种错误中恢复。"

msgid "Transaction rollback"
msgstr "事务回滚"

msgid "The first option is to roll back the entire transaction. For example::"
msgstr "第一个选项是回滚整个事务。比如："

msgid ""
"Calling ``transaction.rollback()`` rolls back the entire transaction. Any "
"uncommitted database operations will be lost. In this example, the changes "
"made by ``a.save()`` would be lost, even though that operation raised no "
"error itself."
msgstr ""
"调用 ``transaction.rollback()`` 回滚整个事务。任何未提交的数据库操作会被丢"
"弃。在这个例子里， ``a.save()`` 做的改变会丢失，即使操作本身没有引发错误。"

msgid "Savepoint rollback"
msgstr "保存点回滚"

msgid ""
"You can use :ref:`savepoints <topics-db-transactions-savepoints>` to control "
"the extent of a rollback. Before performing a database operation that could "
"fail, you can set or update the savepoint; that way, if the operation fails, "
"you can roll back the single offending operation, rather than the entire "
"transaction. For example::"
msgstr ""
"你可以使用 :ref:`savepoints <topics-db-transactions-savepoints>` 来控制回滚的"
"程度。执行可能失败的数据库操作之前，你可以设置或更新保存点；这样，如果操作失"
"败，你可以回滚单一的错误操作，而不是回滚整个事务。比如："

msgid ""
"In this example, ``a.save()`` will not be undone in the case where ``b."
"save()`` raises an exception."
msgstr ""
"在这个例子里， ``a.save()`` 将不会在 ``b.save()`` 引发异常的情况下被撤销。"

msgid "Sending email"
msgstr "发送邮件"

msgid ""
"Although Python provides a mail sending interface via the :mod:`smtplib` "
"module, Django provides a couple of light wrappers over it. These wrappers "
"are provided to make sending email extra quick, to help test email sending "
"during development, and to provide support for platforms that can't use SMTP."
msgstr ""
"虽然 Python 通过 :mod:`smtplib` 模块提供了邮件发送的接口，但是 Django 在其基"
"础上提供了更简化的支持。这些封装意在加快邮件发送，在开发时测试发送邮件，在不"
"支持 SMTP 的平台上支持发送邮件。"

msgid "The code lives in the ``django.core.mail`` module."
msgstr "这些代码位于 ``django.core.mail`` 模块。"

msgid "In two lines::"
msgstr "仅需两行代码::"

msgid ""
"Mail is sent using the SMTP host and port specified in the :setting:"
"`EMAIL_HOST` and :setting:`EMAIL_PORT` settings. The :setting:"
"`EMAIL_HOST_USER` and :setting:`EMAIL_HOST_PASSWORD` settings, if set, are "
"used to authenticate to the SMTP server, and the :setting:`EMAIL_USE_TLS` "
"and :setting:`EMAIL_USE_SSL` settings control whether a secure connection is "
"used."
msgstr ""
"邮件是通过 SMTP 主机和端口发送的，由配置项 :setting:`EMAIL_HOST` 和 :setting:"
"`EMAIL_PORT` 指定。如果配置了 :setting:`EMAIL_HOST_USER` 和 :setting:"
"`EMAIL_HOST_PASSWORD` ，那么它们将被用来验证  SMTP 服务器。配置项 :setting:"
"`EMAIL_USE_TLS` 和 :setting:`EMAIL_USE_SSL` 控制是否使用安全连接。"

msgid ""
"The character set of email sent with ``django.core.mail`` will be set to the "
"value of your :setting:`DEFAULT_CHARSET` setting."
msgstr ""
"通过 ``django.core.mail`` 发送的邮件的字符编码由 :setting:`DEFAULT_CHARSET` "
"设置项指定。"

msgid "``send_mail()``"
msgstr "``send_mail()``"

msgid ""
"In most cases, you can send email using ``django.core.mail.send_mail()``."
msgstr ""
"在大多数情况里，你可以使用 ``django.core.mail.send_mail()`` 来发送邮件。"

msgid ""
"The ``subject``, ``message``, ``from_email`` and ``recipient_list`` "
"parameters are required."
msgstr ""
"参数 ``subject``, ``message``, ``from_email`` 和 ``recipient_list`` 是必须"
"的。"

msgid "``subject``: A string."
msgstr "``subject``: 一个字符串。"

msgid "``message``: A string."
msgstr "``message``: 一个字符串。"

msgid ""
"``from_email``: A string. If ``None``, Django will use the value of the :"
"setting:`DEFAULT_FROM_EMAIL` setting."
msgstr ""
"``from_email`` ：字符串。如果为 ``None`` ，Django 将使用 :setting:"
"`DEFAULT_FROM_EMAIL` 设置的值。"

msgid ""
"``recipient_list``: A list of strings, each an email address. Each member of "
"``recipient_list`` will see the other recipients in the \"To:\" field of the "
"email message."
msgstr ""
"``recipient_list``: 一个字符串列表，每项都是一个邮箱地址。``recipient_list`` "
"中的每个成员都可以在邮件的 \"收件人:\" 中看到其他的收件人。"

msgid ""
"``fail_silently``: A boolean. When it's ``False``, ``send_mail()`` will "
"raise an :exc:`smtplib.SMTPException` if an error occurs. See the :mod:"
"`smtplib` docs for a list of possible exceptions, all of which are "
"subclasses of :exc:`~smtplib.SMTPException`."
msgstr ""
"``fail_silently``: 一个布尔值。若为 ``False``， ``send_mail()`` 会在发生错误"
"时抛出 :exc:`smtplib.SMTPException` 。可在 :mod:`smtplib` 文档找到一系列可能"
"的异常，它们都是 :exc:`~smtplib.SMTPException` 的子类。"

msgid ""
"``auth_user``: The optional username to use to authenticate to the SMTP "
"server. If this isn't provided, Django will use the value of the :setting:"
"`EMAIL_HOST_USER` setting."
msgstr ""
"``auth_user``: 可选的用户名，用于验证登陆 SMTP 服务器。 若未提供，Django 会使"
"用 :setting:`EMAIL_HOST_USER` 指定的值。"

msgid ""
"``auth_password``: The optional password to use to authenticate to the SMTP "
"server. If this isn't provided, Django will use the value of the :setting:"
"`EMAIL_HOST_PASSWORD` setting."
msgstr ""
"``auth_password``: 可选的密码，用于验证登陆 SMTP 服务器。若未提供， Django 会"
"使用 :setting:`EMAIL_HOST_PASSWORD` 指定的值。"

msgid ""
"``connection``: The optional email backend to use to send the mail. If "
"unspecified, an instance of the default backend will be used. See the "
"documentation on :ref:`Email backends <topic-email-backends>` for more "
"details."
msgstr ""
"``connection``: 可选参数，发送邮件使用的后端。若未指定，则使用默认的后端。查"
"询 :ref:`邮件后端 <topic-email-backends>` 文档获取更多细节。"

msgid ""
"``html_message``: If ``html_message`` is provided, the resulting email will "
"be a :mimetype:`multipart/alternative` email with ``message`` as the :"
"mimetype:`text/plain` content type and ``html_message`` as the :mimetype:"
"`text/html` content type."
msgstr ""
"``html_message``: 若提供了 ``html_message``，会使邮件成为 :mimetype:"
"`multipart/alternative` 的实例， ``message`` 的内容类型则是 :mimetype:`text/"
"plain` ，并且 ``html_message`` 的内容类型是 :mimetype:`text/html` 。"

msgid ""
"The return value will be the number of successfully delivered messages "
"(which can be ``0`` or ``1`` since it can only send one message)."
msgstr ""
"返回值会是成功发送的信息的数量（只能是 ``0`` 或 ``1`` ，因为同时只能发送一条"
"消息）。"

msgid "``send_mass_mail()``"
msgstr "``send_mass_mail()``"

msgid ""
"``django.core.mail.send_mass_mail()`` is intended to handle mass emailing."
msgstr "``django.core.mail.send_mass_mail()`` 用于批量发送邮件。"

msgid "``datatuple`` is a tuple in which each element is in this format::"
msgstr "``datatuple`` 是一个元组，形式如下::"

msgid ""
"``fail_silently``, ``auth_user`` and ``auth_password`` have the same "
"functions as in :meth:`~django.core.mail.send_mail()`."
msgstr ""
"``fail_silently``， ``auth_user`` 和 ``auth_password`` 拥有在 :meth:`~django."
"core.mail.send_mail()` 中一样的功能。"

msgid ""
"Each separate element of ``datatuple`` results in a separate email message. "
"As in :meth:`~django.core.mail.send_mail()`, recipients in the same "
"``recipient_list`` will all see the other addresses in the email messages' "
"\"To:\" field."
msgstr ""
"``datatuple`` 参数的每个元素会生成一份独立的邮件内容。就像 :meth:`~django."
"core.mail.send_mail()` 中的一样， ``recipient_list`` 中的每个收件人会在邮件"
"的 \"收件人:\" 中看到其他收件人的地址一样。"

msgid ""
"For example, the following code would send two different messages to two "
"different sets of recipients; however, only one connection to the mail "
"server would be opened::"
msgstr ""
"举个例子，以下代码会向两个不同的收件人列表发送两封不同的邮件，却复用了同一条"
"连接::"

msgid "The return value will be the number of successfully delivered messages."
msgstr "返回值是成功发送的消息的数量。"

msgid "``send_mass_mail()`` vs. ``send_mail()``"
msgstr "``send_mass_mail()`` vs. ``send_mail()``"

msgid ""
"The main difference between :meth:`~django.core.mail.send_mass_mail()` and :"
"meth:`~django.core.mail.send_mail()` is that :meth:`~django.core.mail."
"send_mail()` opens a connection to the mail server each time it's executed, "
"while :meth:`~django.core.mail.send_mass_mail()` uses a single connection "
"for all of its messages. This makes :meth:`~django.core.mail."
"send_mass_mail()` slightly more efficient."
msgstr ""
" :meth:`~django.core.mail.send_mass_mail()` 和 :meth:`~django.core.mail."
"send_mail()` 之间的主要区别是 :meth:`~django.core.mail.send_mail()` 每次执行"
"都会新建一条至邮件服务器的连接，而 :meth:`~django.core.mail."
"send_mass_mail()` 对每封邮件复用同一个连接。这使得 :meth:`~django.core.mail."
"send_mass_mail()` 更高效。"

msgid "``mail_admins()``"
msgstr "``mail_admins()``"

msgid ""
"``django.core.mail.mail_admins()`` is a shortcut for sending an email to the "
"site admins, as defined in the :setting:`ADMINS` setting."
msgstr ""
"``django.core.mail.mail_admins()`` 是定义在 :setting:`ADMINS` 配置项中，用于"
"向网站所有者快速发送邮件。"

msgid ""
"``mail_admins()`` prefixes the subject with the value of the :setting:"
"`EMAIL_SUBJECT_PREFIX` setting, which is ``\"[Django] \"`` by default."
msgstr ""
"``mail_admins()`` 在主题前面添加 :setting:`EMAIL_SUBJECT_PREFIX` 指定的前缀，"
"默认是 ``\"[Django] \"`` 。"

msgid ""
"The \"From:\" header of the email will be the value of the :setting:"
"`SERVER_EMAIL` setting."
msgstr "邮件头的 \"发件人:\" 由 :setting:`SERVER_EMAIL` 配置项指定。"

msgid "This method exists for convenience and readability."
msgstr "创建这个方法是为了方便和可读性。"

msgid ""
"If ``html_message`` is provided, the resulting email will be a :mimetype:"
"`multipart/alternative` email with ``message`` as the :mimetype:`text/plain` "
"content type and ``html_message`` as the :mimetype:`text/html` content type."
msgstr ""
"若提供了 ``html_message``，会使邮件成为 :mimetype:`multipart/alternative` 的"
"实例， ``message`` 的内容类型则是 :mimetype:`text/plain` ，并且 "
"``html_message`` 的内容类型是 :mimetype:`text/html` 。"

msgid "``mail_managers()``"
msgstr "``mail_managers()``"

msgid ""
"``django.core.mail.mail_managers()`` is just like ``mail_admins()``, except "
"it sends an email to the site managers, as defined in the :setting:"
"`MANAGERS` setting."
msgstr ""
"``django.core.mail.mail_managers()`` 类似 ``mail_admins()``，但它向 :setting:"
"`MANAGERS` 指定的管理员们发送邮件。"

msgid "Examples"
msgstr "示例"

msgid ""
"This sends a single email to john@example.com and jane@example.com, with "
"them both appearing in the \"To:\"::"
msgstr ""
"以下发送了一封邮件给 john@example.com 和 jane@example.com，他们都出现在 \"收"
"件人:\"::"

msgid ""
"This sends a message to john@example.com and jane@example.com, with them "
"both receiving a separate email::"
msgstr ""
"以下分别发送了一封邮件给 john@example.com 和 jane@example.com，他们收到了独立"
"的邮件::"

msgid "Preventing header injection"
msgstr "防止头注入"

msgid ""
"`Header injection`_ is a security exploit in which an attacker inserts extra "
"email headers to control the \"To:\" and \"From:\" in email messages that "
"your scripts generate."
msgstr ""
"`Header injection`_ 是一个开发漏洞，攻击者可以利用它在邮件头插入额外信息，以"
"控制脚本生成的邮件中的  \"收件人:\" 和 \"发件人:\" 内容。"

msgid ""
"The Django email functions outlined above all protect against header "
"injection by forbidding newlines in header values. If any ``subject``, "
"``from_email`` or ``recipient_list`` contains a newline (in either Unix, "
"Windows or Mac style), the email function (e.g. :meth:`~django.core.mail."
"send_mail()`) will raise ``django.core.mail.BadHeaderError`` (a subclass of "
"``ValueError``) and, hence, will not send the email. It's your "
"responsibility to validate all data before passing it to the email functions."
msgstr ""
"Django 的邮件函数包含了以上所有的反头注入功能，通过在头中禁止新的行。如果 "
"``subject``， ``from_email`` 或 ``recipient_list`` 包含了新行（不管是 Unix，"
"Windows 或 Mac 格式中的哪一种），邮件函数（比如 :meth:`~django.core.mail."
"send_mail()` ）都会抛出一个 ``django.core.mail.BadHeaderError`` "
"（ ``ValueError`` 的子类），这会中断邮件发送。你需要在将参数传给邮件函数前确"
"保数据的有效性和合法性。"

msgid ""
"If a ``message`` contains headers at the start of the string, the headers "
"will be printed as the first bit of the email message."
msgstr ""
"如果邮件的 ``内容`` 的开始部分包含了邮件头信息，这些头信息只会作为邮件内容原"
"样打印。"

msgid ""
"Here's an example view that takes a ``subject``, ``message`` and "
"``from_email`` from the request's POST data, sends that to admin@example.com "
"and redirects to \"/contact/thanks/\" when it's done::"
msgstr ""
"以下是一个实例视图，从请求的 POST 数据中获取 ``subject``， ``message`` 和 "
"``from_email``，并将其发送至 admin@example.com ，成功后再重定向至 \"/contact/"
"thanks/\" ::"

msgid "The ``EmailMessage`` class"
msgstr "``EmailMessage`` 类"

msgid ""
"Django's :meth:`~django.core.mail.send_mail()` and :meth:`~django.core.mail."
"send_mass_mail()` functions are actually thin wrappers that make use of the :"
"class:`~django.core.mail.EmailMessage` class."
msgstr ""
"Django 的 :meth:`~django.core.mail.send_mail()` 和 :meth:`~django.core.mail."
"send_mass_mail()` 函数仅是对类 :class:`~django.core.mail.EmailMessage` 的简单"
"封装利用。"

msgid ""
"Not all features of the :class:`~django.core.mail.EmailMessage` class are "
"available through the :meth:`~django.core.mail.send_mail()` and related "
"wrapper functions. If you wish to use advanced features, such as BCC'ed "
"recipients, file attachments, or multi-part email, you'll need to create :"
"class:`~django.core.mail.EmailMessage` instances directly."
msgstr ""
"通过 :meth:`~django.core.mail.send_mail()` 和其它关联的封装函数，不是所有 :"
"class:`~django.core.mail.EmailMessage` 的功能都是可用的。如果你想用进阶功能，"
"比如密送收件人，附件，分段邮件，你需要直接创建 :class:`~django.core.mail."
"EmailMessage` 的实例。"

msgid ""
"This is a design feature. :meth:`~django.core.mail.send_mail()` and related "
"functions were originally the only interface Django provided. However, the "
"list of parameters they accepted was slowly growing over time. It made sense "
"to move to a more object-oriented design for email messages and retain the "
"original functions only for backwards compatibility."
msgstr ""
"这是一种设计方式。最初 Django 只提供了 :meth:`~django.core.mail.send_mail()` "
"和其它关联的函数。但是，随着时间的推移，它们的参数列表在慢慢地变长。所以，我"
"们转向了更加面向对象的设计。在兼顾发送邮件的功能的同时，出于向后兼容的考虑，"
"保留了这些函数。"

msgid ""
":class:`~django.core.mail.EmailMessage` is responsible for creating the "
"email message itself. The :ref:`email backend <topic-email-backends>` is "
"then responsible for sending the email."
msgstr ""
":class:`~django.core.mail.EmailMessage` 用于创建邮件消息。 :ref:`邮件后端  "
"<topic-email-backends>` 用于发送邮件。"

msgid ""
"For convenience, :class:`~django.core.mail.EmailMessage` provides a "
"``send()`` method for sending a single email. If you need to send multiple "
"messages, the email backend API :ref:`provides an alternative <topics-"
"sending-multiple-emails>`."
msgstr ""
"出于方便起见， :class:`~django.core.mail.EmailMessage` 提供了一个 ``send()`` "
"方法，用于发送一封邮件。如果你需要发送多封邮件，邮件后端 API :ref:`提供了选"
"择 <topics-sending-multiple-emails>`。"

msgid "``EmailMessage`` Objects"
msgstr "``EmailMessage`` 对象"

msgid ""
"The :class:`~django.core.mail.EmailMessage` class is initialized with the "
"following parameters (in the given order, if positional arguments are used). "
"All parameters are optional and can be set at any time prior to calling the "
"``send()`` method."
msgstr ""
"类 :class:`~django.core.mail.EmailMessage` 通过以下参数构造（可选参数要按指定"
"顺序提供）。所以的参数都是可选的，且可在调用 ``send()`` 方法前设置。"

msgid "``subject``: The subject line of the email."
msgstr "``subject``: 邮件的主题。"

msgid "``body``: The body text. This should be a plain text message."
msgstr "``body``: 邮件内容，需要为纯文本格式。"

msgid ""
"``from_email``: The sender's address. Both ``fred@example.com`` and ``\"Fred"
"\" <fred@example.com>`` forms are legal. If omitted, the :setting:"
"`DEFAULT_FROM_EMAIL` setting is used."
msgstr ""
"``from_email``: 发件人地址。  ``fred@example.com`` 和 ``Fred <fred@example."
"com>`` 形式都是合法的。若省略，则使用 :setting:`DEFAULT_FROM_EMAIL` 配置的"
"值。"

msgid "``to``: A list or tuple of recipient addresses."
msgstr "``to``: 一个包含收件人地址的列表或元组。"

msgid ""
"``bcc``: A list or tuple of addresses used in the \"Bcc\" header when "
"sending the email."
msgstr "``bcc``: 一个包含地址的列表或元组，指定“密送”对象。"

msgid ""
"``connection``: An email backend instance. Use this parameter if you want to "
"use the same connection for multiple messages. If omitted, a new connection "
"is created when ``send()`` is called."
msgstr ""
"``connection``: 一个邮件后端的实例。若在发送多份邮件时，若想复用连接，则设置"
"此参数。如果省略，在调用 ``send()`` 时总会创建新连接。"

msgid ""
"``attachments``: A list of attachments to put on the message. These can be "
"either :class:`~email.mime.base.MIMEBase` instances, or ``(filename, "
"content, mimetype)`` triples."
msgstr ""
"``attachments``: 附加在邮件中的附件列表。 可以是 :class:`~email.mime.base."
"MIMEBase` 的实例，或 ``(文件名，内容，mimetype)`` 的元组。"

msgid ""
"``headers``: A dictionary of extra headers to put on the message. The keys "
"are the header name, values are the header values. It's up to the caller to "
"ensure header names and values are in the correct format for an email "
"message. The corresponding attribute is ``extra_headers``."
msgstr ""
"``headers``: 一个字典，包含邮件中额外的头信息。字典的关键字是头的名称，值为头"
"的值。需要由调用者确保头名和值的正确性。对应的属性是 ``extra_headers`` 。"

msgid ""
"``cc``: A list or tuple of recipient addresses used in the \"Cc\" header "
"when sending the email."
msgstr "``cc``: 一个包含收件人地址的列表或元组，指定“抄送”对象。"

msgid ""
"``reply_to``: A list or tuple of recipient addresses used in the \"Reply-To"
"\" header when sending the email."
msgstr "``reply_to``: 一个包含收件人地址的列表或元组，指定“回复”对象。"

msgid "The class has the following methods:"
msgstr "这个类拥有以下方法："

msgid ""
"``send(fail_silently=False)`` sends the message. If a connection was "
"specified when the email was constructed, that connection will be used. "
"Otherwise, an instance of the default backend will be instantiated and used. "
"If the keyword argument ``fail_silently`` is ``True``, exceptions raised "
"while sending the message will be quashed. An empty list of recipients will "
"not raise an exception. It will return ``1`` if the message was sent "
"successfully, otherwise ``0``."
msgstr ""

msgid ""
"``message()`` constructs a ``django.core.mail.SafeMIMEText`` object (a "
"subclass of Python's :class:`~email.mime.text.MIMEText` class) or a ``django."
"core.mail.SafeMIMEMultipart`` object holding the message to be sent. If you "
"ever need to extend the :class:`~django.core.mail.EmailMessage` class, "
"you'll probably want to override this method to put the content you want "
"into the MIME object."
msgstr ""
"``message()`` 构建了一个 ``django.core.mail.SafeMIMEText`` 对象（ :class:"
"`~email.mime.text.MIMEText` 的子类）或一个 ``django.core.mail."
"SafeMIMEMultipart`` 对象用于存储邮件内容。如果你想继承 :class:`~django.core."
"mail.EmailMessage` ，你可能期望重写这个方法，在 MIME 对象中放入你期望的内容。"

msgid ""
"``recipients()`` returns a list of all the recipients of the message, "
"whether they're recorded in the ``to``, ``cc`` or ``bcc`` attributes. This "
"is another method you might need to override when subclassing, because the "
"SMTP server needs to be told the full list of recipients when the message is "
"sent. If you add another way to specify recipients in your class, they need "
"to be returned from this method as well."
msgstr ""
"``recipients()`` 返回一个包含邮件所以收件人的列表，不管他们是收件人，抄送人，"
"密送人中的哪一个。这可能是另一个你在创建子类时想复现的方法，因为 SMTP 服务器"
"需要你在发送邮件时告诉它完整的收件人列表。如果你在子类中实现了另一个方法，指"
"定收件人列表，这个方法必须也返回相同的结果。"

msgid ""
"``attach()`` creates a new file attachment and adds it to the message. There "
"are two ways to call ``attach()``:"
msgstr ""
"``attach()`` 创建一个新的附件，并加到邮件。有两种调用 ``attach()`` 的方式:"

msgid ""
"You can pass it a single argument that is a :class:`~email.mime.base."
"MIMEBase` instance. This will be inserted directly into the resulting "
"message."
msgstr ""
"可以仅传送一个 :class:`~email.mime.base.MIMEBase` 的实例。这会被直接插入邮"
"件。"

msgid ""
"Alternatively, you can pass ``attach()`` three arguments: ``filename``, "
"``content`` and ``mimetype``. ``filename`` is the name of the file "
"attachment as it will appear in the email, ``content`` is the data that will "
"be contained inside the attachment and ``mimetype`` is the optional MIME "
"type for the attachment. If you omit ``mimetype``, the MIME content type "
"will be guessed from the filename of the attachment."
msgstr ""
"另一个可选的方案，你可以向 ``attach()`` 传递 3 个参数： ``filename`` ， "
"``content`` 和 ``mimetype``。 ``filename`` 是文件附件的名字，它会显示在邮件"
"中， ``content`` 是附件包含的数据，而 ``mimetype`` 是一个可选参数，指定附件"
"的 MIME 类型。如果你省略了 ``mimetype``，MIME 类型将会参考附件的文件名。"

msgid ""
"If you specify a ``mimetype`` of :mimetype:`message/rfc822`, it will also "
"accept :class:`django.core.mail.EmailMessage` and :py:class:`email.message."
"Message`."
msgstr ""
"如果你指定 :mimetype:`message/rfc822` 的 ``mimetype``，它也会接受:class:"
"`django.core.mail.EmailMessage` 和 :py:class:`email.message.Message`。"

msgid ""
"For a ``mimetype`` starting with :mimetype:`text/`, content is expected to "
"be a string. Binary data will be decoded using UTF-8, and if that fails, the "
"MIME type will be changed to :mimetype:`application/octet-stream` and the "
"data will be attached unchanged."
msgstr ""
"对于以 :mimetype:`text/` 开头的 ``mimetype`` 类型，其内容应该是字符串。二进制"
"数据将尝试以 UTF-8 解码，如果失败了，MIME 类型会被改为 :mimetype:"
"`application/octet-stream` ，并不会修改数据内容。"

msgid ""
"In addition, :mimetype:`message/rfc822` attachments will no longer be base64-"
"encoded in violation of :rfc:`2046#section-5.2.1`, which can cause issues "
"with displaying the attachments in `Evolution`__ and `Thunderbird`__."
msgstr ""
"此外， :mimetype:`message/rfc822` 附件不再是 base64 编码，因为违反了 :rfc:"
"`2046#section-5.2.1` 。之前在 `Evolution`__ 和 `Thunderbird`__ 会造成显示问"
"题。"

msgid ""
"``attach_file()`` creates a new attachment using a file from your "
"filesystem. Call it with the path of the file to attach and, optionally, the "
"MIME type to use for the attachment. If the MIME type is omitted, it will be "
"guessed from the filename. You can use it like this::"
msgstr ""
"``attach_file()`` 通过从本地文件系统中选择一个文件的方式创建附件。调用时，传"
"入文件的路径。附件的 MIME 类型是可选的。如果省略了 MIME 类型，会参考文件名。"
"你可以这样使用："

msgid ""
"For MIME types starting with :mimetype:`text/`, binary data is handled as in "
"``attach()``."
msgstr ""
"对于 MIME 类型以 :mimetype:`text/` 开头的，二进制数据的处理方式与 "
"``attach()`` 中的一样。"

msgid "Sending alternative content types"
msgstr "发送可选的内容类型。"

msgid ""
"It can be useful to include multiple versions of the content in an email; "
"the classic example is to send both text and HTML versions of a message. "
"With Django's email library, you can do this using the "
"``EmailMultiAlternatives`` class. This subclass of :class:`~django.core.mail."
"EmailMessage` has an ``attach_alternative()`` method for including extra "
"versions of the message body in the email. All the other methods (including "
"the class initialization) are inherited directly from :class:`~django.core."
"mail.EmailMessage`."
msgstr ""
"在邮件中包含不同类型的内容是很实用的技巧；典型的例子是在邮件中同时包含文本和 "
"HTML 内容。通过 Django 的邮件库，你可以使用 ``EmailMultiAlternatives`` 完成目"
"的。它是 :class:`~django.core.mail.EmailMessage` 的子类，有一个 "
"``attach_alternative()`` 方法，用于在邮件主体中添加不同类型的内容。所以其它的"
"方法（包括类构造器）都直接从父类 :class:`~django.core.mail.EmailMessage` 继"
"承。"

msgid "To send a text and HTML combination, you could write::"
msgstr "发送文本和 HTML 的混合体，你可以这么写::"

msgid ""
"By default, the MIME type of the ``body`` parameter in an :class:`~django."
"core.mail.EmailMessage` is ``\"text/plain\"``. It is good practice to leave "
"this alone, because it guarantees that any recipient will be able to read "
"the email, regardless of their mail client. However, if you are confident "
"that your recipients can handle an alternative content type, you can use the "
"``content_subtype`` attribute on the :class:`~django.core.mail.EmailMessage` "
"class to change the main content type. The major type will always be ``\"text"
"\"``, but you can change the subtype. For example::"
msgstr ""
"默认情况下，:class:`~django.core.mail.EmailMessage` 的 ``body`` 参数的 MIME "
"类型是 ``\"text/plain\"``。经验告诉我们，不改它会更好。因为这样能确保不管收件"
"人使用何种邮件客户端都可以正常的阅读邮件。不过，如果你能确保你的收件人都能处"
"理可选的内容类型，你可以使用 :class:`~django.core.mail.EmailMessage` 类的 "
"``content_subtype`` 属性改变主要内容的类型。主类型一般总是 ``\"text\"``，但你"
"可以修改子类型。比如::"

msgid "Email backends"
msgstr "邮件后端"

msgid "The actual sending of an email is handled by the email backend."
msgstr "发送邮件的动作是由邮件后端执行的。"

msgid "The email backend class has the following methods:"
msgstr "邮件后端类拥有以下方法："

msgid "``open()`` instantiates a long-lived email-sending connection."
msgstr "``open()`` 创建一个发送邮件的长连接。"

msgid "``close()`` closes the current email-sending connection."
msgstr "``close()`` 关闭当前发送邮件的连接。"

msgid ""
"``send_messages(email_messages)`` sends a list of :class:`~django.core.mail."
"EmailMessage` objects. If the connection is not open, this call will "
"implicitly open the connection, and close the connection afterward. If the "
"connection is already open, it will be left open after mail has been sent."
msgstr ""

msgid ""
"It can also be used as a context manager, which will automatically call "
"``open()`` and ``close()`` as needed::"
msgstr ""
"这也可以用作内容管理器，它会在需要的时候自动调用 ``open()`` 和 ``close()``::"

msgid "Obtaining an instance of an email backend"
msgstr "获取邮件后端的一个实例"

msgid ""
"The :meth:`get_connection` function in ``django.core.mail`` returns an "
"instance of the email backend that you can use."
msgstr ""
"``django.core.mail`` 中的 :meth:`get_connection` 函数返回一个你能使用的邮件后"
"端实例。"

msgid ""
"By default, a call to ``get_connection()`` will return an instance of the "
"email backend specified in :setting:`EMAIL_BACKEND`. If you specify the "
"``backend`` argument, an instance of that backend will be instantiated."
msgstr ""
"默认情况下，调用 ``get_connection()`` 会返回配置项 :setting:`EMAIL_BACKEND` "
"指定的后端。如果你传入了 ``backend`` 参数，将会返回该后端的实例。"

msgid ""
"The ``fail_silently`` argument controls how the backend should handle "
"errors. If ``fail_silently`` is True, exceptions during the email sending "
"process will be silently ignored."
msgstr ""
"``fail_silently`` 控制后端怎么处理错误。若 ``fail_silently`` 为 True，发送邮"
"件过程中的异常都会被和谐掉。"

msgid ""
"All other arguments are passed directly to the constructor of the email "
"backend."
msgstr "剩余的参数将直接传给邮件后端的构造器。"

msgid ""
"Django ships with several email sending backends. With the exception of the "
"SMTP backend (which is the default), these backends are only useful during "
"testing and development. If you have special email sending requirements, you "
"can :ref:`write your own email backend <topic-custom-email-backend>`."
msgstr ""
"Django 自带了几种邮件后端。除了 SMTP 后端（默认值）外，这些后端应仅在开发和测"
"试阶段使用。如果对发送邮件有特殊的需求，你可以 :ref:`编写自定义后端 <topic-"
"custom-email-backend>`。"

msgid "SMTP backend"
msgstr "SMTP 后端"

msgid "This is the default backend. Email will be sent through a SMTP server."
msgstr "这是默认的后端。邮件将会通过 SMTP 服务器发送。"

msgid ""
"The value for each argument is retrieved from the matching setting if the "
"argument is ``None``:"
msgstr "若以下某个参数值为 ``None``，则会从匹配的设置项中读取："

msgid "``host``: :setting:`EMAIL_HOST`"
msgstr "``host``: :setting:`EMAIL_HOST`"

msgid "``port``: :setting:`EMAIL_PORT`"
msgstr "``port``: :setting:`EMAIL_PORT`"

msgid "``username``: :setting:`EMAIL_HOST_USER`"
msgstr "``username``: :setting:`EMAIL_HOST_USER`"

msgid "``password``: :setting:`EMAIL_HOST_PASSWORD`"
msgstr "``password``: :setting:`EMAIL_HOST_PASSWORD`"

msgid "``use_tls``: :setting:`EMAIL_USE_TLS`"
msgstr "``use_tls``: :setting:`EMAIL_USE_TLS`"

msgid "``use_ssl``: :setting:`EMAIL_USE_SSL`"
msgstr "``use_ssl``: :setting:`EMAIL_USE_SSL`"

msgid "``timeout``: :setting:`EMAIL_TIMEOUT`"
msgstr "``timeout``: :setting:`EMAIL_TIMEOUT`"

msgid "``ssl_keyfile``: :setting:`EMAIL_SSL_KEYFILE`"
msgstr "``ssl_keyfile``: :setting:`EMAIL_SSL_KEYFILE`"

msgid "``ssl_certfile``: :setting:`EMAIL_SSL_CERTFILE`"
msgstr "``ssl_certfile``: :setting:`EMAIL_SSL_CERTFILE`"

msgid ""
"The SMTP backend is the default configuration inherited by Django. If you "
"want to specify it explicitly, put the following in your settings::"
msgstr ""
"SMTP 后端是 Django 默认配置的。如果你想显示的指定，将以下内容放入你的配置中："

msgid ""
"If unspecified, the default ``timeout`` will be the one provided by :func:"
"`socket.getdefaulttimeout()`, which defaults to ``None`` (no timeout)."
msgstr ""
"若未指定，``timeout`` 的默认值将由 :func:`socket.getdefaulttimeout()` 的返回"
"值确定，其默认值为 ``None`` （无超时）。"

msgid "Console backend"
msgstr "控制台后端"

msgid ""
"Instead of sending out real emails the console backend just writes the "
"emails that would be sent to the standard output. By default, the console "
"backend writes to ``stdout``. You can use a different stream-like object by "
"providing the ``stream`` keyword argument when constructing the connection."
msgstr ""
"控制台后端仅将邮件发送至标准输出，而不是真的发送。默认情况下，控制台后端输出"
"至 ``stdout``。在创建连接时，你可以提供 ``stream`` 关键字参数来使用另一个类"
"似 stream 的对象。"

msgid "To specify this backend, put the following in your settings::"
msgstr "为了使用该后端，将以下代码加入你的配置中："

msgid ""
"This backend is not intended for use in production -- it is provided as a "
"convenience that can be used during development."
msgstr "该后端不是为了在生产环境使用的——出于方便的目的，让你在开发阶段使用。"

msgid "File backend"
msgstr "文件后端"

msgid ""
"The file backend writes emails to a file. A new file is created for each new "
"session that is opened on this backend. The directory to which the files are "
"written is either taken from the :setting:`EMAIL_FILE_PATH` setting or from "
"the ``file_path`` keyword when creating a connection with :meth:`~django."
"core.mail.get_connection`."
msgstr ""
"文件后端将邮件写入文件。对该后端的每次会话都会创建新文件。存储这些文件的目录"
"可以从配置项 :setting:`EMAIL_FILE_PATH` 获取，也可在调用 :meth:`~django.core."
"mail.get_connection` 时以关键字参数 ``file_path`` 指定。"

msgid "In-memory backend"
msgstr "内存后端"

msgid ""
"The ``'locmem'`` backend stores messages in a special attribute of the "
"``django.core.mail`` module. The ``outbox`` attribute is created when the "
"first message is sent. It's a list with an :class:`~django.core.mail."
"EmailMessage` instance for each message that would be sent."
msgstr ""
"该缓存式后端将内容存在 ``django.core.mail`` 模块的某个属性值中。``outbox`` 属"
"性会在第一条消息发送时创建。这是一个列表，每项都是一个 :class:`~django.core."
"mail.EmailMessage` 实例，代表一条要被发送的消息。"

msgid ""
"This backend is not intended for use in production -- it is provided as a "
"convenience that can be used during development and testing."
msgstr "该后端不是为了在生产环境使用的——出于方便的目的，让你在开发阶段使用。"

msgid ""
"Django's test runner :ref:`automatically uses this backend for testing "
"<topics-testing-email>`."
msgstr "Django 的测试器 :ref:`自动为测试使用这个后端 <topics-testing-email>`。"

msgid "Dummy backend"
msgstr "虚拟后端"

msgid ""
"As the name suggests the dummy backend does nothing with your messages. To "
"specify this backend, put the following in your settings::"
msgstr ""
"就像该后端的名字表示的一样，该后端对你发送的消息什么也不做。指定该后端，将以"
"下代码加入你的配置中："

msgid "Defining a custom email backend"
msgstr "自定义邮件后端"

msgid ""
"If you need to change how emails are sent you can write your own email "
"backend. The :setting:`EMAIL_BACKEND` setting in your settings file is then "
"the Python import path for your backend class."
msgstr ""
"若你需要修改邮件发送的方式，你可以编写自定义的邮件后端。后面要在 :setting:"
"`EMAIL_BACKEND` 配置项中指定你的后端类的路径。"

msgid ""
"Custom email backends should subclass ``BaseEmailBackend`` that is located "
"in the ``django.core.mail.backends.base`` module. A custom email backend "
"must implement the ``send_messages(email_messages)`` method. This method "
"receives a list of :class:`~django.core.mail.EmailMessage` instances and "
"returns the number of successfully delivered messages. If your backend has "
"any concept of a persistent session or connection, you should also implement "
"the ``open()`` and ``close()`` methods. Refer to ``smtp.EmailBackend`` for a "
"reference implementation."
msgstr ""
"自定义邮件后端需继承 ``django.core.mail.backends.base`` 模块中的 "
"``BaseEmailBackend`` 类。自定义邮件后端类必须实现 "
"``send_messages(email_messages)`` 方法。该方法接受一个包含 :class:`~django."
"core.mail.EmailMessage` 对象的列表。若你的后端还处理了持久性会话和连接，你还"
"需要实现 ``open()`` 和 ``close()`` 方法。可以参考 ``smtp.EmailBackend`` 的实"
"现。"

msgid "Sending multiple emails"
msgstr "发送多封邮件"

msgid ""
"Establishing and closing an SMTP connection (or any other network "
"connection, for that matter) is an expensive process. If you have a lot of "
"emails to send, it makes sense to reuse an SMTP connection, rather than "
"creating and destroying a connection every time you want to send an email."
msgstr ""
"创建和关闭 SMTP 连接（或其它网络连接）是一项耗时的进程。如果你有很多封邮件要"
"发送，复用连接就显得很有意义，而不是在每次发送邮件时创建和关闭连接。"

msgid "There are two ways you tell an email backend to reuse a connection."
msgstr "有两种方式可以让邮件后端复用连接。"

msgid ""
"Firstly, you can use the ``send_messages()`` method. ``send_messages()`` "
"takes a list of :class:`~django.core.mail.EmailMessage` instances (or "
"subclasses), and sends them all using a single connection."
msgstr ""
"首先，你可以使用 ``send_messages()`` 方法。``send_messages()`` 接受一个包含 :"
"class:`~django.core.mail.EmailMessage` （或其子类）实例的列表，并在发送它们时"
"复用同一条连接。"

msgid ""
"For example, if you have a function called ``get_notification_email()`` that "
"returns a list of :class:`~django.core.mail.EmailMessage` objects "
"representing some periodic email you wish to send out, you could send these "
"emails using a single call to send_messages::"
msgstr ""
"举个例子，你有一个函数，叫做 ``get_notification_email()`` ，他会返回一个包"
"含 :class:`~django.core.mail.EmailMessage` 对象的列表。这些对象是你想要发送的"
"定期邮件。你可以简单的调用一次 send_messages 来发送它们："

msgid ""
"In this example, the call to ``send_messages()`` opens a connection on the "
"backend, sends the list of messages, and then closes the connection again."
msgstr ""
"在该例子中，调用 ``send_messages()`` 在后端创建了一条连接，发送完邮件列表后，"
"关闭了这条连接。"

msgid ""
"The second approach is to use the ``open()`` and ``close()`` methods on the "
"email backend to manually control the connection. ``send_messages()`` will "
"not manually open or close the connection if it is already open, so if you "
"manually open the connection, you can control when it is closed. For "
"example::"
msgstr ""
"第二种方式是在后端使用 ``open()`` 和 ``close()`` 手动控制连接。"
"``send_messages()`` 在连接已经建立的情况下不会控制连接的开关，故此，若你手动"
"打开了连接，你可以决定何时关闭它。比如："

msgid "Configuring email for development"
msgstr "为了开发配置邮件"

msgid ""
"There are times when you do not want Django to send emails at all. For "
"example, while developing a website, you probably don't want to send out "
"thousands of emails -- but you may want to validate that emails will be sent "
"to the right people under the right conditions, and that those emails will "
"contain the correct content."
msgstr ""
"曾经有很多次，你并不想 Django 真的发送邮件。举个例子，在开发网站时，你可能并"
"不期望发送成千上万封邮件——但你想要确保这些邮件将会在正确的时间，包含正确的内"
"容，发送给正确的人。"

msgid ""
"The easiest way to configure email for local development is to use the :ref:"
"`console <topic-email-console-backend>` email backend. This backend "
"redirects all email to stdout, allowing you to inspect the content of mail."
msgstr ""
"出于开发的目的，最简单的配置邮件的方式是使用 :ref:`终端 <topic-email-console-"
"backend>` 邮件后端。这个后端将所有的邮件重定向至标准输出，允许你观察邮件的内"
"容。"

msgid ""
"The :ref:`file <topic-email-file-backend>` email backend can also be useful "
"during development -- this backend dumps the contents of every SMTP "
"connection to a file that can be inspected at your leisure."
msgstr ""
":ref:`文件 <topic-email-file-backend>` 邮件后端在开发时也很有用——这个后端将每"
"次 SMTP 连接的内容输出至一个文件，你可以在你闲暇时查看这个文件。"

msgid ""
"Another approach is to use a \"dumb\" SMTP server that receives the emails "
"locally and displays them to the terminal, but does not actually send "
"anything. The `aiosmtpd`_ package provides a way to accomplish this::"
msgstr ""

msgid ""
"This command will start a minimal SMTP server listening on port 8025 of "
"localhost. This server prints to standard output all email headers and the "
"email body. You then only need to set the :setting:`EMAIL_HOST` and :setting:"
"`EMAIL_PORT` accordingly. For a more detailed discussion of SMTP server "
"options, see the documentation of the `aiosmtpd`_ module."
msgstr ""

msgid ""
"For information about unit-testing the sending of emails in your "
"application, see the :ref:`topics-testing-email` section of the testing "
"documentation."
msgstr ""
"关于发送邮件的单元测试资料，参见测试文档中 :ref:`topics-testing-email` 章节。"

msgid "External packages"
msgstr "扩展包"

msgid ""
"Django ships with a variety of extra, optional tools that solve common "
"problems (``contrib.*``). For easier maintenance and to trim the size of the "
"codebase, a few of those applications have been moved out to separate "
"projects."
msgstr ""
"Django 附带了各种额外的可选工具来解决常见问题 (``contrib.*``)。为了便于维护并"
"减少代码库的大小，一些应用工具已经移到单独项目中。"

msgid "Localflavor"
msgstr "Localflavor"

msgid ""
"``django-localflavor`` is a collection of utilities for particular countries "
"and cultures."
msgstr "``django-localflavor`` 是用于特定国家和文化的实用程序集合。"

msgid "`GitHub <https://github.com/django/django-localflavor>`__"
msgstr "`GitHub <https://github.com/django/django-localflavor>`__"

msgid "`Documentation <https://django-localflavor.readthedocs.io/>`__"
msgstr "`Documentation <https://django-localflavor.readthedocs.io/>`__"

msgid "`PyPI <https://pypi.org/project/django-localflavor/>`__"
msgstr "`PyPI <https://pypi.org/project/django-localflavor/>`__"

msgid "Comments"
msgstr "Comments"

msgid ""
"``django-contrib-comments`` can be used to attach comments to any model, so "
"you can use it for comments on blog entries, photos, book chapters, or "
"anything else. Most users will be better served with a custom solution, or a "
"hosted product like Disqus."
msgstr ""
"``django-contrib-comments`` 可以被用来在任何模型上添加评论，因此你可以在博客"
"文章、图片、书籍和其他上评论。很多用户可以更好的使用这个定制解决方案，或使用 "
"Disqus 这样的托管产品。"

msgid "`GitHub <https://github.com/django/django-contrib-comments>`__"
msgstr "`GitHub <https://github.com/django/django-contrib-comments>`__"

msgid "`Documentation <https://django-contrib-comments.readthedocs.io/>`__"
msgstr "`Documentation <https://django-contrib-comments.readthedocs.io/>`__"

msgid "`PyPI <https://pypi.org/project/django-contrib-comments/>`__"
msgstr "`PyPI <https://pypi.org/project/django-contrib-comments/>`__"

msgid "Formtools"
msgstr "Formtools"

msgid ""
"``django-formtools`` is a collection of assorted utilities to work with "
"forms."
msgstr "``django-formtools`` 是处理表单的一组实用工具的集合。"

msgid "`GitHub <https://github.com/jazzband/django-formtools/>`__"
msgstr ""

msgid "`Documentation <https://django-formtools.readthedocs.io/>`__"
msgstr "`Documentation <https://django-formtools.readthedocs.io/>`__"

msgid "`PyPI <https://pypi.org/project/django-formtools/>`__"
msgstr "`PyPI <https://pypi.org/project/django-formtools/>`__"

msgid "Managing files"
msgstr "管理文件"

msgid ""
"This document describes Django's file access APIs for files such as those "
"uploaded by a user. The lower level APIs are general enough that you could "
"use them for other purposes. If you want to handle \"static files\" (JS, "
"CSS, etc.), see :doc:`/howto/static-files/index`."
msgstr ""
"这个文档描述 Django 文件访问用于文件的 API，例如用户上传的文件。较底层的API足"
"够通用，你可以为其他目的来使用它们。如果你想处理 \"static files\" (JS, CSS, "
"etc.)，可以查看 :doc:`/howto/static-files/index` 。"

msgid ""
"By default, Django stores files locally, using the :setting:`MEDIA_ROOT` "
"and :setting:`MEDIA_URL` settings. The examples below assume that you're "
"using these defaults."
msgstr ""
"默认情况下，Django 使用 :setting:`MEDIA_ROOT` 和 :setting:`MEDIA_URL` 设置本"
"地存储。下面的例子假设你在使用这些默认设置。"

msgid ""
"However, Django provides ways to write custom `file storage systems`_ that "
"allow you to completely customize where and how Django stores files. The "
"second half of this document describes how these storage systems work."
msgstr ""
"不过，Django 提供编写自定义 `file storage systems`_ 的方法，允许你完全自定义 "
"Django 存储文件的位置和方式。这篇文档的后半部分描述了存储系统的工作方式。"

msgid "Using files in models"
msgstr "在模型中使用文件"

msgid ""
"When you use a :class:`~django.db.models.FileField` or :class:`~django.db."
"models.ImageField`, Django provides a set of APIs you can use to deal with "
"that file."
msgstr ""
"当你使用 :class:`~django.db.models.FileField` 或 :class:`~django.db.models."
"ImageField` 时，Django 提供了一组处理文件的API。"

msgid ""
"Consider the following model, using an :class:`~django.db.models.ImageField` "
"to store a photo::"
msgstr ""
"考虑下面的模型，使用 :class:`~django.db.models.ImageField` 来存储照片："

msgid ""
"Any ``Car`` instance will have a ``photo`` attribute that you can use to get "
"at the details of the attached photo::"
msgstr ""
"任何 ``Car`` 实例将拥有一个 ``photo`` 属性，你可以使用它来获取附加照片的详"
"情："

msgid ""
"This object -- ``car.photo`` in the example -- is a ``File`` object, which "
"means it has all the methods and attributes described below."
msgstr ""
"``car.photo`` 是一个 ``File`` 对象，这意味着它拥有下面所描述的所有方法和属"
"性。"

msgid ""
"The file is saved as part of saving the model in the database, so the actual "
"file name used on disk cannot be relied on until after the model has been "
"saved."
msgstr ""
"文件在数据库中作为保存模型的一部分，因此在模型被保存之前，不能依赖磁盘上使用"
"的实际文件名。"

msgid ""
"For example, you can change the file name by setting the file's :attr:"
"`~django.core.files.File.name` to a path relative to the file storage's "
"location (:setting:`MEDIA_ROOT` if you are using the default :class:`~django."
"core.files.storage.FileSystemStorage`)::"
msgstr ""
"例如，您可以通过将文件名设置为相对于文件存储位置的路径来更改文件名（如果你正"
"在使用默认的 :class:`~django.core.files.storage.FileSystemStorage` ，则为 :"
"setting:`MEDIA_ROOT` ）。"

msgid ""
"To save an existing file on disk to a :class:`~django.db.models.FileField`::"
msgstr ""

msgid ""
"While :class:`~django.db.models.ImageField` non-image data attributes, such "
"as ``height``, ``width``, and ``size`` are available on the instance, the "
"underlying image data cannot be used without reopening the image. For "
"example::"
msgstr ""

msgid "The ``File`` object"
msgstr "``File`` 对象"

msgid ""
"Internally, Django uses a :class:`django.core.files.File` instance any time "
"it needs to represent a file."
msgstr ""
"在内部，Django 在任何需要表示文件的时候使用 :class:`django.core.files."
"File` 。"

msgid ""
"Most of the time you'll use a ``File`` that Django's given you (i.e. a file "
"attached to a model as above, or perhaps an uploaded file)."
msgstr ""
"大部分情况下你只需要使用 Django 提供的 ``File`` （即附加到上述模型的文件或已"
"经上传的文件）。"

msgid ""
"If you need to construct a ``File`` yourself, the easiest way is to create "
"one using a Python built-in ``file`` object::"
msgstr ""
"如果你需要自己构建 ``File`` ，最简单的方法是使用 Python 内置的 ``file`` 对象"
"创建一个："

msgid ""
"Now you can use any of the documented attributes and methods of the :class:"
"`~django.core.files.File` class."
msgstr "现在你可以使用 :class:`~django.core.files.File` 类的任何属性和方法。"

msgid ""
"Be aware that files created in this way are not automatically closed. The "
"following approach may be used to close files automatically::"
msgstr "注意在这里创建的文件不会自动关闭。下面的方式可以用来自动关闭文件："

msgid ""
"Closing files is especially important when accessing file fields in a loop "
"over a large number of objects. If files are not manually closed after "
"accessing them, the risk of running out of file descriptors may arise. This "
"may lead to the following error::"
msgstr ""
"在对大量对象进行循环访问文件字段时，关闭文件尤为重要。如果文件在访问后不能手"
"动关闭，可能会出现文件描述符溢出的风险。"

msgid "File storage"
msgstr "文件存储"

msgid ""
"Behind the scenes, Django delegates decisions about how and where to store "
"files to a file storage system. This is the object that actually understands "
"things like file systems, opening and reading files, etc."
msgstr ""
"在后台，Django将如何以及在哪里存储文件的决策委托给文件存储系统。这个对象实际"
"上理解文件系统、打开和读取文件等。"

msgid ""
"Django's default file storage is given by the :setting:"
"`DEFAULT_FILE_STORAGE` setting; if you don't explicitly provide a storage "
"system, this is the one that will be used."
msgstr ""
"Django 的默认文件存储通过 :setting:`DEFAULT_FILE_STORAGE` 配置；如果你不显式"
"地提供存储系统，这里会使用默认配置。"

msgid ""
"See below for details of the built-in default file storage system, and see :"
"doc:`/howto/custom-file-storage` for information on writing your own file "
"storage system."
msgstr ""
"参阅下面内置默认文件存储系统的细节，也可以查看 :doc:`/howto/custom-file-"
"storage` 来了解编写自己的文件存储系统的信息。"

msgid "Storage objects"
msgstr "存储对象"

msgid ""
"Though most of the time you'll want to use a ``File`` object (which "
"delegates to the proper storage for that file), you can use file storage "
"systems directly. You can create an instance of some custom file storage "
"class, or -- often more useful -- you can use the global default storage "
"system::"
msgstr ""
"虽然大部分时间你可以使用 ``File`` 对象（将该文件委托给合适的存储），但你可以"
"直接使用文件存储系统。你可以创建一些自定义文件存储类的示例，或使用通常更有用"
"的全局默认存储系统："

msgid "See :doc:`/ref/files/storage` for the file storage API."
msgstr "查看 :doc:`/ref/files/storage` 来了解文件存储API。"

msgid "The built-in filesystem storage class"
msgstr "内置文件存储类"

msgid ""
"Django ships with a :class:`django.core.files.storage.FileSystemStorage` "
"class which implements basic local filesystem file storage."
msgstr ""
"Django 附带一个 :class:`django.core.files.storage.FileSystemStorage` 类，这个"
"类实现基础的本地文件系统文件存储。"

msgid ""
"For example, the following code will store uploaded files under ``/media/"
"photos`` regardless of what your :setting:`MEDIA_ROOT` setting is::"
msgstr ""
"例如，下面的代码将存储上传文件到 ``/media/photos`` 而会忽略你在  :setting:"
"`MEDIA_ROOT` 的设置："

msgid ""
":doc:`Custom storage systems </howto/custom-file-storage>` work the same "
"way: you can pass them in as the ``storage`` argument to a :class:`~django."
"db.models.FileField`."
msgstr ""
"自定义存储系统（ :doc:`Custom storage systems </howto/custom-file-"
"storage>` ）的工作方式也一样：将它们作为 ``storage`` 参数传递给 :class:"
"`~django.db.models.FileField` 。"

msgid "Using a callable"
msgstr "使用callable"

msgid ""
"You can use a callable as the :attr:`~django.db.models.FileField.storage` "
"parameter for :class:`~django.db.models.FileField` or :class:`~django.db."
"models.ImageField`. This allows you to modify the used storage at runtime, "
"selecting different storages for different environments, for example."
msgstr ""
"你可以使用callable作为 :class:`~django.db.models.FileField` 或 :class:"
"`~django.db.models.ImageField` 的 :attr:`~django.db.models.FileField."
"storage` 参数。它允许你在运行时修改存储参数，不同环境选择不同存储，例如。"

msgid ""
"Your callable will be evaluated when your models classes are loaded, and "
"must return an instance of :class:`~django.core.files.storage.Storage`."
msgstr ""
"当模型类被加载时，callable将进行判断，并返回 :class:`~django.core.files."
"storage.Storage` 实例。"

msgid "Formsets"
msgstr "表单集"

msgid ""
"A formset is a layer of abstraction to work with multiple forms on the same "
"page. It can be best compared to a data grid. Let's say you have the "
"following form::"
msgstr ""
"formset是一个抽象层，它可以在同一页面上处理多个表单的。它最适合被比喻成网格数"
"据。我们假设您有以下表单::"

msgid ""
"You might want to allow the user to create several articles at once. To "
"create a formset out of an ``ArticleForm`` you would do::"
msgstr ""
"您可能想允许用户一次创建多篇文章。 要创建一个 ``ArticleForm`` 的formset，您可"
"以这样做::"

msgid ""
"You now have created a formset class named ``ArticleFormSet``. Instantiating "
"the formset gives you the ability to iterate over the forms in the formset "
"and display them as you would with a regular form::"
msgstr ""
"你现在已经创建了一个名为 ``ArticleFormSet`` 的表单集。实例化表单集让你能够迭"
"代表单集中的表单，并像常规表单一样显示它们："

msgid ""
"As you can see it only displayed one empty form. The number of empty forms "
"that is displayed is controlled by the ``extra`` parameter. By default, :"
"func:`~django.forms.formsets.formset_factory` defines one extra form; the "
"following example will create a formset class to display two blank forms::"
msgstr ""
"如你所见，它只显示一个空表单。显示的空表单数量由 ``额外`` 参数控制。默认情况"
"下，:func:`~django.forms.formsets.formset_factory` 定义了一个额外表单；下面的"
"例子将创建一个表单集类来显示两个空白表单："

msgid ""
"Iterating over a formset will render the forms in the order they were "
"created. You can change this order by providing an alternate implementation "
"for the ``__iter__()`` method."
msgstr ""
"遍历 formset 将按照它们创建的顺序渲染表单。你可以通过为 ``__iter__()`` 方法提"
"供替代的实现来改变这个顺序。"

msgid ""
"Formsets can also be indexed into, which returns the corresponding form. If "
"you override ``__iter__``, you will need to also override ``__getitem__`` to "
"have matching behavior."
msgstr ""
"表单集也可以被索引然后返回对应的表单。如果您已经覆盖了 ``__iter__`` ，则还需"
"覆盖  ``__getitem__`` 让它具备匹配行为。"

msgid "Using initial data with a formset"
msgstr "使用formset的初始数据"

msgid ""
"Initial data is what drives the main usability of a formset. As shown above "
"you can define the number of extra forms. What this means is that you are "
"telling the formset how many additional forms to show in addition to the "
"number of forms it generates from the initial data. Let's take a look at an "
"example::"
msgstr ""
"初始数据驱动着formset的主要能力。如上所示，您可以定义额外表单的数量。也就是"
"说，您告诉formset，除了要生成初始数据所需数量的表单外，还要显示多少额外的表"
"单。我们来看下例子::"

msgid ""
"There are now a total of three forms showing above. One for the initial data "
"that was passed in and two extra forms. Also note that we are passing in a "
"list of dictionaries as the initial data."
msgstr ""
"现在上面显示了三张表单。一张是传了初始数据的，另外两张是额外的。需要注意的"
"是，我们通过传递一个字典列表来作为初始数据。"

msgid ""
"If you use an ``initial`` for displaying a formset, you should pass the same "
"``initial`` when processing that formset's submission so that the formset "
"can detect which forms were changed by the user. For example, you might have "
"something like: ``ArticleFormSet(request.POST, initial=[...])``."
msgstr ""
"如果您使用了 ``initial`` 来显示formset，那么您需要在处理formset提交时传入相同"
"的 ``initial`` ，以便formset检测用户更改了哪些表单。例如，您可能有这样的： "
"``ArticleFormSet(request.POST, initial=[...])`` 。"

msgid ""
":ref:`Creating formsets from models with model formsets <model-formsets>`."
msgstr ":ref:`创建模型表单集 <model-formsets>`。"

msgid "Limiting the maximum number of forms"
msgstr "限制表单的最大数量"

msgid ""
"The ``max_num`` parameter to :func:`~django.forms.formsets.formset_factory` "
"gives you the ability to limit the number of forms the formset will display::"
msgstr ""
":func:`~django.forms.formsets.formset_factory` 的参数 ``max_num`` 让您可以控"
"制表单集将要显示的表单数量::"

msgid ""
"If the value of ``max_num`` is greater than the number of existing items in "
"the initial data, up to ``extra`` additional blank forms will be added to "
"the formset, so long as the total number of forms does not exceed "
"``max_num``. For example, if ``extra=2`` and ``max_num=2`` and the formset "
"is initialized with one ``initial`` item, a form for the initial item and "
"one blank form will be displayed."
msgstr ""
"如果 ``max_num`` 的值大于初始数据现有数量，那空白表单可显示的数量取决于 "
"``extra`` 的数量，只要总表单数不超过 ``max_num`` 。例如， ``extra=2`` ， "
"``max_num=2`` 并且formset有一个 ``initial`` 初始化项，则会显示一张初始化表单"
"和一张空白表单。"

msgid ""
"If the number of items in the initial data exceeds ``max_num``, all initial "
"data forms will be displayed regardless of the value of ``max_num`` and no "
"extra forms will be displayed. For example, if ``extra=3`` and ``max_num=1`` "
"and the formset is initialized with two initial items, two forms with the "
"initial data will be displayed."
msgstr ""
"如果初始数据项的数量超过 ``max_num`` ，那么 ``max_num`` 的值会被无视，所有初"
"始数据表单都会显示，并且也不会有额外的表单显示。例如，假设 ``extra=3`` ， "
"``max_num=1`` 并且formset有两个初始化项，那么只会显示两张有初始化数据的表单。"

msgid ""
"A ``max_num`` value of ``None`` (the default) puts a high limit on the "
"number of forms displayed (1000). In practice this is equivalent to no limit."
msgstr ""
"``max_num`` 的值 ``None`` (默认值)，它限制最多显示(1000)张表单，其实这相当于"
"没有限制。"

msgid ""
"By default, ``max_num`` only affects how many forms are displayed and does "
"not affect validation.  If ``validate_max=True`` is passed to the :func:"
"`~django.forms.formsets.formset_factory`, then ``max_num`` will affect "
"validation.  See :ref:`validate_max`."
msgstr ""
"``max_num`` 默认只影响显示多少数量的表单而不影响验证。如果将 "
"``validate_max=True`` 传给 :func:`~django.forms.formsets.formset_factory`，那"
"么 ``max_num`` 将会影响验证。参见 :ref:`validate_max` 。"

msgid "Limiting the maximum number of instantiated forms"
msgstr "限制实例化表单的最大数量"

msgid ""
"The ``absolute_max`` parameter to :func:`.formset_factory` allows limiting "
"the number of forms that can be instantiated when supplying ``POST`` data. "
"This protects against memory exhaustion attacks using forged ``POST`` "
"requests::"
msgstr ""
":func:`.formet_factory` 的 ``absolute_max`` 参数允许限制在提供 ``POST`` 数据"
"时可以实例化的表单数量。这可以防止使用伪造的 ``POST`` 请求的内存耗尽攻击："

msgid ""
"When ``absolute_max`` is ``None``, it defaults to ``max_num + 1000``. (If "
"``max_num`` is ``None``, it defaults to ``2000``)."
msgstr ""
"当 ``absolute_max`` 为 ``None`` 时，它默认为 ``max_num + 1000``。（如果 "
"``max_num`` 是 ``None``，则默认为 ``2000``）。"

msgid ""
"If ``absolute_max`` is less than ``max_num``, a ``ValueError`` will be "
"raised."
msgstr "如果 ``absolute_max`` 小于 ``max_num``，将引发 ``ValueError``。"

msgid "Formset validation"
msgstr "Formset验证"

msgid ""
"Validation with a formset is almost identical to a regular ``Form``. There "
"is an ``is_valid`` method on the formset to provide a convenient way to "
"validate all forms in the formset::"
msgstr ""
"formset的验证与常规 ``Form`` 几乎相同。formset提供了一个 ``is_valid`` 方法以"
"便验证formset内所有表单::"

msgid ""
"We passed in no data to the formset which is resulting in a valid form. The "
"formset is smart enough to ignore extra forms that were not changed. If we "
"provide an invalid article::"
msgstr ""
"我们传了空数据给formset，并被给了一个有效的结果。formset足够聪明去忽略那些没"
"有变动的额外表单。如果我们提供了一篇无效的文章::"

msgid ""
"As we can see, ``formset.errors`` is a list whose entries correspond to the "
"forms in the formset. Validation was performed for each of the two forms, "
"and the expected error message appears for the second item."
msgstr ""
"正如我们看到的，``formset.errors`` 是一张列表，它的内容对应着formset中表单。"
"两张表都进行了验证，并且第二项中出现了预期的错误消息。"

msgid ""
"Just like when using a normal ``Form``, each field in a formset's forms may "
"include HTML attributes such as ``maxlength`` for browser validation. "
"However, form fields of formsets won't include the ``required`` attribute as "
"that validation may be incorrect when adding and deleting forms."
msgstr ""
"和使用普通 ``Form`` 一样，formset表单中的每个字段都可能包含HTML属性，例如用于"
"浏览器验证的 ``maxlength`` 。但是由于表单添加、删除的时候会影响属性 "
"``required`` 的验证，表单集中的表单不会包含此属性。"

msgid ""
"To check how many errors there are in the formset, we can use the "
"``total_error_count`` method::"
msgstr "我们可以使用 ``total_error_count`` 方法来检查formset中有多少错误::"

msgid ""
"We can also check if form data differs from the initial data (i.e. the form "
"was sent without any data)::"
msgstr "我们还可以检查表单数据与初始数据的区别(即表单没有发送任何数据)::"

msgid "Understanding the ``ManagementForm``"
msgstr "理解 ``ManagementForm`` "

msgid ""
"You may have noticed the additional data (``form-TOTAL_FORMS``, ``form-"
"INITIAL_FORMS``) that was required in the formset's data above. This data is "
"required for the ``ManagementForm``. This form is used by the formset to "
"manage the collection of forms contained in the formset. If you don't "
"provide this management data, the formset will be invalid::"
msgstr ""
"你可能已经注意到在上面的表单集的数据中需要额外的数据（ ``form-TOTAL_FORMS``、"
"``form-INITIAL_FORMS``）。这些数据是 ``ManagementForm`` 需要的。这个表单被表"
"单组用来管理表单组中包含的表单集合。如果你不提供这个管理数据，表单集将是无效"
"的："

msgid ""
"It is used to keep track of how many form instances are being displayed. If "
"you are adding new forms via JavaScript, you should increment the count "
"fields in this form as well. On the other hand, if you are using JavaScript "
"to allow deletion of existing objects, then you need to ensure the ones "
"being removed are properly marked for deletion by including ``form-#-"
"DELETE`` in the ``POST`` data. It is expected that all forms are present in "
"the ``POST`` data regardless."
msgstr ""
"它被用来跟踪显示了多少个表单实例。如果您通过JavaScript添加新表单，那您同样需"
"要增加相应内容到那些数量字段中，另一方面，如果您允许通过JavaScript来删除已存"
"在对象，那么您需确认被移除的对象已经被标记在 ``form-#-DELETE`` 中并被放到 "
"``POST`` 内。无论如何，所有表单都要确保在 ``POST`` 数据中。"

msgid ""
"The management form is available as an attribute of the formset itself. When "
"rendering a formset in a template, you can include all the management data "
"by rendering ``{{ my_formset.management_form }}`` (substituting the name of "
"your formset as appropriate)."
msgstr ""
"管理表单以formset的一项属性而存在。在模板中渲染formset时，你可以使用 "
"``{{ my_formset.management_form }}``  (将my_formset替换为自己的formset名称)渲"
"染出所有管理表单的数据。"

msgid ""
"As well as the ``form-TOTAL_FORMS`` and ``form-INITIAL_FORMS`` fields shown "
"in the examples here, the management form also includes ``form-"
"MIN_NUM_FORMS`` and ``form-MAX_NUM_FORMS`` fields. They are output with the "
"rest of the management form, but only for the convenience of client-side "
"code. These fields are not required and so are not shown in the example "
"``POST`` data."
msgstr ""
"除了这里的例子中显示的 ``form-TOTAL_FORMS`` 和 ``form-INITIAL_FORMS`` 字段，"
"管理表单还包括 ``form-MIN_NUM_FORMS`` 和 ``form-MAX_NUM_FORMS`` 字段。它们与"
"管理表单的其他部分一起输出，但只是为了方便客户端的代码。这些字段不是必须的，"
"所以没有显示在示例的 ``POST`` 数据中。"

msgid ""
"``formset.is_valid()`` now returns ``False`` rather than raising an "
"exception when the management form is missing or has been tampered with."
msgstr ""
"``formset.is_valid()`` 现在返回 ``False``，而不是在管理表单丢失或被篡改时引发"
"异常。"

msgid "``total_form_count`` and ``initial_form_count``"
msgstr " ``total_form_count`` 和 ``initial_form_count`` "

msgid ""
"``BaseFormSet`` has a couple of methods that are closely related to the "
"``ManagementForm``, ``total_form_count`` and ``initial_form_count``."
msgstr ""
"``BaseFormSet`` 有一对与 ``ManagementForm`` 密切相关的方法， "
"``total_form_count``  和  ``initial_form_count`` 。"

msgid ""
"``total_form_count`` returns the total number of forms in this formset. "
"``initial_form_count`` returns the number of forms in the formset that were "
"pre-filled, and is also used to determine how many forms are required. You "
"will probably never need to override either of these methods, so please be "
"sure you understand what they do before doing so."
msgstr ""
"``total_form_count`` 返回该formset内表单的总和。 ``initial_form_count`` 返回"
"该formset内预填充的表单数量，同时用于定义需要多少表单。你可能永远不会重写这两"
"个方法，因此在使用之前请理解它们的用途。"

msgid "``empty_form``"
msgstr "``empty_form``"

msgid ""
"``BaseFormSet`` provides an additional attribute ``empty_form`` which "
"returns a form instance with a prefix of ``__prefix__`` for easier use in "
"dynamic forms with JavaScript."
msgstr ""
"``BaseFormSet``有一项属性``empty_form``，它返回一个以``__prefix__`` 为前缀的"
"表单实例，这是为了方便在动态表单中配合JavaScript使用。"

msgid "``error_messages``"
msgstr "``error_messages``"

msgid ""
"The ``error_messages`` argument lets you override the default messages that "
"the formset will raise. Pass in a dictionary with keys matching the error "
"messages you want to override. For example, here is the default error "
"message when the management form is missing::"
msgstr ""
"``error_messages`` 参数让你覆盖表单集将引发的默认信息。传入一个字典，其键值与"
"你想覆盖的错误信息相匹配。例如，以下是管理表单丢失时的默认错误信息："

msgid "And here is a custom error message::"
msgstr "而这里是一个自定义的错误信息："

msgid "Custom formset validation"
msgstr "自定义formset验证"

msgid ""
"A formset has a ``clean`` method similar to the one on a ``Form`` class. "
"This is where you define your own validation that works at the formset "
"level::"
msgstr ""
"formset有个与 ``Form`` 类相似的 ``clean`` 方法。您可以在这里定义自己的验证规"
"则，它会在formset层面进行验证。"

msgid ""
"The formset ``clean`` method is called after all the ``Form.clean`` methods "
"have been called. The errors will be found using the ``non_form_errors()`` "
"method on the formset."
msgstr ""
"formset的 ``clean`` 方法会在所有 ``Form.clean`` 方法调用完之后被调用。可以使"
"用formset的 ``non_form_errors()`` 方法来查看错误信息。"

msgid ""
"Non-form errors will be rendered with an additional class of ``nonform`` to "
"help distinguish them from form-specific errors. For example, ``{{ formset."
"non_form_errors }}`` would look like:"
msgstr ""
"非表单错误将用一个额外的类 ``nonform`` 来呈现，以帮助区分它们与表单特定错误。"
"例如，``{{ formset.non_form_errors }}`` 将看起来像:"

msgid "The additional ``nonform`` class was added."
msgstr "增加了额外的 ``nonform`` 类。"

msgid "Validating the number of forms in a formset"
msgstr "验证formset中表单的数量"

msgid ""
"Django provides a couple ways to validate the minimum or maximum number of "
"submitted forms. Applications which need more customizable validation of the "
"number of forms should use custom formset validation."
msgstr ""
"Django提供了一对方法来验证已提交的表单的最小和最大数量。如果要对应用程序进行"
"更多的可定制验证，那需要使用自定义formset验证。"

msgid "``validate_max``"
msgstr "``validate_max``"

msgid ""
"If ``validate_max=True`` is passed to :func:`~django.forms.formsets."
"formset_factory`, validation will also check that the number of forms in the "
"data set, minus those marked for deletion, is less than or equal to "
"``max_num``."
msgstr ""
"如果方法 :func:`~django.forms.formsets.formset_factory` 有设置参数 "
"``validate_max=True`` ，验证还会检查数据集内表单的数量，减去那些被标记为删除"
"的表单数量，剩余数量需小于等于 ``max_num`` 。"

msgid ""
"``validate_max=True`` validates against ``max_num`` strictly even if "
"``max_num`` was exceeded because the amount of initial data supplied was "
"excessive."
msgstr ""
"即使因为提供的初始数据量过大而超过了 ``max_num`` 所定义的，"
"``validate_max=True`` 还是会严格针对 ``max_num`` 进行验证。"

msgid ""
"Regardless of ``validate_max``, if the number of forms in a data set exceeds "
"``absolute_max``, then the form will fail to validate as if ``validate_max`` "
"were set, and additionally only the first ``absolute_max`` forms will be "
"validated. The remainder will be truncated entirely. This is to protect "
"against memory exhaustion attacks using forged POST requests. See :ref:"
"`formsets-absolute-max`."
msgstr ""
"不管 ``validate_max`` 如何，如果数据集中的表单数量超过 ``absolute_max``，那么"
"表单将无法验证，就像 ``validate_max`` 被设置一样，另外只有第一个 "
"``absolute_max`` 的表单会被验证。其余的将被完全截断。这是为了防止使用伪造的 "
"POST 请求的内存耗尽攻击。参见 :ref:`formsets-absolute-max`。"

msgid "``validate_min``"
msgstr "``validate_min``"

msgid ""
"If ``validate_min=True`` is passed to :func:`~django.forms.formsets."
"formset_factory`, validation will also check that the number of forms in the "
"data set, minus those marked for deletion, is greater than or equal to "
"``min_num``."
msgstr ""
"如果方法 :func:`~django.forms.formsets.formset_factory` 有传参数 "
"``validate_min=True`` ，还会验证数据集中的表单的数量减去那些被标记为删除的表"
"单数量是否大于或等于 ``min_num`` 定义的数量。"

msgid ""
"Regardless of ``validate_min``, if a formset contains no data, then ``extra "
"+ min_num`` empty forms will be displayed."
msgstr ""
"无论 ``validate_min`` 的值是什么，如果一个 formset 不包含任何数据，那么将显"
"示 ``extra + min_num`` 空表单。"

msgid "Dealing with ordering and deletion of forms"
msgstr "处理表单的排序和删除"

msgid ""
"The :func:`~django.forms.formsets.formset_factory` provides two optional "
"parameters ``can_order`` and ``can_delete`` to help with ordering of forms "
"in formsets and deletion of forms from a formset."
msgstr ""
"方法 :func:`~django.forms.formsets.formset_factory` 提供了两个可选参数 "
"``can_order`` 和 ``can_delete`` 来协助处理formset中表单的排序和删除。"

msgid "``can_order``"
msgstr "``can_order``"

msgid "Default: ``False``"
msgstr "默认值： ``False``"

msgid "Lets you create a formset with the ability to order::"
msgstr "让你创建能排序的formset::"

msgid ""
"This adds an additional field to each form. This new field is named "
"``ORDER`` and is an ``forms.IntegerField``. For the forms that came from the "
"initial data it automatically assigned them a numeric value. Let's look at "
"what will happen when the user changes these values::"
msgstr ""
"它给每个表单添加了一个额外的字段。这是一个名称是 ``ORDER`` 且类型为 ``forms."
"IntegerField`` 的字段。对于初始数据中的表单，它会自动为它们分配一个数值。我们"
"来看看当用户更改这些值时会发生什么情况::"

msgid ""
":class:`~django.forms.formsets.BaseFormSet` also provides an :attr:`~django."
"forms.formsets.BaseFormSet.ordering_widget` attribute and :meth:`~django."
"forms.formsets.BaseFormSet.get_ordering_widget` method that control the "
"widget used with :attr:`~django.forms.formsets.BaseFormSet.can_order`."
msgstr ""
":class:`~django.forms.formsets.BaseFormSet` 也提供了 :attr:`~django.forms."
"formsets.BaseFormSet.ordering_widget` 属性和 :meth:`~django.forms.formsets."
"BaseFormSet.get_ordering_widget` 方法，来控制与 :attr:`~django.forms."
"formsets.BaseFormSet.can_order` 一起使用的小部件。"

msgid "``ordering_widget``"
msgstr "``ordering_widget``"

msgid "Default: :class:`~django.forms.NumberInput`"
msgstr "默认: :class:`~django.forms.NumberInput`"

msgid ""
"Set ``ordering_widget`` to specify the widget class to be used with "
"``can_order``::"
msgstr "设置 ``ordering_widget`` 指定与 ``can_order`` 一起使用的小部件类："

msgid "``get_ordering_widget``"
msgstr "``get_ordering_widget``"

msgid ""
"Override ``get_ordering_widget()`` if you need to provide a widget instance "
"for use with ``can_order``::"
msgstr ""
"如果需要提供与 ``can_order`` 一起来使用的小部件实例，请覆盖 "
"``get_ordering_widget()`` 。"

msgid "``can_delete``"
msgstr "``can_delete``"

msgid ""
"Lets you create a formset with the ability to select forms for deletion::"
msgstr "让你创建能删除指定表单的formset::"

msgid ""
"Similar to ``can_order`` this adds a new field to each form named ``DELETE`` "
"and is a ``forms.BooleanField``. When data comes through marking any of the "
"delete fields you can access them with ``deleted_forms``::"
msgstr ""
"和参数 ``can_order`` 类似，它创建了一个名为 ``DELETE`` 且类型是 ``forms."
"BooleanField`` 的字段。您可以使用 ``deleted_forms`` 访问那些被标记为删除的数"
"据。"

msgid ""
"If you are using a :class:`ModelFormSet<django.forms.models."
"BaseModelFormSet>`, model instances for deleted forms will be deleted when "
"you call ``formset.save()``."
msgstr ""
"如果你使用 :class:`ModelFormSet<django.forms.models.BaseModelFormSet>` ，那些"
"标记为删除的表单模型实例会在调用 ``formset.save()`` 时被删除。"

msgid ""
"If you call ``formset.save(commit=False)``, objects will not be deleted "
"automatically.  You'll need to call ``delete()`` on each of the :attr:"
"`formset.deleted_objects <django.forms.models.BaseModelFormSet."
"deleted_objects>` to actually delete them::"
msgstr ""
"如果您调用调用 ``formset.save(commit=False)`` ，对象将不会被自动删除。您需要"
"在每个 :attr:`formset.deleted_objects <django.forms.models.BaseModelFormSet."
"deleted_objects>`  上调用 ``delete()`` 来真正删除他们::"

msgid ""
"On the other hand, if you are using a plain ``FormSet``, it's up to you to "
"handle ``formset.deleted_forms``, perhaps in your formset's ``save()`` "
"method, as there's no general notion of what it means to delete a form."
msgstr ""
"另一方面，如果您使用的是普通的 ``FormSet`` ，那需要您自己去处理 ``formset."
"deleted_forms`` ，可能写在formset的 ``save()`` 方法中，因为对于阐述删除一张表"
"单还没有一个通用的概念。"

msgid ""
":class:`~django.forms.formsets.BaseFormSet` also provides a :attr:`~django."
"forms.formsets.BaseFormSet.deletion_widget` attribute and :meth:`~django."
"forms.formsets.BaseFormSet.get_deletion_widget` method that control the "
"widget used with :attr:`~django.forms.formsets.BaseFormSet.can_delete`."
msgstr ""
":class:`~django.forms.formsets.BaseFormSet` 也提供了一个 :attr:`~django."
"forms.formsets.BaseFormSet.deletion_widget` 属性和 :meth:`~django.forms."
"formsets.BaseFormSet.get_deletion_widget` 方法，控制用于 :attr:`~django."
"forms.formsets.BaseFormSet.can_delete` 的部件。"

msgid "``deletion_widget``"
msgstr "``deletion_widget``"

msgid "Default: :class:`~django.forms.CheckboxInput`"
msgstr "默认： :class:`~django.forms.CheckboxInput`"

msgid ""
"Set ``deletion_widget`` to specify the widget class to be used with "
"``can_delete``::"
msgstr "设置 ``deletion_widget`` 来指定与 ``can_delete`` 一起使用的部件类："

msgid "``get_deletion_widget``"
msgstr "``get_deletion_widget``"

msgid ""
"Override ``get_deletion_widget()`` if you need to provide a widget instance "
"for use with ``can_delete``::"
msgstr ""
"如果你需要提供一个用于 ``can_delete`` 的部件实例，请覆盖 "
"``get_deletion_widget()``："

msgid "``can_delete_extra``"
msgstr "``can_delete_extra``"

msgid "Default: ``True``"
msgstr "默认： ``True``"

msgid ""
"While setting ``can_delete=True``, specifying ``can_delete_extra=False`` "
"will remove the option to delete extra forms."
msgstr ""
"在设置 ``can_delete=True`` 的同时，指定 ``can_delete_extra=False`` 将移除删除"
"额外表格的选项。"

msgid "Adding additional fields to a formset"
msgstr "给一个formset添加额外字段"

msgid ""
"If you need to add additional fields to the formset this can be easily "
"accomplished. The formset base class provides an ``add_fields`` method. You "
"can override this method to add your own fields or even redefine the default "
"fields/attributes of the order and deletion fields::"
msgstr ""
"如果你想在formset中添加额外的字段，这相当简单。formset的基类提供了一个 "
"``add_fields`` 的方法。你可以覆盖这个方法来添加你自己的字段，甚至可以重新定义"
"默认字段或者那些排序的和被标记为删除的字段的属性："

msgid "Passing custom parameters to formset forms"
msgstr "传递自定义参数到formset表单"

msgid ""
"Sometimes your form class takes custom parameters, like ``MyArticleForm``. "
"You can pass this parameter when instantiating the formset::"
msgstr ""
"有时候您的表单类需要自定义参数，比如 ``MyArticleForm`` 。您可以在formset实例"
"化的时候传递这个参数::"

msgid ""
"The ``form_kwargs`` may also depend on the specific form instance. The "
"formset base class provides a ``get_form_kwargs`` method. The method takes a "
"single argument - the index of the form in the formset. The index is "
"``None`` for the :ref:`empty_form`::"
msgstr ""
"``form_kwargs`` 也可能依赖于特定的表单实例。formset基类提供了一个 "
"``get_form_kwargs`` 方法。该方法只接收一个参数——formset中表单的序列。对于 :"
"ref:`empty_form` ，它的序列是 ``None`` ::"

msgid "Customizing a formset's prefix"
msgstr "自定义formset的前缀"

msgid ""
"In the rendered HTML, formsets include a prefix on each field's name. By "
"default, the prefix is ``'form'``, but it can be customized using the "
"formset's ``prefix`` argument."
msgstr ""
"在已渲染的HTML页面中，表单集中的每个字段都包含一个前缀。这个前缀默认是 "
"``'form'`` ，但可以使用formset的 ``prefix`` 参数来自定义。"

msgid "For example, in the default case, you might see:"
msgstr "例如，在默认情况下，您可能会看到::"

msgid "But with ``ArticleFormset(prefix='article')`` that becomes:"
msgstr "但使用 ``ArticleFormset(prefix='article')`` 的话就会变为："

msgid ""
"This is useful if you want to :ref:`use more than one formset in a view "
"<multiple-formsets-in-view>`."
msgstr ""
"如果您想 :ref:`在视图中使用多个formset <multiple-formsets-in-view> ` ，这个参"
"数会很有用。"

msgid "Using a formset in views and templates"
msgstr "在视图和模板中使用formset"

msgid ""
"Formsets have five attributes and five methods associated with rendering."
msgstr "表单集有五个属性和五个与渲染相关的方法。"

msgid ""
"Specifies the :doc:`renderer </ref/forms/renderers>` to use for the formset. "
"Defaults to the renderer specified by the :setting:`FORM_RENDERER` setting."
msgstr ""
"指定 :doc:`渲染器 </ref/forms/renderers>` 用于表单集。默认为 :setting:"
"`FORM_RENDER` 配置所指定的渲染器。"

msgid ""
"The name of the template used when calling ``__str__`` or :meth:`.render`. "
"This template renders the formset's management form and then each form in "
"the formset as per the template defined by the form's :attr:`~django.forms."
"Form.template_name`. This is a proxy of ``as_table`` by default."
msgstr ""
"当调用 ``__str__`` 或 :meth:`.render` 时使用的模板名称。这个模板渲染表单集的"
"管理表单，然后按照表单的 :attr:`~django.forms.Form.template_name` 所定义的模"
"板渲染表单集中的每个表单。默认情况下这是 ``as_table`` 的代理。"

msgid ""
"The name of the template used when calling :meth:`.as_p`. By default this is "
"``'django/forms/formsets/p.html'``. This template renders the formset's "
"management form and then each form in the formset as per the form's :meth:"
"`~django.forms.Form.as_p` method."
msgstr ""
"调用 :meth:`.as_p` 时使用的模板名称。默认情况下，这是 ``'django/forms/"
"formsets/p.html'``。该模板渲染表单集的管理表单，然后按照表单的 :meth:"
"`~django.forms.Form.as_p` 方法渲染表单集中的每个表单。"

msgid ""
"The name of the template used when calling :meth:`.as_table`. By default "
"this is ``'django/forms/formsets/table.html'``. This template renders the "
"formset's management form and then each form in the formset as per the "
"form's :meth:`~django.forms.Form.as_table` method."
msgstr ""
"调用 :meth:`.as_table` 时使用的模板名称。默认情况下，这是 ``'django/forms/"
"formsets/table.html'``。这个模板渲染表单集的管理表单，然后按照表单的 :meth:"
"`~django.forms.Form.as_table` 方法渲染表单集中的每个表单。"

msgid ""
"The name of the template used when calling :meth:`.as_ul`. By default this "
"is ``'django/forms/formsets/ul.html'``. This template renders the formset's "
"management form and then each form in the formset as per the form's :meth:"
"`~django.forms.Form.as_ul` method."
msgstr ""
"调用 :meth:`.as_ul` 时使用的模板名称。默认情况下，这是 ``'django/forms/"
"formsets/ul.html'``。这个模板渲染表单集的管理表单，然后按照表单的 :meth:"
"`~django.forms.Form.as_ul` 方法渲染表单集中的每个表单。"

msgid "Returns the context for rendering a formset in a template."
msgstr "返回用于在模板中渲染表单集的上下文。"

msgid "The available context is:"
msgstr "可用的上下文："

msgid "``formset`` : The instance of the formset."
msgstr "``formset``：表单集的实例。"

msgid ""
"The render method is called by ``__str__`` as well as the :meth:`.as_p`, :"
"meth:`.as_ul`, and :meth:`.as_table` methods. All arguments are optional and "
"will default to:"
msgstr ""
"渲染方法被 ``__str__`` 以及 :meth:`.as_p`、:meth:`.as_ul` 和 :meth:`."
"as_table` 方法所调用。所有的参数都是可选的，并将默认为："

msgid "``template_name``: :attr:`.template_name`"
msgstr "``template_name``： :attr:`.template_name`"

msgid "``context``: Value returned by :meth:`.get_context`"
msgstr "``context``： 由 :meth:`.get_context` 返回的值"

msgid "``renderer``: Value returned by :attr:`.renderer`"
msgstr "``renderer``： 由 :attr:`.renderer` 返回的值"

msgid "Renders the formset with the :attr:`.template_name_p` template."
msgstr "用 :attr:`.template_name_p` 模板渲染表单集。"

msgid "Renders the formset with the :attr:`.template_name_table` template."
msgstr "使用 :attr:`.template_name_table` 模板渲染表单集。"

msgid "Renders the formset with the :attr:`.template_name_ul` template."
msgstr "用 :attr:`.template_name_ul` 模板渲染表单集。"

msgid ""
"Using a formset inside a view is not very different from using a regular "
"``Form`` class. The only thing you will want to be aware of is making sure "
"to use the management form inside the template. Let's look at a sample view::"
msgstr ""
"在视图中使用formset与使用常规的 ``Form`` 类没有太多不同之处。你唯一需要注意的"
"是确保要在模板中使用管理表单。我们来看一个示例视图："

msgid "The ``manage_articles.html`` template might look like this:"
msgstr "模板 ``manage_articles.html`` 可能如下所示："

msgid ""
"However there's a slight shortcut for the above by letting the formset "
"itself deal with the management form:"
msgstr "但是对于上面让formset自己处理管理表单，还有个小小的捷径："

msgid ""
"The above ends up calling the :meth:`BaseFormSet.render` method on the "
"formset class. This renders the formset using the template specified by the :"
"attr:`~BaseFormSet.template_name` attribute. Similar to forms, by default "
"the formset will be rendered ``as_table``, with other helper methods of "
"``as_p`` and ``as_ul`` being available. The rendering of the formset can be "
"customized by specifying the ``template_name`` attribute, or more generally "
"by :ref:`overriding the default template <overriding-built-in-formset-"
"templates>`."
msgstr ""
"上面的内容最终会调用表单集类上的 :meth:`BaseFormSet.render` 方法。这将使用 :"
"attr:`~BaseFormSet.template_name` 属性指定的模板来渲染表单集。与表单类似，默"
"认情况下，表单集将被渲染为 ``as_table``，其他辅助方法 ``as_p`` 和 ``as_ul`` "
"可用。表单集的渲染可以通过指定 ``template_name`` 属性来定制，或者更普遍的是通"
"过 :ref:`覆盖默认模板 <overriding-built-in-formset-templates>`。"

msgid "Rendering of formsets was moved to the template engine."
msgstr "表单集的渲染被转移到模板引擎。"

msgid "Manually rendered ``can_delete`` and ``can_order``"
msgstr "手动渲染 ``can_delete`` 和 ``can_order`` "

msgid ""
"If you manually render fields in the template, you can render ``can_delete`` "
"parameter with ``{{ form.DELETE }}``:"
msgstr ""
"如果您在模板中手动渲染字段，您可以用 ``{{ form.DELETE }}`` 来渲染参数 "
"``can_delete`` 。"

msgid ""
"Similarly, if the formset has the ability to order (``can_order=True``), it "
"is possible to render it with ``{{ form.ORDER }}``."
msgstr ""
"同样，如果formset能排序( ``can_order=True`` )，可以用 ``{{ form.ORDER }}`` 来"
"渲染它。"

msgid "Using more than one formset in a view"
msgstr "在视图中使用多个formset"

msgid ""
"You are able to use more than one formset in a view if you like. Formsets "
"borrow much of its behavior from forms. With that said you are able to use "
"``prefix`` to prefix formset form field names with a given value to allow "
"more than one formset to be sent to a view without name clashing. Let's take "
"a look at how this might be accomplished::"
msgstr ""
"你可以在视图中使用多个formset。表单集从表单上借鉴了很多行为。像之前说的，你可"
"以使用参数 ``prefix`` 来给formset中表单的字段附上前缀，以避免多个formset的数"
"据传到同一个视图而引起名称冲突。让我们来看下这是如何实现的："

msgid ""
"You would then render the formsets as normal. It is important to point out "
"that you need to pass ``prefix`` on both the POST and non-POST cases so that "
"it is rendered and processed correctly."
msgstr ""
"然后您就可以像平时那样渲染表单集。需要指出的是，您需要同时在POST和非POST情况"
"下传递 ``prefix`` ，以便它能被正确渲染和处理。"

msgid ""
"Each formset's :ref:`prefix <formset-prefix>` replaces the default ``form`` "
"prefix that's added to each field's ``name`` and ``id`` HTML attributes."
msgstr ""
"每个formset的 :ref:`prefix <formset-prefix>` 会替换添加到每个字段的 ``name`` "
"和 ``id`` HTML属性的默认 ``form`` 前缀。"

msgid "Working with forms"
msgstr "使用表单"

msgid "About this document"
msgstr "关于本页文档"

msgid ""
"This document provides an introduction to the basics of web forms and how "
"they are handled in Django. For a more detailed look at specific areas of "
"the forms API, see :doc:`/ref/forms/api`, :doc:`/ref/forms/fields`, and :doc:"
"`/ref/forms/validation`."
msgstr ""
"本页文档介绍了Web表单的基本内容以及它们在Django中是如何处理的。想更详细的了解"
"表单的API，参见 :doc:`/ref/forms/api` ， :doc:`/ref/forms/fields` ，以及 :"
"doc:`/ref/forms/validation` 。"

msgid ""
"Unless you're planning to build websites and applications that do nothing "
"but publish content, and don't accept input from your visitors, you're going "
"to need to understand and use forms."
msgstr ""
"除非您计划搭建的网站和应用只发布内容且不接收访问者的输入，否则您就需要理解和"
"使用表单。"

msgid ""
"Django provides a range of tools and libraries to help you build forms to "
"accept input from site visitors, and then process and respond to the input."
msgstr ""
"Django提供了一系列的工具和库来帮助您构建表单来接收网站访客的输入，然后处理以"
"及响应这些输入。"

msgid "HTML forms"
msgstr "HTML表单"

msgid ""
"In HTML, a form is a collection of elements inside ``<form>...</form>`` that "
"allow a visitor to do things like enter text, select options, manipulate "
"objects or controls, and so on, and then send that information back to the "
"server."
msgstr ""
"在HTML中，表单是在 ``<form>...</form>`` 中的一些元素，它允许访客做一些类似输"
"入文本、选择选项、操作对象或空间等动作，然后发送这些信息到服务端。"

msgid ""
"Some of these form interface elements - text input or checkboxes - are built "
"into HTML itself. Others are much more complex; an interface that pops up a "
"date picker or allows you to move a slider or manipulate controls will "
"typically use JavaScript and CSS as well as HTML form ``<input>`` elements "
"to achieve these effects."
msgstr ""
"一些表单界面元素（文本框或复选框）内置在HTML中。其他会更复杂些；像弹出日期选"
"择或者允许您移动滑块或者操作控件，一般通过使用JavaScript，CSS以及HTML表单中"
"的 ``<input>`` 元素来实现这些效果。"

msgid "As well as its ``<input>`` elements, a form must specify two things:"
msgstr "和它的元素 ``<input>`` 一样，表单必须指定两样东西："

msgid ""
"*where*: the URL to which the data corresponding to the user's input should "
"be returned"
msgstr "*何地*：负责响应用户输入数据的URL地址"

msgid "*how*: the HTTP method the data should be returned by"
msgstr "*如何*：数据请求使用的HTTP方法。"

msgid ""
"As an example, the login form for the Django admin contains several "
"``<input>`` elements: one of ``type=\"text\"`` for the username, one of "
"``type=\"password\"`` for the password, and one of ``type=\"submit\"`` for "
"the \"Log in\" button. It also contains some hidden text fields that the "
"user doesn't see, which Django uses to determine what to do next."
msgstr ""
"例如，Django admin的登录表单包含了一些 ``<input>`` 元素：用户名用 ``type="
"\"text\"`` ，密码用 ``type=\"password\"`` ，登录按钮用 ``type=\"submit\"`` 。"
"它还包含一些用户看不到的隐藏文本字段，Django用它们来决定下一步行为。"

msgid ""
"It also tells the browser that the form data should be sent to the URL "
"specified in the ``<form>``’s ``action`` attribute - ``/admin/`` - and that "
"it should be sent using the HTTP mechanism specified by the ``method`` "
"attribute - ``post``."
msgstr ""
"它还告诉浏览器表单数据应该发往 ``<form>`` 的 ``action`` 属性指定的URL—— ``/"
"admin/`` ，并且应该使用它的 ``method`` 属性指定的HTTP方法—— ``post`` 。"

msgid ""
"When the ``<input type=\"submit\" value=\"Log in\">`` element is triggered, "
"the data is returned to ``/admin/``."
msgstr ""
"当 ``<input type=\"submit\" value=\"Log in\">`` 元素被触发的时候，数据会发送"
"到 ``/admin/`` 。"

msgid "``GET`` and ``POST``"
msgstr "``GET`` 和 ``POST``"

msgid ""
"``GET`` and ``POST`` are the only HTTP methods to use when dealing with "
"forms."
msgstr "处理表单时只会用到 ``GET`` 和 ``POST`` 两种HTTP方法。"

msgid ""
"Django's login form is returned using the ``POST`` method, in which the "
"browser bundles up the form data, encodes it for transmission, sends it to "
"the server, and then receives back its response."
msgstr ""
"Django的登录表单使用 ``POST`` 方法传输数据，在这个方法中浏览器会封装表单数"
"据，为了传输会进行编码，然后发送到服务端并接收它的响应。"

msgid ""
"``GET``, by contrast, bundles the submitted data into a string, and uses "
"this to compose a URL. The URL contains the address where the data must be "
"sent, as well as the data keys and values. You can see this in action if you "
"do a search in the Django documentation, which will produce a URL of the "
"form ``https://docs.djangoproject.com/search/?q=forms&release=1``."
msgstr ""
"相比之下，``GET`` 方法将提交的数据捆绑到一个字符串中，并用它来组成一个URL。该"
"URL包含了数据要发送的地址以及一些键值对应的数据。如果您在Django文档中进行一次"
"搜索，就会看到这点，它会生成一个形似 ``https://docs.djangoproject.com/"
"search/?q=forms&release=1`` 的URL。 "

msgid "``GET`` and ``POST`` are typically used for different purposes."
msgstr "``GET`` 和 ``POST`` 通常用于不同的目的。"

msgid ""
"Any request that could be used to change the state of the system - for "
"example, a request that makes changes in the database - should use ``POST``. "
"``GET`` should be used only for requests that do not affect the state of the "
"system."
msgstr ""
"任何可能用于更改系统状态的请求应该使用 ``POST`` —— 比如一个更改数据库的请求。"
"``GET`` 应该只被用于不会影响系统状态的请求。"

msgid ""
"``GET`` would also be unsuitable for a password form, because the password "
"would appear in the URL, and thus, also in browser history and server logs, "
"all in plain text. Neither would it be suitable for large quantities of "
"data, or for binary data, such as an image. A web application that uses "
"``GET`` requests for admin forms is a security risk: it can be easy for an "
"attacker to mimic a form's request to gain access to sensitive parts of the "
"system. ``POST``, coupled with other protections like Django's :doc:`CSRF "
"protection </ref/csrf/>` offers more control over access."
msgstr ""
"``GET`` 也不适合密码表格，因为密码会出现在 URL 中，因此也会出现在浏览器历史和"
"服务器日志中，都是纯文本。它也不适合于大量的数据，或二进制数据，如图像。一个"
"使用 ``GET`` 请求管理表单的网络应用程序是一个安全风险：攻击者很容易模仿表单的"
"请求来获得对系统敏感部分的访问。``POST``，加上其他保护措施，如 Django 的 :"
"doc:`CSRF 保护 </ref/csrf/>`，可以对访问进行更多控制。"

msgid ""
"On the other hand, ``GET`` is suitable for things like a web search form, "
"because the URLs that represent a ``GET`` request can easily be bookmarked, "
"shared, or resubmitted."
msgstr ""
"另一方面， ``GET`` 方法适用于诸如网页搜索表单这样的内容，因为这类呈现为一个 "
"``GET`` 请求的URL很容易被存为书签、分享或重新提交。"

msgid "Django's role in forms"
msgstr "Django在表单中的角色"

msgid ""
"Handling forms is a complex business. Consider Django's admin, where "
"numerous items of data of several different types may need to be prepared "
"for display in a form, rendered as HTML, edited using a convenient "
"interface, returned to the server, validated and cleaned up, and then saved "
"or passed on for further processing."
msgstr ""
"处理表单是一件挺复杂的事情。想想看Django的admin，许多不同类型的数据可能需要在"
"一张表单中准备显示，渲染成HTML，使用方便的界面进行编辑，传到服务器，验证和清"
"理数据，然后保存或跳过进行下一步处理。"

msgid ""
"Django's form functionality can simplify and automate vast portions of this "
"work, and can also do it more securely than most programmers would be able "
"to do in code they wrote themselves."
msgstr ""
"Django的表单功能可以简化和自动化上述工作的大部分内容，并且也能比大多数程序员"
"自己编写代码去实现来的更安全些。"

msgid "Django handles three distinct parts of the work involved in forms:"
msgstr "Django会处理涉及表单的三个不同部分："

msgid "preparing and restructuring data to make it ready for rendering"
msgstr "准备并重组数据，以便下一步的渲染"

msgid "creating HTML forms for the data"
msgstr "为数据创建HTML 表单"

msgid "receiving and processing submitted forms and data from the client"
msgstr "接收并处理客户端提交的表单及数据"

msgid ""
"It is *possible* to write code that does all of this manually, but Django "
"can take care of it all for you."
msgstr "您 *可以* 手动编写代码来实现，但Django 可以帮你完成所有这些工作。"

msgid "Forms in Django"
msgstr "Django 中的表单"

msgid ""
"We've described HTML forms briefly, but an HTML ``<form>`` is just one part "
"of the machinery required."
msgstr ""
"我们已经简单的描述过了HTML 表单，但是一个HTML ``<form>`` 只是其所需的一部分。"

msgid ""
"In the context of a web application, 'form' might refer to that HTML "
"``<form>``, or to the Django :class:`Form` that produces it, or to the "
"structured data returned when it is submitted, or to the end-to-end working "
"collection of these parts."
msgstr ""
"在网络应用的上下文中，“表单”可能指的是那个HTML ``<form>``，或者指产生它的 "
"Django :class:`Form`，或者指它提交时返回的结构化数据，或者指这些部分的端到端"
"工作集合。"

msgid "The Django :class:`Form` class"
msgstr "Django的 :class:`Form` 类"

msgid ""
"At the heart of this system of components is Django's :class:`Form` class. "
"In much the same way that a Django model describes the logical structure of "
"an object, its behavior, and the way its parts are represented to us, a :"
"class:`Form` class describes a form and determines how it works and appears."
msgstr ""
"Django表单系统的核心组件是 :class:`Form` 类。它与Django模型描述对象的逻辑结"
"构、行为以及它呈现给我们内容的形式的方式大致相同， :class:`Form` 类描述一张表"
"单并决定它如何工作及呈现。"

msgid ""
"In a similar way that a model class's fields map to database fields, a form "
"class's fields map to HTML form ``<input>`` elements. (A :class:`ModelForm` "
"maps a model class's fields to HTML form ``<input>`` elements via a :class:"
"`Form`; this is what the Django admin is based upon.)"
msgstr ""
"类似于模型类的字段映射到数据库字段的方式，表单类的字段会映射到HTML表单的 "
"``<input>`` 元素。 :class:`ModelForm` 通过 :class:`Form` 映射模型类的字段到"
"HTML表单的 ``<input>`` 元素，Django admin就基于此。"

msgid ""
"A form's fields are themselves classes; they manage form data and perform "
"validation when a form is submitted. A :class:`DateField` and a :class:"
"`FileField` handle very different kinds of data and have to do different "
"things with it."
msgstr ""
"表单字段本身也是类；他们管理表单数据并在提交表单时执行验证。 :class:"
"`DateField` 和 :class:`FileField` 处理的数据类型差别很大，所以必须用来处理不"
"同的字段。"

msgid ""
"A form field is represented to a user in the browser as an HTML \"widget\" - "
"a piece of user interface machinery. Each field type has an appropriate "
"default :doc:`Widget class </ref/forms/widgets/>`, but these can be "
"overridden as required."
msgstr ""
"在浏览器中，表单字段以HTML“控件”（用户界面的一个片段）的形式展现给我们。每个"
"字段类型都有与之相匹配的 :doc:`控件类 </ref/forms/widgets/>` ，但必要时可以覆"
"盖。"

msgid "Instantiating, processing, and rendering forms"
msgstr "实例化、处理和渲染表单"

msgid "When rendering an object in Django, we generally:"
msgstr "在Django中渲染一个对象的时候，我们通常："

msgid "get hold of it in the view (fetch it from the database, for example)"
msgstr "在视图中获取它（例如从数据库中取出）"

msgid "pass it to the template context"
msgstr "将它传递给模板上下文"

msgid "expand it to HTML markup using template variables"
msgstr "使用模板变量将它扩展为HTML标记"

msgid ""
"Rendering a form in a template involves nearly the same work as rendering "
"any other kind of object, but there are some key differences."
msgstr ""
"在模板中渲染表单几乎与渲染任何其他类型的对象的一样，但是存在一些关键性的差"
"异。"

msgid ""
"In the case of a model instance that contained no data, it would rarely if "
"ever be useful to do anything with it in a template. On the other hand, it "
"makes perfect sense to render an unpopulated form - that's what we do when "
"we want the user to populate it."
msgstr ""
"如果模型实例不包含数据，在模板中对它做任何处理几乎没什么用。但完全有理由用来"
"渲染一张空表单——当我们希望用户来填充的时候就会这么做。"

msgid ""
"So when we handle a model instance in a view, we typically retrieve it from "
"the database. When we're dealing with a form we typically instantiate it in "
"the view."
msgstr ""
"所以当我们在视图中处理模型实例时，我们一般从数据库中获取它。当我们处理表单"
"时，我们一般在视图中实例化它。"

msgid ""
"When we instantiate a form, we can opt to leave it empty or pre-populate it, "
"for example with:"
msgstr "当我们实例化表单时，我们可以选择让它为空或者对它预先填充，例如使用："

msgid ""
"data from a saved model instance (as in the case of admin forms for editing)"
msgstr "来自已保存的模型实例的数据（例如在管理编辑表单的情况下）"

msgid "data that we have collated from other sources"
msgstr "我们从其他来源获取的数据"

msgid "data received from a previous HTML form submission"
msgstr "从前面一个HTML 表单提交过来的数据"

msgid ""
"The last of these cases is the most interesting, because it's what makes it "
"possible for users not just to read a website, but to send information back "
"to it too."
msgstr ""
"最后一种情况最有趣，因为这使得用户不仅可以阅读网站，而且还可以将信息发回给"
"它。"

msgid "Building a form"
msgstr "构建一张表单"

msgid "The work that needs to be done"
msgstr "需要完成的工作"

msgid ""
"Suppose you want to create a simple form on your website, in order to obtain "
"the user's name. You'd need something like this in your template:"
msgstr ""
"假设您希望在您的网站上创建一张简易的表单，用来获取用户的名字。您需要在模板中"
"使用类似代码："

msgid ""
"This tells the browser to return the form data to the URL ``/your-name/``, "
"using the ``POST`` method. It will display a text field, labeled \"Your name:"
"\", and a button marked \"OK\". If the template context contains a "
"``current_name`` variable, that will be used to pre-fill the ``your_name`` "
"field."
msgstr ""
"这告诉浏览器将表单数据返回给URL ``/your-name/`` ，并使用 ``POST`` 方法。它将"
"显示一个标签为 \"Your name:\" 的文本字段，以及一个 \"OK\" 按钮。如果模板上下"
"文包含一个 ``current_name`` 变量，它会被预填充到 ``your_name`` 字段。"

msgid ""
"You'll need a view that renders the template containing the HTML form, and "
"that can supply the ``current_name`` field as appropriate."
msgstr ""
"您需要一个视图来渲染这个包含HTML表单的模板，并能适当提供 ``current_name`` 字"
"段。"

msgid ""
"When the form is submitted, the ``POST`` request which is sent to the server "
"will contain the form data."
msgstr "提交表单时，发送给服务器的 ``POST`` 请求将包含表单数据。"

msgid ""
"Now you'll also need a view corresponding to that ``/your-name/`` URL which "
"will find the appropriate key/value pairs in the request, and then process "
"them."
msgstr ""
"现在，您还需要一个与该 ``/your-name/`` URL相对应的视图，该视图将在请求中找到"
"相应的键/值对，然后对其进行处理。"

msgid ""
"This is a very simple form. In practice, a form might contain dozens or "
"hundreds of fields, many of which might need to be pre-populated, and we "
"might expect the user to work through the edit-submit cycle several times "
"before concluding the operation."
msgstr ""
"这是一张非常简单的表单。实际应用中，一张表单可能包含数十上百的字段，其中许多"
"可能需要预填充，并且我们可能希望用户在结束操作前需要多次来回编辑-提交。"

msgid ""
"We might require some validation to occur in the browser, even before the "
"form is submitted; we might want to use much more complex fields, that allow "
"the user to do things like pick dates from a calendar and so on."
msgstr ""
"我们可能需要在浏览器中进行一些验证，甚至在表单提交之前；我们可能希望使用更复"
"杂的字段 ，以允许用户做类似日期选择等操作。"

msgid ""
"At this point it's much easier to get Django to do most of this work for us."
msgstr "此刻，我们很容易通过使用Django来完成以上大部分工作。"

msgid "Building a form in Django"
msgstr "在Django 中构建一张表单"

msgid "The :class:`Form` class"
msgstr " :class:`Form` 类"

msgid ""
"We already know what we want our HTML form to look like. Our starting point "
"for it in Django is this:"
msgstr ""
"我们已经很清楚想要的HTML表单看起来会是什么样子。首先，在Django中这样做："

msgid ""
"This defines a :class:`Form` class with a single field (``your_name``). "
"We've applied a human-friendly label to the field, which will appear in the "
"``<label>`` when it's rendered (although in this case, the :attr:`~Field."
"label` we specified is actually the same one that would be generated "
"automatically if we had omitted it)."
msgstr ""
"它定义了一个只包含一个字段（ ``your_name`` ）的  :class:`Form` 类。我们已经为"
"这个字段提供了友好的标签，当它渲染后会显示在 ``<label>`` 中（在这种情况下，如"
"果我们省略之前指定的  :attr:`~Field.label` ，它还是会自动生成一个一样的标"
"签）。"

msgid ""
"The field's maximum allowable length is defined by :attr:`~CharField."
"max_length`. This does two things. It puts a ``maxlength=\"100\"`` on the "
"HTML ``<input>`` (so the browser should prevent the user from entering more "
"than that number of characters in the first place). It also means that when "
"Django receives the form back from the browser, it will validate the length "
"of the data."
msgstr ""
"字段的最大长度由 :attr:`~CharField.max_length` 来定义。它做了两件事情。首先它"
"在HTML的 ``<input>`` 上增加了 ``maxlength=\"100\"`` （这样浏览器会在第一时间"
"阻止用户输入超过这个数量的字符串）。其次它还会在Django收到浏览器传过来的表单"
"时，对数据长度进行验证（也就是服务器端验证）。"

msgid ""
"A :class:`Form` instance has an :meth:`~Form.is_valid()` method, which runs "
"validation routines for all its fields. When this method is called, if all "
"fields contain valid data, it will:"
msgstr ""
" :class:`Form` 实例有一个 :meth:`~Form.is_valid()` 方法，它会对所有它的字段进"
"行验证。当这个方法被调用时且所有字段都包含有效的数据，将："

msgid "return ``True``"
msgstr "返回 ``True`` "

msgid "place the form's data in its :attr:`~Form.cleaned_data` attribute."
msgstr "将表单的数据放到它的属性 :attr:`~Form.cleaned_data` 中。"

msgid "The whole form, when rendered for the first time, will look like:"
msgstr "这样整个表单在第一次渲染时，会显示如下："

msgid ""
"Note that it **does not** include the ``<form>`` tags, or a submit button. "
"We'll have to provide those ourselves in the template."
msgstr ""
"注意它 **没有** 包含 ``<form>`` 标签和提交按钮。我们必须自己在模板中提供。"

msgid "The view"
msgstr "视图"

msgid ""
"Form data sent back to a Django website is processed by a view, generally "
"the same view which published the form. This allows us to reuse some of the "
"same logic."
msgstr ""
"发回Django网站的表单数据由视图来处理，一般和发布这个表单用的是同一个视图。这"
"允许我们重用一些相同的逻辑。"

msgid ""
"To handle the form we need to instantiate it in the view for the URL where "
"we want it to be published:"
msgstr "为了处理表单，我们需要将它实例化到我们希望发布的URL的对应的视图中："

msgid ""
"If we arrive at this view with a ``GET`` request, it will create an empty "
"form instance and place it in the template context to be rendered. This is "
"what we can expect to happen the first time we visit the URL."
msgstr ""
"如果我们访问这个视图用的是 ``GET`` 请求，它会创建一个空的表单实例并将其放置在"
"模板上下文中进行渲染。这是我们在首次访问这个URL时能预料到会发生的情况。"

msgid ""
"If the form is submitted using a ``POST`` request, the view will once again "
"create a form instance and populate it with data from the request: ``form = "
"NameForm(request.POST)`` This is called \"binding data to the form\" (it is "
"now a *bound* form)."
msgstr ""
"如果表单提交用的是 ``POST`` 请求，那么该视图将再次创建一个表单实例并使用请求"
"中的数据填充它： ``form = NameForm(request.POST)`` 这叫“绑定数据到表单” （现"
"在它是一张 *绑定的* 表单）。"

msgid ""
"We call the form's ``is_valid()`` method; if it's not ``True``, we go back "
"to the template with the form. This time the form is no longer empty "
"(*unbound*) so the HTML form will be populated with the data previously "
"submitted, where it can be edited and corrected as required."
msgstr ""
"我们调用表单的 ``is_valid()`` 方法；如果不为 ``True`` ，我们带着表单返回到模"
"板。这次表单不再为空（ *未绑定* ），所以HTML表单将用之前提交的数据进行填充，"
"放到可以根据需要进行编辑和修正的位置。"

msgid ""
"If ``is_valid()`` is ``True``, we'll now be able to find all the validated "
"form data in its ``cleaned_data`` attribute. We can use this data to update "
"the database or do other processing before sending an HTTP redirect to the "
"browser telling it where to go next."
msgstr ""
"如果 ``is_valid()`` 为 ``True`` ，我们就能在其 ``cleaned_data`` 属性中找到所"
"有通过验证的表单数据。我们可以在发送一个HTTP重定向告诉浏览器下一步去向之前用"
"这些数据更新数据库或者做其他处理。"

msgid "The template"
msgstr "模板"

msgid "We don't need to do much in our ``name.html`` template:"
msgstr "我们没有必要在模板 ``name.html`` 中做过多的操作："

msgid ""
"All the form's fields and their attributes will be unpacked into HTML markup "
"from that ``{{ form }}`` by Django's template language."
msgstr ""
"所有的表单字段及其属性都将通过Django模板语言从 ``{{ form }}`` 中被解包成HTML"
"标记。"

msgid "Forms and Cross Site Request Forgery protection"
msgstr "表格和跨站请求伪造保护"

msgid ""
"Django ships with an easy-to-use :doc:`protection against Cross Site Request "
"Forgeries </ref/csrf>`. When submitting a form via ``POST`` with CSRF "
"protection enabled you must use the :ttag:`csrf_token` template tag as in "
"the preceding example. However, since CSRF protection is not directly tied "
"to forms in templates, this tag is omitted from the following examples in "
"this document."
msgstr ""
"Django自带一个简单易用的 :doc:`跨站请求伪造防护 </ref/csrf>` 。当通过 "
"``POST`` 方法提交一张启用了CSRF防护的表单时，您必须使用上例中这样的模板标签 :"
"ttag:`csrf_token` 。但是，由于CSRF防护在模板中没有与表单直接绑定，因此这个标"
"签在本页文档之后的示例中都将被忽略。"

msgid "HTML5 input types and browser validation"
msgstr "HTML5输入类型和浏览器验证"

msgid ""
"If your form includes a :class:`~django.forms.URLField`, an :class:`~django."
"forms.EmailField` or any integer field type, Django will use the ``url``, "
"``email`` and ``number`` HTML5 input types. By default, browsers may apply "
"their own validation on these fields, which may be stricter than Django's "
"validation. If you would like to disable this behavior, set the "
"``novalidate`` attribute on the ``form`` tag, or specify a different widget "
"on the field, like :class:`TextInput`."
msgstr ""
"如果您的表单包含 :class:`~django.forms.URLField` ， :class:`~django.forms."
"EmailField` 或者其他整数字段类型，Django将使用  ``url`` ， ``email`` 和 "
"``number`` HTML5输入类型。默认情况下，浏览器可能会在这些字段上应用他们自己的"
"验证，这也许比Django的验证更加严格。如果您想禁用这个行为，请在 ``form`` 标签"
"上设置 `novalidate` 属性，或者在字段上指定一个不同的控件，比如 :class:"
"`TextInput` 。"

msgid ""
"We now have a working web form, described by a Django :class:`Form`, "
"processed by a view, and rendered as an HTML ``<form>``."
msgstr ""
"现在我们有了一个可以工作的web表单，它通过一张Django :class:`Form` 描述，由一"
"个视图来处理并渲染成一个HTML ``<form>`` 。"

msgid ""
"That's all you need to get started, but the forms framework puts a lot more "
"at your fingertips. Once you understand the basics of the process described "
"above, you should be prepared to understand other features of the forms "
"system and ready to learn a bit more about the underlying machinery."
msgstr ""
"以上是您入门需要了解的所有内容，但是表单框架提供了更多垂手可得的内容。一旦您"
"理解了上述过程的基础知识，您应该再了解下表单系统的其他功能，然后学习更多的底"
"层机制。"

msgid "More about Django :class:`Form` classes"
msgstr "详解Django :class:`Form` 类"

msgid ""
"All form classes are created as subclasses of either :class:`django.forms."
"Form` or :class:`django.forms.ModelForm`. You can think of ``ModelForm`` as "
"a subclass of ``Form``. ``Form`` and ``ModelForm`` actually inherit common "
"functionality from a (private) ``BaseForm`` class, but this implementation "
"detail is rarely important."
msgstr ""
"所有表单类都作为 :class:`django.forms.Form` 或者 :class:`django.forms."
"ModelForm` 的子类来创建。您可以把 ``ModelForm`` 想象成 ``Form`` 的子类。实际"
"上 ``Form`` 和 ``ModelForm`` 从（私有） ``BaseForm`` 类继承了通用功能，但是这"
"个实现细节不怎么重要。"

msgid "Models and Forms"
msgstr "模型和表单"

msgid ""
"In fact if your form is going to be used to directly add or edit a Django "
"model, a :doc:`ModelForm </topics/forms/modelforms>` can save you a great "
"deal of time, effort, and code, because it will build a form, along with the "
"appropriate fields and their attributes, from a ``Model`` class."
msgstr ""
"实际上，如果您的表单是要直接用来添加或编辑Django模型，用 :doc:`ModelForm </"
"topics/forms/modelforms>` ，可以省时、省力、省代码，因为它会根据 ``Model`` 类"
"构建一张对应字段及其属性的表单。"

msgid "Bound and unbound form instances"
msgstr "绑定的和未绑定的表单实例"

msgid ""
"The distinction between :ref:`ref-forms-api-bound-unbound` is important:"
msgstr " :ref:`ref-forms-api-bound-unbound` 之间的区别非常重要："

msgid ""
"An unbound form has no data associated with it. When rendered to the user, "
"it will be empty or will contain default values."
msgstr ""
"未绑定的表单没有与其关联的数据。当渲染给用户的时候，它会是空的或者包含默认"
"值。"

msgid ""
"A bound form has submitted data, and hence can be used to tell if that data "
"is valid. If an invalid bound form is rendered, it can include inline error "
"messages telling the user what data to correct."
msgstr ""
"绑定的表单拥有已提交的数据，因此可以用来判断数据是否合法。如果渲染了一张非法"
"的绑定的表单，它将包含内联的错误信息，告知用户要纠正哪些数据。"

msgid ""
"The form's :attr:`~Form.is_bound` attribute will tell you whether a form has "
"data bound to it or not."
msgstr "表单的 :attr:`~Form.is_bound` 属性将告诉您一张表单是否具有绑定的数据。"

msgid "More on fields"
msgstr "字段详解"

msgid ""
"Consider a more useful form than our minimal example above, which we could "
"use to implement \"contact me\" functionality on a personal website:"
msgstr ""
"考虑一下比我们上面的小示例更有用的一张表单，我们可以用它在个人网站上实现“联系"
"我”的功能："

msgid ""
"Our earlier form used a single field, ``your_name``, a :class:`CharField`. "
"In this case, our form has four fields: ``subject``, ``message``, ``sender`` "
"and ``cc_myself``. :class:`CharField`, :class:`EmailField` and :class:"
"`BooleanField` are just three of the available field types; a full list can "
"be found in :doc:`/ref/forms/fields`."
msgstr ""
"我们之前的表单只用了一个 :class:`CharField` 类型的字段 ``your_name`` 。在这个"
"例子中，我们的表单有四个字段： ``subject`` 、 ``message`` 、 ``sender`` 和 "
"``cc_myself`` 。只用到三种可用的字段类型：  :class:`CharField` 、 :class:"
"`EmailField` 和 :class:`BooleanField` ；完整的字段类型清单请参看  :doc:`/ref/"
"forms/fields` 。"

msgid "Widgets"
msgstr "控件"

msgid ""
"Each form field has a corresponding :doc:`Widget class </ref/forms/widgets/"
">`, which in turn corresponds to an HTML form widget such as ``<input type="
"\"text\">``."
msgstr ""
"每个表单字段都有一个相对应的  :doc:`控件类 </ref/forms/widgets/>` ，这个控件"
"类又有对应的HTML表单控件，比如 ``<input type=\"text\">`` 。"

msgid ""
"In most cases, the field will have a sensible default widget. For example, "
"by default, a :class:`CharField` will have a :class:`TextInput` widget, that "
"produces an ``<input type=\"text\">`` in the HTML. If you needed "
"``<textarea>`` instead, you'd specify the appropriate widget when defining "
"your form field, as we have done for the ``message`` field."
msgstr ""
"多数情况下，字段都有合适的默认控件。比如，默认情况下， :class:`CharField` 有"
"个  :class:`TextInput` 控件，它会在HTML中生成一个 ``<input type=\"text"
"\">`` 。如果您想要的是 ``<textarea> `` ，您要在定义表单字段的时候指定控件，就"
"像我们对 ``message`` 字段那样处理。"

msgid "Field data"
msgstr "字段数据"

msgid ""
"Whatever the data submitted with a form, once it has been successfully "
"validated by calling ``is_valid()`` (and ``is_valid()`` has returned "
"``True``), the validated form data will be in the ``form.cleaned_data`` "
"dictionary. This data will have been nicely converted into Python types for "
"you."
msgstr ""
"无论用表单提交了什么数据，一旦通过调用 ``is_valid()`` 验证成功"
"（  ``is_valid()`` 返回 ``True`` ），已验证的表单数据将被放到 ``form."
"cleaned_data`` 字典中。这里的数据已经很好的为你转化为Python类型。"

msgid ""
"You can still access the unvalidated data directly from ``request.POST`` at "
"this point, but the validated data is better."
msgstr ""
"此时您依然能够直接从 ``request.POST`` 中访问到未验证的数据，但最好还是使用经"
"验证的数据。"

msgid ""
"In the contact form example above, ``cc_myself`` will be a boolean value. "
"Likewise, fields such as :class:`IntegerField` and :class:`FloatField` "
"convert values to a Python ``int`` and ``float`` respectively."
msgstr ""
"在上面的联系表单示例中， ``cc_myself`` 会被转化成一个布尔值。同样的，字段 :"
"class:`IntegerField` 和 :class:`FloatField` 的值分别会被转化为Python的 "
"``int`` 和 ``float`` 类型。"

msgid ""
"Here's how the form data could be processed in the view that handles this "
"form:"
msgstr "下面例举了如何在视图中处理表单数据："

msgid "For more on sending email from Django, see :doc:`/topics/email`."
msgstr "更多关于从Django中发送电子邮件的内容，请参见  :doc:`/topics/email` 。"

msgid ""
"Some field types need some extra handling. For example, files that are "
"uploaded using a form need to be handled differently (they can be retrieved "
"from ``request.FILES``, rather than ``request.POST``). For details of how to "
"handle file uploads with your form, see :ref:`binding-uploaded-files`."
msgstr ""
"有些字段类型需要一些额外的处理。例如，使用表单上传文件就要以不同的方式处理"
"（它们可以从 ``request.FILES`` 获取，而不是 ``request.POST`` 中）。有关如何使"
"用表单处理文件上传的详细信息，请参见 :ref:`binding-uploaded-files` 。"

msgid "Working with form templates"
msgstr "使用表单模板"

msgid ""
"All you need to do to get your form into a template is to place the form "
"instance into the template context. So if your form is called ``form`` in "
"the context, ``{{ form }}`` will render its ``<label>`` and ``<input>`` "
"elements appropriately."
msgstr ""
"您只需将表单实例放到模板的上下文中即可。因此，如果您的表单在上下文中叫 "
"``form`` ，那么  ``{{ form }}`` 将渲染它相应的 ``<label>`` 和 ``<input>`` 元"
"素。"

msgid "Form rendering options"
msgstr "表单渲染选项"

msgid "Additional form template furniture"
msgstr "额外表单模板标签"

msgid ""
"Don't forget that a form's output does *not* include the surrounding "
"``<form>`` tags, or the form's ``submit`` control. You will have to provide "
"these yourself."
msgstr ""
"不要忘记，一张表单的输出 *不* 包含外层 ``<form>`` 标签以及 ``submit`` 控件。"
"这些必须由你自己提供。"

msgid ""
"There are other output options though for the ``<label>``/``<input>`` pairs:"
msgstr "对于 ``<label>`` / ``<input>`` 对，还有其他输出选项："

msgid ""
"``{{ form.as_table }}`` will render them as table cells wrapped in ``<tr>`` "
"tags"
msgstr ""
" ``{{ form.as_table }}`` 会把它们渲染成表格单元格封装到标签 ``<tr>`` 中。"

msgid "``{{ form.as_p }}`` will render them wrapped in ``<p>`` tags"
msgstr " ``{{ form.as_p }}`` 会把它们渲染封装到标签 ``<p>`` 中。"

msgid "``{{ form.as_ul }}`` will render them wrapped in ``<li>`` tags"
msgstr " ``{{ form.as_ul }}`` 会把它们渲染封装到标签 ``<li>`` 中。"

msgid ""
"Note that you'll have to provide the surrounding ``<table>`` or ``<ul>`` "
"elements yourself."
msgstr "注意，您必须自己提供外层的 ``<table>`` 或 ``<ul>`` 元素。"

msgid ""
"Here's the output of ``{{ form.as_p }}`` for our ``ContactForm`` instance:"
msgstr "下面是我们 ``ContactForm`` 实例用 ``{{ form.as_p }}`` 的输出："

msgid ""
"Note that each form field has an ID attribute set to ``id_<field-name>``, "
"which is referenced by the accompanying label tag. This is important in "
"ensuring that forms are accessible to assistive technology such as screen "
"reader software. You can also :ref:`customize the way in which labels and "
"ids are generated <ref-forms-api-configuring-label>`."
msgstr ""
"请注意，每个表单字段都有一个 ``id_<field-name>`` 这样的ID属性，它被附带的"
"label标签引用。这对于确保表单可供屏幕阅读软件这样的辅助技术访问非常重要。您还"
"可以 :ref:`自定义Label和ID的生成方式 <ref-forms-api-configuring-label>` 。"

msgid "See :ref:`ref-forms-api-outputting-html` for more on this."
msgstr "更多相关信息，请参阅 :ref:`ref-forms-api-outputting-html` 。"

msgid "Rendering fields manually"
msgstr "手动渲染字段"

msgid ""
"We don't have to let Django unpack the form's fields; we can do it manually "
"if we like (allowing us to reorder the fields, for example). Each field is "
"available as an attribute of the form using ``{{ form.name_of_field }}``, "
"and in a Django template, will be rendered appropriately. For example:"
msgstr ""
"我们没有必要非要让Django来解包表单字段；如果我们喜欢，可以手动来处理（比如，"
"让我们对字段重新排序）。每个字段都可以用 ``{{ form.name_of_field }}`` 作为表"
"单的一个属性，并被相应的渲染在Django模板中。例如："

msgid ""
"Complete ``<label>`` elements can also be generated using the :meth:`~django."
"forms.BoundField.label_tag`. For example:"
msgstr ""
"完整的 ``<label>`` 元素还可以使用 :meth:`~django.forms.BoundField.label_tag` "
"来生成。例如："

msgid "Rendering form error messages"
msgstr "渲染表单错误信息"

msgid ""
"The price of this flexibility is a bit more work. Until now we haven't had "
"to worry about how to display form errors, because that's taken care of for "
"us. In this example we have had to make sure we take care of any errors for "
"each field and any errors for the form as a whole. Note ``{{ form."
"non_field_errors }}`` at the top of the form and the template lookup for "
"errors on each field."
msgstr ""
"这种灵活性的代价需要多做一点工作。到目前为止，我们不必担心如何显示表单的错误"
"信息，因为它们已经帮我们处理好了。下面的例子中，我们需要自己处理每个字段的错"
"误信息以及表单整体的所有错误信息。注意表单顶部的 ``{{ form."
"non_field_errors }}`` 以及模板中对每个字段查找错误信息。"

msgid ""
"Using ``{{ form.name_of_field.errors }}`` displays a list of form errors, "
"rendered as an unordered list. This might look like:"
msgstr ""
"使用 ``{{ form.name_of_field.errors }}`` 显示该字段的错误信息列表，它被渲染成"
"无序列表。看起来如下："

msgid ""
"The list has a CSS class of ``errorlist`` to allow you to style its "
"appearance. If you wish to further customize the display of errors you can "
"do so by looping over them:"
msgstr ""
"该列表有一个CSS class ``errorlist`` ，允许您自定义其样式。如果你想进一步自定"
"义错误信息的显示，您可以通过遍历它们来实现："

msgid ""
"Non-field errors (and/or hidden field errors that are rendered at the top of "
"the form when using helpers like ``form.as_p()``) will be rendered with an "
"additional class of ``nonfield`` to help distinguish them from field-"
"specific errors. For example, ``{{ form.non_field_errors }}`` would look "
"like:"
msgstr ""
"非字段验证错误信息（或者通过使用像 ``form.as_p()`` 这样的辅助方法渲染产生在表"
"单顶部的隐藏错误信息）渲染后会额外带上一个class  ``nonfield`` 以便与字段验证"
"错误信息区分。例如， ``{{ form.non_field_errors }}`` 渲染后会像这样："

msgid ""
"See :doc:`/ref/forms/api` for more on errors, styling, and working with form "
"attributes in templates."
msgstr ""
"更多错误、样式以及在模板中使用表单属性的内容，请参阅 :doc:`/ref/forms/api` 。"

msgid "Looping over the form's fields"
msgstr "遍历表单字段"

msgid ""
"If you're using the same HTML for each of your form fields, you can reduce "
"duplicate code by looping through each field in turn using a ``{% for %}`` "
"loop:"
msgstr ""
"如果您要给每个表单字段使用相同的HTML，您可以用 ``{% for %}`` 依次循环遍历每个"
"字段来减少重复代码："

msgid "Useful attributes on ``{{ field }}`` include:"
msgstr " ``{{ field }}`` 中有用的属性包括："

msgid "``{{ field.label }}``"
msgstr " ``{{ field.label }}`` "

msgid "The label of the field, e.g. ``Email address``."
msgstr "字段的label，比如 ``Email address``。"

msgid "``{{ field.label_tag }}``"
msgstr " ``{{ field.label_tag }}`` "

msgid ""
"The field's label wrapped in the appropriate HTML ``<label>`` tag. This "
"includes the form's :attr:`~django.forms.Form.label_suffix`. For example, "
"the default ``label_suffix`` is a colon::"
msgstr ""
"该字段的label封装在相应的HTML ``<label>`` 标签中。它包含表单的 :attr:"
"`~django.forms.Form.label_suffix` 。例如，默认的 ``label_suffix`` 是一个冒"
"号："

msgid "``{{ field.id_for_label }}``"
msgstr " ``{{ field.id_for_label }}`` "

msgid ""
"The ID that will be used for this field (``id_email`` in the example above). "
"If you are constructing the label manually, you may want to use this in lieu "
"of ``label_tag``. It's also useful, for example, if you have some inline "
"JavaScript and want to avoid hardcoding the field's ID."
msgstr ""
"用于该字段的 ID（像上面的例子中的 ``id_email`` ）。如果您要手动构建label，您"
"可能要用这个来替换 ``label_tag`` 。例如，如果你有一些内嵌的JavaScript并且想要"
"避免硬编码字段的ID，这也很有用。"

msgid "``{{ field.value }}``"
msgstr " ``{{ field.value }}`` "

msgid "The value of the field. e.g ``someone@example.com``."
msgstr "字段的值。例如 ``someone@example.com`` 。"

msgid "``{{ field.html_name }}``"
msgstr " ``{{ field.html_name }}`` "

msgid ""
"The name of the field that will be used in the input element's name field. "
"This takes the form prefix into account, if it has been set."
msgstr ""
"字段名称：用于其输入元素的name属性中。如果设置了表单前缀，它也会被加进去。"

msgid "``{{ field.help_text }}``"
msgstr " ``{{ field.help_text }}`` "

msgid "Any help text that has been associated with the field."
msgstr "与该字段关联的帮助文本。"

msgid "``{{ field.errors }}``"
msgstr " ``{{ field.errors }}`` "

msgid ""
"Outputs a ``<ul class=\"errorlist\">`` containing any validation errors "
"corresponding to this field. You can customize the presentation of the "
"errors with a ``{% for error in field.errors %}`` loop. In this case, each "
"object in the loop is a string containing the error message."
msgstr ""
"输出一个 ``<ul class=\"errorlist\">`` ，其中包含这个字段的所有验证错误信息。"
"你可以使用 ``{% for error in field.errors %}`` 循环来自定义错误信息的显示。在"
"这种情况下，循环中的每个对象是包含错误信息的字符串。"

msgid "``{{ field.is_hidden }}``"
msgstr " ``{{ field.is_hidden }}`` "

msgid ""
"This attribute is ``True`` if the form field is a hidden field and ``False`` "
"otherwise. It's not particularly useful as a template variable, but could be "
"useful in conditional tests such as:"
msgstr ""
"如果是隐藏字段，这个属性为 ``True`` ，否则为 ``False`` 。它作为模板变量没多大"
"作用，但可用于条件测试，例如："

msgid "``{{ field.field }}``"
msgstr " ``{{ field.field }}`` "

msgid ""
"The :class:`~django.forms.Field` instance from the form class that this :"
"class:`~django.forms.BoundField` wraps. You can use it to access :class:"
"`~django.forms.Field` attributes, e.g. ``{{ char_field.field.max_length }}``."
msgstr ""
"表单类中的 :class:`~django.forms.Field` 实例由 :class:`~django.forms."
"BoundField` 封装。您可以用它来访问 :class:`~django.forms.Field` 的属性，比如 "
"``{{ char_field.field.max_length }}`` 。"

msgid ""
"For a complete list of attributes and methods, see :class:`~django.forms."
"BoundField`."
msgstr ""
"有关字段属性及方法的完整清单，请参阅 :class:`~django.forms.BoundField` 。"

msgid "Looping over hidden and visible fields"
msgstr "遍历隐藏字段和可见字段"

msgid ""
"If you're manually laying out a form in a template, as opposed to relying on "
"Django's default form layout, you might want to treat ``<input type=\"hidden"
"\">`` fields differently from non-hidden fields. For example, because hidden "
"fields don't display anything, putting error messages \"next to\" the field "
"could cause confusion for your users -- so errors for those fields should be "
"handled differently."
msgstr ""
"如果您在手动布置模板中的表单，而不是依靠Django的默认表单布局，您可能希望将 "
"``<input type=\"hidden\">`` 字段与非隐藏字段区别开来。例如，因为隐藏字段不显"
"示任何内容，将错误消息“放到”该字段旁边可能会导致用户混淆——所以这些字段的错误"
"应该以不同的方式处理。"

msgid ""
"Django provides two methods on a form that allow you to loop over the hidden "
"and visible fields independently: ``hidden_fields()`` and "
"``visible_fields()``. Here's a modification of an earlier example that uses "
"these two methods:"
msgstr ""
"Django在表单上提供了两种方法，允许您独立地遍历隐藏和可见的字段： "
"``hidden_fields()`` 和 ``visible_fields()`` 。以下是使用这两种方法对之前示例"
"的修改："

msgid ""
"This example does not handle any errors in the hidden fields. Usually, an "
"error in a hidden field is a sign of form tampering, since normal form "
"interaction won't alter them. However, you could easily insert some error "
"displays for those form errors, as well."
msgstr ""
"这个示例没有处理隐藏字段中的任何错误信息。通常，隐藏字段中的错误象征着表单被"
"篡改，因为正常的表单交互不会去改变它们。但是，您也可以轻松地为这些表单错误插"
"入一些错误信息显示出来。"

msgid "Reusable form templates"
msgstr "可复用的表单模板"

msgid ""
"If your site uses the same rendering logic for forms in multiple places, you "
"can reduce duplication by saving the form's loop in a standalone template "
"and overriding the forms :attr:`~django.forms.Form.template_name` attribute "
"to render the form using the custom template. The below example will result "
"in ``{{ form }}`` being rendered as the output of the ``form_snippet.html`` "
"template."
msgstr ""
"如果你的网站在多个地方使用相同的表单渲染逻辑，你可以通过将表单的循环保存在一"
"个独立的模板中，并覆盖表单的 :attr:`~django.forms.form.template_name` 属性来"
"使用自定义模板渲染表单，从而减少重复。下面的例子将导致 ``{{ form }}`` 被渲染"
"成 ``form_snippet.html`` 模板的输出。"

msgid "In your templates:"
msgstr "在你的模板中："

msgid "In your form::"
msgstr "在你的表单中："

msgid "Template rendering of forms was added."
msgstr "增加了表单的模板渲染。"

msgid "Further topics"
msgstr "更多相关主题"

msgid "This covers the basics, but forms can do a whole lot more:"
msgstr "以上只涵盖了表单的基础知识，但它还可以做更多的事情："

msgid ":doc:`The Forms Reference </ref/forms/index>`"
msgstr " :doc:`表单参考 </ref/forms/index>`"

msgid ""
"Covers the full API reference, including form fields, form widgets, and form "
"and field validation."
msgstr "覆盖完整的API 参考，包括表单字段、表单控件以及表单和字段的验证。"

msgid "Form Assets (the ``Media`` class)"
msgstr "表单资源（ ``Media`` 类）"

msgid ""
"Rendering an attractive and easy-to-use web form requires more than just "
"HTML - it also requires CSS stylesheets, and if you want to use fancy "
"widgets, you may also need to include some JavaScript on each page. The "
"exact combination of CSS and JavaScript that is required for any given page "
"will depend upon the widgets that are in use on that page."
msgstr ""
"呈现一个有吸引力的、易于使用的网络表格需要的不仅仅是 HTML，它还需要 CSS 样式"
"表，如果你想使用花哨的部件，你可能还需要在每个页面上包含一些 JavaScript。任何"
"特定页面所需的 CSS 和 JavaScript 的确切组合将取决于该页面上使用的部件。"

msgid ""
"This is where asset definitions come in. Django allows you to associate "
"different files -- like stylesheets and scripts -- with the forms and "
"widgets that require those assets. For example, if you want to use a "
"calendar to render DateFields, you can define a custom Calendar widget. This "
"widget can then be associated with the CSS and JavaScript that is required "
"to render the calendar. When the Calendar widget is used on a form, Django "
"is able to identify the CSS and JavaScript files that are required, and "
"provide the list of file names in a form suitable for inclusion on your web "
"page."
msgstr ""
"这就是资源定义的作用。Django 允许你将不同的文件——如样式表和脚本——与需要这些资"
"产的表单和部件联系起来。例如，如果你想用一个日历来渲染 DateFields，你可以定义"
"一个自定义的日历部件。然后这个部件可以与渲染日历所需的 CSS 和 JavaScript 相关"
"联。当日历部件在表单上使用时，Django 能够识别需要的 CSS 和 JavaScript 文件，"
"并以适合包含在你的网页上的形式提供文件名列表。"

msgid "Assets and Django Admin"
msgstr "资源及Django Admin"

msgid ""
"The Django Admin application defines a number of customized widgets for "
"calendars, filtered selections, and so on. These widgets define asset "
"requirements, and the Django Admin uses the custom widgets in place of the "
"Django defaults. The Admin templates will only include those files that are "
"required to render the widgets on any given page."
msgstr ""
"Django Admin应用程序为日历、选择过滤及其他功能定义了一些定制的组件。这些组件"
"定义资源的需求，Django Admin使用自定义组件来代替Django的默认组件。Admin模板将"
"只会包含在页面上呈现组件所需的文件。"

msgid ""
"If you like the widgets that the Django Admin application uses, feel free to "
"use them in your own application! They're all stored in ``django.contrib."
"admin.widgets``."
msgstr ""
"如果您喜欢Django Admin应用程序使用的组件，您可以在应用中随意使用它们。它们都"
"位于 ``django.contrib.admin.widgets`` 。"

msgid "Which JavaScript toolkit?"
msgstr "哪个JavaScript工具包？"

msgid ""
"Many JavaScript toolkits exist, and many of them include widgets (such as "
"calendar widgets) that can be used to enhance your application. Django has "
"deliberately avoided blessing any one JavaScript toolkit. Each toolkit has "
"its own relative strengths and weaknesses - use whichever toolkit suits your "
"requirements. Django is able to integrate with any JavaScript toolkit."
msgstr ""
"现在有很多JavaScript工具包，它们中许多都包含组件（比如日历组件），可以用来改"
"善您的应用程序。Django刻意避免去推荐任何一个JavaScript工具包。每个工具包都有"
"自己的优点和缺点，使用适合您需求的工具包。Django能够与任何JavaScript工具包集"
"成。"

msgid "Assets as a static definition"
msgstr "资源作为静态定义"

msgid ""
"The easiest way to define assets is as a static definition. Using this "
"method, the declaration is an inner ``Media`` class. The properties of the "
"inner class define the requirements."
msgstr ""
"定义资源最简单方法是静态定义。要使用这种方法，声明是一个内部的 ``Media`` 类。"
"此内部类的属性定义了这个需求。"

msgid "Here's an example::"
msgstr "这有个例子::"

msgid ""
"This code defines a ``CalendarWidget``, which will be based on "
"``TextInput``. Every time the CalendarWidget is used on a form, that form "
"will be directed to include the CSS file ``pretty.css``, and the JavaScript "
"files ``animations.js`` and ``actions.js``."
msgstr ""
"这段代码定义了一个 ``CalendarWidget`` ，它继承自 ``TextInput`` 。每次"
"CalendarWidget在表单上使用时，该表单都会包含CSS文件 ``pretty.css`` ，以及"
"JavaScript文件 ``animations.js`` 和 ``actions.js`` 。"

msgid ""
"This static definition is converted at runtime into a widget property named "
"``media``. The list of assets for a ``CalendarWidget`` instance can be "
"retrieved through this property::"
msgstr ""
"这个静态定义在运行时被转换成名为 ``media`` 的组件属性。 ``CalendarWidget`` 实"
"例的资源列表可以通过这个属性获得："

msgid ""
"Here's a list of all possible ``Media`` options. There are no required "
"options."
msgstr "以下是所有可能的 ``Media`` 选项列表。没有一个是必需项。"

msgid "``css``"
msgstr " ``css`` "

msgid ""
"A dictionary describing the CSS files required for various forms of output "
"media."
msgstr "描述各种表单输出媒体所需的CSS文件的字典。"

msgid ""
"The values in the dictionary should be a tuple/list of file names. See :ref:"
"`the section on paths <form-asset-paths>` for details of how to specify "
"paths to these files."
msgstr ""
"字典中的值应该是一个文件名元组/列表。有关如何指定这些文件的路径的详细内容，请"
"参阅 :ref:`路径章节<form-asset-paths>` 。"

msgid ""
"The keys in the dictionary are the output media types. These are the same "
"types accepted by CSS files in media declarations: 'all', 'aural', "
"'braille', 'embossed', 'handheld', 'print', 'projection', 'screen', 'tty' "
"and 'tv'. If you need to have different stylesheets for different media "
"types, provide a list of CSS files for each output medium. The following "
"example would provide two CSS options -- one for the screen, and one for "
"print::"
msgstr ""
"字典中的键是输出媒体类型。它们和媒体声明中CSS文件接受的类型相"
"同：'all'、'aural'、'braille'、'embossed'、'handheld'、'print'、'projection'、'screen'、'tty' "
"和 'tv'。如果您需要针对不同媒体类型使用不同的样式表，就要给每个输出媒体提供一"
"个CSS文件列表。下面的示例提供了两个CSS选项——一个用于屏幕，一个用于打印："

msgid ""
"If a group of CSS files are appropriate for multiple output media types, the "
"dictionary key can be a comma separated list of output media types. In the "
"following example, TV's and projectors will have the same media "
"requirements::"
msgstr ""
"如果一组CSS文件适用于多种输出媒体类型，字典的键可以是以逗号分隔的输出媒体类型"
"列表。在下面的例子中，电视和投影机将具有相同的媒体需求："

msgid ""
"If this last CSS definition were to be rendered, it would become the "
"following HTML::"
msgstr "如果最后的这个CSS定义被渲染，它将成为下面的HTML："

msgid "``js``"
msgstr " ``js`` "

msgid ""
"A tuple describing the required JavaScript files. See :ref:`the section on "
"paths <form-asset-paths>` for details of how to specify paths to these files."
msgstr ""
"描述所需JavaScript文件的一个元组。有关如何指定这些文件的路径的详细内容，请参"
"阅 :ref:`路径章节 <form-asset-paths>` 。"

msgid "``extend``"
msgstr " ``extend`` "

msgid "A boolean defining inheritance behavior for ``Media`` declarations."
msgstr "定义了 ``Media`` 声明继承行为的一个布尔值。"

msgid ""
"By default, any object using a static ``Media`` definition will inherit all "
"the assets associated with the parent widget. This occurs regardless of how "
"the parent defines its own requirements. For example, if we were to extend "
"our basic Calendar widget from the example above::"
msgstr ""
"默认情况下，使用静态 ``Media`` 定义的对象都将继承与父组件关联的所有资源。无论"
"父级如何定义自己的需求，都会发生这种情况。例如，如果我们要从上面的例子中扩展"
"我们的基础日历组件："

msgid ""
"The FancyCalendar widget inherits all the assets from its parent widget. If "
"you don't want ``Media`` to be inherited in this way, add an "
"``extend=False`` declaration to the ``Media`` declaration::"
msgstr ""
"FancyCalendar组件从其父组件继承所有资源。如果您不想用这种方式继承 "
"``Media`` ，要在 ``Media`` 声明中添加一个 ``extend=False`` 声明："

msgid ""
"If you require even more control over inheritance, define your assets using "
"a :ref:`dynamic property <dynamic-property>`. Dynamic properties give you "
"complete control over which files are inherited, and which are not."
msgstr ""
"如果您需要更多的继承控制，用一个 :ref:`动态属性 <dynamic-property>` 定义你"
"的 。动态属性使您可以完全控制哪些文件是否继承。"

msgid "``Media`` as a dynamic property"
msgstr "把 ``Media`` 作为动态属性"

msgid ""
"If you need to perform some more sophisticated manipulation of asset "
"requirements, you can define the ``media`` property directly. This is done "
"by defining a widget property that returns an instance of ``forms.Media``.  "
"The constructor for ``forms.Media`` accepts ``css`` and ``js`` keyword "
"arguments in the same format as that used in a static media definition."
msgstr ""
"如果您需要执行一些更复杂的资源需求操作，你可以直接定义 ``media`` 属性。这是通"
"过定义一个返回 ``forms.Media`` 实例的组件属性来实现的。这个 ``forms.Media`` "
"的构造函数接受 ``css`` 和 ``js`` 关键字参数，与静态媒体定义中使用的格式相同。"

msgid ""
"For example, the static definition for our Calendar Widget could also be "
"defined in a dynamic fashion::"
msgstr "例如，我们也可以以动态的方式定义日历组件的静态定义："

msgid ""
"See the section on `Media objects`_ for more details on how to construct "
"return values for dynamic ``media`` properties."
msgstr ""
"更多有关如何为动态 ``media`` 属性构建返回值的内容，请参阅 `媒体对象` 章节。"

msgid "Paths in asset definitions"
msgstr "资源定义中的路径"

msgid ""
"Paths used to specify assets can be either relative or absolute. If a path "
"starts with ``/``, ``http://`` or ``https://``, it will be interpreted as an "
"absolute path, and left as-is. All other paths will be prepended with the "
"value of the appropriate prefix. If the :mod:`django.contrib.staticfiles` "
"app is installed, it will be used to serve assets."
msgstr ""
"用于指定资源的路径可以是相对路径的也可以是绝对路径的。如果路径以 ``/`` 、 "
"``http://`` 或 ``https://`` 开头，则它将被解释为绝对路径，并保持原样。所有其"
"他路径都会以相应值作为前缀。如果在settings中设置了 :mod:`django.contrib."
"staticfiles` ，就可以用来服务于资源。"

msgid ""
"Whether or not you use :mod:`django.contrib.staticfiles`,  the :setting:"
"`STATIC_URL` and :setting:`STATIC_ROOT` settings are required to render a "
"complete web page."
msgstr ""
"无论您是否使用 :mod:`django.contrib.staticfiles` ，都需要设置 :setting:"
"`STATIC_URL` 和 :setting:`STATIC_ROOT` 来渲染一张完整的网页。"

msgid ""
"To find the appropriate prefix to use, Django will check if the :setting:"
"`STATIC_URL` setting is not ``None`` and automatically fall back to using :"
"setting:`MEDIA_URL`. For example, if the :setting:`MEDIA_URL` for your site "
"was ``'http://uploads.example.com/'`` and :setting:`STATIC_URL` was "
"``None``::"
msgstr ""
"为了找到相应的前缀来使用，Django会去检查 :setting:`STATIC_URL` 是否不为 "
"``None`` ，并自动回退使用 :setting:`MEDIA_URL` 。例如，您的网站的 :setting:"
"`MEDIA_URL` 设置为 ``'http://uploads.example.com/'`` 且 :setting:"
"`STATIC_URL` 设置是 ``None`` ："

msgid "But if :setting:`STATIC_URL` is ``'http://static.example.com/'``::"
msgstr ""
"但如果 :setting:`STATIC_URL` 设置是 ``'http://static.example.com/'`` ："

msgid ""
"Or if :mod:`~django.contrib.staticfiles` is configured using the :class:"
"`~django.contrib.staticfiles.storage.ManifestStaticFilesStorage`::"
msgstr ""
"或者如果 :mod:`~django.contrib.staticfiles` 配置使用 :class:`~django.contrib."
"staticfiles.storage.ManifestStaticFilesStorage` ："

msgid "``Media`` objects"
msgstr "``Media`` 对象"

msgid ""
"When you interrogate the ``media`` attribute of a widget or form, the value "
"that is returned is a ``forms.Media`` object. As we have already seen, the "
"string representation of a ``Media`` object is the HTML required to include "
"the relevant files in the ``<head>`` block of your HTML page."
msgstr ""
"当您访问表单或者组件的 ``media`` 属性时，返回值是一个 ``forms.Media`` 对象。"
"正如我们已经看到的， ``Media`` 对象的字符串表示是一段需要在您HTML页面的 "
"``<head>`` 块中包含相关文件的HTML代码。"

msgid "However, ``Media`` objects have some other interesting properties."
msgstr "然而， ``Media`` 对象还有其他一些有趣的属性。"

msgid "Subsets of assets"
msgstr "资源的子集"

msgid ""
"If you only want files of a particular type, you can use the subscript "
"operator to filter out a medium of interest. For example::"
msgstr ""
"如果您只需要特定类型的文件，则可以使用下标运算符过滤出感兴趣的媒体文件。例"
"如："

msgid ""
"When you use the subscript operator, the value that is returned is a new "
"``Media`` object -- but one that only contains the media of interest."
msgstr ""
"当您使用下标运算符时，返回值是一个新的 ``Media`` 对象——但只包含感兴趣的媒体。"

msgid "Combining ``Media`` objects"
msgstr "合并 ``Media`` 对象"

msgid ""
"``Media`` objects can also be added together. When two ``Media`` objects are "
"added, the resulting ``Media`` object contains the union of the assets "
"specified by both::"
msgstr ""
"``Media`` 对象也可以添加到一起。当添加两个 ``Media`` 对象时，生成的 "
"``Media`` 对象包含两者指定的资源的并集："

msgid "Order of assets"
msgstr "资源的排序"

msgid ""
"The order in which assets are inserted into the DOM is often important. For "
"example, you may have a script that depends on jQuery. Therefore, combining "
"``Media`` objects attempts to preserve the relative order in which assets "
"are defined in each ``Media`` class."
msgstr ""
"资源插入DOM的顺序一般来说很重要。例如，您可能有一个依赖于jQuery的脚本。因此，"
"合并 ``Media`` 对象会尝试保持资源在每个 ``Media`` 类中定义的相对顺序。"

msgid ""
"Combining ``Media`` objects with assets in a conflicting order results in a "
"``MediaOrderConflictWarning``."
msgstr ""
"合并 ``Media`` 对象时，如果资源排序冲突，会导致警告提示： "
"``MediaOrderConflictWarning`` 。"

msgid "``Media`` on Forms"
msgstr "表单上的 ``Media`` "

msgid ""
"Widgets aren't the only objects that can have ``media`` definitions -- forms "
"can also define ``media``. The rules for ``media`` definitions on forms are "
"the same as the rules for widgets: declarations can be static or dynamic; "
"path and inheritance rules for those declarations are exactly the same."
msgstr ""
"组件不是唯一可以具有 ``media`` 定义的对象——表单也可以。表单上 ``media`` 定义"
"的规则与组件的规则相同：声明可以是静态的或动态的；声明的路径和继承规则也一模"
"一样。"

msgid ""
"Regardless of whether you define a ``media`` declaration, *all* Form objects "
"have a ``media`` property. The default value for this property is the result "
"of adding the ``media`` definitions for all widgets that are part of the "
"form::"
msgstr ""
"无论您是否定义了 ``media`` 声明，*所有*表单对象都有一个 ``media`` 属性。该属"
"性的默认值是这个表单的所有组件添加 ``media`` 定义的结果："

msgid ""
"If you want to associate additional assets with a form -- for example, CSS "
"for form layout -- add a ``Media`` declaration to the form::"
msgstr ""
"如果您想将其他资源与表单关联起来——例如，表单布局的CSS——只要向表单添加 "
"``Media`` 声明："

msgid "Creating forms from models"
msgstr "从模型创建表单"

msgid "``ModelForm``"
msgstr "``ModelForm``"

msgid ""
"If you're building a database-driven app, chances are you'll have forms that "
"map closely to Django models. For instance, you might have a ``BlogComment`` "
"model, and you want to create a form that lets people submit comments. In "
"this case, it would be redundant to define the field types in your form, "
"because you've already defined the fields in your model."
msgstr ""
"如果您正在构建一个数据库驱动的应用程序，那么您很有可能会用到与Django模型密切"
"相关的表单。例如，您可能有一个 ``BlogComment`` 模型，并且您想创建一个让用户提"
"交评论的表单。在这种情况下，在表单中定义字段类型是多余的，因为您已经在模型中"
"定义了字段。"

msgid ""
"For this reason, Django provides a helper class that lets you create a "
"``Form`` class from a Django model."
msgstr ""
"因此，Django 提供了一个辅助类让你可以从一个 Django 模型创建一个 ``Form`` 类。"

msgid ""
"The generated ``Form`` class will have a form field for every model field "
"specified, in the order specified in the ``fields`` attribute."
msgstr ""
"生成的 ``Form`` 类将按照 ``fields`` 属性中指定的顺序为每个指定的模型字段设置"
"一个表单字段。"

msgid ""
"Each model field has a corresponding default form field. For example, a "
"``CharField`` on a model is represented as a ``CharField`` on a form. A "
"model ``ManyToManyField`` is represented as a ``MultipleChoiceField``. Here "
"is the full list of conversions:"
msgstr ""
"每个模型字段都有一个对应的默认表单字段。例如，模型中的 ``CharField`` 在表单中"
"被表现为 ``CharField`` 。 ``ManyToManyField`` 则表现为 "
"``MultipleChoiceField`` 。以下是完整的转化清单："

msgid "Model field"
msgstr "模型字段"

msgid "Form field"
msgstr "表单字段"

msgid ":class:`AutoField`"
msgstr ":class:`AutoField`"

msgid "Not represented in the form"
msgstr "不呈现在表单中"

msgid ":class:`BigAutoField`"
msgstr ":class:`BigAutoField`"

msgid ":class:`BigIntegerField`"
msgstr ":class:`BigIntegerField`"

msgid ""
":class:`~django.forms.IntegerField` with ``min_value`` set to "
"-9223372036854775808 and ``max_value`` set to 9223372036854775807."
msgstr ""
":class:`~django.forms.IntegerField` 将 ``min_value`` 设置"
"为-9223372036854775808，将 ``max_value`` 设置为9223372036854775807。"

msgid ":class:`BinaryField`"
msgstr ":class:`BinaryField`"

msgid ""
":class:`~django.forms.CharField`, if :attr:`~.Field.editable` is set to "
"``True`` on the model field, otherwise not represented in the form."
msgstr ""
":class:`~django.forms.CharField` ，如果在模型字段上的 :attr:`~.Field."
"editable` 被设置为 ``True`` ，则不在表单中显示。"

msgid ":class:`BooleanField`"
msgstr ":class:`BooleanField`"

msgid ""
":class:`~django.forms.BooleanField`, or :class:`~django.forms."
"NullBooleanField` if ``null=True``."
msgstr ""
":class:`~django.forms.BooleanField`, 或 :class:`~django.forms."
"NullBooleanField` （如果 ``null=True`` ）。"

msgid ":class:`CharField`"
msgstr ":class:`CharField`"

msgid ""
":class:`~django.forms.CharField` with ``max_length`` set to the model "
"field's ``max_length`` and :attr:`~django.forms.CharField.empty_value` set "
"to ``None`` if ``null=True``."
msgstr ""
":class:`~django.forms.CharField` 将 ``max_length`` 设置为模型字段的 "
"``max_length`` ，如果模型中设置了 ``null=True`` ，会将 :attr:`~django.forms."
"CharField.empty_value` 设置为 ``None`` 。"

msgid ":class:`DateField`"
msgstr ":class:`DateField`"

msgid ":class:`~django.forms.DateField`"
msgstr ":class:`~django.forms.DateField`"

msgid ":class:`DateTimeField`"
msgstr ":class:`DateTimeField`"

msgid ":class:`~django.forms.DateTimeField`"
msgstr ":class:`~django.forms.DateTimeField`"

msgid ":class:`DecimalField`"
msgstr ":class:`DecimalField`"

msgid ":class:`~django.forms.DecimalField`"
msgstr ":class:`~django.forms.DecimalField`"

msgid ":class:`DurationField`"
msgstr ":class:`DurationField`"

msgid ":class:`~django.forms.DurationField`"
msgstr ":class:`~django.forms.DurationField`"

msgid ":class:`EmailField`"
msgstr ":class:`EmailField`"

msgid ":class:`~django.forms.EmailField`"
msgstr ":class:`~django.forms.EmailField`"

msgid ":class:`FileField`"
msgstr ":class:`FileField`"

msgid ":class:`~django.forms.FileField`"
msgstr ":class:`~django.forms.FileField`"

msgid ":class:`FilePathField`"
msgstr ":class:`FilePathField`"

msgid ":class:`~django.forms.FilePathField`"
msgstr ":class:`~django.forms.FilePathField`"

msgid ":class:`FloatField`"
msgstr ":class:`FloatField`"

msgid ":class:`~django.forms.FloatField`"
msgstr ":class:`~django.forms.FloatField`"

msgid ":class:`ForeignKey`"
msgstr ":class:`ForeignKey`"

msgid ":class:`~django.forms.ModelChoiceField` (see below)"
msgstr ":class:`~django.forms.ModelChoiceField` （见下文）"

msgid ":class:`ImageField`"
msgstr ":class:`ImageField`"

msgid ":class:`~django.forms.ImageField`"
msgstr ":class:`~django.forms.ImageField`"

msgid ":class:`IntegerField`"
msgstr ":class:`IntegerField`"

msgid ":class:`~django.forms.IntegerField`"
msgstr ":class:`~django.forms.IntegerField`"

msgid "``IPAddressField``"
msgstr "``IPAddressField``"

msgid ":class:`GenericIPAddressField`"
msgstr ":class:`GenericIPAddressField`"

msgid ":class:`~django.forms.GenericIPAddressField`"
msgstr ":class:`~django.forms.GenericIPAddressField`"

msgid ":class:`JSONField`"
msgstr ":class:`JSONField`"

msgid ":class:`~django.forms.JSONField`"
msgstr ":class:`~django.forms.JSONField`"

msgid ":class:`ManyToManyField`"
msgstr ":class:`ManyToManyField`"

msgid ":class:`~django.forms.ModelMultipleChoiceField` (see below)"
msgstr ":class:`~django.forms.ModelMultipleChoiceField` （见下文）"

msgid ":class:`PositiveBigIntegerField`"
msgstr ":class:`PositiveBigIntegerField`"

msgid ":class:`PositiveIntegerField`"
msgstr ":class:`PositiveIntegerField`"

msgid ":class:`PositiveSmallIntegerField`"
msgstr ":class:`PositiveSmallIntegerField`"

msgid ":class:`SlugField`"
msgstr ":class:`SlugField`"

msgid ":class:`~django.forms.SlugField`"
msgstr ":class:`~django.forms.SlugField`"

msgid ":class:`SmallAutoField`"
msgstr ":class:`SmallAutoField`"

msgid ":class:`SmallIntegerField`"
msgstr ":class:`SmallIntegerField`"

msgid ":class:`TextField`"
msgstr ":class:`TextField`"

msgid ":class:`~django.forms.CharField` with ``widget=forms.Textarea``"
msgstr ":class:`~django.forms.CharField` 设置中 ``widget=forms.Textarea``"

msgid ":class:`TimeField`"
msgstr ":class:`TimeField`"

msgid ":class:`~django.forms.TimeField`"
msgstr ":class:`~django.forms.TimeField`"

msgid ":class:`URLField`"
msgstr ":class:`URLField`"

msgid ":class:`~django.forms.URLField`"
msgstr ":class:`~django.forms.URLField`"

msgid ":class:`UUIDField`"
msgstr ":class:`UUIDField`"

msgid ":class:`~django.forms.UUIDField`"
msgstr ":class:`~django.forms.UUIDField`"

msgid ""
"As you might expect, the ``ForeignKey`` and ``ManyToManyField`` model field "
"types are special cases:"
msgstr ""
"如您所料， ``ForeignKey`` 和 ``ManyToManyField`` 模型字段类型是特殊情况："

msgid ""
"``ForeignKey`` is represented by ``django.forms.ModelChoiceField``, which is "
"a ``ChoiceField`` whose choices are a model ``QuerySet``."
msgstr ""
"``ForeignKey`` 由 ``django.forms.ModelChoiceField`` 表示， 它是一个 "
"``ChoiceField`` ，其选项是一个模型的 ``QuerySet`` 。"

msgid ""
"``ManyToManyField`` is represented by ``django.forms."
"ModelMultipleChoiceField``, which is a ``MultipleChoiceField`` whose choices "
"are a model ``QuerySet``."
msgstr ""
"``ManyToManyField`` 由 ``django.forms.ModelMultipleChoiceField`` 表示，它是一"
"个 ``MultipleChoiceField`` ，其选项为一个模型 ``QuerySet`` 。"

msgid "In addition, each generated form field has attributes set as follows:"
msgstr "另外，每个生成的表单字段的属性设置如下："

msgid ""
"If the model field has ``blank=True``, then ``required`` is set to ``False`` "
"on the form field. Otherwise, ``required=True``."
msgstr ""
"如果模型字段设置了 ``blank=True`` ，那么表单字段的 ``required`` 属性被设置为 "
"``False`` ，否则 ``required=True`` 。"

msgid ""
"The form field's ``label`` is set to the ``verbose_name`` of the model "
"field, with the first character capitalized."
msgstr ""
"表单字段的 ``label`` 设置为模型字段的 ``verbose_name`` ，并且首字母大写。"

msgid ""
"The form field's ``help_text`` is set to the ``help_text`` of the model "
"field."
msgstr "表单字段的 ``help_text`` 设置为模型字段的 ``help_text`` 。"

msgid ""
"If the model field has ``choices`` set, then the form field's ``widget`` "
"will be set to ``Select``, with choices coming from the model field's "
"``choices``. The choices will normally include the blank choice which is "
"selected by default. If the field is required, this forces the user to make "
"a selection. The blank choice will not be included if the model field has "
"``blank=False`` and an explicit ``default`` value (the ``default`` value "
"will be initially selected instead)."
msgstr ""
"如果模型字段设置了 ``choices`` ，那么表单字段的 ``widget`` 会被设置为 "
"``Select`` ，其选项来自模型字段的 ``choices`` 。这些选项通常包含一个默认选中"
"的空选项。如果字段设置了必填，则会强制用户进行选择。如果模型字段设置了 "
"``blank=False`` 以及一个明确的 ``default`` 值，则表单字段中不会包含空选项（默"
"认会选中 ``default`` 值）。"

msgid ""
"Finally, note that you can override the form field used for a given model "
"field. See `Overriding the default fields`_ below."
msgstr ""
"最后，请注意，您可以覆盖给定模型字段对应的表单字段。参见下文  `覆盖默认字段"
"`_ 。"

msgid "Consider this set of models::"
msgstr "思考下下面这组模型："

msgid ""
"With these models, the ``ModelForm`` subclasses above would be roughly "
"equivalent to this (the only difference being the ``save()`` method, which "
"we'll discuss in a moment.)::"
msgstr ""
"通过这些模型，上面的 ``ModelForm`` 子类将大致等同于（唯一的区别是 ``save()`` "
"方法，这我们稍后会讨论）："

msgid "Validation on a ``ModelForm``"
msgstr "验证 ``ModelForm``"

msgid "There are two main steps involved in validating a ``ModelForm``:"
msgstr "验证 ``ModelForm`` 主要涉及两个步骤："

msgid ":doc:`Validating the form </ref/forms/validation>`"
msgstr ":doc:`验证表单</ref/forms/validation>`"

msgid ":ref:`Validating the model instance <validating-objects>`"
msgstr ":ref:`验证模型实例<validating-objects>`"

msgid ""
"Just like normal form validation, model form validation is triggered "
"implicitly when calling :meth:`~django.forms.Form.is_valid()` or accessing "
"the :attr:`~django.forms.Form.errors` attribute and explicitly when calling "
"``full_clean()``, although you will typically not use the latter method in "
"practice."
msgstr ""
"和普通的表单验证一样，模型表单验证在调用 :meth:`~django.forms.Form."
"is_valid()` 或访问 :attr:`~django.forms.Form.errors` 属性时隐式触发，在调用 "
"``full_clean()`` 时显式触发，尽管在实际应用中你不大会用到后一种方法。"

msgid ""
"``Model`` validation (:meth:`Model.full_clean() <django.db.models.Model."
"full_clean()>`) is triggered from within the form validation step, right "
"after the form's ``clean()`` method is called."
msgstr ""
"``模型`` 验证（ :meth:`Model.full_clean() <django.db.models.Model."
"full_clean()>` ）在表单验证步骤中紧随表单的 ``clean()`` 方法被调用后触发。"

msgid ""
"The cleaning process modifies the model instance passed to the ``ModelForm`` "
"constructor in various ways. For instance, any date fields on the model are "
"converted into actual date objects. Failed validation may leave the "
"underlying model instance in an inconsistent state and therefore it's not "
"recommended to reuse it."
msgstr ""
"Clean 过程会以各种方式去修改传递给 ``ModelForm`` 构造方法的模型实例。例如，模"
"型上的所有日期字段都将转换为实际的日期对象。验证失败可能会使底层模型实例处于"
"不一致状态，因此不推荐对其重用。"

msgid "Overriding the clean() method"
msgstr "覆盖clean()方法 "

msgid ""
"You can override the ``clean()`` method on a model form to provide "
"additional validation in the same way you can on a normal form."
msgstr ""
"您可以重写模型表单上的 ``clean()`` 方法来提供额外的验证，方式和普通的表单一"
"样。"

msgid ""
"A model form instance attached to a model object will contain an "
"``instance`` attribute that gives its methods access to that specific model "
"instance."
msgstr ""
"访问模型对象对应的表单实例包含一个 ``instance`` 属性，让它可以访问对应的模型"
"实例。"

msgid ""
"The ``ModelForm.clean()`` method sets a flag that makes the :ref:`model "
"validation <validating-objects>` step validate the uniqueness of model "
"fields that are marked as ``unique``, ``unique_together`` or "
"``unique_for_date|month|year``."
msgstr ""
"``ModelForm.clean()`` 方法设置了一个标识符，使程序在 :ref:`模型验证 "
"<validating-objects>`  这步去验证标记为 ``unique`` 、 ``unique_together`` 或 "
"``unique_for_date|month|year`` 的模型字段的唯一性。"

msgid ""
"If you would like to override the ``clean()`` method and maintain this "
"validation, you must call the parent class's ``clean()`` method."
msgstr ""
"如果您想覆盖 ``clean()`` 方法并保持当前的验证，您必须调用父类的 ``clean()`` "
"方法。"

msgid "Interaction with model validation"
msgstr "与模型验证交互"

msgid ""
"As part of the validation process, ``ModelForm`` will call the ``clean()`` "
"method of each field on your model that has a corresponding field on your "
"form. If you have excluded any model fields, validation will not be run on "
"those fields. See the :doc:`form validation </ref/forms/validation>` "
"documentation for more on how field cleaning and validation work."
msgstr ""
"作为验证过程的一部分， ``ModelForm`` 将调用模型上与表单字段对应的每个字段的 "
"``clean()`` 方法。如果您排除了一些模型字段，则验证将不会在这些字段上运行。更"
"多有关字段clean及验证是如何工作的内容，请参阅 :doc:`表单验证 </ref/forms/"
"validation>` 文档。"

msgid ""
"The model's ``clean()`` method will be called before any uniqueness checks "
"are made. See :ref:`Validating objects <validating-objects>` for more "
"information on the model's ``clean()`` hook."
msgstr ""
"模型的 ``clean()`` 方法会在所有唯一性检查之前被调用。有关模型 ``clean()`` 钩"
"子的更多信息，请参阅 :ref:`验证对象 <validating-objects>` 。"

msgid "Considerations regarding model's ``error_messages``"
msgstr "有关模型的 ``error_messages`` 的注意事项"

msgid ""
"Error messages defined at the :attr:`form field <django.forms.Field."
"error_messages>` level or at the :ref:`form Meta <modelforms-overriding-"
"default-fields>` level always take precedence over the error messages "
"defined at the :attr:`model field <django.db.models.Field.error_messages>` "
"level."
msgstr ""
"在 :attr:`表单字段 <django.forms.Field.error_messages>` 级别或者 :ref:`表单 "
"Meta <modelforms-overriding-default-fields>` 级别定义的错误信息优先级总是高于"
"在 :attr:`模型字段 <django.db.models.Field.error_messages>` 级别定义的。"

msgid ""
"Error messages  defined on :attr:`model fields <django.db.models.Field."
"error_messages>` are only used when the ``ValidationError`` is raised during "
"the :ref:`model validation <validating-objects>` step and no corresponding "
"error messages are defined at the form level."
msgstr ""
"在 :attr:`模型字段 <django.db.models.Field.error_messages>` 上定义的错误信息"
"只有在 :ref:`模型验证 <validating-objects>` 步骤引发 ``ValidationError`` 时才"
"会使用，并且没有在表单级定义相应的错误信息。"

msgid ""
"You can override the error messages from ``NON_FIELD_ERRORS`` raised by "
"model validation by adding the :data:`~django.core.exceptions."
"NON_FIELD_ERRORS` key to the ``error_messages`` dictionary of the "
"``ModelForm``’s inner ``Meta`` class::"
msgstr ""
"您可以通过添加 :data:`~django.core.exceptions.NON_FIELD_ERRORS` 键到 "
"``ModelForm`` 内部的 ``Meta`` 类的 ``error_messages`` 中来覆盖模型验证引发的 "
"``NON_FIELD_ERRORS`` 错误信息。"

msgid "The ``save()`` method"
msgstr "``save()`` 方法"

msgid ""
"Every ``ModelForm`` also has a ``save()`` method. This method creates and "
"saves a database object from the data bound to the form. A subclass of "
"``ModelForm`` can accept an existing model instance as the keyword argument "
"``instance``; if this is supplied, ``save()`` will update that instance. If "
"it's not supplied, ``save()`` will create a new instance of the specified "
"model::"
msgstr ""
"每个 ``ModelForm`` 也有 ``save()`` 方法。此方法根据绑定到表单的数据创建并保存"
"数据库对象。 ``ModelForm`` 的子类可接受一个现有的模型实例作为关键字参数 "
"``instance`` ；如果提供了，则 ``save()`` 会更新这个实例。如果没有，则 "
"``save()`` 会创建一个对应模型的新实例。"

msgid ""
"Note that if the form :ref:`hasn't been validated <validation-on-"
"modelform>`, calling ``save()`` will do so by checking ``form.errors``. A "
"``ValueError`` will be raised if the data in the form doesn't validate -- i."
"e., if ``form.errors`` evaluates to ``True``."
msgstr ""
"请注意，如果表单 :ref:`尚未验证 <validation-on-modelform>` ，调用 ``save()`` "
"将通过检查 ``form.errors`` 来实现验证。如果表单验证不过，则会引发 "
"``ValueError`` —— 比如，如果 ``form.errors`` 返回 ``True`` 。"

msgid ""
"If an optional field doesn't appear in the form's data, the resulting model "
"instance uses the model field :attr:`~django.db.models.Field.default`, if "
"there is one, for that field. This behavior doesn't apply to fields that "
"use :class:`~django.forms.CheckboxInput`, :class:`~django.forms."
"CheckboxSelectMultiple`, or :class:`~django.forms.SelectMultiple` (or any "
"custom widget whose :meth:`~django.forms.Widget.value_omitted_from_data` "
"method always returns ``False``) since an unchecked checkbox and unselected "
"``<select multiple>`` don't appear in the data of an HTML form submission. "
"Use a custom form field or widget if you're designing an API and want the "
"default fallback behavior for a field that uses one of these widgets."
msgstr ""
"如果一个可选字段没有出现在表单的数据中，并且您给这个模型字段设置了 :attr:"
"`~django.db.models.Field.default` ，那么对应的模型实例会使用这个值作为结果。"
"此行为不适用于使用以下组件的字段： :class:`~django.forms.CheckboxInput` 、 :"
"class:`~django.forms.CheckboxSelectMultiple` 或者 :class:`~django.forms."
"SelectMultiple` （或者所有其 :meth:`~django.forms.Widget."
"value_omitted_from_data` 方法总是返回 ``False`` 的组件），因为未勾选的复选框"
"和未选中的 ``<select multiple>`` 不会出现在HTML表单提交的数据中。如果您正在设"
"计API并且希望使用这些组件之一的字段有默认回退行为，请使用自定义表单字段或组"
"件。"

msgid ""
"This ``save()`` method accepts an optional ``commit`` keyword argument, "
"which accepts either ``True`` or ``False``. If you call ``save()`` with "
"``commit=False``, then it will return an object that hasn't yet been saved "
"to the database. In this case, it's up to you to call ``save()`` on the "
"resulting model instance. This is useful if you want to do custom processing "
"on the object before saving it, or if you want to use one of the "
"specialized :ref:`model saving options <ref-models-force-insert>`. "
"``commit`` is ``True`` by default."
msgstr ""
"``save()`` 方法接受一个可选参数 ``commit`` ，它的值是 ``True`` 或者 "
"``False`` 。如果调用 ``save()`` 的时候使用 ``commit=False`` ，那么它会返回一"
"个尚未保存到数据库的对象。在这种情况下，需要您自己在生成的模型实例上调用 "
"``save()`` 。如果要在保存对象之前对对象执行自定义操作，或者要使用其中一个专用"
"的 :ref:`模型保存选项 <ref-models-force-insert>` ，这很有用。 ``commit`` 的值"
"默认为 ``True`` 。"

msgid ""
"Another side effect of using ``commit=False`` is seen when your model has a "
"many-to-many relation with another model. If your model has a many-to-many "
"relation and you specify ``commit=False`` when you save a form, Django "
"cannot immediately save the form data for the many-to-many relation. This is "
"because it isn't possible to save many-to-many data for an instance until "
"the instance exists in the database."
msgstr ""
"另一个使用 ``commit=False`` 的作用，您可以在模型与另一个模型有多对多关系的时"
"候看到。如果您的模型具有多对多关系，并且在保存表单时指定了 "
"``commit=False`` ，Django无法立即保存多对多关系的表单数据。这是因为实例的多对"
"多数据只有实例在数据库中存在时才能保存。"

msgid ""
"To work around this problem, every time you save a form using "
"``commit=False``, Django adds a ``save_m2m()`` method to your ``ModelForm`` "
"subclass. After you've manually saved the instance produced by the form, you "
"can invoke ``save_m2m()`` to save the many-to-many form data. For example::"
msgstr ""
"要解决这个问题，Django会在每次使用 ``commit=False`` 保存表单时，向 "
"``ModelForm`` 子类添加一个 ``save_m2m()`` 方法。在您手动保存表单生成的实例"
"后，可以调用 ``save_m2m()`` 来保存多对多的表单数据。例如："

msgid ""
"Calling ``save_m2m()`` is only required if you use ``save(commit=False)``. "
"When you use a ``save()`` on a form, all data -- including many-to-many data "
"-- is saved without the need for any additional method calls.  For example::"
msgstr ""
"只有在您使用 ``save(commit=False)`` 的时候才需要调用 ``save_m2m()`` 。当您在"
"表单上使用 ``save()`` 时，无需调用其他方法，所有数据（包括多对多数据）都会被"
"保存。例如："

msgid ""
"Other than the ``save()`` and ``save_m2m()`` methods, a ``ModelForm`` works "
"exactly the same way as any other ``forms`` form. For example, the "
"``is_valid()`` method is used to check for validity, the ``is_multipart()`` "
"method is used to determine whether a form requires multipart file upload "
"(and hence whether ``request.FILES`` must be passed to the form), etc. See :"
"ref:`binding-uploaded-files` for more information."
msgstr ""
"除了  ``save()`` 和 ``save_m2m()`` 方法之外，``ModelForm`` 与普通的表单工作方"
"式一样。例如，用 ``is_valid()`` 方法来检查合法性，用 ``is_multipart()`` 方法"
"来确定表单是否需要multipart文件上传（之后是否必须将 ``request.FILES`` 传递给"
"表单），等等。更多相关信息，请参阅 :ref:`binding-uploaded-files` 。"

msgid "Selecting the fields to use"
msgstr "选择要使用的字段"

msgid ""
"It is strongly recommended that you explicitly set all fields that should be "
"edited in the form using the ``fields`` attribute. Failure to do so can "
"easily lead to security problems when a form unexpectedly allows a user to "
"set certain fields, especially when new fields are added to a model. "
"Depending on how the form is rendered, the problem may not even be visible "
"on the web page."
msgstr ""
"强烈建议您使用 ``fields`` 属性来显式设置所有应在表单中编辑的字段。如果不这样"
"做，当一张表单不慎允许用户设置某些字段，尤其是在将新字段添加到模型中时，很容"
"易导致安全问题。根据表单渲染方式的不同，甚至可能不会在网页上显示问题。"

msgid ""
"The alternative approach would be to include all fields automatically, or "
"remove only some. This fundamental approach is known to be much less secure "
"and has led to serious exploits on major websites (e.g. `GitHub <https://"
"github.blog/2012-03-04-public-key-security-vulnerability-and-mitigation/>`_)."
msgstr ""
"另一种方法是自动包括所有字段，或只删除一些字段。众所周知，这种基本方法的安全"
"性要低得多，并导致主要网站出现严重的漏洞（例如，`GitHub <https://github."
"blog/2012-03-04-public-key-security-vulnerability-and-mitigation/>`_ ）。"

msgid ""
"There are, however, two shortcuts available for cases where you can "
"guarantee these security concerns do not apply to you:"
msgstr "但是，有两种简单的方法保证你不会出现这些安全问题："

msgid ""
"Set the ``fields`` attribute to the special value ``'__all__'`` to indicate "
"that all fields in the model should be used. For example::"
msgstr ""
"将 ``fields`` 属性设置为特殊值 ``'__all__'`` 以表明需要使用模型中的所有字段。"
"例如："

msgid ""
"Set the ``exclude`` attribute of the ``ModelForm``’s inner ``Meta`` class to "
"a list of fields to be excluded from the form."
msgstr ""
"将 ``ModelForm`` 中Meta类的 ``exclude`` 属性设置为表单中需要排除的字段列表。"

msgid ""
"Since the ``Author`` model has the 3 fields ``name``, ``title`` and "
"``birth_date``, this will result in the fields ``name`` and ``birth_date`` "
"being present on the form."
msgstr ""
"由于 ``Author`` 模型有三个字段 ``name``、 ``title`` 和 ``birth_date`` ，上例"
"的结果是字段 ``name`` 和 ``birth_date`` 会呈现在表单中。"

msgid ""
"If either of these are used, the order the fields appear in the form will be "
"the order the fields are defined in the model, with ``ManyToManyField`` "
"instances appearing last."
msgstr ""
"不管使用哪一种，字段会按模型中定义的顺序在表单中出现， ``ManyToManyField`` 会"
"排在最后。"

msgid ""
"In addition, Django applies the following rule: if you set "
"``editable=False`` on the model field, *any* form created from the model via "
"``ModelForm`` will not include that field."
msgstr ""
"另外，Django有个规则：如果您在模型字段中定义了 ``editable=False`` ， *任何*使"
"用 ``ModelForm`` 给该模型创建的表单都不会包含这个字段。"

msgid ""
"Any fields not included in a form by the above logic will not be set by the "
"form's ``save()`` method. Also, if you manually add the excluded fields back "
"to the form, they will not be initialized from the model instance."
msgstr ""
"任何没在上面逻辑中包含的表单字段都会不被表单的 ``save()`` 方法处理。另外，如"
"果手动将排除的字段添加回表单，它们也不会被模型实例初始化。"

msgid ""
"Django will prevent any attempt to save an incomplete model, so if the model "
"does not allow the missing fields to be empty, and does not provide a "
"default value for the missing fields, any attempt to ``save()`` a "
"``ModelForm`` with missing fields will fail.  To avoid this failure, you "
"must instantiate your model with initial values for the missing, but "
"required fields::"
msgstr ""
"Django会阻止任何尝试保存不完整模型的行为，所以如果模型不允许缺省的字段为空，"
"并且没有为该字段提供缺省值，那么任何尝试用这种字段的 ``ModelForm`` 的 "
"``save()`` 方法都会失败。为了避免这种情况，您必须使用初始值实例化您模型中缺省"
"但又必填的字段："

msgid ""
"Alternatively, you can use ``save(commit=False)`` and manually set any extra "
"required fields::"
msgstr "或者，您可以使用 ``save(commit=False)`` 然后手动设置其他必填字段："

msgid ""
"See the `section on saving forms`_ for more details on using "
"``save(commit=False)``."
msgstr ""
"更多关于使用 ``save(commit=False)`` 的详细内容，请参阅 `保存表单章节`_ 。"

msgid "Overriding the default fields"
msgstr "覆盖默认字段"

msgid ""
"The default field types, as described in the `Field types`_ table above, are "
"sensible defaults. If you have a ``DateField`` in your model, chances are "
"you'd want that to be represented as a ``DateField`` in your form. But "
"``ModelForm`` gives you the flexibility of changing the form field for a "
"given model."
msgstr ""
"之前在 `字段类型`_ 表格中介绍的默认字段类型都是相对合适的。如果您的模型中有一"
"个 ``DateField`` ，您可能希望在表单中将它展示为 ``DateField`` 。但 "
"``ModelForm`` 可以让您灵活地改变给定模型的表单字段。"

msgid ""
"To specify a custom widget for a field, use the ``widgets`` attribute of the "
"inner ``Meta`` class. This should be a dictionary mapping field names to "
"widget classes or instances."
msgstr ""
"要为字段指定自定义组件，请使用内部 ``Meta`` 类的 ``widgets`` 属性。它应该是一"
"个映射字段名到组建类或组件实例的字典。"

msgid ""
"For example, if you want the ``CharField`` for the ``name`` attribute of "
"``Author`` to be represented by a ``<textarea>`` instead of its default "
"``<input type=\"text\">``, you can override the field's widget::"
msgstr ""
"例如，如果您希望 ``Author`` 的 ``name`` 属性的 ``CharField`` 由 "
"``<textarea>`` 代替默认的 ``<input type=\"text\">`` 来表示，您可以重写字段的"
"部件："

msgid ""
"The ``widgets`` dictionary accepts either widget instances (e.g., "
"``Textarea(...)``) or classes (e.g., ``Textarea``). Note that the "
"``widgets`` dictionary is ignored for a model field with a non-empty "
"``choices`` attribute. In this case, you must override the form field to use "
"a different widget."
msgstr ""
"``widgets`` 字典接受任何 widget 实例（例如 ``Textarea(...)`` ）或类（例如 "
"``Textarea``）。注意，对于具有非空 ``choices`` 属性的模型字段，``widgets`` 字"
"典会被忽略。在这个例子里，你必须覆盖表单字段来使用不同的 widget 。"

msgid ""
"Similarly, you can specify the ``labels``, ``help_texts`` and "
"``error_messages`` attributes of the inner ``Meta`` class if you want to "
"further customize a field."
msgstr ""
"同样的，如果您想进一步自定义一个字段，还可以指定内部Meta类的 ``labels`` 、 "
"``help_texts`` 和 ``error_messages`` 属性。"

msgid ""
"For example if you wanted to customize the wording of all user facing "
"strings for the ``name`` field::"
msgstr "例如您想自定义 ``name`` 字段中所有面向用户的字符文本："

msgid ""
"You can also specify ``field_classes`` to customize the type of fields "
"instantiated by the form."
msgstr "您还可以指定  ``field_classes`` 来自定义表单实例化的字段类型："

msgid ""
"For example, if you wanted to use ``MySlugFormField`` for the ``slug`` "
"field, you could do the following::"
msgstr ""
"例如，如果您想对 ``slug`` 字段使用 ``MySlugFormField`` ，您可以这样做："

msgid ""
"Finally, if you want complete control over of a field -- including its type, "
"validators, required, etc. -- you can do this by declaratively specifying "
"fields like you would in a regular ``Form``."
msgstr ""
"最后，如果您想完全控制一个字段（包括它的类型，验证，必填等等），您可以通过声"
"明指定字段来做到这一点，就像在一个普通的 ``Form`` 中那样声明。"

msgid ""
"If you want to specify a field's validators, you can do so by defining the "
"field declaratively and setting its ``validators`` parameter::"
msgstr ""
"如果您想指定一个字段的验证器，可以通过声明定义该字段并设置其 ``validators`` "
"参数来实现："

msgid ""
"When you explicitly instantiate a form field like this, it is important to "
"understand how ``ModelForm`` and regular ``Form`` are related."
msgstr ""
"当您像这样显式地实例化了一个表单字段，理解 ``ModelForm`` 和普通  ``Form`` 的"
"关系很重要。"

msgid ""
"``ModelForm`` is a regular ``Form`` which can automatically generate certain "
"fields. The fields that are automatically generated depend on the content of "
"the ``Meta`` class and on which fields have already been defined "
"declaratively. Basically, ``ModelForm`` will **only** generate fields that "
"are **missing** from the form, or in other words, fields that weren't "
"defined declaratively."
msgstr ""
"``ModelForm`` 是一个可以自动生成特定字段的 ``Form`` 。哪些字段可以自动生成取"
"决于 ``Meta`` 类的内容，以及是否已经被明确定义过。总的来说 ``ModelForm``  **"
"仅会** 自动生成表单中 **缺失** 的字段，或者说，没被明确定义的字段。"

msgid ""
"Fields defined declaratively are left as-is, therefore any customizations "
"made to ``Meta`` attributes such as ``widgets``, ``labels``, ``help_texts``, "
"or ``error_messages`` are ignored; these only apply to fields that are "
"generated automatically."
msgstr ""
"声明定义的字段会保持原样，因此，任何对 ``Meta`` 属性（例如 ``widgets`` 、 "
"``labels`` 、 ``help_texts`` 或者 ``error_messages``）的自定义设置都会被忽"
"略；它们仅适用于自动生成的字段。"

msgid ""
"Similarly, fields defined declaratively do not draw their attributes like "
"``max_length`` or ``required`` from the corresponding model. If you want to "
"maintain the behavior specified in the model, you must set the relevant "
"arguments explicitly when declaring the form field."
msgstr ""
"同样，显式定义的字段不会从对应的模型中获取他们的属性（比如 ``max_length`` 或"
"者 ``required``）。如果要保持模型中指定的行为，则必须在声明表单字段时显式设置"
"相关参数。"

msgid "For example, if the ``Article`` model looks like this::"
msgstr "例如，假设 ``Article`` 模型像下面这样："

msgid ""
"and you want to do some custom validation for ``headline``, while keeping "
"the ``blank`` and ``help_text`` values as specified, you might define "
"``ArticleForm`` like this::"
msgstr ""
"且您希望对 ``headline`` 进行自定义验证，在保留指定的 ``blank`` 和 "
"``help_text`` 值同时，您可以像这样定义 ``ArticleForm`` ："

msgid ""
"You must ensure that the type of the form field can be used to set the "
"contents of the corresponding model field. When they are not compatible, you "
"will get a ``ValueError`` as no implicit conversion takes place."
msgstr ""
"您必须确保表单字段的类型可用于设置对应模型字段的内容。如果它们不兼容，您会因"
"为没有发生隐式转换而得到一个 ``ValueError`` 。"

msgid ""
"See the :doc:`form field documentation </ref/forms/fields>` for more "
"information on fields and their arguments."
msgstr ""
"更多有关字段及其参数的内容，请参阅 :doc:`表单字段文档</ref/forms/fields>` 。"

msgid "Enabling localization of fields"
msgstr "启用对字段的本地化"

msgid ""
"By default, the fields in a ``ModelForm`` will not localize their data. To "
"enable localization for fields, you can use the ``localized_fields`` "
"attribute on the ``Meta`` class."
msgstr ""
"默认情况下， ``ModelForm`` 中的字段不会本地化他们的数据。要为字段启用本地化，"
"您可以在 ``Meta`` 类中使用 ``localized_fields`` 属性。"

msgid ""
"If ``localized_fields`` is set to the special value ``'__all__'``, all "
"fields will be localized."
msgstr ""
"如果 ``localized_fields`` 设置为特殊值 ``'__all__'`` ，则所有字段都将被本地"
"化。"

msgid "Form inheritance"
msgstr "表单继承"

msgid ""
"As with basic forms, you can extend and reuse ``ModelForms`` by inheriting "
"them. This is useful if you need to declare extra fields or extra methods on "
"a parent class for use in a number of forms derived from models. For "
"example, using the previous ``ArticleForm`` class::"
msgstr ""
"与普通表单一样，您可以通过继承它们来扩展和重用 ``ModelForms`` 。如果您需要在"
"父类中声明额外字段或额外方法以用于从模型派生的多个表单中，则此方法非常有用。"
"例如，使用之前的 ``ArticleForm`` 类。"

msgid ""
"This creates a form that behaves identically to ``ArticleForm``, except "
"there's some extra validation and cleaning for the ``pub_date`` field."
msgstr ""
"这会创建一个与 ``ArticleForm`` 行为相同的表单，除了 ``pub_date`` 字段会有一些"
"额外的验证和cleaning。"

msgid ""
"You can also subclass the parent's ``Meta`` inner class if you want to "
"change the ``Meta.fields`` or ``Meta.exclude`` lists::"
msgstr ""
"如果要更改 ``Meta.fields`` 或 ``Meta.exclude`` 列表，您也可以继承父类的内部 "
"``Meta`` 类："

msgid ""
"This adds the extra method from the ``EnhancedArticleForm`` and modifies the "
"original ``ArticleForm.Meta`` to remove one field."
msgstr ""
"这相比 ``EnhancedArticleForm`` 增加了额外方法，并修改了原始的 ``ArticleForm."
"Meta`` 以删除一个字段。"

msgid "There are a couple of things to note, however."
msgstr "然而，有几项需要注意。"

msgid ""
"Normal Python name resolution rules apply. If you have multiple base classes "
"that declare a ``Meta`` inner class, only the first one will be used. This "
"means the child's ``Meta``, if it exists, otherwise the ``Meta`` of the "
"first parent, etc."
msgstr ""
"适用于普通的Python名称解析规则。如果您有多个声明 ``Meta`` 内部类的基类，就是"
"说如果声明了子类的 ``Meta`` 就会使用它，否则就用第一个父类的 ``Meta`` 。"

msgid ""
"It's possible to inherit from both ``Form`` and ``ModelForm`` "
"simultaneously, however, you must ensure that ``ModelForm`` appears first in "
"the MRO. This is because these classes rely on different metaclasses and a "
"class can only have one metaclass."
msgstr ""
"可以同时继承 ``Form`` 和 ``ModelForm`` ，但是，您必须确保 ``ModelForm`` 在MRO"
"中出现在首位。这是因为这些类依赖于不同的元类，而一个类只能有一个元类。"

msgid ""
"It's possible to declaratively remove a ``Field`` inherited from a parent "
"class by setting the name to be ``None`` on the subclass."
msgstr ""
"通过在子类上将名称设置为 ``None`` ，可以声明性地移除从父类继承的 ``Field`` 。"

msgid ""
"You can only use this technique to opt out from a field defined "
"declaratively by a parent class; it won't prevent the ``ModelForm`` "
"metaclass from generating a default field. To opt-out from default fields, "
"see :ref:`modelforms-selecting-fields`."
msgstr ""
"您只能使用这种技术排除父类中声明定义的字段；它不会阻止 ``ModelForm`` 元类生成"
"默认字段。要排除默认字段，请参阅 :ref:`modelforms-selecting-fields` 。"

msgid "Providing initial values"
msgstr "提供初始值"

msgid ""
"As with regular forms, it's possible to specify initial data for forms by "
"specifying an ``initial`` parameter when instantiating the form. Initial "
"values provided this way will override both initial values from the form "
"field and values from an attached model instance. For example::"
msgstr ""
"与普通表单一样，可以在实例化表单时通过指定 ``initial`` 参数来指定表单的初始"
"值。以这种方式提供的初始值会覆盖表单字段的初始值以及对应模型实例的初始值。例"
"如："

msgid "ModelForm factory function"
msgstr "ModelForm的工厂函数"

msgid ""
"You can create forms from a given model using the standalone function :func:"
"`~django.forms.models.modelform_factory`, instead of using a class "
"definition. This may be more convenient if you do not have many "
"customizations to make::"
msgstr ""
"您可以不使用类定义，而是使用独立函数 :func:`~django.forms.models."
"modelform_factory` 来创建给定模型的表单。如果您没有很多自定义设置，这可能会更"
"方便："

msgid ""
"This can also be used to make modifications to existing forms, for example "
"by specifying the widgets to be used for a given field::"
msgstr "这也可以用来对已有表单进行修改，例如给字段指定使用组件："

msgid ""
"The fields to include can be specified using the ``fields`` and ``exclude`` "
"keyword arguments, or the corresponding attributes on the ``ModelForm`` "
"inner ``Meta`` class. Please see the ``ModelForm`` :ref:`modelforms-"
"selecting-fields` documentation."
msgstr ""
"要包含的字段可以使用 ``fields`` 和 ``exclude`` 关键字参数或 ``ModelForm`` 内"
"部的 ``Meta`` 类中相应的属性来指定。请参阅 ``ModelForm`` :ref:`modelforms-"
"selecting-fields` 文档。"

msgid "... or enable localization for specific fields::"
msgstr "... 或者为个别字段启用本地化功能："

msgid "Model formsets"
msgstr "模型表单集"

msgid ""
"Like :doc:`regular formsets </topics/forms/formsets>`, Django provides a "
"couple of enhanced formset classes to make working with Django models more "
"convenient. Let's reuse the ``Author`` model from above::"
msgstr ""
"和 :doc:`regular formsets </topics/forms/formsets>` 一样，Django提供了几个增"
"强的formset类，可以很方便地配合Django模型使用。让我们重用下上面的 ``Author`` "
"模型："

msgid ""
"Using ``fields`` restricts the formset to use only the given fields. "
"Alternatively, you can take an \"opt-out\" approach, specifying which fields "
"to exclude::"
msgstr ""
"使用 ``fields`` 参数限制formset仅使用给定的字段。或者，您可以使用排除法，指定"
"排除哪些字段："

msgid ""
"This will create a formset that is capable of working with the data "
"associated with the ``Author`` model. It works just like a regular formset::"
msgstr ""
"这将创建一个能够处理与 ``Author`` 模型相关数据的formset。它运行起来就像一个普"
"通的formset："

msgid ""
":func:`~django.forms.models.modelformset_factory` uses :func:`~django.forms."
"formsets.formset_factory` to generate formsets. This means that a model "
"formset is an extension of a basic formset that knows how to interact with a "
"particular model."
msgstr ""
":func:`~django.forms.models.modelformset_factory` 使用 :func:`~django.forms."
"formsets.formset_factory` 来生成表单集。这意味着模型formset是一个知道如何与指"
"定模型交互的普通formset的扩展。"

msgid ""
"When using :ref:`multi-table inheritance <multi-table-inheritance>`, forms "
"generated by a formset factory will contain a parent link field (by default "
"``<parent_model_name>_ptr``) instead of an ``id`` field."
msgstr ""
"当使用多表继承（ :ref:`multi-table inheritance <multi-table-"
"inheritance>` ），通过 formset factory 生成的表单将包含父链接字段（默认是 "
"``2_ptr`` ）而不是 ``id`` 字段。"

msgid "Changing the queryset"
msgstr "更改查询集"

msgid ""
"By default, when you create a formset from a model, the formset will use a "
"queryset that includes all objects in the model (e.g., ``Author.objects."
"all()``). You can override this behavior by using the ``queryset`` argument::"
msgstr ""
"默认情况下，当您创建一个模型ormset时，formset将使用一个包含模型中所有对象（例"
"如 ``Author.objects.all()`` ）的查询集。你可以通过使用 ``queryset`` 参数来覆"
"盖这一行为："

msgid ""
"Alternatively, you can create a subclass that sets ``self.queryset`` in "
"``__init__``::"
msgstr ""
"或者，您可以创建一个子类，然后在 ``__init__`` 中设置 ``self.queryset`` ："

msgid "Then, pass your ``BaseAuthorFormSet`` class to the factory function::"
msgstr "然后，将你的 ``BaseAuthorFormSet`` 类传递给工厂函数："

msgid ""
"If you want to return a formset that doesn't include *any* pre-existing "
"instances of the model, you can specify an empty QuerySet::"
msgstr ""
"如果您想返回一个不包含 *任何* 已存在模型实例的formset，您可以指定一个空的"
"QuerySet："

msgid "Changing the form"
msgstr "更改表单"

msgid ""
"By default, when you use ``modelformset_factory``, a model form will be "
"created using :func:`~django.forms.models.modelform_factory`. Often, it can "
"be useful to specify a custom model form. For example, you can create a "
"custom model form that has custom validation::"
msgstr ""
"默认情况下，当您使用 ``modelformset_factory`` 时，程序会用 :func:`~django."
"forms.models.modelform_factory` 创建一个模型表单。这通常在指定自定义模型表单"
"时很有用。例如，您可以创建一个具有自定义验证的自定义模型表单："

msgid "Then, pass your model form to the factory function::"
msgstr "然后，将您的模型表单传递给工厂函数："

msgid ""
"It is not always necessary to define a custom model form. The "
"``modelformset_factory`` function has several arguments which are passed "
"through to ``modelform_factory``, which are described below."
msgstr ""
"并不是总需要自定义模型表单。 ``modelformset_factory`` 函数有几个参数传递给 "
"``modelform_factory`` ，如下所述。"

msgid "Specifying widgets to use in the form with ``widgets``"
msgstr "在表单中使用 ``widgets`` 指定部件。"

msgid ""
"Using the ``widgets`` parameter, you can specify a dictionary of values to "
"customize the ``ModelForm``’s widget class for a particular field. This "
"works the same way as the ``widgets`` dictionary on the inner ``Meta`` class "
"of a ``ModelForm`` works::"
msgstr ""
"使用 ``widgets`` 参数，您可以设置一个字典值来为 ``ModelForm`` 指定字段自定义"
"部件。这与 ``ModelForm`` 内部 ``Meta`` 类中 ``widgets`` 字典的工作方式一样："

msgid "Enabling localization for fields with ``localized_fields``"
msgstr "使用 ``localized_fields`` 来启用字段本地化"

msgid ""
"Using the ``localized_fields`` parameter, you can enable localization for "
"fields in the form."
msgstr "您可以使用 ``localized_fields`` 参数为表单中的字段启用本地化。"

msgid ""
"As with regular formsets, it's possible to :ref:`specify initial data "
"<formsets-initial-data>` for forms in the formset by specifying an "
"``initial`` parameter when instantiating the model formset class returned "
"by :func:`~django.forms.models.modelformset_factory`. However, with model "
"formsets, the initial values only apply to extra forms, those that aren't "
"attached to an existing model instance. If the length of ``initial`` exceeds "
"the number of extra forms, the excess initial data is ignored. If the extra "
"forms with initial data aren't changed by the user, they won't be validated "
"or saved."
msgstr ""
"与常规表单集(formset)一样，在实例化 :func:`~django.forms.models."
"modelformset_factory` 返回的模型表单集类时，可以通过指定初始参数来指定表单集"
"中表单的初始数据。然而，对于模型表单集，初始值只适用于额外的表单，不会附加到"
"已存在的模型实例。如果  ``initial`` 的长度超过了额外表单的数量，多余的初始值"
"会被忽略。如果带有初始值的额外表单没有通过用户去改变，它们不会被验证或保存。"

msgid "Saving objects in the formset"
msgstr "在表单集中保存对象"

msgid ""
"As with a ``ModelForm``, you can save the data as a model object. This is "
"done with the formset's ``save()`` method::"
msgstr ""
"和 ``ModelForm`` 一样，你可以将数据保存为模型对象。这是通过表单集的 "
"``save()`` 方法来完成的："

msgid ""
"The ``save()`` method returns the instances that have been saved to the "
"database. If a given instance's data didn't change in the bound data, the "
"instance won't be saved to the database and won't be included in the return "
"value (``instances``, in the above example)."
msgstr ""
"``save()`` 方法返回已经保存到数据库的实例。如果一个给定实例的数据没有在绑定数"
"据中改变，那么实例不会被保存到数据库，也不会包含在返回值里（上述例子中的 "
"``instances`` ）。"

msgid ""
"When fields are missing from the form (for example because they have been "
"excluded), these fields will not be set by the ``save()`` method. You can "
"find more information about this restriction, which also holds for regular "
"``ModelForms``, in `Selecting the fields to use`_."
msgstr ""
"当表单中缺少字段时（比如因为它们被排除），这些字段不会被 ``save()`` 方法设"
"置。在选择使用字段里（ `Selecting the fields to use`_ ），你可以找到有关此限"
"制的更多信息，这也适用于的普通的 ``ModelForms`` 。"

msgid "Pass ``commit=False`` to return the unsaved model instances::"
msgstr "传递 ``commit=False``，返回未保存的模型实例："

msgid ""
"This gives you the ability to attach data to the instances before saving "
"them to the database. If your formset contains a ``ManyToManyField``, you'll "
"also need to call ``formset.save_m2m()`` to ensure the many-to-many "
"relationships are saved properly."
msgstr ""
"这会你在保存它们到数据库之前，附加数据给实例。如果你的表单集包含 "
"``ManyToManyField`` ，你也将需要调用 ``formset.save_m2m()`` 来确保正确保存了"
"多对多关系。"

msgid ""
"After calling ``save()``, your model formset will have three new attributes "
"containing the formset's changes:"
msgstr ""
"在调用 ``save()`` 之后，你的模型表单集将会有三个包含表单集更改的新属性："

msgid "Limiting the number of editable objects"
msgstr "限制可编辑对象的数量"

msgid ""
"As with regular formsets, you can use the ``max_num`` and ``extra`` "
"parameters to :func:`~django.forms.models.modelformset_factory` to limit the "
"number of extra forms displayed."
msgstr ""
"和普通表单集一样，你可以使用 ``max_num`` 和 ``extra`` 参数来 :func:`~django."
"forms.models.modelformset_factory` 来让 :func:`~django.forms.models."
"modelformset_factory` 限制显示的额外表单数量。"

msgid "``max_num`` does not prevent existing objects from being displayed::"
msgstr "``max_num`` 不会阻止显示已有对象："

msgid ""
"Also, ``extra=0`` doesn't prevent creation of new model instances as you "
"can :ref:`add additional forms with JavaScript <understanding-the-"
"managementform>` or send additional POST data. Formsets :ticket:`don't yet "
"provide functionality <26142>` for an \"edit only\" view that prevents "
"creation of new instances."
msgstr ""
"同样，``extra=0`` 不会阻止新模型实例的创建，因为你可以使用 JavaScript 来添加"
"额外的表单或发送额外的POST数据。表单集还没有为“仅编辑”视图提供阻止创建新实例"
"的功能。"

msgid ""
"If the value of ``max_num`` is greater than the number of existing related "
"objects, up to ``extra`` additional blank forms will be added to the "
"formset, so long as the total number of forms does not exceed ``max_num``::"
msgstr ""
"如果 ``max_num`` 的值大于现有关联对象的数量，只要总表单数不超过 "
"``max_num`` ，就会在表格集中添加额外的空白表单："

msgid "Using a model formset in a view"
msgstr "在视图中使用模型表单集"

msgid ""
"Model formsets are very similar to formsets. Let's say we want to present a "
"formset to edit ``Author`` model instances::"
msgstr ""
"模型表单集与表单集非常相似。假设我们想要一个表单集来编辑 ``Author`` 模型实"
"例："

msgid ""
"As you can see, the view logic of a model formset isn't drastically "
"different than that of a \"normal\" formset. The only difference is that we "
"call ``formset.save()`` to save the data into the database. (This was "
"described above, in :ref:`saving-objects-in-the-formset`.)"
msgstr ""
"像你看到的那样，模型表单集的视图逻辑与普通的表单集并没有太大的不同。唯一的不"
"同是我们调用 ``formset.save()`` 来保存数据到数据库里。（这已在上面的 :ref:"
"`saving-objects-in-the-formset` 中描述。）"

msgid "Overriding ``clean()`` on a ``ModelFormSet``"
msgstr "覆盖 ``ModelFormSet`` 上的 ``clean()``"

msgid ""
"Just like with ``ModelForms``, by default the ``clean()`` method of a "
"``ModelFormSet`` will validate that none of the items in the formset violate "
"the unique constraints on your model (either ``unique``, ``unique_together`` "
"or ``unique_for_date|month|year``).  If you want to override the ``clean()`` "
"method on a ``ModelFormSet`` and maintain this validation, you must call the "
"parent class's ``clean`` method::"
msgstr ""
"就像 ``ModelForms`` 一样，默认情况下，``ModelFormSet`` 的 ``clean()`` 方法将"
"验证表单集中没有任何项目违反模型的唯一约束（ ``unique``, ``unique_together`` "
"或 ``unique_for_date|month|year`` ）。如果你想覆盖 ``ModelFormSet`` 上的 "
"``clean()`` 方法并保持这个验证，那么你必须调用父类的 ``clean`` 方法："

msgid ""
"Also note that by the time you reach this step, individual model instances "
"have already been created for each ``Form``. Modifying a value in ``form."
"cleaned_data`` is not sufficient to affect the saved value. If you wish to "
"modify a value in ``ModelFormSet.clean()`` you must modify ``form."
"instance``::"
msgstr ""
"还要注意的是，到达此步时，已经为每个表单创建了独立模型实例。在 ``form."
"cleaned_data`` 里修改值不足以影响已保存的值。如果你想在 ``ModelFormSet."
"clean()`` 中修改值，你必须修改 ``form.instance`` ："

msgid "Using a custom queryset"
msgstr "使用自定义查询结果集"

msgid ""
"As stated earlier, you can override the default queryset used by the model "
"formset::"
msgstr "如前所述，你可以覆盖模型表单集使用的默认查询集："

msgid ""
"Note that we pass the ``queryset`` argument in both the ``POST`` and ``GET`` "
"cases in this example."
msgstr ""
"注意我们在这个例子里的 ``POST`` and ``GET`` 情况下传递了 ``queryset`` 参数。"

msgid "Using the formset in the template"
msgstr "在模板中使用表单集"

msgid "There are three ways to render a formset in a Django template."
msgstr "有三种办法在 Django 模板中渲染表单集。"

msgid "First, you can let the formset do most of the work::"
msgstr "首先，你可以让表单集完成大部分工作："

msgid ""
"Second, you can manually render the formset, but let the form deal with "
"itself::"
msgstr "其次，你可以手工渲染表单集，但需要让表单自己处理："

msgid ""
"When you manually render the forms yourself, be sure to render the "
"management form as shown above. See the :ref:`management form documentation "
"<understanding-the-managementform>`."
msgstr ""
"当你手工渲染表单时，确保渲染了如上所述的管理表单。请查看文档的“管理”部分 （:"
"ref:`management form documentation <understanding-the-managementform>` ）"

msgid "Third, you can manually render each field::"
msgstr "第三，你可以手工渲染每个字段："

msgid ""
"If you opt to use this third method and you don't iterate over the fields "
"with a ``{% for %}`` loop, you'll need to render the primary key field. For "
"example, if you were rendering the ``name`` and ``age`` fields of a model::"
msgstr ""
"如果你选择使用第三种办法，并且你不使用 ``{% for %}`` 循环遍历字段，那么你需要"
"渲染主键字段。比如，如果你要渲染  ``name`` 和 ``age`` 字段："

msgid ""
"Notice how we need to explicitly render ``{{ form.id }}``. This ensures that "
"the model formset, in the ``POST`` case, will work correctly. (This example "
"assumes a primary key named ``id``. If you've explicitly defined your own "
"primary key that isn't called ``id``, make sure it gets rendered.)"
msgstr ""
"注意我们需要显式地渲染 ``{{ form.id }}`` 。这将确保在 ``POST`` 情况下，模型表"
"单集正确工作。（这个例子假设主键名是 ``id`` 。如果你已经显式定义了不是名为 "
"``id`` 的主键，那你需要确保它正确地渲染。）"

msgid "Inline formsets"
msgstr "内联表单集"

msgid ""
"Inline formsets is a small abstraction layer on top of model formsets. These "
"simplify the case of working with related objects via a foreign key. Suppose "
"you have these two models::"
msgstr ""
"内联表单集是在模型表单集上一个很小的抽象层。这些表单集通过外键简化了处理相关"
"对象的情况。假设你有两个模型："

msgid ""
"If you want to create a formset that allows you to edit books belonging to a "
"particular author, you could do this::"
msgstr "如果你想创建一个允许你编辑属于特定作者的书籍的表单集，你可以这样做："

msgid ""
"``BookFormSet``'s :ref:`prefix <formset-prefix>` is ``'book_set'`` (``<model "
"name>_set`` ). If ``Book``'s ``ForeignKey`` to ``Author`` has a :attr:"
"`~django.db.models.ForeignKey.related_name`, that's used instead."
msgstr ""
"``BookFormSet``'s :ref:`prefix <formset-prefix>` is ``'book_set'`` (``<model "
"name>_set`` ). 如果 ``Book`` 的 指向 ``Author`` 的 ``ForeignKey`` 有一个 :"
"attr:`~django.db.models.ForeignKey.related_name` ，则使用它。"

msgid ""
":func:`~django.forms.models.inlineformset_factory` uses :func:`~django.forms."
"models.modelformset_factory` and marks ``can_delete=True``."
msgstr ""
":func:`~django.forms.models.inlineformset_factory` 使用 :func:`~django.forms."
"models.modelformset_factory` 并标记 ``can_delete=True`` 。"

msgid ""
":ref:`Manually rendered can_delete and can_order <manually-rendered-can-"
"delete-and-can-order>`."
msgstr ""
"手动渲染 can_delete 和 can_order 。（ :ref:`Manually rendered can_delete and "
"can_order <manually-rendered-can-delete-and-can-order>` ）"

msgid "Overriding methods on an ``InlineFormSet``"
msgstr "覆盖 ``InlineFormSet`` 上的方法"

msgid ""
"When overriding methods on ``InlineFormSet``, you should subclass :class:"
"`~models.BaseInlineFormSet` rather than :class:`~models.BaseModelFormSet`."
msgstr ""
"当覆盖 ``InlineFormSet`` 上的方法时，你可以继承 :class:`~models."
"BaseInlineFormSet` 而不是 :class:`~models.BaseModelFormSet` 。"

msgid "For example, if you want to override ``clean()``::"
msgstr "比如，如果你想覆盖 ``clean()`` ："

msgid "See also :ref:`model-formsets-overriding-clean`."
msgstr "也可以看 :ref:`model-formsets-overriding-clean` 。"

msgid ""
"Then when you create your inline formset, pass in the optional argument "
"``formset``::"
msgstr "然后当你创建自定义的内联表单集时，要传递一个可选参数 ``formset`` ："

msgid "More than one foreign key to the same model"
msgstr "同一个模型有多个外键"

msgid ""
"If your model contains more than one foreign key to the same model, you'll "
"need to resolve the ambiguity manually using ``fk_name``. For example, "
"consider the following model::"
msgstr ""
"如果你的模型包含多个外键，你需要解决使用 ``fk_name`` 来解决歧义。比如下面的模"
"型："

msgid ""
"To resolve this, you can use ``fk_name`` to :func:`~django.forms.models."
"inlineformset_factory`::"
msgstr ""
"为了解决这个问题，你可以将 ``fk_name`` 用于 :func:`~django.forms.models."
"inlineformset_factory`: ："

msgid "Using an inline formset in a view"
msgstr "在视图中使用内联表单集"

msgid ""
"You may want to provide a view that allows a user to edit the related "
"objects of a model. Here's how you can do that::"
msgstr "你可以提供一个视图来允许用户编辑模型的相关对象。这里是相关做法："

msgid "Notice how we pass ``instance`` in both the ``POST`` and ``GET`` cases."
msgstr "请注意我们如何将 ``instance`` 传递给 ``POST`` 和 ``GET`` 的。"

msgid "Specifying widgets to use in the inline form"
msgstr "指定要在内联表单中使用的 widgets"

msgid ""
"``inlineformset_factory`` uses ``modelformset_factory`` and passes most of "
"its arguments to ``modelformset_factory``. This means you can use the "
"``widgets`` parameter in much the same way as passing it to "
"``modelformset_factory``. See `Specifying widgets to use in the form with "
"widgets`_ above."
msgstr ""
"``inlineformset_factory`` 使用 ``modelformset_factory``，并传递大部分参数给  "
"``modelformset_factory`` 。这意味着你可以使用 ``widgets`` 参数，就像将它传递"
"给 ``modelformset_factory`` 一样。请查看 `Specifying widgets to use in the "
"form with widgets`_ 。"

msgid "View decorators"
msgstr "视图装饰器"

msgid ""
"Django provides several decorators that can be applied to views to support "
"various HTTP features."
msgstr "Django 提供很多装饰器，它们可以为视图支持多种 HTTP 特性。"

msgid ""
"See :ref:`decorating-class-based-views` for how to use these decorators with "
"class-based views."
msgstr ""
"查看 :ref:`decorating-class-based-views` 来了解如何在基于类的视图中使用这些装"
"饰器。"

msgid "Allowed HTTP methods"
msgstr "允许的 HTTP 方法"

msgid ""
"The decorators in :mod:`django.views.decorators.http` can be used to "
"restrict access to views based on the request method. These decorators will "
"return a :class:`django.http.HttpResponseNotAllowed` if the conditions are "
"not met."
msgstr ""
"在 :mod:`django.views.decorators.http` 中的装饰器可以用来根据请求方法来限制对"
"视图的访问。如果条件不满足，这些装饰器将返回 :class:`django.http."
"HttpResponseNotAllowed` 。"

msgid ""
"Decorator to require that a view only accepts particular request methods. "
"Usage::"
msgstr "装饰器可以要求视图只接受特定的请求方法。用法如下："

msgid "Note that request methods should be in uppercase."
msgstr "注意请求方法应该是大写。"

msgid "Decorator to require that a view only accepts the GET method."
msgstr "装饰器可以要求视图只接受 GET 方法。用法如下："

msgid "Decorator to require that a view only accepts the POST method."
msgstr "装饰器可以要求视图只接受 POST 方法。用法如下："

msgid ""
"Decorator to require that a view only accepts the GET and HEAD methods. "
"These methods are commonly considered \"safe\" because they should not have "
"the significance of taking an action other than retrieving the requested "
"resource."
msgstr ""
"装饰器可以要求视图只接收 GET 和 HEAD 方法。这些方法通常被认为是安全的，因为它"
"们除了检索请求的资源外，没有特别的操作。"

msgid ""
"Web servers should automatically strip the content of responses to HEAD "
"requests while leaving the headers unchanged, so you may handle HEAD "
"requests exactly like GET requests in your views. Since some software, such "
"as link checkers, rely on HEAD requests, you might prefer using "
"``require_safe`` instead of ``require_GET``."
msgstr ""
"Web 服务器自动删除对 HEAD 请求的相应内容，并保持头部不变，所以你可以像处理视"
"图里的 GET 请求一样处理 HEAD 请求。因为一些软件依赖 HEAD 请求（比如链接检测"
"器），因此你需要使用 ``require_safe`` 而不是 ``require_GET`` 。"

msgid "Conditional view processing"
msgstr "条件视图处理"

msgid ""
"The following decorators in :mod:`django.views.decorators.http` can be used "
"to control caching behavior on particular views."
msgstr ""
"下面 :mod:`django.views.decorators.http` 的装饰器被用来控制特殊视图中的缓存行"
"为。"

msgid ""
"These decorators can be used to generate ``ETag`` and ``Last-Modified`` "
"headers; see :doc:`conditional view processing </topics/conditional-view-"
"processing>`."
msgstr ""
"这些装饰器被用来生成 ``ETag`` 和 ``Last-Modified`` 头部；查看 :doc:"
"`conditional view processing </topics/conditional-view-processing>` 。"

msgid "GZip compression"
msgstr "GZip 压缩"

msgid ""
"The decorators in :mod:`django.views.decorators.gzip` control content "
"compression on a per-view basis."
msgstr ""
":mod:`django.views.decorators.gzip` 里的装饰器控制基于每个视图的内容压缩。"

msgid ""
"This decorator compresses content if the browser allows gzip compression. It "
"sets the ``Vary`` header accordingly, so that caches will base their storage "
"on the ``Accept-Encoding`` header."
msgstr ""
"如果浏览器允许 gzip 压缩，那么这个装饰器将压缩内容。它相应的设置了 ``Vary`` "
"头部，这样缓存将基于 ``Accept-Encoding`` 头进行存储。"

msgid "Vary headers"
msgstr "Vary 头"

msgid ""
"The decorators in :mod:`django.views.decorators.vary` can be used to control "
"caching based on specific request headers."
msgstr ""
":mod:`django.views.decorators.vary` 里的装饰器被用来根据特殊请求头的缓存控"
"制。"

msgid ""
"The ``Vary`` header defines which request headers a cache mechanism should "
"take into account when building its cache key."
msgstr "``Vary`` 头定义了缓存机制在构建其缓存密钥时应该考虑哪些请求报头。"

msgid "See :ref:`using vary headers <using-vary-headers>`."
msgstr "查看 :ref:`using vary headers <using-vary-headers>` 。"

msgid "Caching"
msgstr "缓存"

msgid ""
"The decorators in :mod:`django.views.decorators.cache` control server and "
"client-side caching."
msgstr ""
":mod:`django.views.decorators.cache` 中的装饰器控制服务器及客户端的缓存。"

msgid ""
"This decorator patches the response's ``Cache-Control`` header by adding all "
"of the keyword arguments to it. See :func:`~django.utils.cache."
"patch_cache_control` for the details of the transformation."
msgstr ""
"这个装饰器通过添加所有关键字参数来修补响应的 ``Cache-Control`` 头。查看 :"
"func:`~django.utils.cache.patch_cache_control` 来了解转换的详情。"

msgid "This decorator adds an ``Expires`` header to the current date/time."
msgstr ""

msgid ""
"This decorator adds a ``Cache-Control: max-age=0, no-cache, no-store, must-"
"revalidate, private`` header to a response to indicate that a page should "
"never be cached."
msgstr ""
"这个装饰器添加 ``Cache-Control: max-age=0, no-cache, no-store, must-"
"revalidate`` 头到一个响应来标识禁止缓存该页面。"

msgid "Each header is only added if it isn't already set."
msgstr "每个头只有在还没有设置的情况下才会被添加。"

msgid "Common"
msgstr ""

msgid ""
"The decorators in :mod:`django.views.decorators.common` allow per-view "
"customization of :class:`~django.middleware.common.CommonMiddleware` "
"behavior."
msgstr ""

msgid ""
"This decorator allows individual views to be excluded from :setting:"
"`APPEND_SLASH` URL normalization."
msgstr ""

msgid "File Uploads"
msgstr "文件上传"

msgid ""
"When Django handles a file upload, the file data ends up placed in :attr:"
"`request.FILES <django.http.HttpRequest.FILES>` (for more on the ``request`` "
"object see the documentation for :doc:`request and response objects </ref/"
"request-response>`). This document explains how files are stored on disk and "
"in memory, and how to customize the default behavior."
msgstr ""
"当 Django 处理文件上传时，文件数据最终会被放置在 :attr:`request.FILES "
"<django.http.HttpRequest.FILES>` （关于 ``request`` 对象的更多信息，请参见 :"
"doc:`request 和 response 对象 </ref/request-response>` 的文档）。本文档解释了"
"文件如何存储在磁盘和内存中，以及如何自定义默认行为。"

msgid ""
"There are security risks if you are accepting uploaded content from "
"untrusted users! See the security guide's topic on :ref:`user-uploaded-"
"content-security` for mitigation details."
msgstr ""
"如果接收不受信任的用户的上传会有安全隐患， 请阅读 :ref:`user-uploaded-"
"content-security` 获取详情。"

msgid "Basic file uploads"
msgstr "简单文件上传"

msgid "Consider a form containing a :class:`~django.forms.FileField`:"
msgstr "考虑一个包含 :class:`~django.forms.FileField` 的表单："

msgid ""
"A view handling this form will receive the file data in :attr:`request.FILES "
"<django.http.HttpRequest.FILES>`, which is a dictionary containing a key for "
"each :class:`~django.forms.FileField` (or :class:`~django.forms.ImageField`, "
"or other :class:`~django.forms.FileField` subclass) in the form. So the data "
"from the above form would be accessible as ``request.FILES['file']``."
msgstr ""
"处理这个表单的视图将在 :attr:`request.FILES <django.http.HttpRequest.FILES>` "
"中接收文件数据，它是一个字典，包含表单中每个 :class:`~django.forms."
"FileField` （或 :class:`~django.forms.ImageField`，或其他 :class:`~django."
"forms.FileField` 子类）的键。所以上述表单中的数据将以 ``request."
"FILES['file']`` 的形式被访问。"

msgid ""
"Note that :attr:`request.FILES <django.http.HttpRequest.FILES>` will only "
"contain data if the request method was ``POST``, at least one file field was "
"actually posted, and the ``<form>`` that posted the request has the "
"attribute ``enctype=\"multipart/form-data\"``. Otherwise, ``request.FILES`` "
"will be empty."
msgstr ""
"注意 :attr:`request.FILES <django.http.HttpRequest.FILES>` 只有当请求方法是 "
"``POST``，至少有一个文件字段被实际发布，并且发布请求的 ``<form>`` 有 "
"``enctype=\"multipart/form-data\"`` 属性时，才会包含数据。否则 ``request."
"FILES`` 将为空。"

msgid ""
"Most of the time, you'll pass the file data from ``request`` into the form "
"as described in :ref:`binding-uploaded-files`. This would look something "
"like:"
msgstr ""
"大多数情况下，你需要像 :ref:`binding-uploaded-files` 里描述的那样将文件数据"
"从 ``request`` 传递给表单。示例如下："

msgid ""
"Notice that we have to pass :attr:`request.FILES <django.http.HttpRequest."
"FILES>` into the form's constructor; this is how file data gets bound into a "
"form."
msgstr ""
"注意我们必须将 :attr:`request.FILES <django.http.HttpRequest.FILES>` 传入到表"
"单的\n"
"构造方法中，只有这样文件数据才能绑定到表单中。"

msgid "Here's a common way you might handle an uploaded file::"
msgstr "我们通常可能像这样处理上传文件："

msgid ""
"Looping over ``UploadedFile.chunks()`` instead of using ``read()`` ensures "
"that large files don't overwhelm your system's memory."
msgstr ""
"使用 ``UploadedFile.chunks()`` 而不是 ``read()`` 是为了确保即使是大文件又不会"
"将我们系统的内存占满。"

msgid ""
"There are a few other methods and attributes available on ``UploadedFile`` "
"objects; see :class:`UploadedFile` for a complete reference."
msgstr ""
" ``UploadedFile`` 对象还有一些其他可用的方法和属性，完整参考请阅读 :class:"
"`UploadedFile`  。"

msgid "Handling uploaded files with a model"
msgstr "通过模型来处理上传的文件"

msgid ""
"If you're saving a file on a :class:`~django.db.models.Model` with a :class:"
"`~django.db.models.FileField`, using a :class:`~django.forms.ModelForm` "
"makes this process much easier. The file object will be saved to the "
"location specified by the :attr:`~django.db.models.FileField.upload_to` "
"argument of the corresponding :class:`~django.db.models.FileField` when "
"calling ``form.save()``::"
msgstr ""
"如果想要在 :class:`~django.db.models.FileField` 上的 :class:`~django.db."
"models.Model` 保存文件，使用 :class:`~django.forms.ModelForm` 会让这一过程变"
"得简单。当调用 ``form.save()`` 时，文件对象将会被保存在对相应 :class:"
"`~django.db.models.FileField` 的 :attr:`~django.db.models.FileField."
"upload_to` 参数所指定的地方："

msgid ""
"If you are constructing an object manually, you can assign the file object "
"from :attr:`request.FILES <django.http.HttpRequest.FILES>` to the file field "
"in the model::"
msgstr ""
"如果你准备手工构建对象，你可以指定来自 :attr:`request.FILES <django.http."
"HttpRequest.FILES>` 的文件对象到模型里的文件对象："

msgid ""
"If you are constructing an object manually outside of a request, you can "
"assign a :class:`~django.core.files.File` like object to the :class:`~django."
"db.models.FileField`::"
msgstr ""

msgid "Uploading multiple files"
msgstr "上传多个文件"

msgid ""
"If you want to upload multiple files using one form field, set the "
"``multiple`` HTML attribute of field's widget:"
msgstr ""
"如果你想使用一个表单字段上传多个文件，则需要设置字段的 widget 的 "
"``multiple`` HTML 属性。"

msgid ""
"Then override the ``post`` method of your :class:`~django.views.generic.edit."
"FormView` subclass to handle multiple file uploads:"
msgstr ""
"然后覆盖 :class:`~django.views.generic.edit.FormView` 子类的 ``post`` 方法来"
"控制多个文件上传："

msgid "Upload Handlers"
msgstr "上传 Handlers"

msgid ""
"When a user uploads a file, Django passes off the file data to an *upload "
"handler* -- a small class that handles file data as it gets uploaded. Upload "
"handlers are initially defined in the :setting:`FILE_UPLOAD_HANDLERS` "
"setting, which defaults to::"
msgstr ""
"当一个用户上传文件时，Django 会把文件数据传递给 *upload handler* —— 这是一个"
"很小的类，它用来在上传时处理文件数据。上传处理模块最初定义在 :setting:"
"`FILE_UPLOAD_HANDLERS` 里，默认为："

msgid ""
"Together :class:`MemoryFileUploadHandler` and :class:"
"`TemporaryFileUploadHandler` provide Django's default file upload behavior "
"of reading small files into memory and large ones onto disk."
msgstr ""
":class:`MemoryFileUploadHandler` 和 :class:`TemporaryFileUploadHandler` 提供 "
"Django 默认文件上传行为，小文件读入内存，大文件存在磁盘上。"

msgid ""
"You can write custom handlers that customize how Django handles files. You "
"could, for example, use custom handlers to enforce user-level quotas, "
"compress data on the fly, render progress bars, and even send data to "
"another storage location directly without storing it locally. See :ref:"
"`custom_upload_handlers` for details on how you can customize or completely "
"replace upload behavior."
msgstr ""
"你可以编写自定义的 handlers 来自定义 Django 如何处理文件。比如，你可以使用自"
"定义的 handlers 来强制处理用户层面的配额，动态压缩数据，渲染进度条，甚至可以"
"将数据发送到其他存储地址而不是本地。查看 :ref:`custom_upload_handlers` 来了解"
"你如何自定义或者完全替换上传行为。"

msgid "Where uploaded data is stored"
msgstr "上传数据的存储"

msgid "Before you save uploaded files, the data needs to be stored somewhere."
msgstr "在保存上传的文件之前，数据需要保存到某处。"

msgid ""
"By default, if an uploaded file is smaller than 2.5 megabytes, Django will "
"hold the entire contents of the upload in memory. This means that saving the "
"file involves only a read from memory and a write to disk and thus is very "
"fast."
msgstr ""
"默认情况下，如果上传的文件小于2.5兆，Django 将把文件的所有内容保存到内存里。"
"这意味着保存文件只涉及从内存中读取和写入磁盘，因此这很快。"

msgid ""
"However, if an uploaded file is too large, Django will write the uploaded "
"file to a temporary file stored in your system's temporary directory. On a "
"Unix-like platform this means you can expect Django to generate a file "
"called something like ``/tmp/tmpzfp6I6.upload``. If an upload is large "
"enough, you can watch this file grow in size as Django streams the data onto "
"disk."
msgstr ""
"但如果上传的文件很大，Django 会把文件写入系统临时目录的临时文件里存储。在类 "
"Unix 平台里这意味着 Django 会生成一个类似名为 ``/tmp/tmpzfp6I6.upload`` 的文"
"件。如果上传的文件非常大，你可以查看这个文件的大小增长，因为 Django 将数据流"
"式传输到磁盘上。"

msgid ""
"These specifics -- 2.5 megabytes; ``/tmp``; etc. -- are \"reasonable defaults"
"\" which can be customized as described in the next section."
msgstr ""
"2.5 megabytes; ``/tmp``; 等这些细节只是合理的默认值，在下一节要介绍它们如何被"
"自定义。"

msgid "Changing upload handler behavior"
msgstr "改变上传处理行为"

msgid ""
"There are a few settings which control Django's file upload behavior. See :"
"ref:`File Upload Settings <file-upload-settings>` for details."
msgstr ""
"这里有一些控制 Django 文件上传行为的配置，请查看 :ref:`File Upload Settings "
"<file-upload-settings>` 。"

msgid "Modifying upload handlers on the fly"
msgstr "动态修改上传处理程序"

msgid ""
"Sometimes particular views require different upload behavior. In these "
"cases, you can override upload handlers on a per-request basis by modifying "
"``request.upload_handlers``. By default, this list will contain the upload "
"handlers given by :setting:`FILE_UPLOAD_HANDLERS`, but you can modify the "
"list as you would any other list."
msgstr ""
"有时候某些视图需要不同的上传行为。在这些例子里，你可以基于每个请求覆盖上传处"
"理程序。默认情况下，这个列表将包含由 :setting:`FILE_UPLOAD_HANDLERS` 设置的上"
"传处理程序，但你可以像修改其他列表一样修改这个列表。"

msgid ""
"For instance, suppose you've written a ``ProgressBarUploadHandler`` that "
"provides feedback on upload progress to some sort of AJAX widget. You'd add "
"this handler to your upload handlers like this::"
msgstr ""
"比如，假设你正在编写 ``ProgressBarUploadHandler`` ，来提供在上传过程中的反馈"
"给 Ajax widget。你需要添加这个处理程序到你的上传处理模块："

msgid ""
"You'd probably want to use ``list.insert()`` in this case (instead of "
"``append()``) because a progress bar handler would need to run *before* any "
"other handlers. Remember, the upload handlers are processed in order."
msgstr ""
"你或许想在这里使用 ``list.insert()`` （而不是 ``append()`` ），因为进度条处理"
"程序需要在其他处理程序之前使用。记住，上传处理程序是按顺序处理的。"

msgid ""
"If you want to replace the upload handlers completely, you can assign a new "
"list::"
msgstr "如果你想完全替换上传处理程序，你需要指定新列表："

msgid ""
"You can only modify upload handlers *before* accessing ``request.POST`` or "
"``request.FILES`` -- it doesn't make sense to change upload handlers after "
"upload handling has already started. If you try to modify ``request."
"upload_handlers`` after reading from ``request.POST`` or ``request.FILES`` "
"Django will throw an error."
msgstr ""
"你只能在访问 ``request.POST`` 或 ``request.FILES`` 之前修改上传处理程序，开始"
"上传处理后修改上传处理程序没有意义。如果你从读取 ``request.POST`` 或 "
"``request.FILES`` 之后尝试修改 ``request.upload_handlers`` ，Django 会报错。"

msgid ""
"Thus, you should always modify uploading handlers as early in your view as "
"possible."
msgstr "因此，你要尽早在视图里修改上传处理程序。"

msgid ""
"Also, ``request.POST`` is accessed by :class:`~django.middleware.csrf."
"CsrfViewMiddleware` which is enabled by default. This means you will need to "
"use :func:`~django.views.decorators.csrf.csrf_exempt` on your view to allow "
"you to change the upload handlers.  You will then need to use :func:`~django."
"views.decorators.csrf.csrf_protect` on the function that actually processes "
"the request.  Note that this means that the handlers may start receiving the "
"file upload before the CSRF checks have been done. Example code::"
msgstr ""
"而且， ``request.POST`` 由 :class:`~django.middleware.csrf."
"CsrfViewMiddleware` 访问，默认情况下已开启。这意味着你需要在视图上使用 :func:"
"`~django.views.decorators.csrf.csrf_exempt` 来允许你改变上传处理程序。然后你"
"需要在实际处理请求的函数上使用 :func:`~django.views.decorators.csrf."
"csrf_protect` 。注意这可能会让处理程序在 CSRF 检测完成之前开始接受文件上传。"
"示例："

msgid ""
"If you are using a class-based view, you will need to use :func:`~django."
"views.decorators.csrf.csrf_exempt` on its :meth:`~django.views.generic.base."
"View.dispatch` method and :func:`~django.views.decorators.csrf.csrf_protect` "
"on the method that actually processes the request. Example code::"
msgstr ""
"如果你使用的是基于类的视图，你需要在其 :meth:`~django.view.decorators.csrf."
"csrf_exempt` 方法上使用 :func:`~django.view.generic.base.View.dispatch`，并在"
"实际处理请求的方法上使用 :func:`~django.view.decorators.csrf.csrf_protect`。"
"示例代码："

msgid "Generic views"
msgstr "通用视图"

msgid "See :doc:`/ref/class-based-views/index`."
msgstr "参考 :doc:`/ref/class-based-views/index`。"

msgid "Handling HTTP requests"
msgstr "处理 HTTP 请求"

msgid "Information on handling HTTP requests in Django:"
msgstr "Django 中处理 HTTP 请求的信息："

msgid "Middleware"
msgstr "中间件"

msgid ""
"Middleware is a framework of hooks into Django's request/response "
"processing. It's a light, low-level \"plugin\" system for globally altering "
"Django's input or output."
msgstr ""
"中间件是 Django 请求/响应处理的钩子框架。它是一个轻量级的、低级的“插件”系统，"
"用于全局改变 Django 的输入或输出。"

msgid ""
"Each middleware component is responsible for doing some specific function. "
"For example, Django includes a middleware component, :class:`~django.contrib."
"auth.middleware.AuthenticationMiddleware`, that associates users with "
"requests using sessions."
msgstr ""
"每个中间件组件负责做一些特定的功能。例如，Django 包含一个中间件组件 :class:"
"`~django.contrib.auth.middleware.AuthenticationMiddleware`，它使用会话将用户"
"与请求关联起来。"

msgid ""
"This document explains how middleware works, how you activate middleware, "
"and how to write your own middleware. Django ships with some built-in "
"middleware you can use right out of the box. They're documented in the :doc:"
"`built-in middleware reference </ref/middleware>`."
msgstr ""
"他的文档解释了中间件是如何工作的，如何激活中间件，以及如何编写自己的中间件。"
"Django 具有一些内置的中间件，你可以直接使用。它们被记录在 :doc:`built-in "
"middleware reference </ref/middleware>` 中。"

msgid "Writing your own middleware"
msgstr "编写自己的中间件"

msgid ""
"A middleware factory is a callable that takes a ``get_response`` callable "
"and returns a middleware. A middleware is a callable that takes a request "
"and returns a response, just like a view."
msgstr ""
"中间件工厂是一个可调用的程序，它接受 ``get_response`` 可调用并返回中间件。中"
"间件是可调用的，它接受请求并返回响应，就像视图一样。"

msgid "A middleware can be written as a function that looks like this::"
msgstr "中间件可以被写成这样的函数："

msgid ""
"Or it can be written as a class whose instances are callable, like this::"
msgstr "或者它可以写成一个类，它的实例是可调用的，如下："

msgid ""
"The ``get_response`` callable provided by Django might be the actual view "
"(if this is the last listed middleware) or it might be the next middleware "
"in the chain. The current middleware doesn't need to know or care what "
"exactly it is, just that it represents whatever comes next."
msgstr ""
"Django 提供的 ``get_response`` 响应可能是实际视图（如果这是最后列出的中间"
"件），或者它可能是链中的下一个中间件。不需要知道或关心当前的中间件到底是什"
"么，它只是代表了下一步的内容。"

msgid ""
"The above is a slight simplification -- the ``get_response`` callable for "
"the last middleware in the chain won't be the actual view but rather a "
"wrapper method from the handler which takes care of applying :ref:`view "
"middleware <view-middleware>`, calling the view with appropriate URL "
"arguments, and applying :ref:`template-response <template-response-"
"middleware>` and :ref:`exception <exception-middleware>` middleware."
msgstr ""
"以上是一个轻微的简化——链中最后一个中间件调用的 ``get_response`` 可不是实际视"
"图，而是处理程序的包装方法，它负责应用 :ref:`view middleware <view-"
"middleware>`，调用具有适当URL参数的视图，并应用 :ref:`template-response "
"<template-response-middleware>` 和 :ref:`exception <exception-middleware>` 中"
"间件。"

msgid ""
"Middleware can either support only synchronous Python (the default), only "
"asynchronous Python, or both. See :ref:`async-middleware` for details of how "
"to advertise what you support, and know what kind of request you are getting."
msgstr ""
"中间件可以只支持同步Python(默认)，或异步Python，或者二者都支持。查看 :ref:"
"`async-middleware` 来了解如何通知你支持的是什么以及如何知道你是哪种请求。"

msgid "Middleware can live anywhere on your Python path."
msgstr "中间件可以放在 Python 路径上的任何地方。"

msgid "``__init__(get_response)``"
msgstr "``__init__(get_response)``"

msgid ""
"Middleware factories must accept a ``get_response`` argument. You can also "
"initialize some global state for the middleware. Keep in mind a couple of "
"caveats:"
msgstr ""
"中间件工厂必须接受 ``get_response`` 参数。还可以初始化中间件的一些全局状态。"
"记住两个注意事项："

msgid ""
"Django initializes your middleware with only the ``get_response`` argument, "
"so you can't define ``__init__()`` as requiring any other arguments."
msgstr ""
"Django仅用 ``get_response`` 参数初始化您的中间件，因此不能定义 "
"``__init__()`` ，因为需要其他参数。"

msgid ""
"Unlike the ``__call__()`` method which is called once per request, "
"``__init__()`` is called only *once*, when the web server starts."
msgstr ""

msgid "Marking middleware as unused"
msgstr "标记未使用的中间件"

msgid ""
"It's sometimes useful to determine at startup time whether a piece of "
"middleware should be used. In these cases, your middleware's ``__init__()`` "
"method may raise :exc:`~django.core.exceptions.MiddlewareNotUsed`. Django "
"will then remove that middleware from the middleware process and log a debug "
"message to the :ref:`django-request-logger` logger when :setting:`DEBUG` is "
"``True``."
msgstr ""
"在启动时确定是否应该使用一个中间件有时是有用的。在这些情况下，您的中间件的 "
"``__init__()`` 方法可能会引发 :exc:`~django.core.exceptions."
"MiddlewareNotUsed`。Django 将从中间件进程中删除该中间件，并将调试消息记录到 :"
"ref:`django-request-logger` 日志：设置 :setting:`DEBUG` 为 ``True``。"

msgid "Activating middleware"
msgstr "激活中间件"

msgid ""
"To activate a middleware component, add it to the :setting:`MIDDLEWARE` list "
"in your Django settings."
msgstr ""
"若要激活中间件组件，请将其添加到 Django 设置中的 :setting:`MIDDLEWARE` 列表"
"中。"

msgid ""
"In :setting:`MIDDLEWARE`, each middleware component is represented by a "
"string: the full Python path to the middleware factory's class or function "
"name. For example, here's the default value created by :djadmin:`django-"
"admin startproject <startproject>`::"
msgstr ""
"在 :setting:`MIDDLEWARE` 中，每个中间件组件由字符串表示：指向中间件工厂的类或"
"函数名的完整 Python 路径。例如，这里创建的默认值是 :djadmin:`django-admin "
"startproject <startproject>`："

msgid ""
"A Django installation doesn't require any middleware — :setting:`MIDDLEWARE` "
"can be empty, if you'd like — but it's strongly suggested that you at least "
"use :class:`~django.middleware.common.CommonMiddleware`."
msgstr ""
"Django 安装不需要任何中间件——如果您愿意的话，:setting:`MIDDLEWARE` 可以为空——"
"但是强烈建议您至少使用 :class:`~django.middleware.common.CommonMiddleware`。"

msgid ""
"The order in :setting:`MIDDLEWARE` matters because a middleware can depend "
"on other middleware. For instance, :class:`~django.contrib.auth.middleware."
"AuthenticationMiddleware` stores the authenticated user in the session; "
"therefore, it must run after :class:`~django.contrib.sessions.middleware."
"SessionMiddleware`. See :ref:`middleware-ordering` for some common hints "
"about ordering of Django middleware classes."
msgstr ""
":setting:`MIDDLEWARE` 的顺序很重要，因为中间件会依赖其他中间件。例如：类 :"
"class:`~django.contrib.auth.middleware.AuthenticationMiddleware` 在会话中存储"
"经过身份验证的用户；因此，它必须在 :class:`~django.contrib.sessions."
"middleware.SessionMiddleware` 后面运行 。中间件。Session中间件。请参阅 :ref:"
"`middleware-ordering` ，用于一些关于 Django 中间件类排序的常见提示。"

msgid "Middleware order and layering"
msgstr "中间件顺序与分层"

msgid ""
"During the request phase, before calling the view, Django applies middleware "
"in the order it's defined in :setting:`MIDDLEWARE`, top-down."
msgstr ""
"在请求阶段，在调用视图之前，Django 按照定义的顺序应用中间件 :setting:"
"`MIDDLEWARE`，自顶向下。"

msgid ""
"You can think of it like an onion: each middleware class is a \"layer\" that "
"wraps the view, which is in the core of the onion. If the request passes "
"through all the layers of the onion (each one calls ``get_response`` to pass "
"the request in to the next layer), all the way to the view at the core, the "
"response will then pass through every layer (in reverse order) on the way "
"back out."
msgstr ""
"你可以把它想象成一个洋葱：每个中间件类都是一个“层”，它覆盖了洋葱的核心。如果"
"请求通过洋葱的所有层（每一个调用 ``get_response`` ）以将请求传递到下一层，一"
"直到内核的视图，那么响应将在返回的过程中通过每个层（以相反的顺序）。"

msgid ""
"If one of the layers decides to short-circuit and return a response without "
"ever calling its ``get_response``, none of the layers of the onion inside "
"that layer (including the view) will see the request or the response. The "
"response will only return through the same layers that the request passed in "
"through."
msgstr ""
"如果其中一层决定停止并返回响应而不调用get_response，那么该层(包括视图)中的洋"
"葱层都不会看到请求或响应。响应将只通过请求传入的相同层返回。"

msgid "Other middleware hooks"
msgstr "其他中间件钩子"

msgid ""
"Besides the basic request/response middleware pattern described earlier, you "
"can add three other special methods to class-based middleware:"
msgstr ""
"除前面说书的基础请求/响应中间件模式外，你可以给基于类的中间件添加三种其他特殊"
"方法："

msgid "``process_view()``"
msgstr "``process_view()``"

msgid ""
"``request`` is an :class:`~django.http.HttpRequest` object. ``view_func`` is "
"the Python function that Django is about to use. (It's the actual function "
"object, not the name of the function as a string.) ``view_args`` is a list "
"of positional arguments that will be passed to the view, and ``view_kwargs`` "
"is a dictionary of keyword arguments that will be passed to the view. "
"Neither ``view_args`` nor ``view_kwargs`` include the first view argument "
"(``request``)."
msgstr ""
"``request`` 是一个 :class:`~django.http.HttpRequest` 对象。``view_func`` 是一"
"个 Django 将要使用的 Python 函数。（这是一个真实的函数对象，不是函数的名"
"称）；``view_args`` 是一个用来传递给视图的位置参数列表，；``view_kwargs`` 是"
"一个用来传递给视图的关键字参数字典。``view_args`` 和 ``view_kwargs`` 都不包含"
"第一个视图参数 ( ``request`` )。"

msgid "``process_view()`` is called just before Django calls the view."
msgstr "``process_view()`` 只在 Django 调用视图前被调用。"

msgid ""
"It should return either ``None`` or an :class:`~django.http.HttpResponse` "
"object. If it returns ``None``, Django will continue processing this "
"request, executing any other ``process_view()`` middleware and, then, the "
"appropriate view. If it returns an :class:`~django.http.HttpResponse` "
"object, Django won't bother calling the appropriate view; it'll apply "
"response middleware to that :class:`~django.http.HttpResponse` and return "
"the result."
msgstr ""
"它应该返回 ``None`` 或 :class:`~django.http.HttpResponse` 对象。如果它返回 "
"``None`` ，Django 将继续处理这个请求，执行任何其他的 ``process_view()`` ，然"
"后执行相应的视图。如果它返回 :class:`~django.http.HttpResponse` 对象，Django "
"不会去影响调用相应的视图；它会将响应中间件应用到 :class:`~django.http."
"HttpResponse` 并返回结果。"

msgid ""
"Accessing :attr:`request.POST <django.http.HttpRequest.POST>` inside "
"middleware before the view runs or in ``process_view()`` will prevent any "
"view running after the middleware from being able to :ref:`modify the upload "
"handlers for the request <modifying_upload_handlers_on_the_fly>`, and should "
"normally be avoided."
msgstr ""
"在视图运行前或在 ``process_view()`` 内访问中间件里的 :attr:`request.POST "
"<django.http.HttpRequest.POST>` 将阻止中间件之后运行的任何视图修改请求的上传"
"处理程序 （:ref:`modify the upload handlers for the request "
"<modifying_upload_handlers_on_the_fly>`  ），通常应该避免这样。"

msgid ""
"The :class:`~django.middleware.csrf.CsrfViewMiddleware` class can be "
"considered an exception, as it provides the :func:`~django.views.decorators."
"csrf.csrf_exempt` and :func:`~django.views.decorators.csrf.csrf_protect` "
"decorators which allow views to explicitly control at what point the CSRF "
"validation should occur."
msgstr ""
":class:`~django.middleware.csrf.CsrfViewMiddleware` 类可以被视为一个例外，因"
"为它提供 :func:`~django.views.decorators.csrf.csrf_exempt` 和 :func:`~django."
"views.decorators.csrf.csrf_protect` 装饰器，它们允许视图完全控制 CSRF 验证在"
"什么时候进行。"

msgid "``process_exception()``"
msgstr "``process_exception()``"

msgid ""
"``request`` is an :class:`~django.http.HttpRequest` object. ``exception`` is "
"an ``Exception`` object raised by the view function."
msgstr ""
"``request`` 是一个 :class:`~django.http.HttpRequest` 对象。 ``exception`` 是"
"一个由视图函数引发的 ``Exception`` 对象。"

msgid ""
"Django calls ``process_exception()`` when a view raises an exception. "
"``process_exception()`` should return either ``None`` or an :class:`~django."
"http.HttpResponse` object. If it returns an :class:`~django.http."
"HttpResponse` object, the template response and response middleware will be "
"applied and the resulting response returned to the browser. Otherwise, :ref:"
"`default exception handling <error-views>` kicks in."
msgstr ""
"当视图引发异常时，Django 会调用 ``process_exception()``。"
"``process_exception()`` 应该返回 ``None`` 或 :class:`~django.http."
"HttpResponse` 对象。如果它返回一个 :class:`~django.http.HttpResponse` 对象，"
"模板响应和响应中间件将被应用且会将结果响应返回浏览器。否则，就会开始默认异常"
"处理（ :ref:`default exception handling <error-views>` ）。"

msgid ""
"Again, middleware are run in reverse order during the response phase, which "
"includes ``process_exception``. If an exception middleware returns a "
"response, the ``process_exception`` methods of the middleware classes above "
"that middleware won't be called at all."
msgstr ""
"再次，中间件在响应阶段会按照相反的顺序运行，其中包括 ``process_exception`` 。"
"如果异常中间件返回一个响应，那么中间件之上的中间件类的 ``process_exception`` "
"方法根本不会被调用。"

msgid "``process_template_response()``"
msgstr "``process_template_response()``"

msgid ""
"``request`` is an :class:`~django.http.HttpRequest` object. ``response`` is "
"the :class:`~django.template.response.TemplateResponse` object (or "
"equivalent) returned by a Django view or by a middleware."
msgstr ""
"``request`` 是一个 :class:`~django.http.HttpRequest` 对象。``response`` 是 :"
"class:`~django.template.response.TemplateResponse` 对象（或者等效对象），它通"
"过 Django 视图或中间件返回。"

msgid ""
"``process_template_response()`` is called just after the view has finished "
"executing, if the response instance has a ``render()`` method, indicating "
"that it is a :class:`~django.template.response.TemplateResponse` or "
"equivalent."
msgstr ""
"``process_template_response()`` 在视图被完全执行后调用，如果响应实例有 "
"``render()`` 方法，表明它是一个 :class:`~django.template.response."
"TemplateResponse` 或等效对象。"

msgid ""
"It must return a response object that implements a ``render`` method. It "
"could alter the given ``response`` by changing ``response.template_name`` "
"and ``response.context_data``, or it could create and return a brand-new :"
"class:`~django.template.response.TemplateResponse` or equivalent."
msgstr ""
"它必须返回一个实现了 ``render`` 方法的响应对象。它可以通过改变``response."
"template_name`` 和 ``response.context_data`` 来改变给定的 ``response`` ，或者"
"它可以创建和返回全新的 :class:`~django.template.response.TemplateResponse` 或"
"等效对象。"

msgid ""
"You don't need to explicitly render responses -- responses will be "
"automatically rendered once all template response middleware has been called."
msgstr "你不需要显式地渲染响应——一旦所有模板中间件被调用，响应会被自动渲染。"

msgid ""
"Middleware are run in reverse order during the response phase, which "
"includes ``process_template_response()``."
msgstr ""
"中间件会在响应阶段按照相反的顺序运行，其中包括 "
"``process_template_response()`` 。"

msgid "Dealing with streaming responses"
msgstr "处理流式响应"

msgid ""
"Unlike :class:`~django.http.HttpResponse`, :class:`~django.http."
"StreamingHttpResponse` does not have a ``content`` attribute. As a result, "
"middleware can no longer assume that all responses will have a ``content`` "
"attribute. If they need access to the content, they must test for streaming "
"responses and adjust their behavior accordingly::"
msgstr ""
"与 :class:`~django.http.HttpResponse` 不同，:class:`~django.http."
"StreamingHttpResponse` 没有 ``content`` 属性。因此，中间件不能再假设所有响应"
"有 ``content`` 属性。如果它们需要访问 content，它们必须为流式响应进行测试，并"
"且调整其行为："

msgid ""
"``streaming_content`` should be assumed to be too large to hold in memory. "
"Response middleware may wrap it in a new generator, but must not consume it. "
"Wrapping is typically implemented as follows::"
msgstr ""
"``streaming_content`` 被假设为体积太大而无法在内存中保存。响应中间件可以将其"
"包装在一个新的生成器里，但不能使用它。包装通常如下实现："

msgid ""
"Django automatically converts exceptions raised by the view or by middleware "
"into an appropriate HTTP response with an error status code. :ref:`Certain "
"exceptions <error-views>` are converted to 4xx status codes, while an "
"unknown exception is converted to a 500 status code."
msgstr ""
"Django 自动转换视图引发的异常，或者带有错误状态代码的特定 HTTP 响应内的中间件"
"引发的异常。某些异常（ :ref:`Certain exceptions <error-views>` ）被转换为 "
"4xx 状态代码，而未知异常被转换为 500 状态代码。"

msgid ""
"This conversion takes place before and after each middleware (you can think "
"of it as the thin film in between each layer of the onion), so that every "
"middleware can always rely on getting some kind of HTTP response back from "
"calling its ``get_response`` callable. Middleware don't need to worry about "
"wrapping their call to ``get_response`` in a ``try/except`` and handling an "
"exception that might have been raised by a later middleware or the view. "
"Even if the very next middleware in the chain raises an :class:`~django.http."
"Http404` exception, for example, your middleware won't see that exception; "
"instead it will get an :class:`~django.http.HttpResponse` object with a :"
"attr:`~django.http.HttpResponse.status_code` of 404."
msgstr ""
"这个变换发生在每个中间件的前后（你可以把它想象成洋葱每层中间的薄膜），因此每"
"个中间件总是可以依赖于从调用它的 ``get_response`` 回调中获得某种类型的HTTP响"
"应。中间件不需要担心它们对 ``get_response`` 的调用包装在 ``try/except`` 里，"
"也不需要担心处理稍后的中间件或视图引发的异常。即使链中的下一个中间件引发了 :"
"class:`~django.http.Http404` 异常，比如中间件不会查看异常，相反，它会得到一个"
"带有404 :attr:`~django.http.HttpResponse.status_code` 的 :class:`~django."
"http.HttpResponse` 对象。"

msgid ""
"You can set :setting:`DEBUG_PROPAGATE_EXCEPTIONS` to ``True`` to skip this "
"conversion and propagate exceptions upward."
msgstr ""

msgid ""
"Middleware can support any combination of synchronous and asynchronous "
"requests. Django will adapt requests to fit the middleware's requirements if "
"it cannot support both, but at a performance penalty."
msgstr ""
"中间件支持同步和异步请求的任意组合。如果Django不能同时支持它们，它会调整请求"
"来适应中间件的需求，但会有性能损失。"

msgid ""
"By default, Django assumes that your middleware is capable of handling only "
"synchronous requests. To change these assumptions, set the following "
"attributes on your middleware factory function or class:"
msgstr ""
"默认情况下，Django假设你的中间件只能处理同步请求。如果要改变这种模式，需要在"
"你的中间件工厂函数或类中添加入如下属性："

msgid ""
"``sync_capable`` is a boolean indicating if the middleware can handle "
"synchronous requests. Defaults to ``True``."
msgstr ""
"``sync_capable`` 是一个布尔值，来表明中间件是否处理同步请求。默认为 "
"``True``。"

msgid ""
"``async_capable`` is a boolean indicating if the middleware can handle "
"asynchronous requests. Defaults to ``False``."
msgstr ""
"``async_capable`` 是一个布尔值，来表明中间件是否处理异步请求。默认为 "
"``False``。"

msgid ""
"If your middleware has both ``sync_capable = True`` and ``async_capable = "
"True``, then Django will pass it the request without converting it. In this "
"case, you can work out if your middleware will receive async requests by "
"checking if the ``get_response`` object you are passed is a coroutine "
"function, using :py:func:`asyncio.iscoroutinefunction`."
msgstr ""
"如果中间件的``sync_capable = True`` 并且 ``async_capable = True``，那么"
"Django 会将请求传递给它而不进行转换。在这种情况下，你可以使用 :py:func:"
"`asyncio.iscoroutinefunction` 来检查传递的 ``get_response`` 是否是一个协同函"
"数，从而确定中间件是否接收到异步请求。"

msgid ""
"The ``django.utils.decorators`` module contains :func:`~django.utils."
"decorators.sync_only_middleware`, :func:`~django.utils.decorators."
"async_only_middleware`, and :func:`~django.utils.decorators."
"sync_and_async_middleware` decorators that allow you to apply these flags to "
"middleware factory functions."
msgstr ""
"``django.utils.decorators`` 模块包含 :func:`~django.utils.decorators."
"sync_only_middleware`，:func:`~django.utils.decorators."
"async_only_middleware` 和 :func:`~django.utils.decorators."
"sync_and_async_middleware` 装饰器，允许你将这些标志应用到中间件工厂函数中。"

msgid ""
"The returned callable must match the sync or async nature of the "
"``get_response`` method. If you have an asynchronous ``get_response``, you "
"must return a coroutine function (``async def``)."
msgstr ""
"返回的可调用对象必须符合 ``get_response`` 方法的同步或异步性质。如果你有一个"
"异步的 ``get_response``，你必须返回一个协程函数（``async def``）。"

msgid ""
"``process_view``, ``process_template_response`` and ``process_exception`` "
"methods, if they are provided, should also be adapted to match the sync/"
"async mode. However, Django will individually adapt them as required if you "
"do not, at an additional performance penalty."
msgstr ""
"``process_view``、``process_template_response`` 和 ``process_exception`` 方"
"法，如果有的话，也应该进行调整以匹配同步／异步模式。然而，如果你不这样做，"
"Django 会根据需要单独调整它们，但会有额外的性能损失。"

msgid ""
"Here's an example of how to create a middleware function that supports both::"
msgstr "下面以一个例子来说明如何创建一个支持这两种功能的中间件函数："

msgid ""
"If you declare a hybrid middleware that supports both synchronous and "
"asynchronous calls, the kind of call you get may not match the underlying "
"view. Django will optimize the middleware call stack to have as few sync/"
"async transitions as possible."
msgstr ""
"如果你声明了一个同时支持同步和异步调用的混合中间件，你得到的调用种类可能与底"
"层视图不匹配。Django 会优化中间件调用栈，使其尽可能少的同步／异步转换。"

msgid ""
"Thus, even if you are wrapping an async view, you may be called in sync mode "
"if there is other, synchronous middleware between you and the view."
msgstr ""
"因此，即使你包装的是一个异步视图，如果在你和视图之间有其他的、同步的中间件，"
"你也可能会在同步模式下被调用。"

msgid "Upgrading pre-Django 1.10-style middleware"
msgstr "升级 Django 1.10 之前的中间件"

msgid ""
"Django provides ``django.utils.deprecation.MiddlewareMixin`` to ease "
"creating middleware classes that are compatible with both :setting:"
"`MIDDLEWARE` and the old ``MIDDLEWARE_CLASSES``, and support synchronous and "
"asynchronous requests. All middleware classes included with Django are "
"compatible with both settings."
msgstr ""
"Django 提供了 ``django.utils.deprecation.MiddlewareMixin`` 来方便创建同时兼"
"容 :setting:`MIDDLEWARE` 和旧的 ``MIDDLEWARE_CLASSES`` 的中间件类，并支持同步"
"和异步请求。Django 所包含的所有中间件类都兼容这两种配置。"

msgid ""
"The mixin provides an ``__init__()`` method that requires a ``get_response`` "
"argument and stores it in ``self.get_response``."
msgstr ""
"mixin 提供了一个 ``__init__()`` 方法，它需要一个 ``get_response`` 参数，并将"
"其存储在 ``self.get_response`` 中。"

msgid "The ``__call__()`` method:"
msgstr "``__call__()`` 方法："

msgid "Calls ``self.process_request(request)`` (if defined)."
msgstr "调用 ``self.process_request(request)`` （如果被定义过）。"

msgid ""
"Calls ``self.get_response(request)`` to get the response from later "
"middleware and the view."
msgstr "调用 ``self.get_response(request)`` 来从后续的中间件和视图得到响应。"

msgid "Calls ``self.process_response(request, response)`` (if defined)."
msgstr "调用 ``self.process_response(request, response)`` （如果被定义过）。"

msgid "Returns the response."
msgstr "返回响应。"

msgid ""
"If used with ``MIDDLEWARE_CLASSES``, the ``__call__()`` method will never be "
"used; Django calls ``process_request()`` and ``process_response()`` directly."
msgstr ""
"如果和 ``MIDDLEWARE_CLASSES`` 一起使用，``__call__()`` 方法将永远不会被使用；"
"Django 会直接调用 ``process_request()`` 和 ``process_response()`` 。"

msgid ""
"In most cases, inheriting from this mixin will be sufficient to make an old-"
"style middleware compatible with the new system with sufficient backwards-"
"compatibility. The new short-circuiting semantics will be harmless or even "
"beneficial to the existing middleware. In a few cases, a middleware class "
"may need some changes to adjust to the new semantics."
msgstr ""
"在大多数情况下，从这个 Mixin 中继承就足以使一个旧式中间件与新系统兼容，并具有"
"足够的向后兼容性。新的短路语义对现有中间件无害甚至有益。在少数情况下，中间件"
"类可能需要一些改变来适应新的语义。"

msgid ""
"These are the behavioral differences between using :setting:`MIDDLEWARE` and "
"``MIDDLEWARE_CLASSES``:"
msgstr ":setting:`MIDDLEWARE` 和 ``MIDDLEWARE_CLASSES`` 在使用上有些行为差异："

msgid ""
"Under ``MIDDLEWARE_CLASSES``, every middleware will always have its "
"``process_response`` method called, even if an earlier middleware short-"
"circuited by returning a response from its ``process_request`` method. "
"Under :setting:`MIDDLEWARE`, middleware behaves more like an onion: the "
"layers that a response goes through on the way out are the same layers that "
"saw the request on the way in. If a middleware short-circuits, only that "
"middleware and the ones before it in :setting:`MIDDLEWARE` will see the "
"response."
msgstr ""
"``MIDDLEWARE_CLASSES`` 下，每个中间件将始终调用它的 ``process_response`` 方"
"法，即使早期的中间件通过从其 ``process_response`` 方法返回响应而短路。:"
"setting:`MIDDLEWARE` 下，中间件行为更像洋葱：响应在输出时经过的层与在输入时看"
"到请求的层相同。如果一个中间件短路，只有那个中间件和之前的中间件可以看到响"
"应。"

msgid ""
"Under ``MIDDLEWARE_CLASSES``, ``process_exception`` is applied to exceptions "
"raised from a middleware ``process_request`` method. Under :setting:"
"`MIDDLEWARE`, ``process_exception`` applies only to exceptions raised from "
"the view (or from the ``render`` method of a :class:`~django.template."
"response.TemplateResponse`). Exceptions raised from a middleware are "
"converted to the appropriate HTTP response and then passed to the next "
"middleware."
msgstr ""
"在 ``MIDDLEWARE_CLASSES`` 下，``process_exception`` 应用于中间件 "
"``process_request`` 方法引发的异常。在 :setting:`MIDDLEWARE` 下，"
"``process_exception`` 只应用于视图引发的异常（或者从 :class:`~django."
"template.response.TemplateResponse` 的 ``render`` 方法引发的异常）。中间件引"
"发的异常被转换为合适的 HTTP 响应，然后传递到下一个中间件。"

msgid ""
"Under ``MIDDLEWARE_CLASSES``, if a ``process_response`` method raises an "
"exception, the ``process_response`` methods of all earlier middleware are "
"skipped and a ``500 Internal Server Error`` HTTP response is always returned "
"(even if the exception raised was e.g. an :class:`~django.http.Http404`). "
"Under :setting:`MIDDLEWARE`, an exception raised from a middleware will "
"immediately be converted to the appropriate HTTP response, and then the next "
"middleware in line will see that response. Middleware are never skipped due "
"to a middleware raising an exception."
msgstr ""
"``MIDDLEWARE_CLASSES`` 下，如果 ``process_response`` 方法引发了异常，所有更早"
"之前的中间件的 ``process_response`` 方法会被跳过，并一直返回 ``500 Internal "
"Server Error`` 的 HTTP 响应（即使引发的异常是例如 :class:`~django.http."
"Http404` ）。在 :setting:`MIDDLEWARE` ，一个中间件引发的异常将立刻被转换为合"
"适的 HTTP 响应，然后下一个中间件将看到响应。中间件不会因为中间件引发异常而被"
"跳过。"

msgid "How to use sessions"
msgstr "如何使用会话"

msgid ""
"Django provides full support for anonymous sessions. The session framework "
"lets you store and retrieve arbitrary data on a per-site-visitor basis. It "
"stores data on the server side and abstracts the sending and receiving of "
"cookies. Cookies contain a session ID -- not the data itself (unless you're "
"using the :ref:`cookie based backend<cookie-session-backend>`)."
msgstr ""
"Django 是支持匿名会话的。会话框架允许您基于每个站点访问者存储和检索任意数据。"
"它在服务器端存储数据并提供cookie的发送和接收。Cookie包含会话ID - 而不是数据本"
"身（除非您使用基于cookie的后端）。"

msgid "Enabling sessions"
msgstr "打开会话"

msgid ""
"Sessions are implemented via a piece of :doc:`middleware </ref/middleware>`."
msgstr "会话通过配置一个中间件实现的"

msgid "To enable session functionality, do the following:"
msgstr "为了打开会话，需要做下面的操作"

msgid ""
"Edit the :setting:`MIDDLEWARE` setting and make sure it contains ``'django."
"contrib.sessions.middleware.SessionMiddleware'``. The default ``settings."
"py`` created by ``django-admin startproject`` has ``SessionMiddleware`` "
"activated."
msgstr ""
"编辑设置中的 `MIDDLEWARE`，并确保他包含了 `'django.contrib.sessions."
"middleware.SessionMiddleware'`。通过 `django-admin startproject` 创建的默认 "
"`settings.py` 文件是已经打开了 `SessionMiddleware` 这项设置的。"

msgid ""
"If you don't want to use sessions, you might as well remove the "
"``SessionMiddleware`` line from :setting:`MIDDLEWARE` and ``'django.contrib."
"sessions'`` from your :setting:`INSTALLED_APPS`. It'll save you a small bit "
"of overhead."
msgstr ""
"如果你不想使用会话功能，你可以从配置的 `MIDDLEWARE 中删除 "
"`SessionMiddleware`，并且从 `INSTALLED_APPS` 中删除 `'django.contrib."
"sessions'`。它将会为您节省一点开销。"

msgid "Configuring the session engine"
msgstr "配置会话(session)引擎"

msgid ""
"By default, Django stores sessions in your database (using the model "
"``django.contrib.sessions.models.Session``). Though this is convenient, in "
"some setups it's faster to store session data elsewhere, so Django can be "
"configured to store session data on your filesystem or in your cache."
msgstr ""
"默认情况下，Django 在数据库里存储会话（使用 ``django.contrib.sessions.models."
"Session`` ）。虽然这很方便，但在一些设置里，在其他地方存储会话数据速度更快，"
"因此 Django 可以在文件系统或缓存中配置存储会话数据。"

msgid "Using database-backed sessions"
msgstr "使用数据库支持的会话"

msgid ""
"If you want to use a database-backed session, you need to add ``'django."
"contrib.sessions'`` to your :setting:`INSTALLED_APPS` setting."
msgstr ""
"如果你想使用数据库支持的会话，你需要在 :setting:`INSTALLED_APPS` 里添加 "
"``'django.contrib.sessions'`` 。"

msgid ""
"Once you have configured your installation, run ``manage.py migrate`` to "
"install the single database table that stores session data."
msgstr ""
"一旦在安装中配置，运行 ``manage.py migrate`` 来安装单个数据库表来存储会话数"
"据。"

msgid "Using cached sessions"
msgstr "使用缓存会话"

msgid ""
"For better performance, you may want to use a cache-based session backend."
msgstr "为了得到更好的性能，你可以使用基于缓存的会话后端。"

msgid ""
"To store session data using Django's cache system, you'll first need to make "
"sure you've configured your cache; see the :doc:`cache documentation </"
"topics/cache>` for details."
msgstr ""
"使用 Django 的缓存系统来存储会话，你首先需要确保已经配置了缓存，查看 :doc:"
"`cache documentation </topics/cache>` 获取详情。"

msgid ""
"You should only use cache-based sessions if you're using the Memcached or "
"Redis cache backend. The local-memory cache backend doesn't retain data long "
"enough to be a good choice, and it'll be faster to use file or database "
"sessions directly instead of sending everything through the file or database "
"cache backends. Additionally, the local-memory cache backend is NOT multi-"
"process safe, therefore probably not a good choice for production "
"environments."
msgstr ""

msgid ""
"If you have multiple caches defined in :setting:`CACHES`, Django will use "
"the default cache. To use another cache, set :setting:`SESSION_CACHE_ALIAS` "
"to the name of that cache."
msgstr ""
"如果你在 :setting:`CACHES` 定义了多缓存，Django 会使用默认缓存。如果要使用其"
"他缓存，请将 :setting:`SESSION_CACHE_ALIAS` 设置为该缓存名。"

msgid ""
"Once your cache is configured, you've got two choices for how to store data "
"in the cache:"
msgstr "一旦配置好了缓存，你有两种办法在缓存中存储数据："

msgid ""
"Set :setting:`SESSION_ENGINE` to ``\"django.contrib.sessions.backends.cache"
"\"`` for a simple caching session store. Session data will be stored "
"directly in your cache. However, session data may not be persistent: cached "
"data can be evicted if the cache fills up or if the cache server is "
"restarted."
msgstr ""
"设置 :setting:`SESSION_ENGINE` 为 ``\"django.contrib.sessions.backends.cache"
"\"`` 用于简单缓存会话存储。会话数据直接被存储在缓存里。然而，会话数据可能不是"
"长久的：因为缓存满了或者缓存服务重启了，所以缓存数据会被收回。"

msgid ""
"For persistent, cached data, set :setting:`SESSION_ENGINE` to ``\"django."
"contrib.sessions.backends.cached_db\"``. This uses a write-through cache -- "
"every write to the cache will also be written to the database. Session reads "
"only use the database if the data is not already in the cache."
msgstr ""
"为了持久化缓存数据，设置 :setting:`SESSION_ENGINE` 为 ``\"django.contrib."
"sessions.backends.cached_db\"`` 。这使用直写式缓存——每次写入缓存的数据也会被"
"写入到数据库。如果数据不在缓存中，会话仅使用数据库进行读取。"

msgid ""
"Both session stores are quite fast, but the simple cache is faster because "
"it disregards persistence. In most cases, the ``cached_db`` backend will be "
"fast enough, but if you need that last bit of performance, and are willing "
"to let session data be expunged from time to time, the ``cache`` backend is "
"for you."
msgstr ""
"这两中会话存储会非常快，但简单缓存会更快，因为它忽略了持久化。在大部分情况"
"下，``cached_db`` 后端将足够快，但如果你需要最后一点的性能，并且愿意不时地删"
"除会话数据，那么 ``cache`` 后端适合你。"

msgid ""
"If you use the ``cached_db`` session backend, you also need to follow the "
"configuration instructions for the `using database-backed sessions`_."
msgstr ""
"如果你使用 ``cached_db`` 会话后端，你也需要遵循使用数据库支持的会话配置说明"
"( `using database-backed sessions`_ )。"

msgid "Using file-based sessions"
msgstr "使用基于文件的会话"

msgid ""
"To use file-based sessions, set the :setting:`SESSION_ENGINE` setting to ``"
"\"django.contrib.sessions.backends.file\"``."
msgstr ""
"要使用基于文件的会话，需要设置 :setting:`SESSION_ENGINE` 为 ``\"django."
"contrib.sessions.backends.file\"`` 。"

msgid ""
"You might also want to set the :setting:`SESSION_FILE_PATH` setting (which "
"defaults to output from ``tempfile.gettempdir()``, most likely ``/tmp``) to "
"control where Django stores session files. Be sure to check that your web "
"server has permissions to read and write to this location."
msgstr ""

msgid "Using cookie-based sessions"
msgstr "使用基于cookie的会话"

msgid ""
"To use cookies-based sessions, set the :setting:`SESSION_ENGINE` setting to "
"``\"django.contrib.sessions.backends.signed_cookies\"``. The session data "
"will be stored using Django's tools for :doc:`cryptographic signing </topics/"
"signing>` and the :setting:`SECRET_KEY` setting."
msgstr ""
"要使用基于cookies的会话，需要设置 :setting:`SESSION_ENGINE` 为 ``\"django."
"contrib.sessions.backends.signed_cookies\"`` 。这个会话数据将使用 Django 的加"
"密工具( :doc:`cryptographic signing </topics/signing>` ) 和 :setting:"
"`SECRET_KEY` 工具进行保存。"

msgid ""
"It's recommended to leave the :setting:`SESSION_COOKIE_HTTPONLY` setting on "
"``True`` to prevent access to the stored data from JavaScript."
msgstr ""
"建议将 :setting:`SESSION_COOKIE_HTTPONLY` 设置为 ``True`` 来防止通过 "
"JavaScript 访问存储数据。"

msgid ""
"**If the SECRET_KEY is not kept secret and you are using the** :class:"
"`~django.contrib.sessions.serializers.PickleSerializer`, **this can lead to "
"arbitrary remote code execution.**"
msgstr ""
"如果 SECRET_KEY 泄露了，并且你正在使用 :class:`~django.contrib.sessions."
"serializers.PickleSerializer` ，这会导致任意远程代码执行。"

msgid ""
"An attacker in possession of the :setting:`SECRET_KEY` can not only generate "
"falsified session data, which your site will trust, but also remotely "
"execute arbitrary code, as the data is serialized using pickle."
msgstr ""
"拥有 :setting:`SECRET_KEY` 的攻击者不仅可以生成站点信任的伪造会话数据，也可以"
"远程执行任意的代码，因为数据是使用 pickle 序列化的。"

msgid ""
"If you use cookie-based sessions, pay extra care that your secret key is "
"always kept completely secret, for any system which might be remotely "
"accessible."
msgstr ""
"如果你使用基于 cookie 的会话，一定要注意对于任何可能远程访问的系统，密钥是完"
"全保密的。"

msgid "**The session data is signed but not encrypted**"
msgstr "**会话数据已签名但未被加密**"

msgid ""
"When using the cookies backend the session data can be read by the client."
msgstr "当使用cookie后端时，会话数据可以被客户端读取。"

msgid ""
"A MAC (Message Authentication Code) is used to protect the data against "
"changes by the client, so that the session data will be invalidated when "
"being tampered with. The same invalidation happens if the client storing the "
"cookie (e.g. your user's browser) can't store all of the session cookie and "
"drops data. Even though Django compresses the data, it's still entirely "
"possible to exceed the :rfc:`common limit of 4096 bytes <2965#section-5.3>` "
"per cookie."
msgstr ""
"MAC(消息验证代码) 被用来保护数据不被客户端修改，因此会话数据在被篡改时失效。"
"如果存储cookie 的客户端 (比如浏览器) 不能存储所有会话数据并丢弃数据，则会同样"
"发生失效。即使 Django 压缩数据，它仍然完全有可能每个 cookie 超过4096字节的通"
"用限制（ :rfc:`common limit of 4096 bytes <2965#section-5.3>` ）。"

msgid "**No freshness guarantee**"
msgstr "**不保证新鲜度**"

msgid ""
"Note also that while the MAC can guarantee the authenticity of the data "
"(that it was generated by your site, and not someone else), and the "
"integrity of the data (that it is all there and correct), it cannot "
"guarantee freshness i.e. that you are being sent back the last thing you "
"sent to the client. This means that for some uses of session data, the "
"cookie backend might open you up to `replay attacks`_. Unlike other session "
"backends which keep a server-side record of each session and invalidate it "
"when a user logs out, cookie-based sessions are not invalidated when a user "
"logs out. Thus if an attacker steals a user's cookie, they can use that "
"cookie to login as that user even if the user logs out. Cookies will only be "
"detected as 'stale' if they are older than your :setting:"
"`SESSION_COOKIE_AGE`."
msgstr ""
"注意虽然 MAC 可以保证数据(通过站点生成，而不是其他人)真实性和数据完整(它是完"
"整和正确的)，但它不能保证新鲜度，也就是说，您最后发送给客户端的东西会被退回。"
"这意味着cookie后端为了使用一些会话数据，可能会面临重播攻击。与其他会话后端(每"
"个会话保持服务端记录，并且当用户退出时使会话失效)不同，基于cookie的会话在用户"
"退出的时候并不会让会话失效。因此攻击者窃取用户cookie，即使用户登出了，攻击者"
"还可以使用cookie登录该用户。如果 Cookie 比 :setting:`SESSION_COOKIE_AGE` 设置"
"的时间还旧时，则cookie会被检测为 '陈旧' 。"

msgid "**Performance**"
msgstr "**性能**"

msgid ""
"Finally, the size of a cookie can have an impact on the speed of your site."
msgstr ""

msgid "Using sessions in views"
msgstr "在视图中使用会话"

msgid ""
"When ``SessionMiddleware`` is activated, each :class:`~django.http."
"HttpRequest` object -- the first argument to any Django view function -- "
"will have a ``session`` attribute, which is a dictionary-like object."
msgstr ""
"当激活 ``SessionMiddleware`` 后，每个 :class:`~django.http.HttpRequest` 对象"
"（任何 Django 视图函数的第一个参数） 将得到一个 ``session`` 属性，该属性是一"
"个类字典对象。"

msgid ""
"You can read it and write to ``request.session`` at any point in your view. "
"You can edit it multiple times."
msgstr ""
"你可以在视图中任意位置读取它并写入 ``request.session`` 。你可以多次编辑它。"

msgid ""
"This is the base class for all session objects. It has the following "
"standard dictionary methods:"
msgstr "这是所有会话对象的基础类。它有以下标准字典方法："

msgid "Example: ``fav_color = request.session['fav_color']``"
msgstr "比如：``fav_color = request.session['fav_color']``"

msgid "Example: ``request.session['fav_color'] = 'blue'``"
msgstr "比如：``request.session['fav_color'] = 'blue'``"

msgid ""
"Example: ``del request.session['fav_color']``. This raises ``KeyError`` if "
"the given ``key`` isn't already in the session."
msgstr ""
"比如：``del request.session['fav_color']`` 。如果给定的 ``key`` 不在会话里，"
"会引发 ``KeyError`` 。"

msgid "Example: ``'fav_color' in request.session``"
msgstr "比如：``'fav_color' in request.session``"

msgid "Example: ``fav_color = request.session.get('fav_color', 'red')``"
msgstr "比如：``fav_color = request.session.get('fav_color', 'red')``"

msgid "Example: ``fav_color = request.session.pop('fav_color', 'blue')``"
msgstr "比如：``fav_color = request.session.pop('fav_color', 'blue')``"

msgid "It also has these methods:"
msgstr "它也有以下方法："

msgid ""
"Deletes the current session data from the session and deletes the session "
"cookie. This is used if you want to ensure that the previous session data "
"can't be accessed again from the user's browser (for example, the :func:"
"`django.contrib.auth.logout()` function calls it)."
msgstr ""
"删除当前会话和会话cookie。如果你想确保早先的会话数据不能被用户的浏览器再次访"
"问时，可以使用这个方法（比如，:func:`django.contrib.auth.logout()` 函数调用"
"它）。"

msgid ""
"Sets a test cookie to determine whether the user's browser supports cookies. "
"Due to the way cookies work, you won't be able to test this until the user's "
"next page request. See `Setting test cookies`_ below for more information."
msgstr ""
"设置一个测试cookie来确定用户的浏览器是否支持cookie。由于测试通过，你不需要在"
"下一个页面请求时再次测试它。查看 `Setting test cookies`_ 获取更多信息。"

msgid ""
"Returns either ``True`` or ``False``, depending on whether the user's "
"browser accepted the test cookie. Due to the way cookies work, you'll have "
"to call ``set_test_cookie()`` on a previous, separate page request. See "
"`Setting test cookies`_ below for more information."
msgstr ""
"返回 ``True`` 或 ``False`` ，这取决于用户浏览器是否接受测试cookie。由于 "
"cookie 的工作方式，你将必须在上一个独立的页面请求里调用 "
"``set_test_cookie()`` 。查看 `Setting test cookies`_ 获取更多信息。"

msgid "Deletes the test cookie. Use this to clean up after yourself."
msgstr "删除测试cookie。使用完测试cookie后用它来删除。"

msgid ""
"Returns the age of session cookies, in seconds. Defaults to :setting:"
"`SESSION_COOKIE_AGE`."
msgstr ""
"返回 session cookies的失效时间，以秒为单位。默认 :setting:"
"`SESSION_COOKIE_AGE` 。"

msgid ""
"Sets the expiration time for the session. You can pass a number of different "
"values:"
msgstr "为会话设置过期时间。你可以传递很多不同值："

msgid ""
"If ``value`` is an integer, the session will expire after that many seconds "
"of inactivity. For example, calling ``request.session.set_expiry(300)`` "
"would make the session expire in 5 minutes."
msgstr ""
"如果 ``value`` 是整型，会话将在闲置数秒后过期。比如，调用 ``request.session."
"set_expiry(300)`` 会使得会话在5分钟后过期。"

msgid ""
"If ``value`` is a ``datetime`` or ``timedelta`` object, the session will "
"expire at that specific date/time. Note that ``datetime`` and ``timedelta`` "
"values are only serializable if you are using the :class:`~django.contrib."
"sessions.serializers.PickleSerializer`."
msgstr ""
"如果 ``value`` 是一个 ``datetime`` 或 ``timedelta`` 对象，会话将在指定的 "
"date/time 过期。注意，如果你正在使用 :class:`~django.contrib.sessions."
"serializers.PickleSerializer` ，那么 ``datetime`` 和 ``timedelta`` 的值只能序"
"列化。"

msgid ""
"If ``value`` is ``0``, the user's session cookie will expire when the user's "
"web browser is closed."
msgstr ""

msgid ""
"If ``value`` is ``None``, the session reverts to using the global session "
"expiry policy."
msgstr "如果 ``value`` 是 ``None`` ，会话会恢复为全局会话过期策略。"

msgid ""
"Reading a session is not considered activity for expiration purposes. "
"Session expiration is computed from the last time the session was *modified*."
msgstr ""
"出于过期目的，读取会话不被视为活动。会话过期时间会在会话最后一次*修改*后开始"
"计算。"

msgid ""
"Returns the number of seconds until this session expires. For sessions with "
"no custom expiration (or those set to expire at browser close), this will "
"equal :setting:`SESSION_COOKIE_AGE`."
msgstr ""
"返回该会话过期的秒数。对于没有自定义过期时间的会话（或者那些设置为浏览器关闭"
"时过期的），这等同于 :setting:`SESSION_COOKIE_AGE` 。"

msgid "This function accepts two optional keyword arguments:"
msgstr "这个函数接受两个可选的关键参数："

msgid ""
"``modification``: last modification of the session, as a :class:`~datetime."
"datetime` object. Defaults to the current time."
msgstr ""
"``modification`` ：会话的最后一次修改，当做一个 :class:`~datetime.datetime` "
"对象。默认是当前时间。"

msgid ""
"``expiry``: expiry information for the session, as a :class:`~datetime."
"datetime` object, an :class:`int` (in seconds), or ``None``. Defaults to the "
"value stored in the session by :meth:`set_expiry`, if there is one, or "
"``None``."
msgstr ""
"``expiry`` ：会话的过期信息，如一个 :class:`~datetime.datetime` 对象，整数"
"（秒）或 ``None``。默认为通过 :meth:`set_expiry` 存储在会话中的值，或 "
"``None`` 。"

msgid ""
"Returns the date this session will expire. For sessions with no custom "
"expiration (or those set to expire at browser close), this will equal the "
"date :setting:`SESSION_COOKIE_AGE` seconds from now."
msgstr ""
"返回该会话的到期日期。对于没有自定义过期的会话(或那些设置为在浏览器关闭时过期"
"的会话)，这将等于从现在开始的SESSION_COOKIE_AGE秒的日期。"

msgid ""
"This function accepts the same keyword arguments as :meth:`get_expiry_age`."
msgstr "这个函数接受与 :meth:`get_expiry_age` 相同的参数。"

msgid ""
"Returns either ``True`` or ``False``, depending on whether the user's "
"session cookie will expire when the user's web browser is closed."
msgstr ""

msgid ""
"Removes expired sessions from the session store. This class method is called "
"by :djadmin:`clearsessions`."
msgstr ""
"从会话存储中移除过期会话。这个类方法通过 :djadmin:`clearsessions` 调用。"

msgid ""
"Creates a new session key while retaining the current session data. :func:"
"`django.contrib.auth.login()` calls this method to mitigate against session "
"fixation."
msgstr ""
"在保留当前会话的同时创建新的会话秘钥。:func:`django.contrib.auth.login()` 调"
"用这个方法来防止会话固定攻击。"

msgid "Session serialization"
msgstr "会话序列化"

msgid ""
"By default, Django serializes session data using JSON. You can use the :"
"setting:`SESSION_SERIALIZER` setting to customize the session serialization "
"format. Even with the caveats described in :ref:`custom-serializers`, we "
"highly recommend sticking with JSON serialization *especially if you are "
"using the cookie backend*."
msgstr ""
"默认情况下，Django 序列会话数据使用 JSON 。你可以设置 :setting:"
"`SESSION_SERIALIZER` 来自定义会话序列化格式。即使在编写你自己的序列化程序中描"
"述了警告，我们仍然强烈建议您坚持JSON序列化，尤其是在您使用cookie后端的情况"
"下。"

msgid ""
"For example, here's an attack scenario if you use :mod:`pickle` to serialize "
"session data. If you're using the :ref:`signed cookie session backend "
"<cookie-session-backend>` and :setting:`SECRET_KEY` is known by an attacker "
"(there isn't an inherent vulnerability in Django that would cause it to "
"leak), the attacker could insert a string into their session which, when "
"unpickled, executes arbitrary code on the server. The technique for doing so "
"is simple and easily available on the internet. Although the cookie session "
"storage signs the cookie-stored data to prevent tampering, a :setting:"
"`SECRET_KEY` leak immediately escalates to a remote code execution "
"vulnerability."
msgstr ""
"比如，如果你使用 :mod:`pickle` 来序列化会话数据，那么这里一个攻击场景。如果你"
"正在使用 :ref:`signed cookie session backend <cookie-session-backend>` 并且攻"
"击者已经知道了 :setting:`SECRET_KEY` （Django 并不存在会导致其泄露的固有漏"
"洞），攻击者可以在会话里插入一个字符串，当 unpickled 时，在服务器上执行任意代"
"码。这样做的技术很简单，在互联网上也很容易获得。尽管cookie会话存储会对cookie"
"数据进行签名防止篡改，但是泄露 :setting:`SECRET_KEY` 会立即升级为远程代码执行"
"的漏洞。"

msgid "Bundled serializers"
msgstr "绑定序列化"

msgid ""
"A wrapper around the JSON serializer from :mod:`django.core.signing`. Can "
"only serialize basic data types."
msgstr ""
"来自 :mod:`django.core.signing` 的JSON序列化器的装饰器。可以只序列化基本数据"
"类型。"

msgid ""
"In addition, as JSON supports only string keys, note that using non-string "
"keys in ``request.session`` won't work as expected::"
msgstr ""
"另外，因为JSON只支持字符串键，注意在 ``request.session`` 使用非字符串键会无法"
"工作："

msgid ""
"Similarly, data that can't be encoded in JSON, such as non-UTF8 bytes like "
"``'\\xd9'`` (which raises :exc:`UnicodeDecodeError`), can't be stored."
msgstr ""
"同样，数据也不能在JSON中编码，例如像 ``'\\xd9'`` 这种非UTF8字节(会引发 :exc:"
"`UnicodeDecodeError` )不会被存储。"

msgid ""
"See the :ref:`custom-serializers` section for more details on limitations of "
"JSON serialization."
msgstr ""
"查看 :ref:`custom-serializers` 部分来获取更多有关JSON序列化局限性的内容。"

msgid ""
"Supports arbitrary Python objects, but, as described above, can lead to a "
"remote code execution vulnerability if :setting:`SECRET_KEY` becomes known "
"by an attacker."
msgstr ""
"支持任何Python对象，但是，如上所述，如果 :setting:`SECRET_KEY` 泄露，这会导致"
"攻击者执行远程代码的漏洞。"

msgid "Write your own serializer"
msgstr "编写自定义的序列化器"

msgid ""
"Note that unlike :class:`~django.contrib.sessions.serializers."
"PickleSerializer`, the :class:`~django.contrib.sessions.serializers."
"JSONSerializer` cannot handle arbitrary Python data types. As is often the "
"case, there is a trade-off between convenience and security. If you wish to "
"store more advanced data types including ``datetime`` and ``Decimal`` in "
"JSON backed sessions, you will need to write a custom serializer (or convert "
"such values to a JSON serializable object before storing them in ``request."
"session``). While serializing these values is often straightforward (:class:"
"`~django.core.serializers.json.DjangoJSONEncoder` may be helpful), writing a "
"decoder that can reliably get back the same thing that you put in is more "
"fragile. For example, you run the risk of returning a ``datetime`` that was "
"actually a string that just happened to be in the same format chosen for "
"``datetime``\\s)."
msgstr ""
"注意这与 :class:`~django.contrib.sessions.serializers.PickleSerializer` 不"
"同，:class:`~django.contrib.sessions.serializers.JSONSerializer` 不会处理任何"
"Python数据类型。通常情况下，便利性和安全性之间要做出权衡取舍。如果你想在 "
"JSON 支持的会话里存储任何高级数据类型(比如 ``datetime`` 和 ``Decimal`` )，你"
"需要编写自己的序列化器(或者在存储这类值到 ``request.session`` 之前把它们转化"
"JSON序列化类型)。虽然序列化这些值通常很简单( :class:`~django.core."
"serializers.json.DjangoJSONEncoder` 或许有帮助)，但编写一个解码器来可靠地取回"
"你放进去的东西就更不容易了。 例如，你要返回一个字符串格式的 ``datetime`` ，但"
"这恰好与为 ``datetime`` s 选择的格式相同，这样会有风险。"

msgid ""
"Your serializer class must implement two methods, ``dumps(self, obj)`` and "
"``loads(self, data)``, to serialize and deserialize the dictionary of "
"session data, respectively."
msgstr ""
"你的序列化类必须实现两个方法( ``dumps(self, obj)`` 和 ``loads(self, "
"data)`` ) 来分别进行序列化和反序列化会话数据字典。"

msgid "Session object guidelines"
msgstr "会话对象指南"

msgid ""
"Use normal Python strings as dictionary keys on ``request.session``. This is "
"more of a convention than a hard-and-fast rule."
msgstr ""
"在  ``request.session`` 上使用普通的 Python 字符串作为字典键。这更多的是一种"
"惯例而不是硬性规定。"

msgid ""
"Session dictionary keys that begin with an underscore are reserved for "
"internal use by Django."
msgstr "以下划线开头的会话字典键保留给 Django 作内部使用。"

msgid ""
"Don't override ``request.session`` with a new object, and don't access or "
"set its attributes. Use it like a Python dictionary."
msgstr ""
"不要使用新对象覆盖 ``request.session`` ，不要访问或设置它的属性。像使用 "
"Python 字典一样使用它。"

msgid ""
"This simplistic view sets a ``has_commented`` variable to ``True`` after a "
"user posts a comment. It doesn't let a user post a comment more than once::"
msgstr ""
"这个简单的视图将一个 ``has_commented`` 变量在用户评论后设置为 ``True`` 。它不"
"允许用户发表评论多于一次："

msgid "This simplistic view logs in a \"member\" of the site::"
msgstr "这是一个记录站点成员的简单的视图。"

msgid "...And this one logs a member out, according to ``login()`` above::"
msgstr "这是记录成员退出的视图："

msgid ""
"The standard :meth:`django.contrib.auth.logout` function actually does a bit "
"more than this to prevent inadvertent data leakage. It calls the :meth:"
"`~backends.base.SessionBase.flush` method of ``request.session``. We are "
"using this example as a demonstration of how to work with session objects, "
"not as a full ``logout()`` implementation."
msgstr ""
"标准的 :meth:`django.contrib.auth.logout` 函数实际上比这里要多一些来防止数据"
"意外泄露。它调用 ``request.session`` 的 :meth:`~backends.base.SessionBase."
"flush` 方法。我们使用这个例子作为示范如何使用会话对象，而不是完整的 "
"``logout()`` 实现。"

msgid "Setting test cookies"
msgstr "测试 ``cookies`` 设置"

msgid ""
"As a convenience, Django provides a way to test whether the user's browser "
"accepts cookies. Call the :meth:`~backends.base.SessionBase.set_test_cookie` "
"method of ``request.session`` in a view, and call :meth:`~backends.base."
"SessionBase.test_cookie_worked` in a subsequent view -- not in the same view "
"call."
msgstr ""
"为了方便起见，Django 提供一种方法来测试用户浏览器是否支持cookies。调用视图里 "
"``request.session`` 的 :meth:`~backends.base.SessionBase.set_test_cookie` 方"
"法，并且在后续视图里调用 :meth:`~backends.base.SessionBase."
"test_cookie_worked` —— 不是在同一个视图里调用。"

msgid ""
"This awkward split between ``set_test_cookie()`` and "
"``test_cookie_worked()`` is necessary due to the way cookies work. When you "
"set a cookie, you can't actually tell whether a browser accepted it until "
"the browser's next request."
msgstr ""
"由于 cookies 的工作方式， ``set_test_cookie()`` 和 ``test_cookie_worked()`` "
"之间尴尬的分割是有必要的。当你设置了一个 cookie，在浏览器的下一个请求之前，实"
"际上你不能判断浏览器是否接受它。"

msgid ""
"It's good practice to use :meth:`~backends.base.SessionBase."
"delete_test_cookie()` to clean up after yourself. Do this after you've "
"verified that the test cookie worked."
msgstr ""
"使用 :meth:`~backends.base.SessionBase.delete_test_cookie()` 来清理是个好习"
"惯。在验证测试的 cookie 可用之后来执行它。"

msgid "Here's a typical usage example::"
msgstr "这里是一个典型的用法示例："

msgid "Using sessions out of views"
msgstr "在视图外使用会话"

msgid ""
"The examples in this section import the ``SessionStore`` object directly "
"from the ``django.contrib.sessions.backends.db`` backend. In your own code, "
"you should consider importing ``SessionStore`` from the session engine "
"designated by :setting:`SESSION_ENGINE`, as below:"
msgstr ""
"这部分的例子直接从 ``django.contrib.sessions.backends.db`` 后端导入 "
"``SessionStore`` 对象。在你自己的代码里，你应该考虑从 :setting:"
"`SESSION_ENGINE` 指定的会话引擎导入 ``SessionStore`` 。"

msgid "An API is available to manipulate session data outside of a view::"
msgstr "可以在视图外对会话数据进行操作的 API ："

msgid ""
"``SessionStore.create()`` is designed to create a new session (i.e. one not "
"loaded from the session store and with ``session_key=None``). ``save()`` is "
"designed to save an existing session (i.e. one loaded from the session "
"store). Calling ``save()`` on a new session may also work but has a small "
"chance of generating a ``session_key`` that collides with an existing one. "
"``create()`` calls ``save()`` and loops until an unused ``session_key`` is "
"generated."
msgstr ""
"``SessionStore.create()`` 用来创建一个新会话（即不从会话中加载，并带有 "
"``session_key=None``）。``save()`` 用来保存已存在的会话（即从会话存储中加"
"载）。在新会话上调用 ``save()`` 也许会工作，但生成与现有会话相冲突的 "
"``session_key`` 的概率很小。``create()`` 调用 ``save()`` 并循环，直到生成了未"
"使用过的 ``session_key`` 。"

msgid ""
"If you're using the ``django.contrib.sessions.backends.db`` backend, each "
"session is a normal Django model. The ``Session`` model is defined in "
"``django/contrib/sessions/models.py``. Because it's a normal model, you can "
"access sessions using the normal Django database API::"
msgstr ""
"如果你正在使用 ``django.contrib.sessions.backends.db`` 后端，每个会话就会是一"
"个普通的 Django 模型。 ``Session`` 模型在 ``django/contrib/sessions/models."
"py`` 中定义。因为它就是一个普通模型，你可以使用普通的 Django 数据库 API 访问"
"会话。"

msgid ""
"Note that you'll need to call :meth:`~base_session.AbstractBaseSession."
"get_decoded()` to get the session dictionary. This is necessary because the "
"dictionary is stored in an encoded format::"
msgstr ""
"注意你将需要调用 :meth:`~base_session.AbstractBaseSession.get_decoded()` 来得"
"到会话字典。这是必须的，因为字典是按照编码格式存储的："

msgid "When sessions are saved"
msgstr "当保存会话时"

msgid ""
"By default, Django only saves to the session database when the session has "
"been modified -- that is if any of its dictionary values have been assigned "
"or deleted::"
msgstr ""
"默认情况下，Django 只在会话被修改后才会向会话数据库保存会话——也就是说，是否已"
"经分配或删除了它的任何字典值："

msgid ""
"In the last case of the above example, we can tell the session object "
"explicitly that it has been modified by setting the ``modified`` attribute "
"on the session object::"
msgstr ""
"在上面例子的最后一个例子中，我们可以通过在会话对象上设置 ``modified`` 属性来"
"明确地告诉会话对象它已经被修改："

msgid ""
"To change this default behavior, set the :setting:"
"`SESSION_SAVE_EVERY_REQUEST` setting to ``True``. When set to ``True``, "
"Django will save the session to the database on every single request."
msgstr ""
"要想改变这个默认行为，可以设置 :setting:`SESSION_SAVE_EVERY_REQUEST` 为 "
"``True`` 。当设置为 ``True`` 时，Django 会根据每个请求将会话保存到数据库中。"

msgid ""
"Note that the session cookie is only sent when a session has been created or "
"modified. If :setting:`SESSION_SAVE_EVERY_REQUEST` is ``True``, the session "
"cookie will be sent on every request."
msgstr ""
"注意，仅在会话被创建或修改时发送会话 cookie 。如果 :setting:"
"`SESSION_SAVE_EVERY_REQUEST` 为 ``True`` ，则会话cookie将在每次请求时发送。"

msgid ""
"Similarly, the ``expires`` part of a session cookie is updated each time the "
"session cookie is sent."
msgstr ""
"同样地，每次发送会话 cookie 时都会更新会话 cookie 的 ``expires`` 部分。"

msgid "The session is not saved if the response's status code is 500."
msgstr "如果响应状态代码为 500，会话不会被保存。"

msgid "Browser-length sessions vs. persistent sessions"
msgstr "Browser-length 会话 vs 持久会话"

msgid ""
"You can control whether the session framework uses browser-length sessions "
"vs. persistent sessions with the :setting:`SESSION_EXPIRE_AT_BROWSER_CLOSE` "
"setting."
msgstr ""
"你可以通过设置 :setting:`SESSION_EXPIRE_AT_BROWSER_CLOSE` 来控制会话框架是使"
"用 browser-length 会话还是持久会话。"

msgid ""
"By default, :setting:`SESSION_EXPIRE_AT_BROWSER_CLOSE` is set to ``False``, "
"which means session cookies will be stored in users' browsers for as long "
"as :setting:`SESSION_COOKIE_AGE`. Use this if you don't want people to have "
"to log in every time they open a browser."
msgstr ""
"默认情况下， :setting:`SESSION_EXPIRE_AT_BROWSER_CLOSE` 为 ``False`` ，这意味"
"着会话 cookies 将保存在用户浏览器中持续 :setting:`SESSION_COOKIE_AGE` 的时"
"间。如果你不想用户每次打开浏览器时必须登录，就用这个。"

msgid ""
"If :setting:`SESSION_EXPIRE_AT_BROWSER_CLOSE` is set to ``True``, Django "
"will use browser-length cookies -- cookies that expire as soon as the user "
"closes their browser. Use this if you want people to have to log in every "
"time they open a browser."
msgstr ""
"如果 :setting:`SESSION_EXPIRE_AT_BROWSER_CLOSE` 为 ``True``，Django 将使用 "
"browser-length cookies —— cookies 在用户关闭浏览器时过期。如果你想让用户每次"
"打开浏览器时必须登录，就用这个。"

msgid ""
"This setting is a global default and can be overwritten at a per-session "
"level by explicitly calling the :meth:`~backends.base.SessionBase."
"set_expiry` method of ``request.session`` as described above in `using "
"sessions in views`_."
msgstr ""
"这个设置是全局默认的，并且可以通过显式调用 ``request.session``  的 :meth:"
"`~backends.base.SessionBase.set_expiry` 在每个会话级别上覆盖，和之前的 "
"`using sessions in views`_ 里描述的一样。"

msgid ""
"Some browsers (Chrome, for example) provide settings that allow users to "
"continue browsing sessions after closing and re-opening the browser. In some "
"cases, this can interfere with the :setting:"
"`SESSION_EXPIRE_AT_BROWSER_CLOSE` setting and prevent sessions from expiring "
"on browser close. Please be aware of this while testing Django applications "
"which have the :setting:`SESSION_EXPIRE_AT_BROWSER_CLOSE` setting enabled."
msgstr ""
"有一些浏览器（比如谷歌浏览器）提供允许用户在关闭或重新打开浏览器后继续浏览会"
"话的设置。有时候，这会妨碍 :setting:`SESSION_EXPIRE_AT_BROWSER_CLOSE` 设置，"
"并且阻止会话在浏览器关闭时过期。如果开启了 :setting:"
"`SESSION_EXPIRE_AT_BROWSER_CLOSE` 设置，在测试 Django 程序时要注意这一点。"

msgid "Clearing the session store"
msgstr "清除会话存储"

msgid ""
"As users create new sessions on your website, session data can accumulate in "
"your session store. If you're using the database backend, the "
"``django_session`` database table will grow. If you're using the file "
"backend, your temporary directory will contain an increasing number of files."
msgstr ""
"当用户创建了新会话，会话数据会累积在会话存储中。如果你正在使用数据库后端，"
"``django_session`` 数据库表会增加。如果你使用的是文件后端，临时目录会包含新增"
"加的文件。"

msgid ""
"To understand this problem, consider what happens with the database backend. "
"When a user logs in, Django adds a row to the ``django_session`` database "
"table. Django updates this row each time the session data changes. If the "
"user logs out manually, Django deletes the row. But if the user does *not* "
"log out, the row never gets deleted. A similar process happens with the file "
"backend."
msgstr ""
"为了理解这个问题，要考虑数据库后端会发生什么。当用户登录时，Django 在 "
"``django_session`` 增加了一行。每次会话更改时，Django 会更新该行。如果用户手"
"动退出，Django 会删除该行。但如果用户不退出，该行就不会被删除。文件后端也是类"
"似的处理。"

msgid ""
"Django does *not* provide automatic purging of expired sessions. Therefore, "
"it's your job to purge expired sessions on a regular basis. Django provides "
"a clean-up management command for this purpose: :djadmin:`clearsessions`. "
"It's recommended to call this command on a regular basis, for example as a "
"daily cron job."
msgstr ""
"Django 没有提供过期会话自动清除的功能。因此，你需要定期清除过期会话。Django "
"提供了一个清除管理命令：:djadmin:`clearsessions` 。推荐在定期清除时使用该命"
"令，例如在日常的定时任务中。"

msgid ""
"Note that the cache backend isn't vulnerable to this problem, because caches "
"automatically delete stale data. Neither is the cookie backend, because the "
"session data is stored by the users' browsers."
msgstr ""
"注意缓存后端不受此问题的影响，因为缓存会自动删除过期数据。cookie 后端也一样，"
"因为会话数据通过浏览器存储。"

msgid "Settings"
msgstr "配置"

msgid ""
"A few :ref:`Django settings <settings-sessions>` give you control over "
"session behavior:"
msgstr ""
"一些可以用来控制会话行为的 :ref:`Django settings <settings-sessions>` ："

msgid ":setting:`SESSION_CACHE_ALIAS`"
msgstr ":setting:`SESSION_CACHE_ALIAS`"

msgid ":setting:`SESSION_COOKIE_AGE`"
msgstr ":setting:`SESSION_COOKIE_AGE`"

msgid ":setting:`SESSION_COOKIE_DOMAIN`"
msgstr ":setting:`SESSION_COOKIE_DOMAIN`"

msgid ":setting:`SESSION_COOKIE_HTTPONLY`"
msgstr ":setting:`SESSION_COOKIE_HTTPONLY`"

msgid ":setting:`SESSION_COOKIE_NAME`"
msgstr ":setting:`SESSION_COOKIE_NAME`"

msgid ":setting:`SESSION_COOKIE_PATH`"
msgstr ":setting:`SESSION_COOKIE_PATH`"

msgid ":setting:`SESSION_COOKIE_SAMESITE`"
msgstr ":setting:`SESSION_COOKIE_SAMESITE`"

msgid ":setting:`SESSION_COOKIE_SECURE`"
msgstr ":setting:`SESSION_COOKIE_SECURE`"

msgid ":setting:`SESSION_ENGINE`"
msgstr ":setting:`SESSION_ENGINE`"

msgid ":setting:`SESSION_EXPIRE_AT_BROWSER_CLOSE`"
msgstr ":setting:`SESSION_EXPIRE_AT_BROWSER_CLOSE`"

msgid ":setting:`SESSION_FILE_PATH`"
msgstr ":setting:`SESSION_FILE_PATH`"

msgid ":setting:`SESSION_SAVE_EVERY_REQUEST`"
msgstr ":setting:`SESSION_SAVE_EVERY_REQUEST`"

msgid ":setting:`SESSION_SERIALIZER`"
msgstr ":setting:`SESSION_SERIALIZER`"

msgid "Session security"
msgstr "会话安全"

msgid ""
"Subdomains within a site are able to set cookies on the client for the whole "
"domain. This makes session fixation possible if cookies are permitted from "
"subdomains not controlled by trusted users."
msgstr ""
"站点内的子域可以在客户端上为整个域设置 cookies。如果 cookies 允许来自不受新人"
"用户控制的子域，这将使会话固定成为可能。"

msgid ""
"For example, an attacker could log into ``good.example.com`` and get a valid "
"session for their account. If the attacker has control over ``bad.example."
"com``, they can use it to send their session key to you since a subdomain is "
"permitted to set cookies on ``*.example.com``. When you visit ``good.example."
"com``, you'll be logged in as the attacker and might inadvertently enter "
"your sensitive personal data (e.g. credit card info) into the attacker's "
"account."
msgstr ""
"比如，一个攻击者登入了 ``good.example.com`` 并且为账户获得了一个有效会话。如"
"果攻击者控制了 ``bad.example.com`` ，他们可以使用它来发送他们的会话秘钥给你"
"（会话秘钥是保证用户跟其它计算机或者两台计算机之间安全通信会话而随机产生的加"
"密和解密密钥），因为子域已经允许在 ``*.example.com`` 上设置 cookies 。"

msgid ""
"Another possible attack would be if ``good.example.com`` sets its :setting:"
"`SESSION_COOKIE_DOMAIN` to ``\"example.com\"`` which would cause session "
"cookies from that site to be sent to ``bad.example.com``."
msgstr ""
"另一个可能的攻击是如果 ``good.example.com`` 设置它的 :setting:"
"`SESSION_COOKIE_DOMAIN` 为 ``\"example.com\"`` ，会导致来自站点的会话 "
"cookies 发送到 ``bad.example.com`` 。"

msgid "Technical details"
msgstr "技术细节"

msgid ""
"The session dictionary accepts any :mod:`json` serializable value when "
"using :class:`~django.contrib.sessions.serializers.JSONSerializer` or any "
"picklable Python object when using :class:`~django.contrib.sessions."
"serializers.PickleSerializer`. See the :mod:`pickle` module for more "
"information."
msgstr ""
"该会话目录在使用 :class:`~django.contrib.sessions.serializers."
"JSONSerializer` 时接受任何 :mod:`json` 序列化值或者当使用 :class:`~django."
"contrib.sessions.serializers.PickleSerializer` 时接受任何 picklable Python对"
"象。查看 :mod:`pickle` 模块获取更多信息。"

msgid "Session data is stored in a database table named ``django_session`` ."
msgstr "会话数据保存在名为 ``django_session`` 的数据库表中。"

msgid ""
"Django only sends a cookie if it needs to. If you don't set any session "
"data, it won't send a session cookie."
msgstr ""
"Django 只有它需要的时候才会发送 cookie 。如果你不想设置任何会话数据，它将不会"
"发送会话 cookie 。"

msgid "The ``SessionStore`` object"
msgstr "``SessionStore`` 对象"

msgid ""
"When working with sessions internally, Django uses a session store object "
"from the corresponding session engine. By convention, the session store "
"object class is named ``SessionStore`` and is located in the module "
"designated by :setting:`SESSION_ENGINE`."
msgstr ""
"当内部使用会话时，Django 使用来自相应会话引擎的会话存储对象。按照惯例，会话存"
"储对象类名为 ``SessionStore`` ，并且位于 :setting:`SESSION_ENGINE` 的模块中。"

msgid ""
"All ``SessionStore`` classes available in Django inherit from :class:"
"`~backends.base.SessionBase` and implement data manipulation methods, namely:"
msgstr ""
"所有 ``SessionStore`` 类继承了 :class:`~backends.base.SessionBase` 并且实现了"
"数据操作方法，即："

msgid "``exists()``"
msgstr "``exists()``"

msgid "``create()``"
msgstr "``create()``"

msgid "``save()``"
msgstr "``save()``"

msgid "``delete()``"
msgstr "``delete()``"

msgid "``load()``"
msgstr "``load()``"

msgid ":meth:`~backends.base.SessionBase.clear_expired`"
msgstr ":meth:`~backends.base.SessionBase.clear_expired`"

msgid ""
"In order to build a custom session engine or to customize an existing one, "
"you may create a new class inheriting from :class:`~backends.base."
"SessionBase` or any other existing ``SessionStore`` class."
msgstr ""
"为了搭建自定义的会话引擎或自定义已有的引擎，你可以创建一个继承自 :class:"
"`~backends.base.SessionBase` 的新类或任何其他已存在的 ``SessionStore`` 类。"

msgid ""
"You can extend the session engines, but doing so with database-backed "
"session engines generally requires some extra effort (see the next section "
"for details)."
msgstr ""
"你可以扩展会话引擎，但对于使用数据库支持的会话引擎通常需要额外的功夫（查看下"
"节来获取更多详情）。"

msgid "Extending database-backed session engines"
msgstr "扩展数据库支持的会话引擎"

msgid ""
"Creating a custom database-backed session engine built upon those included "
"in Django (namely ``db`` and ``cached_db``) may be done by inheriting :class:"
"`~base_session.AbstractBaseSession` and either ``SessionStore`` class."
msgstr ""
"可以通过继承 :class:`~base_session.AbstractBaseSession` 和 ``SessionStore``类"
"来创建基于Django中包含的自定义数据库支持的会话引擎(即 ``db`` 和 "
"``cached_db`` )。"

msgid ""
"``AbstractBaseSession`` and ``BaseSessionManager`` are importable from "
"``django.contrib.sessions.base_session`` so that they can be imported "
"without including ``django.contrib.sessions`` in :setting:`INSTALLED_APPS`."
msgstr ""
"``AbstractBaseSession`` 和 ``BaseSessionManager`` 可以从 ``django.contrib."
"sessions.base_session`` 导入，因此它们可以在  :setting:`INSTALLED_APPS` 不包"
"含 ``django.contrib.sessions`` 的情况下导入。"

msgid "The abstract base session model."
msgstr "抽象基本会话模型。"

msgid ""
"Primary key. The field itself may contain up to 40 characters. The current "
"implementation generates a 32-character string (a random sequence of digits "
"and lowercase ASCII letters)."
msgstr ""
"主键。字段本身可能包含多达40个字符。当前实现生成一个32个字符的字符串（一个随"
"机的数字序列和小写的ascii字母）。"

msgid "A string containing an encoded and serialized session dictionary."
msgstr "包含编码和序列化会话字典的字符串。"

msgid "A datetime designating when the session expires."
msgstr "指定会话何时到期的日期时间。"

msgid ""
"Expired sessions are not available to a user, however, they may still be "
"stored in the database until the :djadmin:`clearsessions` management command "
"is run."
msgstr ""
"但是，过期的会话对用户不可用，但在运行 :djadmin:`clearsessions` 管理命令之"
"前，它们仍可能存储在数据库中。"

msgid "Returns a session store class to be used with this session model."
msgstr "返回要与此会话模型一起使用的会话存储类。"

msgid "Returns decoded session data."
msgstr "返回解码的会话数据。"

msgid "Decoding is performed by the session store class."
msgstr "解码由会话存储类执行。"

msgid ""
"You can also customize the model manager by subclassing :class:`~django."
"contrib.sessions.base_session.BaseSessionManager`:"
msgstr ""
"还可以通过子类 :class:`~django.contrib.sessions.base_session."
"BaseSessionManager` 自定义模型管理器。"

msgid ""
"Returns the given session dictionary serialized and encoded as a string."
msgstr "返回序列化并编码为字符串的给定会话字典。"

msgid "Encoding is performed by the session store class tied to a model class."
msgstr "编码由绑定到模型类的会话存储类执行。"

msgid ""
"Saves session data for a provided session key, or deletes the session in "
"case the data is empty."
msgstr "为提供的会话密钥保存会话数据，或在数据为空时删除会话。"

msgid ""
"Customization of ``SessionStore`` classes is achieved by overriding methods "
"and properties described below:"
msgstr "通过重写以下描述的方法和属性，实现了 ``SessionStore`` 类的定制："

msgid "Implements database-backed session store."
msgstr "实现数据库支持的会话存储。"

msgid "Override this method to return a custom session model if you need one."
msgstr "如果需要的话，重写此方法以返回自定义会话模型。"

msgid ""
"Returns a new instance of the session model object, which represents the "
"current session state."
msgstr "返回会话模型对象的新实例，该实例表示当前会话状态。"

msgid ""
"Overriding this method provides the ability to modify session model data "
"before it's saved to database."
msgstr "重写此方法提供了在将会话模型数据保存到数据库之前修改它的能力。"

msgid "Implements cached database-backed session store."
msgstr "实现缓存数据库支持的会话存储。"

msgid "A prefix added to a session key to build a cache key string."
msgstr "添加到会话键中以生成缓存键字符串的前缀。"

msgid "Example"
msgstr "例如"

msgid ""
"The example below shows a custom database-backed session engine that "
"includes an additional database column to store an account ID (thus "
"providing an option to query the database for all active sessions for an "
"account)::"
msgstr ""
"下面的示例显示了一个自定义数据库支持的会话引擎，它包括一个用于存储帐户id的附"
"加数据库列（从而提供了一个选项，用于查询数据库中帐户的所有活动会话）："

msgid ""
"If you are migrating from the Django's built-in ``cached_db`` session store "
"to a custom one based on ``cached_db``, you should override the cache key "
"prefix in order to prevent a namespace clash::"
msgstr ""
"如果要从Django的内置 ``cached_db`` 会话存储迁移到基于``cached_db`` 的自定义存"
"储，则应重写缓存键前缀，以防止名称空间冲突："

msgid "Session IDs in URLs"
msgstr "URL中的会话ID"

msgid ""
"The Django sessions framework is entirely, and solely, cookie-based. It does "
"not fall back to putting session IDs in URLs as a last resort, as PHP does. "
"This is an intentional design decision. Not only does that behavior make "
"URLs ugly, it makes your site vulnerable to session-ID theft via the "
"\"Referer\" header."
msgstr ""
"Django会话框架完全是基于cookie的。 正如PHP所做的那样，它不会回退到将会话ID放"
"置在URL中作为最后的手段。 这是一个有意设计的决定。 这种行为不仅使URL变得很难"
"看，而且使您的站点容易受到会话ID的盗用。"

msgid "Django shortcut functions"
msgstr "Django 便捷函数"

msgid ""
"The package ``django.shortcuts`` collects helper functions and classes that "
"\"span\" multiple levels of MVC. In other words, these functions/classes "
"introduce controlled coupling for convenience's sake."
msgstr ""
"包 ``django.shortcuts`` 收集助手函数和“跨”多级mvc的类，换句话说，为了方便起"
"见，这些函数/类引入受控耦合。"

msgid "``render()``"
msgstr "``render()``"

msgid ""
"Combines a given template with a given context dictionary and returns an :"
"class:`~django.http.HttpResponse` object with that rendered text."
msgstr ""
"将给定的模板与给定的上下文字典组合在一起，并以渲染的文本返回一个 :class:"
"`~django.http.HttpResponse` 对象。"

msgid ""
"Django does not provide a shortcut function which returns a :class:`~django."
"template.response.TemplateResponse` because the constructor of :class:"
"`~django.template.response.TemplateResponse` offers the same level of "
"convenience as :func:`render()`."
msgstr ""
"Django没有提供返回 :class:`~django.template.response.TemplateResponse` 的便捷"
"函数，因为 :class:`~django.template.response.TemplateResponse` 的构造函数提供"
"了与 :func:`render()` 同等程度的便利。"

msgid "Required arguments"
msgstr "必选参数"

msgid "``request``"
msgstr "``request``"

msgid "The request object used to generate this response."
msgstr "用于生成此响应的请求对象。"

msgid "``template_name``"
msgstr "``template_name``"

msgid ""
"The full name of a template to use or sequence of template names. If a "
"sequence is given, the first template that exists will be used. See the :ref:"
"`template loading documentation <template-loading>` for more information on "
"how templates are found."
msgstr ""
"要使用的模板的全名或模板名称的序列。如果给定一个序列，则将使用存在的第一个模"
"板。有关如何查找模板的更多信息，请参见 :ref:`模板加载文档 <template-"
"loading>` 。"

msgid "Optional arguments"
msgstr "可选参数"

msgid "``context``"
msgstr "``context``"

msgid ""
"A dictionary of values to add to the template context. By default, this is "
"an empty dictionary. If a value in the dictionary is callable, the view will "
"call it just before rendering the template."
msgstr ""
"要添加到模板上下文的值的字典。 默认情况下，这是一个空的字典。 如果字典中的值"
"是可调用的，则视图将在渲染模板之前调用它。"

msgid "``content_type``"
msgstr "``content_type``"

msgid ""
"The MIME type to use for the resulting document. Defaults to ``'text/html'``."
msgstr "用于结果文档的 MIME 类型。默认 ``'text/html'`` 。"

msgid "``status``"
msgstr "``status``"

msgid "The status code for the response. Defaults to ``200``."
msgstr "响应的状态码默认为 ``200``。"

msgid "``using``"
msgstr "``using``"

msgid ""
"The :setting:`NAME <TEMPLATES-NAME>` of a template engine to use for loading "
"the template."
msgstr "用于加载模板的模板引擎的 :setting:`NAME <TEMPLATES-NAME>` 。"

msgid ""
"The following example renders the template ``myapp/index.html`` with the "
"MIME type :mimetype:`application/xhtml+xml`::"
msgstr ""
"下面的示例使用 MIME 类型呈现模板 ``myapp/index.html`` :mimetype:`application/"
"xhtml+xml` ："

msgid "This example is equivalent to::"
msgstr "此示例相当于："

msgid "``redirect()``"
msgstr "``redirect()``"

msgid ""
"Returns an :class:`~django.http.HttpResponseRedirect` to the appropriate URL "
"for the arguments passed."
msgstr ""
"返回一个 :class:`~django.http.HttpResponseRedirect`，指向传递参数的适当 URL。"

msgid "The arguments could be:"
msgstr "参数可以是："

msgid ""
"A model: the model's :meth:`~django.db.models.Model.get_absolute_url()` "
"function will be called."
msgstr ""
"一个模型：模型的 :meth:`~django.db.models.Model.get_absolute_url()` 函数将被"
"调用。"

msgid ""
"A view name, possibly with arguments: :func:`~django.urls.reverse` will be "
"used to reverse-resolve the name."
msgstr ""
"视图名，可能带有的参数：:func:`~django.urls.reverse` 将被用于反向解析名称。"

msgid ""
"An absolute or relative URL, which will be used as-is for the redirect "
"location."
msgstr "一个绝对或相对 URL，将按原样用作重定向位置。"

msgid ""
"By default issues a temporary redirect; pass ``permanent=True`` to issue a "
"permanent redirect."
msgstr "默认情况下发出临时重定向；通过传递 ``permanent=True`` 发出永久重定向。"

msgid "You can use the :func:`redirect` function in a number of ways."
msgstr "你可以通过多种方法使用 :func:`redirect` 函数。"

msgid ""
"By passing some object; that object's :meth:`~django.db.models.Model."
"get_absolute_url` method will be called to figure out the redirect URL::"
msgstr ""
"传递对象，对象的 :meth:`~django.db.models.Model.get_absolute_url` 方法将被调"
"用来指向重定向地址："

msgid ""
"By passing the name of a view and optionally some positional or keyword "
"arguments; the URL will be reverse resolved using the :func:`~django.urls."
"reverse` method::"
msgstr ""
"传递视图名和一些可选的位置或关键字参数；URL 将使用 :func:`~django.urls."
"reverse` 方法来反向解析："

msgid "By passing a hardcoded URL to redirect to::"
msgstr "传递硬编码 URL 来重定向："

msgid "This also works with full URLs::"
msgstr "这也适用于完整的 URL ："

msgid ""
"By default, :func:`redirect` returns a temporary redirect. All of the above "
"forms accept a ``permanent`` argument; if set to ``True`` a permanent "
"redirect will be returned::"
msgstr ""
"默认情况下，:func:`redirect` 返回临时重定向。所有以上形式都接受 "
"``permanent`` 参数；如果设置为 ``True`` 会返回一个永久重定向："

msgid "``get_object_or_404()``"
msgstr "``get_object_or_404()``"

msgid ""
"Calls :meth:`~django.db.models.query.QuerySet.get()` on a given model "
"manager, but it raises :class:`~django.http.Http404` instead of the model's :"
"class:`~django.db.models.Model.DoesNotExist` exception."
msgstr ""
"在给定的模型管理器( model manager) 上调用 :meth:`~django.db.models.query."
"QuerySet.get()` ，但它会引发 :class:`~django.http.Http404` 而不是模型的 :"
"class:`~django.db.models.Model.DoesNotExist` 异常。"

msgid "``klass``"
msgstr "``klass``"

msgid ""
"A :class:`~django.db.models.Model` class, a :class:`~django.db.models."
"Manager`, or a :class:`~django.db.models.query.QuerySet` instance from which "
"to get the object."
msgstr ""
"从中获取对象的 :class:`~django.db.models.Model` 类， :class:`~django.db."
"models.Manager` ，或  :class:`~django.db.models.query.QuerySet` 实例。"

msgid "``**kwargs``"
msgstr "``**kwargs``"

msgid ""
"Lookup parameters, which should be in the format accepted by ``get()`` and "
"``filter()``."
msgstr "查询参数，应采用 ``get()`` 和 ``filter()`` 接受的格式。"

msgid ""
"The following example gets the object with the primary key of 1 from "
"``MyModel``::"
msgstr "下面的例子是展示从 ``MyModel`` 中获取主键为1的对象："

msgid ""
"The most common use case is to pass a :class:`~django.db.models.Model`, as "
"shown above. However, you can also pass a :class:`~django.db.models.query."
"QuerySet` instance::"
msgstr ""
"如上所示，最常用的使用案例是传递 :class:`~django.db.models.Model` 。但是，你"
"也可以传递一个 :class:`~django.db.models.query.QuerySet` 实例："

msgid "The above example is a bit contrived since it's equivalent to doing::"
msgstr "以上例子有点冗长，因为它等同于："

msgid ""
"but it can be useful if you are passed the ``queryset`` variable from "
"somewhere else."
msgstr "但如果你是从其他地方传递的 ``queryset`` 变量，那它会很有用。"

msgid ""
"Finally, you can also use a :class:`~django.db.models.Manager`. This is "
"useful for example if you have a :ref:`custom manager<custom-managers>`::"
msgstr ""
"最后，你也可以使用 :class:`~django.db.models.Manager` 。如果你有自定义管理器"
"( :ref:`custom manager<custom-managers>` )会很有用："

msgid ""
"You can also use :class:`related managers<django.db.models.fields.related."
"RelatedManager>`::"
msgstr ""
"你也可以使用关联管理器( :class:`related managers<django.db.models.fields."
"related.RelatedManager>` )："

msgid ""
"Note: As with ``get()``, a :class:`~django.core.exceptions."
"MultipleObjectsReturned` exception will be raised if more than one object is "
"found."
msgstr ""
"注意：与 ``get()`` 一样，如果查询结果有多个对象，那么会引发 :class:`~django."
"core.exceptions.MultipleObjectsReturned` 异常。"

msgid "``get_list_or_404()``"
msgstr "``get_list_or_404()``"

msgid ""
"Returns the result of :meth:`~django.db.models.query.QuerySet.filter()` on a "
"given model manager cast to a list, raising :class:`~django.http.Http404` if "
"the resulting list is empty."
msgstr ""
"返回给定模型管理器上 :meth:`~django.db.models.query.QuerySet.filter()` 转换为"
"列表的结果，如果结果列表为空，则引发 :class:`~django.http.Http404`。"

msgid ""
"A :class:`~django.db.models.Model`, :class:`~django.db.models.Manager` or :"
"class:`~django.db.models.query.QuerySet` instance from which to get the list."
msgstr ""
"从中获取列表的 :class:`~django.db.models.Model` ，:class:`~django.db.models."
"Manager` 或 :class:`~django.db.models.query.QuerySet` 实例。"

msgid "The following example gets all published objects from ``MyModel``::"
msgstr "下面的例子展示从 ``MyModel`` 中获取所有 published=True 的对象："

msgid "URL dispatcher"
msgstr "URL调度器"

msgid ""
"A clean, elegant URL scheme is an important detail in a high-quality web "
"application. Django lets you design URLs however you want, with no framework "
"limitations."
msgstr ""

msgid ""
"See `Cool URIs don't change`_, by World Wide Web creator Tim Berners-Lee, "
"for excellent arguments on why URLs should be clean and usable."
msgstr ""
"参见万维网的发明者 Berners-Lee 的 `Cool URIs don't change`_，里面有关于为什么"
"URL 应该保持整洁和有意义的卓越论证。"

msgid ""
"To design URLs for an app, you create a Python module informally called a "
"**URLconf** (URL configuration). This module is pure Python code and is a "
"mapping between URL path expressions to Python functions (your views)."
msgstr ""
"为了给一个应用设计 URL，你需要创建一个 Python 模块，通常被称为 **URLconf** "
"（URL configuration）。这个模块是纯粹的 Python 代码，包含 URL 模式（简单的正"
"则表达式）到 Python 函数（你的视图）的简单映射。"

msgid ""
"This mapping can be as short or as long as needed. It can reference other "
"mappings. And, because it's pure Python code, it can be constructed "
"dynamically."
msgstr ""
"映射可短可长，随便你。它可以引用其它的映射。而且，因为它是纯粹的 Python 代"
"码，它可以动态构造。"

msgid ""
"Django also provides a way to translate URLs according to the active "
"language. See the :ref:`internationalization documentation <url-"
"internationalization>` for more information."
msgstr ""
"Django 还提供根据当前语言翻译 URL 的一种方法。更多信息参见 :ref:`国际化文档 "
"<url-internationalization>`。"

msgid "How Django processes a request"
msgstr "Django 如何处理一个请求"

msgid ""
"When a user requests a page from your Django-powered site, this is the "
"algorithm the system follows to determine which Python code to execute:"
msgstr ""
"当一个用户请求 Django 站点的一个页面，下面是 Django 系统决定执行哪个 Python "
"代码使用的算法："

msgid ""
"Django determines the root URLconf module to use. Ordinarily, this is the "
"value of the :setting:`ROOT_URLCONF` setting, but if the incoming "
"``HttpRequest`` object has a :attr:`~django.http.HttpRequest.urlconf` "
"attribute (set by middleware), its value will be used in place of the :"
"setting:`ROOT_URLCONF` setting."
msgstr ""
"Django 确定使用根 URLconf 模块。通常，这是 :setting:`ROOT_URLCONF` 设置的值，"
"但如果传入 ``HttpRequest`` 对象拥有 :attr:`~django.http.HttpRequest.urlconf` "
"属性（通过中间件设置），它的值将被用来代替 :setting:`ROOT_URLCONF` 设置。"

msgid ""
"Django loads that Python module and looks for the variable ``urlpatterns``. "
"This should be a :term:`sequence` of :func:`django.urls.path` and/or :func:"
"`django.urls.re_path` instances."
msgstr ""
"Django 加载该 Python 模块并寻找可用的 ``urlpatterns`` 。它是 :func:`django."
"urls.path` 和(或) :func:`django.urls.re_path` 实例的序列(:term:`sequence`)。"

msgid ""
"Django runs through each URL pattern, in order, and stops at the first one "
"that matches the requested URL, matching against :attr:`~django.http."
"HttpRequest.path_info`."
msgstr ""
"Django 会按顺序遍历每个 URL 模式，然后会在所请求的URL匹配到第一个模式后停止，"
"并与 :attr:`~django.http.HttpRequest.path_info` 匹配。"

msgid ""
"Once one of the URL patterns matches, Django imports and calls the given "
"view, which is a Python function (or a :doc:`class-based view </topics/class-"
"based-views/index>`). The view gets passed the following arguments:"
msgstr ""
"一旦有 URL 匹配成功，Djagno 导入并调用相关的视图，这个视图是一个Python 函数"
"（或基于类的视图 :doc:`class-based view </topics/class-based-views/"
"index>` ）。视图会获得如下参数："

msgid "An instance of :class:`~django.http.HttpRequest`."
msgstr "一个 :class:`~django.http.HttpRequest` 实例。"

msgid ""
"If the matched URL pattern contained no named groups, then the matches from "
"the regular expression are provided as positional arguments."
msgstr ""
"如果匹配的 URL 包含未命名组，那么来自正则表达式中的匹配项将作为位置参数提供。"

msgid ""
"The keyword arguments are made up of any named parts matched by the path "
"expression that are provided, overridden by any arguments specified in the "
"optional ``kwargs`` argument to :func:`django.urls.path` or :func:`django."
"urls.re_path`."
msgstr ""
"关键字参数由路径表达式匹配的任何命名部分组成，并由 :func:`django.urls.path` "
"或 :func:`django.urls.re_path` 的可选 ``kwargs`` 参数中指定的任何参数覆盖。"

msgid ""
"If no URL pattern matches, or if an exception is raised during any point in "
"this process, Django invokes an appropriate error-handling view. See `Error "
"handling`_ below."
msgstr ""
"如果没有 URL 被匹配，或者匹配过程中出现了异常，Django 会调用一个适当的错误处"
"理视图。参加下面的错误处理(  `Error handling`_ )。"

msgid "Here's a sample URLconf::"
msgstr "下面是一个简单的 URLconf:: "

msgid "To capture a value from the URL, use angle brackets."
msgstr "要从 URL 中取值，使用尖括号。"

msgid ""
"Captured values can optionally include a converter type. For example, use "
"``<int:name>`` to capture an integer parameter. If a converter isn't "
"included, any string, excluding a ``/`` character, is matched."
msgstr ""
"捕获的值可以选择性地包含转换器类型。比如，使用 ``<int:name>`` 来捕获整型参"
"数。如果不包含转换器，则会匹配除了 ``/`` 外的任何字符。"

msgid ""
"There's no need to add a leading slash, because every URL has that. For "
"example, it's ``articles``, not ``/articles``."
msgstr ""
"这里不需要添加反斜杠，因为每个 URL 都有。比如，应该是 ``articles`` 而不是 ``/"
"articles`` 。"

msgid "Example requests:"
msgstr "一些请求的例子："

msgid ""
"A request to ``/articles/2005/03/`` would match the third entry in the list. "
"Django would call the function ``views.month_archive(request, year=2005, "
"month=3)``."
msgstr ""
"``/articles/2005/03/`` 会匹配 URL 列表中的第三项。Django 会调用函数 ``views."
"month_archive(request, year=2005, month=3)`` 。"

msgid ""
"``/articles/2003/`` would match the first pattern in the list, not the "
"second one, because the patterns are tested in order, and the first one is "
"the first test to pass. Feel free to exploit the ordering to insert special "
"cases like this. Here, Django would call the function ``views."
"special_case_2003(request)``"
msgstr ""
"``/articles/2003/`` 将匹配列表中的第一个模式不是第二个，因为模式按顺序匹配，"
"第一个会首先测试是否匹配。请像这样自由插入一些特殊的情况来探测匹配的次序。在"
"这里 Django 会调用函数 ``views.special_case_2003(request)`` "

msgid ""
"``/articles/2003`` would not match any of these patterns, because each "
"pattern requires that the URL end with a slash."
msgstr ""
"``/articles/2003`` 不匹配任何一个模式，因为每个模式要求 URL 以一个斜线结尾。"

msgid ""
"``/articles/2003/03/building-a-django-site/`` would match the final pattern. "
"Django would call the function ``views.article_detail(request, year=2003, "
"month=3, slug=\"building-a-django-site\")``."
msgstr ""
"``/articles/2003/03/building-a-django-site/`` 会匹配 URL 列表中的最后一项。"
"Django 会调用函数 ``views.article_detail(request, year=2003, month=3, slug="
"\"building-a-django-site\")`` 。"

msgid "Path converters"
msgstr "路径转换器"

msgid "The following path converters are available by default:"
msgstr "下面的路径转换器在默认情况下是有效的："

msgid ""
"``str`` - Matches any non-empty string, excluding the path separator, "
"``'/'``. This is the default if a converter isn't included in the expression."
msgstr ""
"``str`` - 匹配除了 ``'/'`` 之外的非空字符串。如果表达式内不包含转换器，则会默"
"认匹配字符串。"

msgid "``int`` - Matches zero or any positive integer. Returns an ``int``."
msgstr "``int`` - 匹配 0 或任何正整数。返回一个 ``int`` 。"

msgid ""
"``slug`` - Matches any slug string consisting of ASCII letters or numbers, "
"plus the hyphen and underscore characters. For example, ``building-your-1st-"
"django-site``."
msgstr ""
"``slug`` - 匹配任意由 ASCII 字母或数字以及连字符和下划线组成的短标签。比如，"
"``building-your-1st-django-site`` 。"

msgid ""
"``uuid`` - Matches a formatted UUID. To prevent multiple URLs from mapping "
"to the same page, dashes must be included and letters must be lowercase. For "
"example, ``075194d3-6885-417e-a8a8-6c931e272f00``. Returns a :class:`~uuid."
"UUID` instance."
msgstr ""
"``uuid`` - 匹配一个格式化的 UUID 。为了防止多个 URL 映射到同一个页面，必须包"
"含破折号并且字符都为小写。比如，``075194d3-6885-417e-a8a8-6c931e272f00``。返"
"回一个 :class:`~uuid.UUID` 实例。"

msgid ""
"``path`` - Matches any non-empty string, including the path separator, "
"``'/'``. This allows you to match against a complete URL path rather than a "
"segment of a URL path as with ``str``."
msgstr ""
"``path`` - 匹配非空字段，包括路径分隔符 ``'/'`` 。它允许你匹配完整的 URL 路径"
"而不是像 ``str`` 那样匹配 URL 的一部分。"

msgid "Registering custom path converters"
msgstr "注册自定义的路径转换器"

msgid ""
"For more complex matching requirements, you can define your own path "
"converters."
msgstr "对于更复杂的匹配需求，你能定义你自己的路径转换器。"

msgid "A converter is a class that includes the following:"
msgstr "转换器是一个类，包含如下内容："

msgid "A ``regex`` class attribute, as a string."
msgstr "字符串形式的 ``regex`` 类属性。"

msgid ""
"A ``to_python(self, value)`` method, which handles converting the matched "
"string into the type that should be passed to the view function. It should "
"raise ``ValueError`` if it can't convert the given value. A ``ValueError`` "
"is interpreted as no match and as a consequence a 404 response is sent to "
"the user unless another URL pattern matches."
msgstr ""
"``to_python(self, value)`` 方法，用来处理匹配的字符串转换为传递到函数的类型。"
"如果没有转换为给定的值，它应该会引发 ``ValueError`` 。``ValueError`` 说明没有"
"匹配成功，因此除非另一个 URL 模式匹配成功，否则会向用户发送404响应。"

msgid ""
"A ``to_url(self, value)`` method, which handles converting the Python type "
"into a string to be used in the URL. It should raise ``ValueError`` if it "
"can't convert the given value. A ``ValueError`` is interpreted as no match "
"and as a consequence :func:`~django.urls.reverse` will raise :class:`~django."
"urls.NoReverseMatch` unless another URL pattern matches."
msgstr ""
"一个 ``to_url(self, value)`` 方法，它将处理 Python 类型转换为字符串以用于 "
"URL 中。如果不能转换给定的值，它应该引发 ``ValueError``。``ValueError`` 被解"
"释为无匹配项，因此 :func:`~django.urls.reverse` 将引发 :class:`~django.urls."
"NoReverseMatch`，除非有其他 URL 模式匹配。"

msgid ""
"Register custom converter classes in your URLconf using :func:`~django.urls."
"register_converter`::"
msgstr ""
"在 URLconf 中使用 :func:`~django.urls.register_converter` 来注册自定义的转换"
"器类："

msgid "Using regular expressions"
msgstr "使用正则表达式"

msgid ""
"If the paths and converters syntax isn't sufficient for defining your URL "
"patterns, you can also use regular expressions. To do so, use :func:`~django."
"urls.re_path` instead of :func:`~django.urls.path`."
msgstr ""
"如果路径和转化器语法不能很好的定义你的 URL 模式，你可以可以使用正则表达式。如"
"果要这样做，请使用 :func:`~django.urls.re_path` 而不是 :func:`~django.urls."
"path` 。"

msgid ""
"In Python regular expressions, the syntax for named regular expression "
"groups is ``(?P<name>pattern)``, where ``name`` is the name of the group and "
"``pattern`` is some pattern to match."
msgstr ""
"在 Python 正则表达式中，命名正则表达式组的语法是 ``(?P<name>pattern)`` ，其"
"中 ``name`` 是组名，``pattern`` 是要匹配的模式。"

msgid ""
"Here's the example URLconf from earlier, rewritten using regular "
"expressions::"
msgstr "这里是先前 URLconf 的一些例子，现在用正则表达式重写一下："

msgid ""
"This accomplishes roughly the same thing as the previous example, except:"
msgstr "这实现了与前面示例大致相同的功能，除了:"

msgid ""
"The exact URLs that will match are slightly more constrained. For example, "
"the year 10000 will no longer match since the year integers are constrained "
"to be exactly four digits long."
msgstr ""
"将要匹配的 URLs 将稍受限制。比如，10000 年将不在匹配，因为 year 被限制长度为"
"4。"

msgid ""
"Each captured argument is sent to the view as a string, regardless of what "
"sort of match the regular expression makes."
msgstr "无论正则表达式进行哪种匹配，每个捕获的参数都作为字符串发送到视图。"

msgid ""
"When switching from using :func:`~django.urls.path` to :func:`~django.urls."
"re_path` or vice versa, it's particularly important to be aware that the "
"type of the view arguments may change, and so you may need to adapt your "
"views."
msgstr ""
"当从使用 :func:`~django.urls.path` 切换到 :func:`~django.urls.re_path` （反之"
"亦然），要特别注意，视图参数类型可能发生变化，你可能需要调整你的视图。"

msgid "Using unnamed regular expression groups"
msgstr "使用未命名的正则表达式组"

msgid ""
"As well as the named group syntax, e.g. ``(?P<year>[0-9]{4})``, you can also "
"use the shorter unnamed group, e.g. ``([0-9]{4})``."
msgstr ""
"还有命名组语法，例如 ``(?P<year>[0-9]{4})`` ，你也可以使用更短的未命名组，例"
"如 ``([0-9]{4})`` 。"

msgid ""
"This usage isn't particularly recommended as it makes it easier to "
"accidentally introduce errors between the intended meaning of a match and "
"the arguments of the view."
msgstr ""
"不是特别推荐这个用法，因为它会更容易在匹配的预期含义和视图参数之间引发错误。"

msgid ""
"In either case, using only one style within a given regex is recommended. "
"When both styles are mixed, any unnamed groups are ignored and only named "
"groups are passed to the view function."
msgstr ""
"在任何情况下，推荐在给定的正则表达式里只使用一个样式。当混杂两种样式时，任何"
"未命名的组都会被忽略，而且只有命名的组才会传递给视图函数。"

msgid "Nested arguments"
msgstr "嵌套参数"

msgid ""
"Regular expressions allow nested arguments, and Django will resolve them and "
"pass them to the view. When reversing, Django will try to fill in all outer "
"captured arguments, ignoring any nested captured arguments. Consider the "
"following URL patterns which optionally take a page argument::"
msgstr ""
"正则表达式允许嵌套参数，Django 将处理它们并传递给视图。当转换时，Django 将试"
"着填充给所有外部捕捉参数，忽略任何嵌套捕捉参数。考虑下面可选的带有页面参数的 "
"URL 模式："

msgid ""
"Both patterns use nested arguments and will resolve: for example, ``blog/"
"page-2/`` will result in a match to ``blog_articles`` with two positional "
"arguments: ``page-2/`` and ``2``. The second pattern for ``comments`` will "
"match ``comments/page-2/`` with keyword argument ``page_number`` set to 2. "
"The outer argument in this case is a non-capturing argument ``(?:...)``."
msgstr ""
"两个模式使用嵌套参数，并处理：例如, ``blog/page-2/`` 将匹配给 "
"``blog_articles`` 并带有2个参数：``page-2/`` 和 ``2`` 。第二个模式为 "
"``comments`` 匹配 ``comments/page-2/`` 并带有设置为2的关键参数 "
"``page_number`` 。这个案例里的外部参数是一个非捕捉参数 ``(?:...)`` 。"

msgid ""
"The ``blog_articles`` view needs the outermost captured argument to be "
"reversed, ``page-2/`` or no arguments in this case, while ``comments`` can "
"be reversed with either no arguments or a value for ``page_number``."
msgstr ""
"``blog_articles`` 视图需要反转最外层捕捉的参数，``page-2/`` 或在这里不需要参"
"数，而 ``comments`` 可以在没有参数或 ``page_number`` 值的情况下反转。"

msgid ""
"Nested captured arguments create a strong coupling between the view "
"arguments and the URL as illustrated by ``blog_articles``: the view receives "
"part of the URL (``page-2/``) instead of only the value the view is "
"interested in. This coupling is even more pronounced when reversing, since "
"to reverse the view we need to pass the piece of URL instead of the page "
"number."
msgstr ""
"嵌套捕捉参数在视图参数和 URL 直接创建一个强耦合，如 ``blog_articles`` 所示："
"视图接收部分 URL (``page-2/``) 而不只是视图要的值。当反转时这种耦合更明显，因"
"为反转视图我们需要传递一段 URL 而不是 page number。"

msgid ""
"As a rule of thumb, only capture the values the view needs to work with and "
"use non-capturing arguments when the regular expression needs an argument "
"but the view ignores it."
msgstr ""
"根据经验，只有当正则表达式需要一个参数但视图忽略它时，才捕捉该视图需要的值并"
"使用非捕捉参数。"

msgid "What the URLconf searches against"
msgstr "URLconf 在什么上查找"

msgid ""
"The URLconf searches against the requested URL, as a normal Python string. "
"This does not include GET or POST parameters, or the domain name."
msgstr ""
"请求的URL被看做是一个普通的Python 字符串， URLconf在其上查找并匹配。进行匹配"
"时将不包括GET或POST请求方式的参数以及域名。"

msgid ""
"For example, in a request to ``https://www.example.com/myapp/``, the URLconf "
"will look for ``myapp/``."
msgstr ""
"例如，  ``https://www.example.com/myapp/`` 请求中，URLconf 将查找 ``myapp/`` "

msgid ""
"In a request to ``https://www.example.com/myapp/?page=3``, the URLconf will "
"look for ``myapp/``."
msgstr ""
"在 ``https://www.example.com/myapp/?page=3`` 请求中，URLconf 仍将查找 "
"``myapp/`` 。"

msgid ""
"The URLconf doesn't look at the request method. In other words, all request "
"methods -- ``POST``, ``GET``, ``HEAD``, etc. -- will be routed to the same "
"function for the same URL."
msgstr ""
"URLconf 不检查使用了哪种请求方法。换句话讲，所有的请求方法 —— 即，对同一个URL"
"的无论是 ``POST请求`` 、 ``GET请求`` 、或 ``HEAD`` 请求方法等等 —— 都将路由到"
"相同的函数。"

msgid "Specifying defaults for view arguments"
msgstr "指定视图参数的默认值"

msgid ""
"A convenient trick is to specify default parameters for your views' "
"arguments. Here's an example URLconf and view::"
msgstr ""
"有一个方便的小技巧是指定视图参数的默认值。 下面是一个URLconf 和视图的示例："

msgid ""
"In the above example, both URL patterns point to the same view -- ``views."
"page`` -- but the first pattern doesn't capture anything from the URL. If "
"the first pattern matches, the ``page()`` function will use its default "
"argument for ``num``, ``1``. If the second pattern matches, ``page()`` will "
"use whatever ``num`` value was captured."
msgstr ""
"在上面的例子中，两个URL模式都指向了相同的视图—— ``views.page`` 但是第一个样式"
"不能在URL中捕获到任意东西。如果第一个URL模式去匹配URL，``page()`` 函数会使用"
"它默认参数 ``num=1``。如果第二个URL模式去匹配URL，``page()``  函数都会使用捕"
"获到的任意 ``num``参数。"

msgid ""
"Each regular expression in a ``urlpatterns`` is compiled the first time it's "
"accessed. This makes the system blazingly fast."
msgstr ""
"``urlpatterns`` 中的每个正则表达式在第一次访问它们时被编译。这使得系统相当"
"快。"

msgid "Syntax of the ``urlpatterns`` variable"
msgstr " ``urlpatterns`` 变量的语法"

msgid ""
"``urlpatterns`` should be a :term:`sequence` of :func:`~django.urls.path` "
"and/or :func:`~django.urls.re_path` instances."
msgstr "urlpatterns 应该是 ``path()`` 或 ``re_path()`` 实例的序列。"

msgid "Error handling"
msgstr "错误处理"

msgid ""
"When Django can't find a match for the requested URL, or when an exception "
"is raised, Django invokes an error-handling view."
msgstr ""
"当 Django 找不到所匹配的请求 URL 时，或引发了异常时，Django 会调用一个错误处"
"理视图。"

msgid ""
"The views to use for these cases are specified by four variables. Their "
"default values should suffice for most projects, but further customization "
"is possible by overriding their default values."
msgstr ""
"这些情况发生时使用的视图通过4个变量指定。它们的默认值应该满足大部分项目，但是"
"通过赋值给它们以进一步的自定义也是可以的。"

msgid ""
"See the documentation on :ref:`customizing error views <customizing-error-"
"views>` for the full details."
msgstr "完整的细节请参见 :ref:`自定义错误视图 <customizing-error-views>`  。"

msgid ""
"Such values can be set in your root URLconf. Setting these variables in any "
"other URLconf will have no effect."
msgstr ""
"这些值得在你的根URLconf 中设置。在其它URLconf 中设置这些变量将不会生效果。"

msgid ""
"Values must be callables, or strings representing the full Python import "
"path to the view that should be called to handle the error condition at hand."
msgstr ""
"它们的值必须是可调用的或者是表示视图的Python 完整导入路径的字符串，可以方便地"
"调用它们来处理错误情况。"

msgid "The variables are:"
msgstr "这些值是："

msgid "``handler400`` -- See :data:`django.conf.urls.handler400`."
msgstr "``handler400`` -- 查看 :data:`django.conf.urls.handler400`."

msgid "``handler403`` -- See :data:`django.conf.urls.handler403`."
msgstr "``handler403`` -- 查看 :data:`django.conf.urls.handler403`."

msgid "``handler404`` -- See :data:`django.conf.urls.handler404`."
msgstr "``handler404`` -- 查看 :data:`django.conf.urls.handler404`."

msgid "``handler500`` -- See :data:`django.conf.urls.handler500`."
msgstr "``handler500`` -- 查看 :data:`django.conf.urls.handler500`."

msgid "Including other URLconfs"
msgstr "包含其它的URLconfs"

msgid ""
"At any point, your ``urlpatterns`` can \"include\" other URLconf modules. "
"This essentially \"roots\" a set of URLs below other ones."
msgstr ""
"在任何时候，你的 ``urlpatterns`` 都可以 \"include\" 其它URLconf 模块。这实际"
"上将一部分URL 放置于其它URL 下面。"

msgid ""
"For example, here's an excerpt of the URLconf for the `Django website`_ "
"itself. It includes a number of other URLconfs::"
msgstr ""
"例如，下面是URLconf  `Django website`_ 自己的URLconf 中一个片段。它包含许多其"
"它URLconf："

msgid ""
"Whenever Django encounters :func:`~django.urls.include()`, it chops off "
"whatever part of the URL matched up to that point and sends the remaining "
"string to the included URLconf for further processing."
msgstr ""
"每当 Django 遇到 :func:`~django.urls.include()` ，它会将匹配到该点的URLconf的"
"任何部分切掉，并将剩余的字符串发送到包含的URLconf进行进一步处理。"

msgid ""
"Another possibility is to include additional URL patterns by using a list "
"of :func:`~django.urls.path` instances. For example, consider this URLconf::"
msgstr ""
"另一种可能性是通过使用 :func:`~django.urls.path`  实例的列表来包含其他 URL 模"
"式。比如，看这个 URLconf::"

msgid ""
"In this example, the ``/credit/reports/`` URL will be handled by the "
"``credit_views.report()`` Django view."
msgstr ""
"在这个例子中， ``/credit/reports/``  URL将被 ``credit.views.report()`` 这个"
"Django 视图处理。"

msgid ""
"This can be used to remove redundancy from URLconfs where a single pattern "
"prefix is used repeatedly. For example, consider this URLconf::"
msgstr ""
"这种方法可以用来去除URLconf 中的冗余，其中某个模式前缀被重复使用。例如，考虑"
"这个URLconf::"

msgid ""
"We can improve this by stating the common path prefix only once and grouping "
"the suffixes that differ::"
msgstr "我们可以改进它，通过只声明共同的路径前缀一次并将后面的部分分组::"

msgid "Captured parameters"
msgstr "捕获的参数"

msgid ""
"An included URLconf receives any captured parameters from parent URLconfs, "
"so the following example is valid::"
msgstr ""
"被包含的URLconf 会收到来自父URLconf 捕获的任何参数，所以下面的例子是合法的::"

msgid ""
"In the above example, the captured ``\"username\"`` variable is passed to "
"the included URLconf, as expected."
msgstr ""
"在上面的例子中，捕获的 ``\"username\"`` 变量将被如期传递给include()指向的"
"URLconf。"

msgid "Passing extra options to view functions"
msgstr "传递额外选项给视图函数"

msgid ""
"URLconfs have a hook that lets you pass extra arguments to your view "
"functions, as a Python dictionary."
msgstr "URLconfs 有钩子来允许你把其他参数作为 Python 字典来传递给视图函数。"

msgid ""
"The :func:`~django.urls.path` function can take an optional third argument "
"which should be a dictionary of extra keyword arguments to pass to the view "
"function."
msgstr ""
":func:`~django.urls.path` 函数可带有可选的第三参数（必须是字典），传递到视图"
"函数里。"

msgid ""
"In this example, for a request to ``/blog/2005/``, Django will call ``views."
"year_archive(request, year=2005, foo='bar')``."
msgstr ""
"在这个例子里，当请求到 ``/blog/2005/`` 时，Django 将调用 ``views."
"year_archive(request, year=2005, foo='bar')`` 。"

msgid ""
"This technique is used in the :doc:`syndication framework </ref/contrib/"
"syndication>` to pass metadata and options to views."
msgstr ""
"在 :doc:`syndication framework </ref/contrib/syndication>` 中使用了这个办法，"
"来向视图传递元数据和可选参数。"

msgid "Dealing with conflicts"
msgstr "处理冲突"

msgid ""
"It's possible to have a URL pattern which captures named keyword arguments, "
"and also passes arguments with the same names in its dictionary of extra "
"arguments. When this happens, the arguments in the dictionary will be used "
"instead of the arguments captured in the URL."
msgstr ""
"可能有一个 URL 模式来捕捉命名的关键字参数，并且同时也在附加参数字典里传递了同"
"名的参数。当发生这种情况时，将使用字典里的参数来替代捕捉的参数。"

msgid "Passing extra options to ``include()``"
msgstr "传递额外选项给 ``include()``"

msgid ""
"Similarly, you can pass extra options to :func:`~django.urls.include` and "
"each line in the included URLconf will be passed the extra options."
msgstr ""
"同样的，你可以额外其他选项给 :func:`~django.urls.include` ，并且已包含的 "
"URLconf 里的每一行将被传递额外选项。"

msgid "For example, these two URLconf sets are functionally identical:"
msgstr "例如，下面两个 URLconf 配置在功能上是相同的："

msgid "Set one::"
msgstr "配置一："

msgid "Set two::"
msgstr "配置二："

msgid ""
"Note that extra options will *always* be passed to *every* line in the "
"included URLconf, regardless of whether the line's view actually accepts "
"those options as valid. For this reason, this technique is only useful if "
"you're certain that every view in the included URLconf accepts the extra "
"options you're passing."
msgstr ""
"注意额外的选项会一直传递给所包含的 URLconf 的每一行，不管视图是否接受这些额外"
"选项。因此，这个技巧仅在确定所包含的 URLconf 中的每一个视图接受你传递的额外选"
"项时有用。"

msgid "Reverse resolution of URLs"
msgstr "URL 的反向解析"

msgid ""
"A common need when working on a Django project is the possibility to obtain "
"URLs in their final forms either for embedding in generated content (views "
"and assets URLs, URLs shown to the user, etc.) or for handling of the "
"navigation flow on the server side (redirections, etc.)"
msgstr ""
"在 Django 项目中，一个常见需求是获取最终形式的 URL，比如用于嵌入生成的内容中"
"（视图和资源网址，给用户展示网址等）或用户服务器端的导航处理（重定向等）。"

msgid ""
"It is strongly desirable to avoid hard-coding these URLs (a laborious, non-"
"scalable and error-prone strategy). Equally dangerous is devising ad-hoc "
"mechanisms to generate URLs that are parallel to the design described by the "
"URLconf, which can result in the production of URLs that become stale over "
"time."
msgstr ""
"强烈建议不要硬编码 URL（这是一个费力、不能扩展、容易出错的主意）。同样危险的"
"是设计临时机制来生成的 URL 与URLconf描述的设计的URL一样，这会导致 URL 随着时"
"间的推移变得过时。"

msgid ""
"In other words, what's needed is a DRY mechanism. Among other advantages it "
"would allow evolution of the URL design without having to go over all the "
"project source code to search and replace outdated URLs."
msgstr ""
"换句话说，需要的是 DRY 机制。除其他优势外，它还允许 URL 设计自动更新，而不必"
"遍历所有项目代码来搜索和替换过时的 URL 。"

msgid ""
"The primary piece of information we have available to get a URL is an "
"identification (e.g. the name) of the view in charge of handling it. Other "
"pieces of information that necessarily must participate in the lookup of the "
"right URL are the types (positional, keyword) and values of the view "
"arguments."
msgstr ""
"我们用来获取 URL 的首要信息是负责处理它的视图的标识(例如名称)。必须参与查找正"
"确网址的其他信息是视图参数的类型(位置、关键字)和值。"

msgid ""
"Django provides a solution such that the URL mapper is the only repository "
"of the URL design. You feed it with your URLconf and then it can be used in "
"both directions:"
msgstr ""
"Django 提供了一个解决方案，使得 URL 映射是 URL 设计唯一的仓库。你使用 "
"URLconf 来填充它，然后可以双向使用它："

msgid ""
"Starting with a URL requested by the user/browser, it calls the right Django "
"view providing any arguments it might need with their values as extracted "
"from the URL."
msgstr ""
"从用户/浏览器请求的 URL 开始，它调用正确的Django视图，并从 URL 中提取它的参数"
"需要的值。"

msgid ""
"Starting with the identification of the corresponding Django view plus the "
"values of arguments that would be passed to it, obtain the associated URL."
msgstr "从相应的 Django 视图标识以及要传递给它的参数来获取相关联的 URL 。"

msgid ""
"The first one is the usage we've been discussing in the previous sections. "
"The second one is what is known as *reverse resolution of URLs*, *reverse "
"URL matching*, *reverse URL lookup*, or simply *URL reversing*."
msgstr ""
"第一条我们在前面的章节以及讨论过。第二条就是所谓的 *反向解析 URL *，*反向 "
"URL 匹配*，*反向 URL 查找*，或简称 *URL 反向*。"

msgid ""
"Django provides tools for performing URL reversing that match the different "
"layers where URLs are needed:"
msgstr "Django 提供执行反转 URL 的工具，这些工具与需要 URL 的不同层匹配："

msgid "In templates: Using the :ttag:`url` template tag."
msgstr "在模板里：使用 :ttag:`url` 模板标签。"

msgid "In Python code: Using the :func:`~django.urls.reverse` function."
msgstr "在 Python 编码：使用 :func:`~django.urls.reverse` 函数。"

msgid ""
"In higher level code related to handling of URLs of Django model instances: "
"The :meth:`~django.db.models.Model.get_absolute_url` method."
msgstr ""
"在与 Django 模型实例的 URL 处理相关的高级代码中： :meth:`~django.db.models."
"Model.get_absolute_url` 方法。"

msgid "Consider again this URLconf entry::"
msgstr "再次考虑这个 URLconf 条目："

msgid ""
"According to this design, the URL for the archive corresponding to year "
"*nnnn* is ``/articles/<nnnn>/``."
msgstr "根据这个设计，与 year *nnnn* 相对应的 URL 是 ``/articles/<nnnn>/`` 。"

msgid "You can obtain these in template code by using:"
msgstr "你可以使用以下方式在模板代码中来获取它们："

msgid "Or in Python code::"
msgstr "或在 Python 代码里："

msgid ""
"If, for some reason, it was decided that the URLs where content for yearly "
"article archives are published at should be changed then you would only need "
"to change the entry in the URLconf."
msgstr ""
"因为某些原因，如果决定改变每年已发布的文章存档内容的 URL ，你只需要改变 "
"URLconf 中的条目即可。"

msgid ""
"In some scenarios where views are of a generic nature, a many-to-one "
"relationship might exist between URLs and views. For these cases the view "
"name isn't a good enough identifier for it when comes the time of reversing "
"URLs. Read the next section to know about the solution Django provides for "
"this."
msgstr ""
"在一些视图具有一般性质的场景下，URLs 和视图存在多对一关系。对于这些情况，当反"
"转 URLs 时，视图名并不是一个足够好的标识符。阅读下一节来了解 Django 如何解决"
"这一问题。"

msgid "Naming URL patterns"
msgstr "命名 URL 模式"

msgid ""
"In order to perform URL reversing, you'll need to use **named URL patterns** "
"as done in the examples above. The string used for the URL name can contain "
"any characters you like. You are not restricted to valid Python names."
msgstr ""
"为了完成反向解析 URL ，你需要像上面那样使用 **命名 URL 模式** 。用于命名 URL "
"的字符串可以包含任意字符，并不仅限于 Python 里合法的命名。"

msgid ""
"When naming URL patterns, choose names that are unlikely to clash with other "
"applications' choice of names. If you call your URL pattern ``comment`` and "
"another application does the same thing, the URL that :func:`~django.urls."
"reverse()` finds depends on whichever pattern is last in your project's "
"``urlpatterns`` list."
msgstr ""
"当命名 URL 模式时，请选择名称与其他应用名称冲突的名字。如果你命名的 URL 模"
"式  ``comment``  和其他应用程序做了同样的事情，:func:`~django.urls."
"reverse()` 查询出的 URL 会是在项目的 ``urlpatterns`` 列表里靠后的那个。"

msgid ""
"Putting a prefix on your URL names, perhaps derived from the application "
"name (such as ``myapp-comment`` instead of ``comment``), decreases the "
"chance of collision."
msgstr ""
"在 URL 名称前加入前缀，可以来自app名称（比如 ``myapp-comment`` 而不是 "
"``comment`` ），这样可以减少冲突。"

msgid ""
"You can deliberately choose the *same URL name* as another application if "
"you want to override a view. For example, a common use case is to override "
"the :class:`~django.contrib.auth.views.LoginView`. Parts of Django and most "
"third-party apps assume that this view has a URL pattern with the name "
"``login``. If you have a custom login view and give its URL the name "
"``login``, :func:`~django.urls.reverse()` will find your custom view as long "
"as it's in ``urlpatterns`` after ``django.contrib.auth.urls`` is included "
"(if that's included at all)."
msgstr ""
"如果你想覆盖某个视图，你可以有意选择一些和应用程序 *相同的URL名*。比如，一个"
"常见的案例是覆盖 :class:`~django.contrib.auth.views.LoginView` 。Django 的部"
"分和绝大多数第三方 app 假设这个视图有名叫 ``login`` 的 URL 模式。如果你有名"
"叫 ``login`` 的自定义登录视图，:func:`~django.urls.reverse()` 将会在 "
"``django.contrib.auth.urls`` 之后寻找你的自定义视图。"

msgid ""
"You may also use the same name for multiple URL patterns if they differ in "
"their arguments. In addition to the URL name, :func:`~django.urls.reverse()` "
"matches the number of arguments and the names of the keyword arguments. Path "
"converters can also raise ``ValueError`` to indicate no match, see :ref:"
"`registering-custom-path-converters` for details."
msgstr ""
"如果多个 URL 模式的参数不同，也可以使用相同的名称。除了 URL 名称外， :func:"
"`~django.urls.reverse()` 会匹配参数的数量和关键字参数的名称。路径转换器也可以"
"引发 ``ValueError`` 表示不匹配，详见 :ref:`registering-custom-path-"
"converters`。"

msgid "URL namespaces"
msgstr "URL 命名空间"

msgid "Introduction"
msgstr "介绍"

msgid ""
"URL namespaces allow you to uniquely reverse :ref:`named URL patterns "
"<naming-url-patterns>` even if different applications use the same URL "
"names. It's a good practice for third-party apps to always use namespaced "
"URLs (as we did in the tutorial). Similarly, it also allows you to reverse "
"URLs if multiple instances of an application are deployed. In other words, "
"since multiple instances of a single application will share named URLs, "
"namespaces provide a way to tell these named URLs apart."
msgstr ""
"URL 命名空间允许你使用唯一的反向命名URL模式（ :ref:`named URL patterns "
"<naming-url-patterns>` ），即便不同应用程序使用相同的 URL 名称。对于第三方应"
"用程序来说，始终使用 URL 命名空间是个好习惯（像在教程里说的那样）。同样，如果"
"已部署了应用程序的多个实例，它也允许你反向解析 URL。换句话说，因为单个应用的"
"多个实例会分享已命名的 URL，命名空间提供了区分这些已命名 URL 的方法。"

msgid ""
"Django applications that make proper use of URL namespacing can be deployed "
"more than once for a particular site. For example :mod:`django.contrib."
"admin` has an :class:`~django.contrib.admin.AdminSite` class which allows "
"you to :ref:`deploy more than one instance of the admin <multiple-admin-"
"sites>`.  In a later example, we'll discuss the idea of deploying the polls "
"application from the tutorial in two different locations so we can serve the "
"same functionality to two different audiences (authors and publishers)."
msgstr ""
"对于特定站点，正确使用URL名称空间的Django应用程序可以部署多次。比如 :mod:"
"`django.contrib.admin` 有一个 :class:`~django.contrib.admin.AdminSite` ，它允"
"许admin实例部署多次（:ref:`deploy more than one instance of the admin "
"<multiple-admin-sites>`）。在稍后的例子里，我们将从教程里的两个不同位置讨论投"
"票程序的部署，以便我们可以提供相同的函数给两个不同的群体（作者和出版社）。"

msgid "A URL namespace comes in two parts, both of which are strings:"
msgstr "URL 命名空间分为两部分，它们都是字符串："

msgid "application namespace"
msgstr "应用程序命名空间"

msgid ""
"This describes the name of the application that is being deployed. Every "
"instance of a single application will have the same application namespace. "
"For example, Django's admin application has the somewhat predictable "
"application namespace of ``'admin'``."
msgstr ""
"这描述了正在部署的程序名。单个应用的每个实例拥有相同的命名空间。比如，Django "
"admin 应用有可预测的应用命名空间 ``'admin'`` 。"

msgid "instance namespace"
msgstr "实例命名空间"

msgid ""
"This identifies a specific instance of an application. Instance namespaces "
"should be unique across your entire project. However, an instance namespace "
"can be the same as the application namespace. This is used to specify a "
"default instance of an application. For example, the default Django admin "
"instance has an instance namespace of ``'admin'``."
msgstr ""
"这标识了应用程序的特定实例。实例命名空间应该是完整项目唯一的。但是实例命名空"
"间可以和应用命名空间相同。这常用来指定应用的默认实例。比如，默认Django admin "
"实例拥有名为 ``'admin'`` 的实例命名空间。"

msgid ""
"Namespaced URLs are specified using the ``':'`` operator. For example, the "
"main index page of the admin application is referenced using ``'admin:"
"index'``. This indicates a namespace of ``'admin'``, and a named URL of "
"``'index'``."
msgstr ""
"被指定的命名空间 URL 使用 ``':'`` 操作符。比如，使用  ``'admin:index'`` 引用"
"admin 应用的首页。这表明命名空间为 ``'admin'`` ，命名 URL 为 ``'index'`` 。"

msgid ""
"Namespaces can also be nested. The named URL ``'sports:polls:index'`` would "
"look for a pattern named ``'index'`` in the namespace ``'polls'`` that is "
"itself defined within the top-level namespace ``'sports'``."
msgstr ""
"命名空间也可以嵌套。命名 URL ``'sports:polls:index'`` 将在命名空间 "
"``'polls'`` 中寻找命名为 ``'index'`` 的模式，该模式是在顶层命名空间 "
"``'sports'`` 中定义的。"

msgid "Reversing namespaced URLs"
msgstr "反向命名空间 URLs"

msgid ""
"When given a namespaced URL (e.g. ``'polls:index'``) to resolve, Django "
"splits the fully qualified name into parts and then tries the following "
"lookup:"
msgstr ""
"当给定一个命名空间 URL（例如 ``'polls:index'`` ）解析时，Django 会将完全限定"
"的名称拆分成多个部分，然后尝试下面的查询："

msgid ""
"First, Django looks for a matching :term:`application namespace` (in this "
"example, ``'polls'``). This will yield a list of instances of that "
"application."
msgstr ""
"首先，Django 查找匹配 :term:`application namespace` （这个例子里是 "
"``'polls'`` ）。这将产生应用实例列表。"

msgid ""
"If there is a current application defined, Django finds and returns the URL "
"resolver for that instance. The current application can be specified with "
"the ``current_app`` argument to the :func:`~django.urls.reverse()` function."
msgstr ""
"如果定义了当前应用程序，Django 会为这个实例查找并返回 URL 解析器。可以用 :"
"func:`~django.urls.reverse()` 函数的 ``current_app`` 参数来指定当前应用程序。"

msgid ""
"The :ttag:`url` template tag uses the namespace of the currently resolved "
"view as the current application in a :class:`~django.template."
"RequestContext`. You can override this default by setting the current "
"application on the :attr:`request.current_app <django.http.HttpRequest."
"current_app>` attribute."
msgstr ""
":ttag:`url` 模板标签使用当前已解析的视图命名空间当作 :class:`~django."
"template.RequestContext` 中的应用程序。你可以通过设置在 :attr:`request."
"current_app <django.http.HttpRequest.current_app>` 属性上的当前应用来覆盖这个"
"默认配置。"

msgid ""
"If there is no current application, Django looks for a default application "
"instance. The default application instance is the instance that has an :term:"
"`instance namespace` matching the :term:`application namespace` (in this "
"example, an instance of ``polls`` called ``'polls'``)."
msgstr ""
"如果当前没有应用程序，Django 会寻找默认的应用实例。默认应用程序实例是具有与实"
"例命名空间匹配的应用程序命名空间的实例（比如， ``polls`` 实例被称为 "
"``'polls'`` ）。"

msgid ""
"If there is no default application instance, Django will pick the last "
"deployed instance of the application, whatever its instance name may be."
msgstr ""
"如果没有默认的应用程序实例，Django 将会引用最后一次部署的应用程序实例，无论其"
"实例命名是什么。"

msgid ""
"If the provided namespace doesn't match an :term:`application namespace` in "
"step 1, Django will attempt a direct lookup of the namespace as an :term:"
"`instance namespace`."
msgstr ""
"如果提供的命名空间无法在第一步里匹配应用程序命名空间（ :term:`application "
"namespace` ），Django 会尝试直接寻找命名空间来作为实例命名空间（ :term:"
"`instance namespace` ）。"

msgid ""
"If there are nested namespaces, these steps are repeated for each part of "
"the namespace until only the view name is unresolved. The view name will "
"then be resolved into a URL in the namespace that has been found."
msgstr ""
"如果有嵌套的命名空间，则会对命名空间的每个部分重复这些步骤，直到视图名不被解"
"析为止，然后视图名称将被解析为已找到的命名空间中的一个 URL 。"

msgid ""
"To show this resolution strategy in action, consider an example of two "
"instances of the ``polls`` application from the tutorial: one called "
"``'author-polls'`` and one called ``'publisher-polls'``. Assume we have "
"enhanced that application so that it takes the instance namespace into "
"consideration when creating and displaying polls."
msgstr ""
"为了展示这个解决策略的实际作用，请考虑教程里 ``polls`` 应用程序的两个实例案"
"例：分别被称为 ``'author-polls'`` 和 ``'publisher-polls'`` 。假设我们已经增强"
"了这个应用程序，以便会在创建和显示 polls 时考虑实例命名空间"

msgid "polls/urls.py"
msgstr "polls/urls.py"

msgid "Using this setup, the following lookups are possible:"
msgstr "使用这步后，可以进行以下查找："

msgid ""
"If one of the instances is current - say, if we were rendering the detail "
"page in the instance ``'author-polls'`` - ``'polls:index'`` will resolve to "
"the index page of the ``'author-polls'`` instance; i.e. both of the "
"following will result in ``\"/author-polls/\"``."
msgstr ""
"如果其中一个实例是最新的- 例如，如果我们在实例 ``'author-polls'`` 中渲染详情"
"页 - ``'polls:index'`` 将解析为 ``'author-polls'`` 的首页；比如下面两种都将触"
"发 ``\"/author-polls/\"`` 。"

msgid "In the method of a class-based view::"
msgstr "在基于类的视图里的方法："

msgid "and in the template:"
msgstr "以及在模板中："

msgid ""
"If there is no current instance - say, if we were rendering a page somewhere "
"else on the site - ``'polls:index'`` will resolve to the last registered "
"instance of ``polls``. Since there is no default instance (instance "
"namespace of ``'polls'``), the last instance of ``polls`` that is registered "
"will be used. This would be ``'publisher-polls'`` since it's declared last "
"in the ``urlpatterns``."
msgstr ""
"如果其中一个实例是最新的 - 例如，如果我们在站点某处渲染一个页面 - ``'polls:"
"index'`` 将被解析为 ``polls`` 的最后一个注册实例。因为这里没有默认实例"
"（ ``'polls'`` 的实例命名空间），所以将使用 ``polls`` 的最后一个注册实例。这"
"将是 ``'publisher-polls'`` ，因为它是在 ``urlpatterns`` 的最后面声明的。"

msgid ""
"``'author-polls:index'`` will always resolve to the index page of the "
"instance ``'author-polls'`` (and likewise for ``'publisher-polls'``) ."
msgstr ""
"``'author-polls:index'`` 会一直被解析为实例 ``'author-polls'`` 的首页（对于 "
"``'publisher-polls'`` 同样如此）。"

msgid ""
"If there were also a default instance - i.e., an instance named ``'polls'`` "
"- the only change from above would be in the case where there is no current "
"instance (the second item in the list above). In this case ``'polls:index'`` "
"would resolve to the index page of the default instance instead of the "
"instance declared last in ``urlpatterns``."
msgstr ""
"如果还有一个默认实例 - 例如，一个叫 ``'polls'`` 的实例 - 唯一的变化就是没有当"
"前实例（上面列表中的第二项）。在这个例子 ``'polls:index'`` 将解析为默认实例的"
"首页而不是在 ``urlpatterns`` 中最后声明的实例。"

msgid "URL namespaces and included URLconfs"
msgstr "URL 命名空间和包含的 URLconfs"

msgid ""
"Application namespaces of included URLconfs can be specified in two ways."
msgstr "有两种办法指定包含的URLconfs应用程序空间。"

msgid ""
"Firstly, you can set an ``app_name`` attribute in the included URLconf "
"module, at the same level as the ``urlpatterns`` attribute. You have to pass "
"the actual module, or a string reference to the module, to :func:`~django."
"urls.include`, not the list of ``urlpatterns`` itself."
msgstr ""
"首先，你可以在包含的 URLcon 模块中设置一个  ``app_name`` 属性，在相同层作为 "
"``urlpatterns`` 属性。你必须传递实际的模块或对该模块的一个字符串引用传递给 :"
"func:`~django.urls.include` ，而不是 ``urlpatterns`` 本身的列表。"

msgid ""
"The URLs defined in ``polls.urls`` will have an application namespace "
"``polls``."
msgstr "``polls.urls`` 里的 URLs 定义将具有应用程序命名空间 ``polls`` 。"

msgid ""
"Secondly, you can include an object that contains embedded namespace data. "
"If you ``include()`` a list of :func:`~django.urls.path` or :func:`~django."
"urls.re_path` instances, the URLs contained in that object will be added to "
"the global namespace. However, you can also ``include()`` a 2-tuple "
"containing::"
msgstr ""
"其次，你可以包括一个包含嵌入式命名空间数据的对象。如果你 ``include()`` 了一"
"个 :func:`~django.urls.path`  或 :func:`~django.urls.re_path` 实例的列表，那"
"个对象里包含的 URLs 将被添加到全局命名空间内。但是，你也可以 ``include()`` 一"
"个包含以下内容的2元组："

msgid ""
"This will include the nominated URL patterns into the given application "
"namespace."
msgstr "这会将指定的 URL 模式包含到给定的应用程序命名空间里。"

msgid ""
"The instance namespace can be specified using the ``namespace`` argument to :"
"func:`~django.urls.include`. If the instance namespace is not specified, it "
"will default to the included URLconf's application namespace. This means it "
"will also be the default instance for that namespace."
msgstr ""
"使用 :func:`~django.urls.include` 的 ``namespace`` 参数来指定实例命名空间。如"
"果实例命名空间没有被指定，会默认已被导入的 URLconf 的应用程序命名空间。这意味"
"着它也将成为那个命名空间的默认实例。"

msgid "Writing views"
msgstr "编写视图"

msgid ""
"A view function, or *view* for short, is a Python function that takes a web "
"request and returns a web response. This response can be the HTML contents "
"of a web page, or a redirect, or a 404 error, or an XML document, or an "
"image . . . or anything, really. The view itself contains whatever arbitrary "
"logic is necessary to return that response. This code can live anywhere you "
"want, as long as it's on your Python path. There's no other requirement--no "
"\"magic,\" so to speak. For the sake of putting the code *somewhere*, the "
"convention is to put views in a file called ``views.py``, placed in your "
"project or application directory."
msgstr ""

msgid "A simple view"
msgstr "一个简单的视图"

msgid ""
"Here's a view that returns the current date and time, as an HTML document::"
msgstr "这里是一个以 HTML 文档形式返回当前日期和时间的视图："

msgid "Let's step through this code one line at a time:"
msgstr "让我们来完成这个代码："

msgid ""
"First, we import the class :class:`~django.http.HttpResponse` from the :mod:"
"`django.http` module, along with Python's ``datetime`` library."
msgstr ""
"首先，我们从 :mod:`django.http` 模块导入类 :class:`~django.http."
"HttpResponse` ，以及 Python 的 ``datetime`` 库。"

msgid ""
"Next, we define a function called ``current_datetime``. This is the view "
"function. Each view function takes an :class:`~django.http.HttpRequest` "
"object as its first parameter, which is typically named ``request``."
msgstr ""
"然后，我们定义一个名为 ``current_datetime`` 的函数。这是一个视图函数。每个视"
"图函数都将 :class:`~django.http.HttpRequest` 对象作为第一个参数，通常名为 "
"``request`` 。"

msgid ""
"Note that the name of the view function doesn't matter; it doesn't have to "
"be named in a certain way in order for Django to recognize it. We're calling "
"it ``current_datetime`` here, because that name clearly indicates what it "
"does."
msgstr ""
"注意视图函数名称无关紧要；它不需要以特定的名称来让 Django 识别它。我们在这里"
"命名 ``current_datetime`` ，因为这个名字可以清楚的表示它的用途。"

msgid ""
"The view returns an :class:`~django.http.HttpResponse` object that contains "
"the generated response. Each view function is responsible for returning an :"
"class:`~django.http.HttpResponse` object. (There are exceptions, but we'll "
"get to those later.)"
msgstr ""
"视图返回一个包含生成的响应的 :class:`~django.http.HttpResponse` 对象。每个视"
"图函数都要返回 :class:`~django.http.HttpResponse` 对象。（有例外，我们稍后再"
"讲）"

msgid "Django's Time Zone"
msgstr "Django 时区"

msgid ""
"Django includes a :setting:`TIME_ZONE` setting that defaults to ``America/"
"Chicago``. This probably isn't where you live, so you might want to change "
"it in your settings file."
msgstr ""
"Django 包含 :setting:`TIME_ZONE` 设置，默认是 ``America/Chicago`` 。你可以在"
"配置文件里改成你所在的时区。"

msgid "Mapping URLs to views"
msgstr "将 URL 映射到视图"

msgid ""
"So, to recap, this view function returns an HTML page that includes the "
"current date and time. To display this view at a particular URL, you'll need "
"to create a *URLconf*; see :doc:`/topics/http/urls` for instructions."
msgstr ""
"因此，回顾一下，这个视图函数返回包含当前日期时间的HTML页面。如果在特定的 URL "
"使用这个视图，你需要创建 *URLconf* ；查看 :doc:`/topics/http/urls` 的操作说"
"明。"

msgid "Returning errors"
msgstr "返回错误信息"

msgid ""
"Django provides help for returning HTTP error codes. There are subclasses "
"of :class:`~django.http.HttpResponse` for a number of common HTTP status "
"codes other than 200 (which means *\"OK\"*). You can find the full list of "
"available subclasses in the :ref:`request/response <ref-httpresponse-"
"subclasses>` documentation. Return an instance of one of those subclasses "
"instead of a normal :class:`~django.http.HttpResponse` in order to signify "
"an error. For example::"
msgstr ""
"Django 提供了有关返回 HTTP 错误代码的帮助。:class:`~django.http."
"HttpResponse` 的子类除了200外，还有很多常见的 HTTP 状态代码。你可以在 :ref:"
"`request/response <ref-httpresponse-subclasses>` 文档中找到所有可用子类的列"
"表。返回这些子类中某个子类的实例而不是 :class:`~django.http.HttpResponse` 来"
"表示错误。比如："

msgid ""
"There isn't a specialized subclass for every possible HTTP response code, "
"since many of them aren't going to be that common. However, as documented in "
"the :class:`~django.http.HttpResponse` documentation, you can also pass the "
"HTTP status code into the constructor for :class:`~django.http.HttpResponse` "
"to create a return class for any status code you like. For example::"
msgstr ""
"并不是每个可用 HTTP 响应代码都有专门指定的子类，因为它们很多并不常见。然而，"
"如 :class:`~django.http.HttpResponse` 文档中所述的那样，你也可以将 HTTP 状态"
"代码传递给 :class:`~django.http.HttpResponse` 的构造函数，这样就可以为任何状"
"态代码创建返回类。比如："

msgid ""
"Because 404 errors are by far the most common HTTP error, there's an easier "
"way to handle those errors."
msgstr "因为 404 错误是最常见的 HTTP 错误，这里有更简单的方法来处理这些错误。"

msgid "The ``Http404`` exception"
msgstr "``Http404`` 异常"

msgid ""
"When you return an error such as :class:`~django.http.HttpResponseNotFound`, "
"you're responsible for defining the HTML of the resulting error page::"
msgstr ""
"当你返回错误，例如 :class:`~django.http.HttpResponseNotFound` ，你需要定义错"
"误页面的 HTML 。"

msgid ""
"For convenience, and because it's a good idea to have a consistent 404 error "
"page across your site, Django provides an ``Http404`` exception. If you "
"raise ``Http404`` at any point in a view function, Django will catch it and "
"return the standard error page for your application, along with an HTTP "
"error code 404."
msgstr ""
"为方便起见，在你的网站里有个一致的 404 错误页面是个好办法，Django 提供 "
"``Http404`` 异常。如果你在视图的任何地方引发了 ``Http404`` ，Django 会捕捉到"
"它并且返回标准的错误页面，连同 HTTP 错误代码 404 。"

msgid ""
"In order to show customized HTML when Django returns a 404, you can create "
"an HTML template named ``404.html`` and place it in the top level of your "
"template tree. This template will then be served when :setting:`DEBUG` is "
"set to ``False``."
msgstr ""
"为了在 Django 返回404时显示自定义的 HTML，你可以创建名为  ``404.html`` 的HTML"
"模板，并将其放置在你的模板树顶层。这个模板将在 :setting:`DEBUG` 设为 "
"``False`` 时提供。"

msgid ""
"When :setting:`DEBUG` is ``True``, you can provide a message to ``Http404`` "
"and it will appear in the standard 404 debug template. Use these messages "
"for debugging purposes; they generally aren't suitable for use in a "
"production 404 template."
msgstr ""
"当 :setting:`DEBUG` 为 ``True`` 时，你可以提供 ``Http404`` 信息，并且在标准"
"的 404 调试模板里显示。使用这些信息来调试；它们通常不适合在生产环境下的404模"
"板。"

msgid "Customizing error views"
msgstr "自定义报错视图"

msgid ""
"The default error views in Django should suffice for most web applications, "
"but can easily be overridden if you need any custom behavior. Specify the "
"handlers as seen below in your URLconf (setting them anywhere else will have "
"no effect)."
msgstr ""

msgid ""
"The :func:`~django.views.defaults.page_not_found` view is overridden by :"
"data:`~django.conf.urls.handler404`::"
msgstr ""
"可以用 :data:`~django.conf.urls.handler404`: 覆盖 :func:`~django.views."
"defaults.page_not_found` 视图："

msgid ""
"The :func:`~django.views.defaults.server_error` view is overridden by :data:"
"`~django.conf.urls.handler500`::"
msgstr ""
"可以用 :data:`~django.conf.urls.handler500`: 覆盖 :func:`~django.views."
"defaults.server_error` 视图："

msgid ""
"The :func:`~django.views.defaults.permission_denied` view is overridden by :"
"data:`~django.conf.urls.handler403`::"
msgstr ""
"可以用 :data:`~django.conf.urls.handler403`: 覆盖 :func:`~django.views."
"defaults.permission_denied` 视图："

msgid ""
"The :func:`~django.views.defaults.bad_request` view is overridden by :data:"
"`~django.conf.urls.handler400`::"
msgstr ""
"可以用 :data:`~django.conf.urls.handler400`: 覆盖 :func:`~django.views."
"defaults.bad_request` 视图："

msgid ""
"Use the :setting:`CSRF_FAILURE_VIEW` setting to override the CSRF error view."
msgstr "使用 :setting:`CSRF_FAILURE_VIEW` 来覆盖 CSRF 报错视图。"

msgid "Testing custom error views"
msgstr "测试自定义报错视图"

msgid ""
"To test the response of a custom error handler, raise the appropriate "
"exception in a test view. For example::"
msgstr "为了测试自定义报错处理的响应，可以适当地在测试视图里引发异常。例如："

msgid ""
"As well as being synchronous functions, views can also be asynchronous "
"(\"async\") functions, normally defined using Python's ``async def`` syntax. "
"Django will automatically detect these and run them in an async context. "
"However, you will need to use an async server based on ASGI to get their "
"performance benefits."
msgstr ""
"除了同步函数，视图也可以是异步（“async”）函数，通常使用 Python 的 ``async "
"def`` 语法定义。Django 会自动检测这些函数，并在异步上下文中运行它们。但是，你"
"需要使用基于 ASGI 的异步服务器来获得它们的性能优势。"

msgid "Here's an example of an async view::"
msgstr "下面是一个异步视图的例子："

msgid ""
"You can read more about Django's async support, and how to best use async "
"views, in :doc:`/topics/async`."
msgstr ""
"你可以在 :doc:`/topics/async` 中阅读更多关于 Django 的异步支持，以及如何最好"
"的使用异步视图。"

msgid "Format localization"
msgstr "本地格式化"

msgid ""
"Django's formatting system is capable of displaying dates, times and numbers "
"in templates using the format specified for the current :term:`locale "
"<locale name>`. It also handles localized input in forms."
msgstr ""
"Django 的格式化系统可以在模板中使用指定的格式化工具为当前的 :term:`locale "
"<locale name>` 来显示日期、时间和数字。"

msgid ""
"When it's enabled, two users accessing the same content may see dates, times "
"and numbers formatted in different ways, depending on the formats for their "
"current locale."
msgstr ""
"启用后，访问相同内容的两个用户可能看见不同的日期、时间和数字，这取决于他们本"
"地的语言环境。"

msgid ""
"The formatting system is disabled by default. To enable it, it's necessary "
"to set :setting:`USE_L10N = True <USE_L10N>` in your settings file."
msgstr ""
"格式化系统默认是关闭的。如果要启用它，在配置文件里设置 :setting:`USE_L10N = "
"True <USE_L10N>` 即可。"

msgid ""
"To enable number formatting with thousand separators, it is necessary to "
"set :setting:`USE_THOUSAND_SEPARATOR = True <USE_THOUSAND_SEPARATOR>` in "
"your settings file. Alternatively, you could use :tfilter:`intcomma` to "
"format numbers in your template."
msgstr ""
"要启用千位分隔符的数字格式，必须在你的配置文件中设置 :setting:"
"`USE_THOUSAND_SEPARATOR = True <USE_THOUSAND_SEPARATOR>`。另外，你可以使用 :"
"tfilter:`intcomma` 在你的模板中格式化数字。"

msgid ""
"There is a related :setting:`USE_I18N` setting that controls if Django "
"should activate translation. See :doc:`/topics/i18n/translation` for more "
"details."
msgstr ""
"有一个相关的 :setting:`USE_I18N` 配置，控制 Django 是否应该激活翻译。更多细节"
"请参见 :doc:`/topics/i18n/translation`。"

msgid "Locale aware input in forms"
msgstr "表单中感知本地语言环境输入"

msgid ""
"When formatting is enabled, Django can use localized formats when parsing "
"dates, times and numbers in forms. That means it tries different formats for "
"different locales when guessing the format used by the user when inputting "
"data on forms."
msgstr ""
"格式化开启后，当在表单里解析日期、时间和数字时，Django 可以使用本地化格式。这"
"意味着猜测用户在表单上的输入时所使用的格式化时，会对不同语言环境尝试不同的格"
"式化。"

msgid ""
"Django uses different formats for displaying data to those it uses for "
"parsing data. Most notably, the formats for parsing dates can't use the ``"
"%a`` (abbreviated weekday name), ``%A`` (full weekday name), ``%b`` "
"(abbreviated month name), ``%B`` (full month name), or ``%p`` (AM/PM)."
msgstr ""
"Django 使用与解析数据不同的格式来显示数据。最值得注意的是，解析日期的格式化不"
"能使用 ``%a`` （缩写的日期），``%A`` （完整的日期），``%b`` （缩写的月份），"
"``%B`` （完整的月份），或者 ``%p`` (AM/PM)。"

msgid ""
"To enable a form field to localize input and output data use its "
"``localize`` argument::"
msgstr "使用 ``localize`` 参数来使表单字段能本地化输入和输出数据："

msgid "Controlling localization in templates"
msgstr "在模板中控制本地化"

msgid ""
"When you have enabled formatting with :setting:`USE_L10N`, Django will try "
"to use a locale specific format whenever it outputs a value in a template."
msgstr ""
"使用 :setting:`USE_L10N` 启用格式化后，每当 Django 在模板中输入数值时，它会试"
"着使用本地语言环境指定的格式化。"

msgid ""
"However, it may not always be appropriate to use localized values -- for "
"example, if you're outputting JavaScript or XML that is designed to be "
"machine-readable, you will always want unlocalized values. You may also want "
"to use localization in selected templates, rather than using localization "
"everywhere."
msgstr ""
"然而，使用本地化值可能并不总是合适的——比如，如果你正在输出机器可读的 "
"JavaScript 或 XML ，则始终需要非本地化的值。你也可以在已选的模板里使用本地"
"化，而不是在所有地方使用。"

msgid ""
"To allow for fine control over the use of localization, Django provides the "
"``l10n`` template library that contains the following tags and filters."
msgstr ""
"为了更好的控制本地化的使用，Django 提供 ``l10n`` 模板库，它包含以下的  tags "
"和 filters。"

msgid "Template tags"
msgstr "模板标签"

msgid "``localize``"
msgstr "``localize``"

msgid ""
"Enables or disables localization of template variables in the contained "
"block."
msgstr "在模板里启用和禁用模板变量本地化。"

msgid ""
"This tag allows a more fine grained control of localization than :setting:"
"`USE_L10N`."
msgstr "相比 :setting:`USE_L10N` ，这个标签可对本地化进行更精细的控制。"

msgid "To activate or deactivate localization for a template block, use::"
msgstr "要为模板块激活或禁用本地化，请用："

msgid ""
"The value of :setting:`USE_L10N` isn't respected inside of a ``{% localize %}"
"`` block."
msgstr "在 ``{% localize %}`` 块中，:setting:`USE_L10N` 的值会被忽略。"

msgid ""
"See :tfilter:`localize` and :tfilter:`unlocalize` for template filters that "
"will do the same job on a per-variable basis."
msgstr ""
"查看 :tfilter:`localize` 和 :tfilter:`unlocalize` 来获取在每个变量基础上执行"
"相同任务的模板过滤器。"

msgid "Template filters"
msgstr "模板过滤器"

msgid "Forces localization of a single value."
msgstr "对单一值的强制本地化"

msgid ""
"To disable localization on a single value, use :tfilter:`unlocalize`. To "
"control localization over a large section of a template, use the :ttag:"
"`localize` template tag."
msgstr ""
"对单一值取消本地化，使用 :tfilter:`unlocalize` 。要控制大部分模板的本地化，请"
"使用 :ttag:`localize` 模板标签。"

msgid "``unlocalize``"
msgstr "``unlocalize``"

msgid "Forces a single value to be printed without localization."
msgstr "强制地让单一值不被本地化。"

msgid ""
"To force localization of a single value, use :tfilter:`localize`. To control "
"localization over a large section of a template, use the :ttag:`localize` "
"template tag."
msgstr ""
"对单一值强制本地化，使用 :tfilter:`localize` 。要控制大部分模板的本地化，请使"
"用 :ttag:`localize` 模板标签。"

msgid ""
"Returns a string representation for unlocalized numbers  (``int``, "
"``float``, or ``Decimal``)."
msgstr "返回未本地化数字（``int``、``float`` 或 ``Decimal``）的字符串表示。"

msgid "Creating custom format files"
msgstr "创建自定义的格式化文件"

msgid ""
"Django provides format definitions for many locales, but sometimes you might "
"want to create your own, because a format file doesn't exist for your "
"locale, or because you want to overwrite some of the values."
msgstr ""
"Django 为许多地区提供了格式定义，但有时你可能想创建自己的格式，因为你的地区不"
"存在一个格式文件，或者你想覆盖一些值。"

msgid ""
"To use custom formats, specify the path where you'll place format files "
"first.  To do that, set your :setting:`FORMAT_MODULE_PATH` setting to the "
"package where format files will exist, for instance::"
msgstr ""
"要使用自定义格式化，你首先要指定格式化文件的路径，需要将 :setting:"
"`FORMAT_MODULE_PATH` 设置为格式化文件所在的包路径，例如："

msgid ""
"Files are not placed directly in this directory, but in a directory named as "
"the locale, and must be named ``formats.py``. Be careful not to put "
"sensitive information in these files as values inside can be exposed if you "
"pass the string to ``django.utils.formats.get_format()`` (used by the :"
"tfilter:`date` template filter)."
msgstr ""
"文件不能直接放置在这个目录里，而是要放在本地语言环境的目录中，而且必须命名为 "
"``formats.py`` 。要注意不要在这些文件里放置敏感信息，因为如果你把字符串传递"
"给 ``django.utils.formats.get_format()`` （使用 :tfilter:`date` 模板过滤"
"器），那么内部值会被暴露。"

msgid ""
"To customize the English formats, a structure like this would be needed::"
msgstr "要想自定义英语格式化，需要这样的结构："

msgid ""
"where :file:`formats.py` contains custom format definitions. For example::"
msgstr ":file:`formats.py` 包含自定义格式化定义。例如："

msgid ""
"to use a non-breaking space (Unicode ``00A0``) as a thousand separator, "
"instead of the default for English, a comma."
msgstr ""
"使用不换行空格（硬空格 Unicode ``00A0`` ）作为千位分隔符，而不是英语的默认逗"
"号。"

msgid "Limitations of the provided locale formats"
msgstr "提供本地语言环境格式化的局限性"

msgid ""
"Some locales use context-sensitive formats for numbers, which Django's "
"localization system cannot handle automatically."
msgstr ""
"一些本地语言环境为数字使用上下文相关的格式化，而 Django 本地化系统不能自动处"
"理。"

msgid "Switzerland (German)"
msgstr "Switzerland (German)"

msgid ""
"The Swiss number formatting depends on the type of number that is being "
"formatted. For monetary values, a comma is used as the thousand separator "
"and a decimal point for the decimal separator. For all other numbers, a "
"comma is used as decimal separator and a space as thousand separator. The "
"locale format provided by Django uses the generic separators, a comma for "
"decimal and a space for thousand separators."
msgstr ""
"瑞士数字格式化取决于要格式化的数字类型。对于货币值，用逗号作为千位分隔符，小"
"数点作为小数点分隔符。对于其他数字，逗号用作小数点分隔符，空格用作千分位分隔"
"符。Django 提供的本地语言环境格式化使用通用分隔符，小数点用逗号，千分位分隔符"
"用空格。"

msgid "Internationalization and localization"
msgstr "国际化和本地化"

msgid ""
"The goal of internationalization and localization is to allow a single web "
"application to offer its content in languages and formats tailored to the "
"audience."
msgstr ""

msgid ""
"Django has full support for :doc:`translation of text </topics/i18n/"
"translation>`, :doc:`formatting of dates, times and numbers </topics/i18n/"
"formatting>`, and :doc:`time zones </topics/i18n/timezones>`."
msgstr ""
"Django 完整支持 :doc:`翻译文本 </topics/i18n/translation>`， :doc:`格式化日"
"期，时间和数字 </topics/i18n/formatting>` 以及 :doc:`时区 </topics/i18n/"
"timezones>`。"

msgid "Essentially, Django does two things:"
msgstr "实际上，Django 做了两件事："

msgid ""
"It allows developers and template authors to specify which parts of their "
"apps should be translated or formatted for local languages and cultures."
msgstr ""
"它允许开发者和模板作者指定应用的哪个部分应该被翻译或格式化为本地语言，符合本"
"地文化。"

msgid ""
"It uses these hooks to localize web apps for particular users according to "
"their preferences."
msgstr ""

msgid ""
"Translation depends on the target language, and formatting usually depends "
"on the target country. This information is provided by browsers in the "
"``Accept-Language`` header. However, the time zone isn't readily available."
msgstr ""
"翻译依赖于目标语言，而格式化规则依赖于目标国家。此信息由浏览器的 ``Accept-"
"Language`` 头提供。但是，时区并不容易获得。"

msgid "Definitions"
msgstr "定义"

msgid ""
"The words \"internationalization\" and \"localization\" often cause "
"confusion; here's a simplified definition:"
msgstr ""
"单词国际化（internationalization）和本地化（localization）总是令人迷惑；以下"
"是个简单的定义："

msgid "internationalization"
msgstr "国际化"

msgid "Preparing the software for localization. Usually done by developers."
msgstr "为本地化准备软件。通常由开发者完成。"

msgid "localization"
msgstr "本地化"

msgid ""
"Writing the translations and local formats. Usually done by translators."
msgstr "编写翻译和本地格式化。通常由翻译者完成。"

msgid ""
"More details can be found in the `W3C Web Internationalization FAQ`_, the "
"`Wikipedia article`_ or the `GNU gettext documentation`_."
msgstr ""
"更多细节请查阅 `W3C Web Internationalization FAQ`_ ， `Wikipedia article`_  "
"或  `GNU gettext documentation`_ 。"

msgid ""
"Translation and formatting are controlled by :setting:`USE_I18N` and :"
"setting:`USE_L10N` settings respectively. However, both features involve "
"internationalization and localization. The names of the settings are an "
"unfortunate result of Django's history."
msgstr ""
"翻译和格式化分别由 :setting:`USE_I18N` 和 :setting:`USE_L10N` 控制。但是，这"
"两个功能都涉及国际化和本地化。这两个配置的名字是 Django 的历史原因所导致。"

msgid ""
"Here are some other terms that will help us to handle a common language:"
msgstr "下面是一些术语，可以帮助我们处理通用语言："

msgid "locale name"
msgstr "locale name"

msgid ""
"A locale name, either a language specification of the form ``ll`` or a "
"combined language and country specification of the form ``ll_CC``. Examples: "
"``it``, ``de_AT``, ``es``, ``pt_BR``, ``sr_Latn``. The language part is "
"always in lowercase. The country part is in titlecase if it has more than 2 "
"characters, otherwise it's in uppercase. The separator is an underscore."
msgstr ""
"区域名称，可以是 ``ll`` 形式的语言规范，也可以是 ``ll_CC`` 形式的语言和国家组"
"合规范。例如：``it``、``de_AT``、``es``、``pt_BR``、``sr_Latn``。语言部分总是"
"用小写。国家部分如果超过两个字符，则首字母大写，否则全部大写。分隔符为下划"
"线。"

msgid "language code"
msgstr "language code"

msgid ""
"Represents the name of a language. Browsers send the names of the languages "
"they accept in the ``Accept-Language`` HTTP header using this format. "
"Examples: ``it``, ``de-at``, ``es``, ``pt-br``. Language codes are generally "
"represented in lowercase, but the HTTP ``Accept-Language`` header is case-"
"insensitive. The separator is a dash."
msgstr ""
"代表语言名。浏览器使用这个格式来在 ``Accept-Language`` HTTP header 里发送浏览"
"器接受的语言名。比如：``it``, ``de-at``, ``es``, ``pt-br`` 。语言代码一般用小"
"写表示，但是 HTTP ``Accept-Language`` header 不区分大小写。用破折号来间隔。"

msgid "message file"
msgstr "message file"

msgid ""
"A message file is a plain-text file, representing a single language, that "
"contains all available :term:`translation strings <translation string>` and "
"how they should be represented in the given language. Message files have a "
"``.po`` file extension."
msgstr ""
"一个消息文件是文本文件，代表一种语言，包含所有可用的 :term:`translation "
"strings <translation string>` ，以及它们如何在给定的语言里表示。消息文件的文"
"件扩展名是 ``.po`` 。"

msgid "translation string"
msgstr "translation string"

msgid "A literal that can be translated."
msgstr "可以翻译的文字。"

msgid "format file"
msgstr "format file"

msgid ""
"A format file is a Python module that defines the data formats for a given "
"locale."
msgstr "格式文件是一个 Python 模块，用于定义本地数据格式。"

msgid "Time zones"
msgstr "时区"

msgid ""
"When support for time zones is enabled, Django stores datetime information "
"in UTC in the database, uses time-zone-aware datetime objects internally, "
"and translates them to the end user's time zone in templates and forms."
msgstr ""
"当启用对时区的支持时，Django 在数据库中以 UTC 为单位存储日期时间信息，在内部"
"使用具有时区的日期时间对象，并在模板和表单中将其转换为最终用户的时区。"

msgid ""
"This is handy if your users live in more than one time zone and you want to "
"display datetime information according to each user's wall clock."
msgstr ""
"如果用户居住在多个时区时，这会很方便。你要根据用户的时间来显示日期信息。"

msgid ""
"Even if your website is available in only one time zone, it's still good "
"practice to store data in UTC in your database. The main reason is daylight "
"saving time (DST). Many countries have a system of DST, where clocks are "
"moved forward in spring and backward in autumn. If you're working in local "
"time, you're likely to encounter errors twice a year, when the transitions "
"happen. This probably doesn't matter for your blog, but it's a problem if "
"you over bill or under bill your customers by one hour, twice a year, every "
"year. The solution to this problem is to use UTC in the code and use local "
"time only when interacting with end users."
msgstr ""
"即使你的网站只在一个时区提供服务，在你的数据库中用 UTC 存储数据仍然是一个好的"
"做法。主要原因是夏令时（DST）。许多国家都有一个 DST 系统，春天的时钟会向前移"
"动，秋天的时钟会向后移动。当转换发生时，如果你使用当地时间工作，你很可能会遇"
"到一年两次的错误。这可能对你的博客并不重要，但如果你每年向客户多收或少收一个"
"小时的费用，每年两次，这就是一个问题。解决这个问题的办法是在代码中使用 UTC，"
"只在与终端用户互动时使用当地时间。"

msgid ""
"Time zone support is disabled by default. To enable it, set :setting:`USE_TZ "
"= True <USE_TZ>` in your settings file."
msgstr ""
"时区支持在默认情况下是禁用的。要启用它，请在你的配置文件中设置 :setting:"
"`USE_TZ = True <USE_TZ>`。"

msgid "In Django 5.0, time zone support will be enabled by default."
msgstr "在 Django 5.0 中，时区支持将被默认启用。"

msgid ""
"Time zone support uses :mod:`zoneinfo`, which is part of the Python standard "
"library from Python 3.9.  The ``backports.zoneinfo`` package is "
"automatically installed alongside Django if you are using Python 3.8."
msgstr ""
"时区支持使用 :mod:`zoneinfo`，它是 Python 3.9 中 Python 标准库的一部分。 如果"
"你使用 Python 3.8，``backports.zoneinfo`` 包会自动与 Django 一起安装。"

msgid "Support for non-``pytz`` timezone implementations was added."
msgstr "增加了对非 ``pytz`` 时区实现的支持。"

msgid ""
":mod:`zoneinfo` was made the default timezone implementation. You may "
"continue to use `pytz`_ during the 4.x release cycle via the :setting:"
"`USE_DEPRECATED_PYTZ` setting."
msgstr ""
":mod:`zoneinfo` 被用作默认的时区实现。在 4.x 发布周期内，你可以通过 :setting:"
"`USE_DEPRECATED_PYTZ` 设置继续使用 `pytz`_ 。"

msgid ""
"The default :file:`settings.py` file created by :djadmin:`django-admin "
"startproject <startproject>` includes :setting:`USE_TZ = True <USE_TZ>` for "
"convenience."
msgstr ""
"方便起见，在执行 :djadmin:`django-admin startproject <startproject>` 后创建默"
"认的 :file:`settings.py` 文件中包含了 :setting:`USE_TZ = True <USE_TZ>` 。"

msgid ""
"If you're wrestling with a particular problem, start with the :ref:`time "
"zone FAQ <time-zones-faq>`."
msgstr ""
"如果你正在解决一个特定问题，请从阅读 :ref:`时区常见问题 <time-zones-faq>` 开"
"始。"

msgid "Concepts"
msgstr "概念"

msgid "Naive and aware datetime objects"
msgstr "无时区日期时间对象与有时区日期对象"

msgid ""
"Python's :class:`datetime.datetime` objects have a ``tzinfo`` attribute that "
"can be used to store time zone information, represented as an instance of a "
"subclass of :class:`datetime.tzinfo`. When this attribute is set and "
"describes an offset, a datetime object is **aware**. Otherwise, it's "
"**naive**."
msgstr ""
"Python 的 :class:`datetime.datetime` 对象有一个 ``tzinfo`` 属性，可以用来存储"
"时区信息，表示为 :class:`datetime.tzinfo` 子类的一个实例。当设置这个属性并描"
"述了偏移量后，日期对象就是 **有时区** 的，否则就是 **无时区** 的。"

msgid ""
"You can use :func:`~django.utils.timezone.is_aware` and :func:`~django.utils."
"timezone.is_naive` to determine whether datetimes are aware or naive."
msgstr ""
"你可以使用 :func:`~django.utils.timezone.is_aware` 和 :func:`~django.utils."
"timezone.is_naive` 来确定日期时间是有时区的还是无时区的。"

msgid ""
"When time zone support is disabled, Django uses naive datetime objects in "
"local time. This is sufficient for many use cases. In this mode, to obtain "
"the current time, you would write::"
msgstr ""
"当关闭了时区支持，Django 会在本地时间里使用无时区日期时间对象。这对很多用例来"
"说足够了。在这个模式下，如果你想获取当前时间，你可以这么写："

msgid ""
"When time zone support is enabled (:setting:`USE_TZ=True <USE_TZ>`), Django "
"uses time-zone-aware datetime objects. If your code creates datetime "
"objects, they should be aware too. In this mode, the example above becomes::"
msgstr ""
"当启用了时区支持 (:setting:`USE_TZ=True <USE_TZ>`) ，Django 使用有时区日期时"
"间对象。如果你的代码创建了日期时间对象，她们应该也是有时区的。在这个模式下，"
"上面的例子变成："

msgid ""
"Dealing with aware datetime objects isn't always intuitive. For instance, "
"the ``tzinfo`` argument of the standard datetime constructor doesn't work "
"reliably for time zones with DST. Using UTC is generally safe; if you're "
"using other time zones, you should review the :mod:`zoneinfo` documentation "
"carefully."
msgstr ""
"处理有时区日期时间对象并不总是直观的。例如，标准日期时间构造函数的 "
"``tzinfo`` 参数对于 DST 的时区并不可靠。使用 UTC 通常是安全的；如果你使用其他"
"时区，你应该仔细查看 :mod:`zoneinfo` 文档。"

msgid ""
"Python's :class:`datetime.time` objects also feature a ``tzinfo`` attribute, "
"and PostgreSQL has a matching ``time with time zone`` type. However, as "
"PostgreSQL's docs put it, this type \"exhibits properties which lead to "
"questionable usefulness\"."
msgstr ""
"Python 的 :class:`datetime.time` 对象具有 ``tzinfo`` 属性，PostgreSQL 也具有"
"匹配 ``带有时区时间`` 的类型。但是，正如 PostgreSQL 所描述的，这个类型 \"展示"
"了导致可用性存疑的特性\"。"

msgid ""
"Django only supports naive time objects and will raise an exception if you "
"attempt to save an aware time object, as a timezone for a time with no "
"associated date does not make sense."
msgstr ""
"Django 只支持无时区时间对象，如果打算保存有时区时间对象会引发异常，因为没有关"
"联日期的有时区时间是没有意义的。"

msgid "Interpretation of naive datetime objects"
msgstr "无时区日期时间对象的说明"

msgid ""
"When :setting:`USE_TZ` is ``True``, Django still accepts naive datetime "
"objects, in order to preserve backwards-compatibility. When the database "
"layer receives one, it attempts to make it aware by interpreting it in the :"
"ref:`default time zone <default-current-time-zone>` and raises a warning."
msgstr ""
"当 :setting:`USE_TZ` 为 ``True`` 时，Django 仍然接受无时区日期时间对象，以保"
"持向后兼容。当数据库层收到一个无时区日期时间对象，会试着用 :ref:`默认时区 "
"<default-current-time-zone>` 进行解释将其变为有时区日期对象，并发出警告。"

msgid ""
"Unfortunately, during DST transitions, some datetimes don't exist or are "
"ambiguous. That's why you should always create aware datetime objects when "
"time zone support is enabled. (See the :mod:`Using ZoneInfo section of the "
"zoneinfo docs <zoneinfo>` for examples using the ``fold`` attribute to "
"specify the offset that should apply to a datetime during a DST transition.)"
msgstr ""
"不幸的是，在 DST 转换期间，一些日期时间不存在或不明确。这就是为什么你应该在启"
"用时区支持时创建有时区日期时间对象。（参见 :mod:`zoneinfo 文档的使用 "
"ZoneInfo 章节 <zoneinfo>` ，了解使用 ``fold`` 属性来指定在 DST 过渡期间应该适"
"用于日期时间的偏移量的例子。)"

msgid ""
"In practice, this is rarely an issue. Django gives you aware datetime "
"objects in the models and forms, and most often, new datetime objects are "
"created from existing ones through :class:`~datetime.timedelta` arithmetic. "
"The only datetime that's often created in application code is the current "
"time, and :func:`timezone.now() <django.utils.timezone.now>` automatically "
"does the right thing."
msgstr ""
"实际上，这种情况很罕见。Django 在模型和表单里为你提供了有时区日期时间对象，并"
"且在大部分时候，新的日期时间对象是通过 :class:`~datetime.timedelta` 算法从现"
"有的对象创建的。仅有的经常在应用代码里创建的日期时间是当前时间，:func:"
"`timezone.now() <django.utils.timezone.now>` 会自动且正确的完成这个操作。"

msgid "Default time zone and current time zone"
msgstr "默认时区和当前时区"

msgid ""
"The **default time zone** is the time zone defined by the :setting:"
"`TIME_ZONE` setting."
msgstr "**默认时区** 是通过 :setting:`TIME_ZONE` 定义的时区。"

msgid "The **current time zone** is the time zone that's used for rendering."
msgstr "**当前时区** 是用来渲染的时区。"

msgid ""
"You should set the current time zone to the end user's actual time zone "
"with :func:`~django.utils.timezone.activate`. Otherwise, the default time "
"zone is used."
msgstr ""
"你应该用 :func:`~django.utils.timezone.activated` 将当前时区设置为终端用户的"
"实际时区。否则，将使用默认的时区。"

msgid ""
"As explained in the documentation of :setting:`TIME_ZONE`, Django sets "
"environment variables so that its process runs in the default time zone. "
"This happens regardless of the value of :setting:`USE_TZ` and of the current "
"time zone."
msgstr ""
"正如在 :setting:`TIME_ZONE` 的文档中所解释的，Django 设置环境变量，使其进程在"
"默认时区运行。这与 :setting:`USE_TZ` 的值或当前时区无关。"

msgid ""
"When :setting:`USE_TZ` is ``True``, this is useful to preserve backwards-"
"compatibility with applications that still rely on local time. However, :ref:"
"`as explained above <naive-datetime-objects>`, this isn't entirely reliable, "
"and you should always work with aware datetimes in UTC in your own code. For "
"instance, use :meth:`~datetime.datetime.fromtimestamp` and set the ``tz`` "
"parameter to :data:`~django.utils.timezone.utc`."
msgstr ""
"当 :setting:`USE_TZ` 设置为 ``True`` 时，这样有助于保持仍然需要依赖当地时间的"
"应用程序的后端兼容性。然而， :ref:`就像前面所说的 <naive-datetime-objects>`，"
"这样并不完全可靠，你应该始终在代码里使用有时区日期时间的 UTC 来工作。比如，使"
"用 :meth:`~datetime.datetime.fromtimestamp` 并且将 ``tz`` 参数设置为 :data:"
"`~django.utils.timezone.utc` 。"

msgid "Selecting the current time zone"
msgstr "选择当前时区"

msgid ""
"The current time zone is the equivalent of the current :term:`locale <locale "
"name>` for translations. However, there's no equivalent of the ``Accept-"
"Language`` HTTP header that Django could use to determine the user's time "
"zone automatically. Instead, Django provides :ref:`time zone selection "
"functions <time-zone-selection-functions>`. Use them to build the time zone "
"selection logic that makes sense for you."
msgstr ""
"当前时区相当于当前 :term:`区域 <locale name>` 。但是，Django 没有可用于自动确"
"定用户时区的如  ``Accept-Language`` 的 HTTP 头。相反，Django 提供了 :ref:`时"
"区选择函数 <time-zone-selection-functions>` 。使用它们来建立对你有用的时区选"
"择逻辑。"

msgid ""
"Most websites that care about time zones ask users in which time zone they "
"live and store this information in the user's profile. For anonymous users, "
"they use the time zone of their primary audience or UTC. :func:`zoneinfo."
"available_timezones` provides a set of available timezones that you can use "
"to build a map from likely locations to time zones."
msgstr ""
"大多数关心时区的网站都会询问用户居住在哪个时区，并将这些信息存储在用户的个人"
"资料中。:func:`zoneinfo.available_timezones` 提供了一组可用的时区，你可以用它"
"来建立一个从可能的地点到时区的映射。"

msgid ""
"Here's an example that stores the current timezone in the session. (It skips "
"error handling entirely for the sake of simplicity.)"
msgstr ""
"这里有个在会话(session)里存储当前时区的例子。（为简单起见，它完全跳过了错误处"
"理）"

msgid "Add the following middleware to :setting:`MIDDLEWARE`::"
msgstr "在 :setting:`MIDDLEWARE`: 里添加下面的中间件："

msgid "Create a view that can set the current timezone::"
msgstr "创建一个可以设置当前时区的视图："

msgid "Include a form in ``template.html`` that will ``POST`` to this view:"
msgstr "在  ``template.html``  包含了一个发送 ``POST`` 到视图的表单："

msgid "Time zone aware input in forms"
msgstr "表单里有时区的输入"

msgid ""
"When you enable time zone support, Django interprets datetimes entered in "
"forms in the :ref:`current time zone <default-current-time-zone>` and "
"returns aware datetime objects in ``cleaned_data``."
msgstr ""
"当启用了时区支持，Django会以 :ref:`当前时区 <default-current-time-zone>` 解释"
"表单中输入的日期时间，并且在 ``cleaned_data`` 中返回有时区日期时间对象。"

msgid ""
"Converted datetimes that don't exist or are ambiguous because they fall in a "
"DST transition will be reported as invalid values."
msgstr ""
"转换后的数据时间如果不存在，或者因为属于夏令时过渡期而含糊不清，将被报告为无"
"效的值。"

msgid "Time zone aware output in templates"
msgstr "模板中有时区的输出"

msgid ""
"When you enable time zone support, Django converts aware datetime objects to "
"the :ref:`current time zone <default-current-time-zone>` when they're "
"rendered in templates. This behaves very much like :doc:`format localization "
"</topics/i18n/formatting>`."
msgstr ""
"当启用了时区支持，Django 会在模板中渲染有时区日期时间时，将其转换为当前时区。"
"这非常类似于 :doc:`格式本地化 </topics/i18n/formatting>` 。"

msgid ""
"Django doesn't convert naive datetime objects, because they could be "
"ambiguous, and because your code should never produce naive datetimes when "
"time zone support is enabled. However, you can force conversion with the "
"template filters described below."
msgstr ""
"Django 不会转换无时区日期时间对象，因为它们是含糊不清的，而且当开启了时区支持"
"后，你的代码里绝不应该生成无时区日期时间。但是，你可以使用下面描述的模板过滤"
"器来强制转换。"

msgid ""
"Conversion to local time isn't always appropriate -- you may be generating "
"output for computers rather than for humans. The following filters and tags, "
"provided by the ``tz`` template tag library, allow you to control the time "
"zone conversions."
msgstr ""
"转换为当地时间并不总是合适的——你或许是为计算机而不是为人类生成输出。下面的过"
"滤器和标签，由  ``tz`` 模板标签库支持，允许你控制时区转换。"

msgid "``localtime``"
msgstr "``localtime``"

msgid ""
"Enables or disables conversion of aware datetime objects to the current time "
"zone in the contained block."
msgstr "在包含块里开启或关闭将有时区日期时间对象的转换为当前时区。"

msgid ""
"This tag has exactly the same effects as the :setting:`USE_TZ` setting as "
"far as the template engine is concerned. It allows a more fine grained "
"control of conversion."
msgstr ""
"就模板引擎而言，该标签与 :setting:`USE_TZ` 具有完全相同的效果。它可以更精细地"
"控制转换。"

msgid "To activate or deactivate conversion for a template block, use::"
msgstr "要模板块激活或关闭转换，使用："

msgid ""
"The value of :setting:`USE_TZ` isn't respected inside of a ``{% localtime %}"
"`` block."
msgstr ":setting:`USE_TZ` 的值在 ``{% localtime %}`` 块内被忽略。"

msgid "``timezone``"
msgstr "``timezone``"

msgid ""
"Sets or unsets the current time zone in the contained block. When the "
"current time zone is unset, the default time zone applies."
msgstr "在包含块内设置或取消当前时区。当没有设置当前时区时，会使用默认时区。"

msgid "``get_current_timezone``"
msgstr "``get_current_timezone``"

msgid ""
"You can get the name of the current time zone using the "
"``get_current_timezone`` tag::"
msgstr "使用 ``get_current_timezone`` 标签来获取当前时区的名称："

msgid ""
"Alternatively, you can activate the :func:`~django.template."
"context_processors.tz` context processor and use the ``TIME_ZONE`` context "
"variable."
msgstr ""
"另外，你可以激活 :func:`~django.template.context_processors.tz` 上下文处理器"
"并使用 ``TIME_ZONE`` 上下文变量。"

msgid ""
"These filters accept both aware and naive datetimes. For conversion "
"purposes, they assume that naive datetimes are in the default time zone. "
"They always return aware datetimes."
msgstr ""
"这些过滤器接受有时区日期时间和无时区日期时间。出于转换目的，它们假设无时区日"
"期时间在默认时区中。它们始终返回有时区日期时间。"

msgid "Forces conversion of a single value to the current time zone."
msgstr "单一值强制转换为当前时区。"

msgid "``utc``"
msgstr "``utc``"

msgid "Forces conversion of a single value to UTC."
msgstr "单一值强制转换为 UTC 。"

msgid "Forces conversion of a single value to an arbitrary timezone."
msgstr "单一值强制转换为任意时区。"

msgid ""
"The argument must be an instance of a :class:`~datetime.tzinfo` subclass or "
"a time zone name."
msgstr "参数必须是 :class:`~datetime.tzinfo` 子类实例或时区名。"

msgid "Migration guide"
msgstr "迁移指南"

msgid ""
"Here's how to migrate a project that was started before Django supported "
"time zones."
msgstr "以下是迁移在 Django 支持时区之前已有项目的方法。"

msgid "Database"
msgstr "数据库"

msgid "PostgreSQL"
msgstr "PostgreSQL"

msgid ""
"The PostgreSQL backend stores datetimes as ``timestamp with time zone``. In "
"practice, this means it converts datetimes from the connection's time zone "
"to UTC on storage, and from UTC to the connection's time zone on retrieval."
msgstr ""
"PostgreSQL 后端存储将日期时间存储为 ``带时区的时间戳`` 。事实上，这意味着它在"
"存储时会将日期从连接的时区转换为UTC，并在检索时将UTC转换为连接的时区。"

msgid ""
"As a consequence, if you're using PostgreSQL, you can switch between "
"``USE_TZ = False`` and ``USE_TZ = True`` freely. The database connection's "
"time zone will be set to :setting:`TIME_ZONE` or ``UTC`` respectively, so "
"that Django obtains correct datetimes in all cases. You don't need to "
"perform any data conversions."
msgstr ""
"因此，如果你正在使用 PostgreSQL，你可以在 ``USE_TZ = False`` 和  ``USE_TZ = "
"True`` 之间自由选择，数据库连接的时区将分别设置为 :setting:`TIME_ZONE` 或 "
"``UTC`` ，以便 Django 在所有情况下将得到正确的日期。你不需要执行任何数据转"
"换。"

msgid "Other databases"
msgstr "其他数据库"

msgid ""
"Other backends store datetimes without time zone information. If you switch "
"from ``USE_TZ = False`` to ``USE_TZ = True``, you must convert your data "
"from local time to UTC -- which isn't deterministic if your local time has "
"DST."
msgstr ""
"其他后端存储没有时区信息的日期。如果你的选择从 ``USE_TZ = False`` 变为 "
"``USE_TZ = True`` ，你必须将你的数据从本地时间转换为UTC —— 如果你的当地时间有"
"夏令时时，则不确定。"

msgid "Code"
msgstr "代码"

msgid ""
"The first step is to add :setting:`USE_TZ = True <USE_TZ>` to your settings "
"file. At this point, things should mostly work. If you create naive datetime "
"objects in your code, Django makes them aware when necessary."
msgstr ""
"第一步是将 :setting:`USE_TZ = True <USE_TZ>` 添加到你的配置文件里。在这点上，"
"大多数情况下都应该起作用。如果你在代码里创建无时区日期时间对象，Django 会在必"
"要时将它们转换为有时区日期时间对象。"

msgid ""
"However, these conversions may fail around DST transitions, which means you "
"aren't getting the full benefits of time zone support yet. Also, you're "
"likely to run into a few problems because it's impossible to compare a naive "
"datetime with an aware datetime. Since Django now gives you aware datetimes, "
"you'll get exceptions wherever you compare a datetime that comes from a "
"model or a form with a naive datetime that you've created in your code."
msgstr ""
"然而，这些转换有可能在夏令时转换时失败，这意味着你并没有获得时区支持的所有好"
"处。而且，在运行的时候很可能会遇到一些问题，因为它无法将无时区日期时间和有时"
"区日期时间进行比较。由于 Django 现在为你提供了 有时区时间，你在比较来自模型或"
"表单的日期与代码里创建的无时区日期时间时，会遇到一些异常。"

msgid ""
"So the second step is to refactor your code wherever you instantiate "
"datetime objects to make them aware. This can be done incrementally. :mod:"
"`django.utils.timezone` defines some handy helpers for compatibility code: :"
"func:`~django.utils.timezone.now`, :func:`~django.utils.timezone.is_aware`, :"
"func:`~django.utils.timezone.is_naive`, :func:`~django.utils.timezone."
"make_aware`, and :func:`~django.utils.timezone.make_naive`."
msgstr ""
"第二步是重构你在任何地方实例化的日期时间，将它们转换为有时区日期时间。这可以"
"逐步完成。:mod:`django.utils.timezone` 为了代码兼容性而定义了一些方法：:func:"
"`~django.utils.timezone.now`、 :func:`~django.utils.timezone.is_aware`、 :"
"func:`~django.utils.timezone.is_naive`、 :func:`~django.utils.timezone."
"make_aware` 和 :func:`~django.utils.timezone.make_naive` 。"

msgid ""
"Finally, in order to help you locate code that needs upgrading, Django "
"raises a warning when you attempt to save a naive datetime to the database::"
msgstr ""
"最后，为了帮助你定位需要升级的代码，Django 会在你试图保存无时区日期代码到数据"
"库的时候，引发一个警告。"

msgid ""
"During development, you can turn such warnings into exceptions and get a "
"traceback by adding the following to your settings file::"
msgstr ""
"在开发期间，你可以通过在配置文件中添加下面的代码，使得此类警告变成异常，方便"
"追踪："

msgid "Fixtures"
msgstr "辅助工具"

msgid ""
"When serializing an aware datetime, the UTC offset is included, like this::"
msgstr "当序列化有时区日期时间时，会包含 UTC 偏移，如下："

msgid "While for a naive datetime, it isn't::"
msgstr "对于无时区日期时间，它不能这样："

msgid ""
"For models with :class:`~django.db.models.DateTimeField`\\ s, this "
"difference makes it impossible to write a fixture that works both with and "
"without time zone support."
msgstr ""
"对于带有 :class:`~django.db.models.DateTimeField` 的模型，这种差异使得编写一"
"个支持和不支持时区的辅助工具变得不可能。"

msgid ""
"Fixtures generated with ``USE_TZ = False``, or before Django 1.4, use the "
"\"naive\" format. If your project contains such fixtures, after you enable "
"time zone support, you'll see :exc:`RuntimeWarning`\\ s when you load them. "
"To get rid of the warnings, you must convert your fixtures to the \"aware\" "
"format."
msgstr ""
"使用 ``USE_TZ = False`` 生成辅助工具，或者 Django 1.4 版本之前，使用“无时"
"区”格式化。如果你的项目包含这些辅助工具，则在开始时区支持后，你将会在加载它们"
"时，看到 :exc:`RuntimeWarning` 。为了避免这些警告，你必须将辅助工具转换为“有"
"时区”格式。"

msgid ""
"You can regenerate fixtures with :djadmin:`loaddata` then :djadmin:"
"`dumpdata`. Or, if they're small enough, you can edit them to add the UTC "
"offset that matches your :setting:`TIME_ZONE` to each serialized datetime."
msgstr ""
"你可以先使用 :djadmin:`loaddata` 然后 :djadmin:`dumpdata` 重新生成辅助工具。"
"或者，如果它们足够小，你可以对它们编辑，与将匹配到 :setting:`TIME_ZONE` 的 "
"UTC 偏移量添加到每个序列化日期时间。"

msgid "FAQ"
msgstr "常见问题"

msgid "Setup"
msgstr "安装"

msgid ""
"**I don't need multiple time zones. Should I enable time zone support?**"
msgstr "**我不需要多时区服务。我应该开启时区支持吗？**"

msgid ""
"Yes. When time zone support is enabled, Django uses a more accurate model of "
"local time. This shields you from subtle and unreproducible bugs around "
"daylight saving time (DST) transitions."
msgstr ""
"是的。当启用时区支持时，Django 会使用一个更准确的本地时间模型。这可以让你避免"
"在夏令时（DST）转换时出现细微的、不可再现的错误。"

msgid ""
"When you enable time zone support, you'll encounter some errors because "
"you're using naive datetimes where Django expects aware datetimes. Such "
"errors show up when running tests. You'll quickly learn how to avoid invalid "
"operations."
msgstr ""
"开启时区支持后，会遇到一些错误，因为你使用无时区日期时间，而 Django 期望使用"
"有时区日期时间。这些错误在运行测试的时候会显示出来。你会很快学会如何避免错误"
"的操作。"

msgid ""
"On the other hand, bugs caused by the lack of time zone support are much "
"harder to prevent, diagnose and fix. Anything that involves scheduled tasks "
"or datetime arithmetic is a candidate for subtle bugs that will bite you "
"only once or twice a year."
msgstr ""
"另一方面，由于缺乏时区支持而导致的错误更难预防、诊断和修复。任何涉及到计划任"
"务或日期时间运算的东西都是微妙错误的候选者，这些错误一年只影响你一次或两次。"

msgid ""
"For these reasons, time zone support is enabled by default in new projects, "
"and you should keep it unless you have a very good reason not to."
msgstr ""
"由于这些原因，时区支持在新项目中是默认启用的，除非你有非常好的理由不这样做，"
"否则你应该保持它。"

msgid "**I've enabled time zone support. Am I safe?**"
msgstr "**我已经开启了时区支持。我安全了吗？**"

msgid ""
"Maybe. You're better protected from DST-related bugs, but you can still "
"shoot yourself in the foot by carelessly turning naive datetimes into aware "
"datetimes, and vice-versa."
msgstr ""
"也许吧。你可以更好地避免与 DST 有关的错误，但你仍然可以通过不小心把无时区日期"
"时间变成有时区日期时间，反之亦然。"

msgid ""
"If your application connects to other systems -- for instance, if it queries "
"a web service -- make sure datetimes are properly specified. To transmit "
"datetimes safely, their representation should include the UTC offset, or "
"their values should be in UTC (or both!)."
msgstr ""
"如果你的应用程序连接到其他系统——例如，如果它查询一个网络服务——请确保日期时间"
"被正确指定。为了安全地传输日期，它们的表示应该包括 UTC 的偏移量，或者它们的值"
"应该是 UTC 的（或者两者都是！）。"

msgid ""
"Finally, our calendar system contains interesting edge cases. For example, "
"you can't always subtract one year directly from a given date::"
msgstr ""
"最后，我们的日历系统包含了有趣的边缘情况。例如，你不能总是直接从给定日期中减"
"去一年："

msgid ""
"To implement such a function correctly, you must decide whether 2012-02-29 "
"minus one year is 2011-02-28 or 2011-03-01, which depends on your business "
"requirements."
msgstr ""
"为了正确实现这样的功能，你必须决定 2012-02-29 减去一年是 2011-02-28 还是 "
"2011-03-01，这取决于你的业务需求。"

msgid ""
"**How do I interact with a database that stores datetimes in local time?**"
msgstr "**我该如何与存储本地日期时间的数据库进行交互？**"

msgid ""
"Set the :setting:`TIME_ZONE <DATABASE-TIME_ZONE>` option to the appropriate "
"time zone for this database in the :setting:`DATABASES` setting."
msgstr ""
"在 :setting:`DATABASES` 里将:setting:`TIME_ZONE <DATABASE-TIME_ZONE>` 选项设"
"置为适合该数据库的时区。"

msgid ""
"This is useful for connecting to a database that doesn't support time zones "
"and that isn't managed by Django when :setting:`USE_TZ` is ``True``."
msgstr ""
"当 :setting:`USE_TZ` 为 ``True`` 时，这对连接到不支持时区以及不受 Django 管理"
"的数据库很有用。"

msgid "Troubleshooting"
msgstr "错误调试"

msgid ""
"**My application crashes with** ``TypeError: can't compare offset-naive`` "
"``and offset-aware datetimes`` **-- what's wrong?**"
msgstr ""
"**我的程序因不能比较带有偏移的无时区日期时间与带有偏移的有时区日期时间而崩溃"
"——怎么回事？**"

msgid "Let's reproduce this error by comparing a naive and an aware datetime::"
msgstr "我们通过比较无时区日期时间和有时区日期时间来重现一下这个错误："

msgid ""
"If you encounter this error, most likely your code is comparing these two "
"things:"
msgstr "如果遇到这个错误，很可能你的代码正在比较这两件事："

msgid ""
"a datetime provided by Django -- for instance, a value read from a form or a "
"model field. Since you enabled time zone support, it's aware."
msgstr ""
"Django 支持的日期——比如，读取来自表单或模型字段的值。因为你开启了时区支持，所"
"以它是有时区的。"

msgid ""
"a datetime generated by your code, which is naive (or you wouldn't be "
"reading this)."
msgstr "通过代码生成了日期时间，它是无时区的（否则你就不会读到这里）。"

msgid ""
"Generally, the correct solution is to change your code to use an aware "
"datetime instead."
msgstr "一般来说，正确的解决办法是修改代码，用有时区日期时间代替它。"

msgid ""
"If you're writing a pluggable application that's expected to work "
"independently of the value of :setting:`USE_TZ`, you may find :func:`django."
"utils.timezone.now` useful. This function returns the current date and time "
"as a naive datetime when ``USE_TZ = False`` and as an aware datetime when "
"``USE_TZ = True``. You can add or subtract :class:`datetime.timedelta` as "
"needed."
msgstr ""
"如果你正在编写可插拔的应用独立于 :setting:`USE_TZ` 的值运行，你会发现 :func:"
"`django.utils.timezone.now` 很有用。这个函数会在 ``USE_TZ = False``  时将当前"
"日期和时间以无时区返回，并且在 ``USE_TZ = True`` 时将当前日期和时间以有时区返"
"回。你可以在需要时添加或减少 :class:`datetime.timedelta` 。"

msgid ""
"**I see lots of** ``RuntimeWarning: DateTimeField received a naive "
"datetime`` ``(YYYY-MM-DD HH:MM:SS)`` ``while time zone support is active`` "
"**-- is that bad?**"
msgstr ""
"**我发现了很多告警：** ``RuntimeWarning: DateTimeField received a naive "
"datetime`` ``(YYYY-MM-DD HH:MM:SS)`` ``while time zone support is active`` **"
"——这样不好吗？**"

msgid ""
"When time zone support is enabled, the database layer expects to receive "
"only aware datetimes from your code. This warning occurs when it receives a "
"naive datetime. This indicates that you haven't finished porting your code "
"for time zone support. Please refer to the :ref:`migration guide <time-zones-"
"migration-guide>` for tips on this process."
msgstr ""
"当启用时区支持后，数据库层会期望仅从你的代码里收到有时区日期时间。这个告警发"
"生在数据库收到无时区日期时间时。这表明你没有为时区支持而完成代码移植。请参"
"考 :ref:`迁移指南 <time-zones-migration-guide>` 来获取此过程的提示。"

msgid ""
"In the meantime, for backwards compatibility, the datetime is considered to "
"be in the default time zone, which is generally what you expect."
msgstr ""
"在这期间，为了向后兼容，日期时间被认为处于默认时区内，通常这是你期望的。"

msgid "``now.date()`` **is yesterday! (or tomorrow)**"
msgstr "``now.date()`` 方法得到的结果 **为什么是昨天（或明天）？**"

msgid ""
"If you've always used naive datetimes, you probably believe that you can "
"convert a datetime to a date by calling its :meth:`~datetime.datetime.date` "
"method. You also consider that a :class:`~datetime.date` is a lot like a :"
"class:`~datetime.datetime`, except that it's less accurate."
msgstr ""
"如果你一直在使用无时区日期时间，你或许相信可以通过调用 :meth:`~datetime."
"datetime.date` 方法来将日期时间转换为日期。你也认为 :class:`~datetime.date` "
"和 :class:`~datetime.datetime` 很像，除了它的准确性较差。"

msgid "None of this is true in a time zone aware environment::"
msgstr "在有时区的环境里，这些都不是正确的："

msgid ""
"As this example shows, the same datetime has a different date, depending on "
"the time zone in which it is represented. But the real problem is more "
"fundamental."
msgstr ""
"正如这个例子所显示的，同一个日期时间有不同的日期，这取决于它所代表的时区。但"
"真正的问题是更基本的。"

msgid ""
"A datetime represents a **point in time**. It's absolute: it doesn't depend "
"on anything. On the contrary, a date is a **calendaring concept**. It's a "
"period of time whose bounds depend on the time zone in which the date is "
"considered. As you can see, these two concepts are fundamentally different, "
"and converting a datetime to a date isn't a deterministic operation."
msgstr ""
"一个日期时间代表一个 **时间点**。它是绝对的，不依赖任何事物。另一方面，一个日"
"期是一个 **计算概念** 。它是一个时间段，其范围取决于日期所在的时区。如你所"
"见，这两个概念在根本上是不同的，将日期时间转换为日期并不是确定性的操作。"

msgid "What does this mean in practice?"
msgstr "这在实践中意味着什么？"

msgid ""
"Generally, you should avoid converting a :class:`~datetime.datetime` to :"
"class:`~datetime.date`. For instance, you can use the :tfilter:`date` "
"template filter to only show the date part of a datetime. This filter will "
"convert the datetime into the current time zone before formatting it, "
"ensuring the results appear correctly."
msgstr ""
"通常，你应该避免将 :class:`~datetime.datetime` 转换为 :class:`~datetime."
"date` 。比如，你可以使用 :tfilter:`date` 模板过滤器来只展示日期时间的日期部"
"分。这个过滤器在格式化之前将日期时间转换为为当前时间，确保显示正确的结果。"

msgid ""
"If you really need to do the conversion yourself, you must ensure the "
"datetime is converted to the appropriate time zone first. Usually, this will "
"be the current timezone::"
msgstr ""
"如果你确实需要自己进行转换，你必须首先确保日期时间转换为合适的时区。通常，这"
"将是当前时区："

msgid ""
"**I get an error** \"``Are time zone definitions for your database installed?"
"``\""
msgstr "**收到“你的数据库安装时区定义了吗？”的错误**"

msgid ""
"If you are using MySQL, see the :ref:`mysql-time-zone-definitions` section "
"of the MySQL notes for instructions on loading time zone definitions."
msgstr ""
"如果你正在使用 MySQL，查看  :ref:`mysql-time-zone-definitions` 部分，以获取有"
"关加载时区定义的说明。"

msgid ""
"**I have a string** ``\"2012-02-21 10:28:45\"`` **and I know it's in the** ``"
"\"Europe/Helsinki\"`` **time zone. How do I turn that into an aware datetime?"
"**"
msgstr ""
"**我有一个字符串** ``\"2012-02-21 10:28:45\"`` **并且我知道时区是** ``"
"\"Europe/Helsinki\"`` **。我该如何将其转换为有时区日期时间？**"

msgid ""
"Here you need to create the required ``ZoneInfo`` instance and attach it to "
"the naïve datetime::"
msgstr ""
"在这里，你需要创建所需的 ``ZoneInfo`` 实例，并将其附加到无时区日期时间："

msgid "**How can I obtain the local time in the current time zone?**"
msgstr "**如何在当前时区里获取当地时间？**"

msgid "Well, the first question is, do you really need to?"
msgstr "好吧，首先要问下自己，你真的需要这么做吗？"

msgid ""
"You should only use local time when you're interacting with humans, and the "
"template layer provides :ref:`filters and tags <time-zones-in-templates>` to "
"convert datetimes to the time zone of your choice."
msgstr ""
"当与用户进行交互的时候，你应该只使用当地时间，模板层提供了:ref:`过滤器和标签 "
"<time-zones-in-templates>` 来将日期时间转换为你选择的时区。"

msgid ""
"Furthermore, Python knows how to compare aware datetimes, taking into "
"account UTC offsets when necessary. It's much easier (and possibly faster) "
"to write all your model and view code in UTC. So, in most circumstances, the "
"datetime in UTC returned by :func:`django.utils.timezone.now` will be "
"sufficient."
msgstr ""
"而且，Python 知道如何去比较有时区日期时间，并在必要时考虑 UTC 偏移量。使用 "
"UTC 编写所有模型和视图代码里很容易（并且可能很快）。因此，在大部分情况下，"
"由 :func:`django.utils.timezone.now` 返回的 UTC 日期时间足够了。"

msgid ""
"For the sake of completeness, though, if you really want the local time in "
"the current time zone, here's how you can obtain it::"
msgstr "但是，为了完整性，如果你真的想在当前时区里获取当地时间，你可以这么做："

msgid "In this example, the current time zone is ``\"Europe/Paris\"``."
msgstr "在这个例子里，当前时区是 ``\"Europe/Paris\"`` 。"

msgid "**How can I see all available time zones?**"
msgstr "如何查看所有可用时区？"

msgid ""
":func:`zoneinfo.available_timezones` provides the set of all valid keys for "
"IANA time zones available to your system. See the docs for usage "
"considerations."
msgstr ""
":func:`zoneinfo.available_timezones` 为你的系统提供 IANA 时区的所有有效键集。"
"关于使用注意事项，请参见文档。"

msgid "Translation"
msgstr "翻译"

msgid ""
"In order to make a Django project translatable, you have to add a minimal "
"number of hooks to your Python code and templates. These hooks are called :"
"term:`translation strings <translation string>`. They tell Django: \"This "
"text should be translated into the end user's language, if a translation for "
"this text is available in that language.\" It's your responsibility to mark "
"translatable strings; the system can only translate strings it knows about."
msgstr ""
"为了使 Django 项目可以翻译，你需要在 Python 代码和模板中添加少量钩子。这些钩"
"子被成为 :term:`translation strings <translation string>` 。它们告知Django："
"如果在终端用户语言里，这个文本有对应的翻译，那么应该使用翻译。标记字符串是你"
"的职责，系统只会翻译它知道的字符串。"

msgid ""
"Django then provides utilities to extract the translation strings into a :"
"term:`message file`. This file is a convenient way for translators to "
"provide the equivalent of the translation strings in the target language. "
"Once the translators have filled in the message file, it must be compiled. "
"This process relies on the GNU gettext toolset."
msgstr ""
"然后 Django 提供工具将翻译字符串提取到 :term:`message file` 中。这个文件让翻"
"译者方便地提供翻译字符串。一旦翻译者填写了 message file ，就必须编译它。这个"
"过程依赖 GNU gettext 工具集。"

msgid ""
"Once this is done, Django takes care of translating web apps on the fly in "
"each available language, according to users' language preferences."
msgstr ""

msgid ""
"Django's internationalization hooks are on by default, and that means "
"there's a bit of i18n-related overhead in certain places of the framework. "
"If you don't use internationalization, you should take the two seconds to "
"set :setting:`USE_I18N = False <USE_I18N>` in your settings file. Then "
"Django will make some optimizations so as not to load the "
"internationalization machinery."
msgstr ""
"Django 的国际化钩子默认是开启的，这意味着在框架的某些位置存在一些 i18n 相关的"
"开销。如果你不使用国际化，你应该在配置文件里设置 :setting:`USE_I18N = False "
"<USE_I18N>` 。然后 Django 将进行优化，以免加载国际化机制。"

msgid ""
"Make sure you've activated translation for your project (the fastest way is "
"to check if :setting:`MIDDLEWARE` includes :mod:`django.middleware.locale."
"LocaleMiddleware`). If you haven't yet, see :ref:`how-django-discovers-"
"language-preference`."
msgstr ""
"确保你的项目已经激活了翻译（最快的办法是检查 :setting:`MIDDLEWARE` 是否包含 :"
"mod:`django.middleware.locale.LocaleMiddleware` ）。如果还没有激活，请查看“ "
"Django 如何发现语言偏好（ :ref:`how-django-discovers-language-"
"preference` ）”。"

msgid "Internationalization: in Python code"
msgstr "在 Python 代码中进行国际化"

msgid "Standard translation"
msgstr "标准翻译"

msgid ""
"Specify a translation string by using the function :func:`~django.utils."
"translation.gettext`. It's convention to import this as a shorter alias, "
"``_``, to save typing."
msgstr ""
"使用函数 :func:`~django.utils.translation.gettext` 来指定翻译字符串。按照惯"
"例，将其作为下划线( _ )导入，以保存输入。"

msgid ""
"Python's standard library ``gettext`` module installs ``_()`` into the "
"global namespace, as an alias for ``gettext()``. In Django, we have chosen "
"not to follow this practice, for a couple of reasons:"
msgstr ""
"Python 标准库 ``gettext`` 模块在全局命名空间里安装了 ``_()`` 。在 Django 里，"
"我们没有遵循这个做法，出于下面两个原因："

msgid ""
"Sometimes, you should use :func:`~django.utils.translation.gettext_lazy` as "
"the default translation method for a particular file. Without ``_()`` in the "
"global namespace, the developer has to think about which is the most "
"appropriate translation function."
msgstr ""
"有时，对于特定文件，你应该使用 :func:`~django.utils.translation."
"gettext_lazy` 作为默认翻译方法。如果全局命名空间里没有 ``_()`` ，开发者必须考"
"虑哪个是最合适的翻译函数。"

msgid ""
"The underscore character (``_``) is used to represent \"the previous result"
"\" in Python's interactive shell and doctest tests. Installing a global "
"``_()`` function causes interference. Explicitly importing ``gettext()`` as "
"``_()`` avoids this problem."
msgstr ""
"下划线(\"_\") 用于表示在 Python 的交互式终端和 doctest 测试中 \"上一个结果"
"\" 。安装全局 ``_()`` 函数会引发冲突。导入 ``gettext()`` 替换 ``_()`` 可以避"
"免这个问题。"

msgid "What functions may be aliased as ``_``?"
msgstr "哪些函数能以 ``_`` 为别名？"

msgid ""
"Because of how ``xgettext`` (used by :djadmin:`makemessages`) works, only "
"functions that take a single string argument can be imported as ``_``:"
msgstr ""
"由于 ``xgettext`` 的工作方式，只有带有单一字符串参数的函数才能当做 ``_`` 引"
"入："

msgid ":func:`~django.utils.translation.gettext`"
msgstr ":func:`~django.utils.translation.gettext`"

msgid ":func:`~django.utils.translation.gettext_lazy`"
msgstr ":func:`~django.utils.translation.gettext_lazy`"

msgid ""
"In this example, the text ``\"Welcome to my site.\"`` is marked as a "
"translation string::"
msgstr "在这个例子里，文本  ``\"Welcome to my site.\"``  被标记为翻译字符串："

msgid ""
"You could code this without using the alias. This example is identical to "
"the previous one::"
msgstr "代码里可以不使用别名。这个例子与上一个例子等同："

msgid ""
"Translation works on computed values. This example is identical to the "
"previous two::"
msgstr "翻译适用于计算值。这个例子与前面两个例子等同："

msgid "Translation works on variables. Again, here's an identical example::"
msgstr "翻译适用于变量。同样，这个例子和上面的等同："

msgid ""
"(The caveat with using variables or computed values, as in the previous two "
"examples, is that Django's translation-string-detecting utility, :djadmin:"
"`django-admin makemessages <makemessages>`, won't be able to find these "
"strings. More on :djadmin:`makemessages` later.)"
msgstr ""
"(像上述两个例子那样，使用变量或计算值的警告是： Django 的翻译字符检测实用程"
"序 :djadmin:`django-admin makemessages <makemessages>` 不能找到这些字符串。更"
"多细节在稍后的  :djadmin:`makemessages`  介绍。)"

msgid ""
"The strings you pass to ``_()`` or ``gettext()`` can take placeholders, "
"specified with Python's standard named-string interpolation syntax. Example::"
msgstr ""
"传递到 ``_()`` or ``gettext()``  的字符串可以使用占位符，这是 Python 标准命名"
"字符串插值语法指定的。例如："

msgid ""
"This technique lets language-specific translations reorder the placeholder "
"text. For example, an English translation may be ``\"Today is November 26."
"\"``, while a Spanish translation may be ``\"Hoy es 26 de noviembre.\"`` -- "
"with the month and the day placeholders swapped."
msgstr ""
"这是技巧使得特定语言翻译可以重新排序占位符字段。比如，一条英文翻译可能是 ``"
"\"Today is November 26.\"`` ，而对于西班牙翻译可能就是  ``\"Hoy es 26 de "
"noviembre.\"`` ——其中月份和日期占位符互相交换。"

msgid ""
"For this reason, you should use named-string interpolation (e.g., ``"
"%(day)s``) instead of positional interpolation (e.g., ``%s`` or ``%d``) "
"whenever you have more than a single parameter. If you used positional "
"interpolation, translations wouldn't be able to reorder placeholder text."
msgstr ""
"所以，当你有多个参数的时候，你应该使用命名字符串插值（比如 %(day)s ）而不是位"
"置插值（比如 %s 或 %d ）。如果你使用位置插值，翻译时就不会对占位符字段重新排"
"序。"

msgid ""
"Since string extraction is done by the ``xgettext`` command, only syntaxes "
"supported by ``gettext`` are supported by Django. In particular, Python :py:"
"ref:`f-strings <f-strings>` are not yet supported by ``xgettext``, and "
"JavaScript template strings need ``gettext`` 0.21+."
msgstr ""
"因为字符串提取由 ``xgettext`` 命令行完成，Django 仅支持由 ``gettext`` 支持的"
"语法。特别是，``xgettext`` 尚未支持 Python :py:ref:`f-strings <f-strings>` ，"
"而 JavaScript 模板字符串需要 ``gettext`` 0.21+ 。"

msgid "Comments for translators"
msgstr "为翻译者提供注释"

msgid ""
"If you would like to give translators hints about a translatable string, you "
"can add a comment prefixed with the ``Translators`` keyword on the line "
"preceding the string, e.g.::"
msgstr ""
"如果你想为翻译者提供一些翻译字段的提示，你可以添加以 ``Translators`` 为前缀的"
"注释。例如："

msgid ""
"The comment will then appear in the resulting ``.po`` file associated with "
"the translatable construct located below it and should also be displayed by "
"most translation tools."
msgstr ""
"这个注释将出现在 ``.po`` 文件中与所翻译词条相关的词条下方，并且也应该由大部分"
"翻译工具显示。"

msgid ""
"Just for completeness, this is the corresponding fragment of the resulting "
"``.po`` file:"
msgstr "为了完整起见，这是 ``.po`` 文件的相应片段："

msgid ""
"This also works in templates. See :ref:`translator-comments-in-templates` "
"for more details."
msgstr ""
"这个办法在模板里也同样适用。查看 :ref:`translator-comments-in-templates` 来获"
"取更多详情。"

msgid "Marking strings as no-op"
msgstr "标记不用翻译的字符"

msgid ""
"Use the function :func:`django.utils.translation.gettext_noop()` to mark a "
"string as a translation string without translating it. The string is later "
"translated from a variable."
msgstr ""
"使用 :func:`django.utils.translation.gettext_noop()` 来将字符串标记不用翻译的"
"翻译字符串。这个字符会稍后使用变量来翻译。"

msgid ""
"Use this if you have constant strings that should be stored in the source "
"language because they are exchanged over systems or users -- such as strings "
"in a database -- but should be translated at the last possible point in "
"time, such as when the string is presented to the user."
msgstr ""
"使用该方法的场景是：如果你有一个常量字符串，该字符串以源语言存储，它们通过系"
"统或用户进行交换（比如数据库里的字符串），但应该最后可能的时间点进行翻译，比"
"如当字符串展示给用户时。"

msgid "Pluralization"
msgstr "多元化"

msgid ""
"Use the function :func:`django.utils.translation.ngettext()` to specify "
"pluralized messages."
msgstr ""
"使用  :func:`django.utils.translation.ngettext()`  函数指定多元化信息。"

msgid ""
"``ngettext()`` takes three arguments: the singular translation string, the "
"plural translation string and the number of objects."
msgstr ""
"``ngettext()`` 带有三个参数：单数翻译字符串，复数翻译字符串和一些对象。"

msgid ""
"This function is useful when you need your Django application to be "
"localizable to languages where the number and complexity of `plural forms "
"<https://www.gnu.org/software/gettext/manual/gettext.html#Plural-forms>`_ is "
"greater than the two forms used in English ('object' for the singular and "
"'objects' for all the cases where ``count`` is different from one, "
"irrespective of its value.)"
msgstr ""
"当你需要 Django 应用本地化为复数形式的数量和复杂度大于英语中使用的两种形式的"
"语言时，该函数非常有用。（'object' 表示单数，'objects' 表示  ``count``  不同"
"于1时的所有情况，不论其值如何）"

msgid ""
"In this example the number of objects is passed to the translation languages "
"as the ``count`` variable."
msgstr "在这个例子里，对象的数量作为 count 变量传递给翻译语言。"

msgid ""
"Note that pluralization is complicated and works differently in each "
"language. Comparing ``count`` to 1 isn't always the correct rule. This code "
"looks sophisticated, but will produce incorrect results for some languages::"
msgstr ""
"要注意复数形式是复杂的，并且在每种语言中工作方式不同。比较 count 和 1 并不总"
"是正确的规则。该代码看着很复杂，但会对某些语言产生不正确的结果："

msgid ""
"Don't try to implement your own singular-or-plural logic; it won't be "
"correct. In a case like this, consider something like the following::"
msgstr ""
"不要尝试实现自定义的单数或复数逻辑，它会出错的。像在这种例子中，请考虑以下内"
"容："

msgid ""
"When using ``ngettext()``, make sure you use a single name for every "
"extrapolated variable included in the literal. In the examples above, note "
"how we used the ``name`` Python variable in both translation strings. This "
"example, besides being incorrect in some languages as noted above, would "
"fail::"
msgstr ""
"当使用 ``ngettext()`` 时，要确保为每一个变量使用一个名称。上面的例子中，请注"
"意我们在两个翻译字符串中如何使用 ``name`` Python 变量。该例子除了上面提到的错"
"误外，还会遇到下面的问题："

msgid ""
"You would get an error when running :djadmin:`django-admin compilemessages "
"<compilemessages>`::"
msgstr ""
"当正在运行 :djadmin:`django-admin compilemessages <compilemessages>` 时会遇到"
"错误："

msgid "Contextual markers"
msgstr "上下文标记"

msgid ""
"Sometimes words have several meanings, such as ``\"May\"`` in English, which "
"refers to a month name and to a verb. To enable translators to translate "
"these words correctly in different contexts, you can use the :func:`django."
"utils.translation.pgettext()` function, or the :func:`django.utils."
"translation.npgettext()` function if the string needs pluralization. Both "
"take a context string as the first variable."
msgstr ""
"一些词组有很多不同含义，比如 ``\"May\"`` ，它指五月或者表示一个动词。为了使翻"
"译者在不同上下文中正确翻译这些词组，可以使用 :func:`django.utils.translation."
"pgettext()` 函数，或者如果字符串需要复数形式的话，可以使用 :func:`django."
"utils.translation.npgettext()` 函数。两者都使用上下文字符串作为第一个变量。"

msgid ""
"In the resulting ``.po`` file, the string will then appear as often as there "
"are different contextual markers for the same string (the context will "
"appear on the ``msgctxt`` line), allowing the translator to give a different "
"translation for each of them."
msgstr ""
"在生成的 ``.po`` 文件中，字符串将会频繁出现，因为相同字符串 ( 上下文将在 "
"``msgctxt`` 行上显示) 有不同的上下文标记，所以允许翻译者为每个字符串给出不同"
"翻译。"

msgid "or::"
msgstr "或者："

msgid "will appear in the ``.po`` file as:"
msgstr "将以下方形式出现在 ``.po`` 文件中："

msgid ""
"Contextual markers are also supported by the :ttag:`translate` and :ttag:"
"`blocktranslate` template tags."
msgstr ""
"上下文标记也由 :ttag:`translate` 和 :ttag:`blocktranslate` 模板标签支持。"

msgid "Lazy translation"
msgstr "惰性翻译"

msgid ""
"Use the lazy versions of translation functions in :mod:`django.utils."
"translation` (easily recognizable by the ``lazy`` suffix in their names) to "
"translate strings lazily -- when the value is accessed rather than when "
"they're called."
msgstr ""
"当访问值而不是调用它们时，使用 :mod:`django.utils.translation` 中翻译函数的惰"
"性版本 (在名称中加入 ``lazy`` 前缀来识别) 来延迟翻译字符串。"

msgid ""
"These functions store a lazy reference to the string -- not the actual "
"translation. The translation itself will be done when the string is used in "
"a string context, such as in template rendering."
msgstr ""
"这些函数存储对字符串的惰性引用 —— 并非真实的翻译。当在字符串上下文里使用字符"
"串时，才会翻译。比如模板渲染。"

msgid ""
"This is essential when calls to these functions are located in code paths "
"that are executed at module load time."
msgstr "当对这些函数的调用位于模块加载时执行的代码路径中时，这一点非常重要。"

msgid ""
"This is something that can easily happen when defining models, forms and "
"model forms, because Django implements these such that their fields are "
"actually class-level attributes. For that reason, make sure to use lazy "
"translations in the following cases:"
msgstr ""
"在定义模型、表单和模型表单的时候，很容易遇见这种情况，因为 Django 已经实现了"
"这些，所以它们的字段实际是类级别的属性。因此，请确保以下情况下使用惰性翻译："

msgid ""
"Model fields and relationships ``verbose_name`` and ``help_text`` option "
"values"
msgstr "模型字段和相关的 ``verbose_name`` 与 ``help_text`` 选项值"

msgid ""
"For example, to translate the help text of the *name* field in the following "
"model, do the following::"
msgstr "比如下面这个模型，为了翻译其中 *name* 字段的帮助提示，可以这么做："

msgid ""
"You can mark names of :class:`~django.db.models.ForeignKey`, :class:`~django."
"db.models.ManyToManyField` or :class:`~django.db.models.OneToOneField` "
"relationship as translatable by using their :attr:`~django.db.models.Options."
"verbose_name` options::"
msgstr ""
"你可以通过使用 :attr:`~django.db.models.Options.verbose_name` 选项来将  :"
"class:`~django.db.models.ForeignKey`, :class:`~django.db.models."
"ManyToManyField` 或 :class:`~django.db.models.OneToOneField` 关系标记为可翻"
"译："

msgid ""
"Just like you would do in :attr:`~django.db.models.Options.verbose_name` you "
"should provide a lowercase verbose name text for the relation as Django will "
"automatically titlecase it when required."
msgstr ""
"就像你在 :attr:`~django.db.models.Options.verbose_name` 中所做的那样，你应该"
"为关系提供一个小写的详细名称文本，因为 Django 会在需要时自动为其命名。"

msgid "Model verbose names values"
msgstr "模型详细名称的值"

msgid ""
"It is recommended to always provide explicit :attr:`~django.db.models."
"Options.verbose_name` and :attr:`~django.db.models.Options."
"verbose_name_plural` options rather than relying on the fallback English-"
"centric and somewhat naïve determination of verbose names Django performs by "
"looking at the model's class name::"
msgstr ""
"建议始终提供显式的 :attr:`~django.db.models.Options.verbose_name` 和  :attr:"
"`~django.db.models.Options.verbose_name_plural` 选项，而不是依赖 Django 查看"
"模型的类名来确定以英文为主而且有点简单的详细名称："

msgid "Model methods ``description`` argument to the ``@display`` decorator"
msgstr ""

msgid ""
"For model methods, you can provide translations to Django and the admin site "
"with the ``description`` argument to the :func:`~django.contrib.admin."
"display` decorator::"
msgstr ""

msgid "Working with lazy translation objects"
msgstr "使用惰性翻译对象"

msgid ""
"The result of a ``gettext_lazy()`` call can be used wherever you would use a "
"string (a :class:`str` object) in other Django code, but it may not work "
"with arbitrary Python code. For example, the following won't work because "
"the `requests <https://pypi.org/project/requests/>`_ library doesn't handle "
"``gettext_lazy`` objects::"
msgstr ""
"``gettext_lazy()`` 调用的结果可以在其他 Django 代码使用字符串( :class:`str` "
"对象)的任何地方使用，但它可能不适用于任何 Python 代码。比如，下面这种情况就不"
"行，因为 `requests <https://pypi.org/project/requests/>`_ 库不会处理 "
"``gettext_lazy`` 对象："

msgid ""
"You can avoid such problems by casting ``gettext_lazy()`` objects to text "
"strings before passing them to non-Django code::"
msgstr ""
"要想避免这些问题，你可以在文本字符传递给非 Django 代码之前，将  "
"``gettext_lazy()`` 对象转换为文本字符。"

msgid ""
"If you don't like the long ``gettext_lazy`` name, you can alias it as ``_`` "
"(underscore), like so::"
msgstr ""
"如果你觉得 ``gettext_lazy`` 这个名字有点长，你可以定义它的别名为下划线 "
"``_`` ，像这样："

msgid ""
"Using ``gettext_lazy()`` and ``ngettext_lazy()`` to mark strings in models "
"and utility functions is a common operation. When you're working with these "
"objects elsewhere in your code, you should ensure that you don't "
"accidentally convert them to strings, because they should be converted as "
"late as possible (so that the correct locale is in effect). This "
"necessitates the use of the helper function described next."
msgstr ""
"在模型和工具函数里使用 ``gettext_lazy()`` 和 ``ngettext_lazy()`` 来标记字符串"
"是个常用方法。但在代码的其他地方使用这些对象时，你要确保它们不会被不小心转化"
"为字符串，因为它们要尽量晚一些被转换（以便正确的语言环境生效）。这需要使用下"
"面所描述的帮助函数。"

msgid "Lazy translations and plural"
msgstr "惰性翻译与复数"

msgid ""
"When using lazy translation for a plural string (``n[p]gettext_lazy``), you "
"generally don't know the ``number`` argument at the time of the string "
"definition. Therefore, you are authorized to pass a key name instead of an "
"integer as the ``number`` argument. Then ``number`` will be looked up in the "
"dictionary under that key during string interpolation. Here's example::"
msgstr ""
"当为复数字符串 (``n[p]gettext_lazy``) 使用惰性翻译时，通常不知道字符串定义"
"时  ``number`` 参数值。因此，你可以传递一个关键字名称来作为  ``number`` 参数"
"而不是整数。然后，在插值期间，会在字典里查找 ``number``。例如："

msgid ""
"If the string contains exactly one unnamed placeholder, you can interpolate "
"directly with the ``number`` argument::"
msgstr "如果字符串恰好包含一个未命名的占位符，你可以直接插入 ``number`` 参数："

msgid "Formatting strings: ``format_lazy()``"
msgstr "格式化字符串：``format_lazy()``"

msgid ""
"Python's :meth:`str.format()` method will not work when either the "
"``format_string`` or any of the arguments to :meth:`str.format()` contains "
"lazy translation objects. Instead, you can use :func:`django.utils.text."
"format_lazy()`, which creates a lazy object that runs the ``str.format()`` "
"method only when the result is included in a string. For example::"
msgstr ""
"当 ``format_string`` 或 :meth:`str.format()` 的任何参数包含惰性转换对象时，"
"Python的 :meth:`str.format()` 方法将不起作用。相反，你可以使用 :func:`django."
"utils.text.format_lazy()` ，它会创建一个仅当结果包含在字符串里时会才运行 "
"``str.format()`` 的惰性对象。比如："

msgid ""
"In this case, the lazy translations in ``result`` will only be converted to "
"strings when ``result`` itself is used in a string (usually at template "
"rendering time)."
msgstr ""
"在这种情况下，在 ``result`` 中的惰性翻译仅在字符串(通常在模板渲染时间)里使用 "
"``result`` 时才会被转换成字符串。"

msgid "Other uses of lazy in delayed translations"
msgstr "延迟翻译中惰性(lazy)的其他用法"

msgid ""
"For any other case where you would like to delay the translation, but have "
"to pass the translatable string as argument to another function, you can "
"wrap this function inside a lazy call yourself. For example::"
msgstr ""
"对于“你想延迟翻译，但不得不传递要翻译的字符串作为参数到其他函数”的情况，你可"
"以在惰性调用中包装这个函数。比如："

msgid "And then later::"
msgstr "然后："

msgid "Localized names of languages"
msgstr "语言的本地化名称"

msgid ""
"The ``get_language_info()`` function provides detailed information about "
"languages::"
msgstr "``get_language_info()`` 函数提供关于语言的详细信息："

msgid ""
"The ``name``, ``name_local``, and ``name_translated`` attributes of the "
"dictionary contain the name of the language in English, in the language "
"itself, and in your current active language respectively.  The ``bidi`` "
"attribute is True only for bi-directional languages."
msgstr ""
"字典的 ``name``, ``name_local``, 以及 ``name_translated`` 属性分别包含用英"
"语、该语言本身以及当前启用的语言的名称。``bidi`` 属性仅对于双向(bi-"
"directional)语言为 True 。"

msgid ""
"The source of the language information is the ``django.conf.locale`` module. "
"Similar access to this information is available for template code. See below."
msgstr ""
"语言信息的来源是 ``django.conf.locale`` 模块。模板代码也可以使用类似方式访问"
"信息。"

msgid "Internationalization: in template code"
msgstr "在模板代码中国际化 "

msgid ""
"Translations in :doc:`Django templates </ref/templates/language>` uses two "
"template tags and a slightly different syntax than in Python code. To give "
"your template access to these tags, put ``{% load i18n %}`` toward the top "
"of your template. As with all template tags, this tag needs to be loaded in "
"all templates which use translations, even those templates that extend from "
"other templates which have already loaded the ``i18n`` tag."
msgstr ""
":doc:`Django templates </ref/templates/language>` 中的翻译使用两个模板标签，"
"并且语法与 Python 代码中的语法略有不同。要使模板访问这些标签，需要在模板顶部"
"加入 ``{% load i18n %}`` 。与所有模板标签一样，这个标签需要在所有需要翻译的模"
"板中加载，甚至那些从其他模板继承(extend)而来的模板，也需要继承  ``i18n`` 标"
"签。"

msgid ""
"Translated strings will not be escaped when rendered in a template. This "
"allows you to include HTML in translations, for example for emphasis, but "
"potentially dangerous characters (e.g. ``\"``) will also be rendered "
"unchanged."
msgstr ""
"在渲染模板的时候，翻译后的字符串不会被转义。这使你在翻译中包含 HTML ，比如为"
"了强调，但潜在的危险字符（比如 ``\"``）也将保持不变。"

msgid "``translate`` template tag"
msgstr "``translate`` 模板标签"

msgid ""
"The ``{% translate %}`` template tag translates either a constant string "
"(enclosed in single or double quotes) or variable content::"
msgstr ""
"``{% translate %}`` 模板标签可以翻译常量字符串（用单引号或双引号括起来）或变"
"量内容："

msgid ""
"If the ``noop`` option is present, variable lookup still takes place but the "
"translation is skipped. This is useful when \"stubbing out\" content that "
"will require translation in the future::"
msgstr ""
"如果存在 ``noop`` 选项，则变量查找仍会发生，但会跳过翻译。这在“剔除”将来需要"
"翻译的内容时非常有用："

msgid ""
"Internally, inline translations use an :func:`~django.utils.translation."
"gettext` call."
msgstr "在内部，内联翻译使用 :func:`~django.utils.translation.gettext` 调用。"

msgid ""
"In case a template var (``myvar`` above) is passed to the tag, the tag will "
"first resolve such variable to a string at run-time and then look up that "
"string in the message catalogs."
msgstr ""
"如果模板变量（如上面的 ``myvar`` ）传递给了一个标签，该标签将在运行时首先将这"
"些变量解析为字符串，然后在消息目录里查找变量。"

msgid ""
"It's not possible to mix a template variable inside a string within ``{% "
"translate %}``. If your translations require strings with variables "
"(placeholders), use :ttag:`{% blocktranslate %}<blocktranslate>` instead."
msgstr ""
"在 ``{% translate %}`` 中，不可能在字符串中混合模板变量。如果你的翻译需要变量"
"字符串（占位符），请使用 :ttag:`{% blocktranslate %}<blocktranslate>` 替代。"

msgid ""
"If you'd like to retrieve a translated string without displaying it, you can "
"use the following syntax::"
msgstr "如果你想检索翻译的字符串而不显示它，那你可以使用下面的语法："

msgid ""
"In practice you'll use this to get a string you can use in multiple places "
"in a template or so you can use the output as an argument for other template "
"tags or filters::"
msgstr ""
"事实上你可以使用这个办法来获取一个在模板中多处使用的字符串，或将输出作为其他"
"模板标签或过滤器的参数："

msgid ""
"``{% translate %}`` also supports :ref:`contextual markers<contextual-"
"markers>` using the ``context`` keyword:"
msgstr ""
"``{% translate %}`` 也支持使用 ``context`` 关键词的 :ref:`上下文标记"
"<contextual-markers>`："

msgid "``blocktranslate`` template tag"
msgstr "``blocktranslate`` 模板标签"

msgid ""
"Contrarily to the :ttag:`translate` tag, the ``blocktranslate`` tag allows "
"you to mark complex sentences consisting of literals and variable content "
"for translation by making use of placeholders::"
msgstr ""
"与 :ttag:`translate` 标签相反，``blocktranslate`` 标签允许你通过使用占位符来"
"标记复杂的句子，包括文字和可变内容的翻译："

msgid ""
"To translate a template expression -- say, accessing object attributes or "
"using template filters -- you need to bind the expression to a local "
"variable for use within the translation block. Examples::"
msgstr ""
"要翻译模板表达式（比如，访问对象属性或使用模板过滤器），你需要绑定表达式到本"
"地变量，以便在翻译块中使用。例如："

msgid ""
"You can use multiple expressions inside a single ``blocktranslate`` tag::"
msgstr "你可以在一个 ``blocktranslate`` 标签内使用多个表达式："

msgid ""
"The previous more verbose format is still supported: ``{% blocktranslate "
"with book|title as book_t and author|title as author_t %}``"
msgstr ""
"仍然支持以前的更简洁的格式：``{% blocktranslate with book|title as book_t "
"and author|title as author_t %}``。"

msgid ""
"Other block tags (for example ``{% for %}`` or ``{% if %}``) are not allowed "
"inside a ``blocktranslate`` tag."
msgstr ""
"其他区块标签（例如 ``{% for %}`` 或 ``{% if %}``）不允许放在 "
"``blocktranslate`` 标签内。"

msgid ""
"If resolving one of the block arguments fails, ``blocktranslate`` will fall "
"back to the default language by deactivating the currently active language "
"temporarily with the :func:`~django.utils.translation.deactivate_all` "
"function."
msgstr ""
"如果解决一个区块参数失败，``blocktranslate`` 将回到默认语言，暂时停用当前活动"
"的语言与 :func:`~django.utils.translation.deactivate_all` 函数。"

msgid "This tag also provides for pluralization. To use it:"
msgstr "该标签也提供复数形式。要使用它："

msgid ""
"Designate and bind a counter value with the name ``count``. This value will "
"be the one used to select the right plural form."
msgstr "指定并绑定名称为 ``count`` 的计数器值。该值将用于选择正确的复数形式。"

msgid ""
"Specify both the singular and plural forms separating them with the ``{% "
"plural %}`` tag within the ``{% blocktranslate %}`` and ``{% "
"endblocktranslate %}`` tags."
msgstr ""
"在 ``{% blocktranslate %}`` 和 ``{% endblocktranslate %}`` 标签中，用 ``{% "
"plural %}`` 标签指定单数和复数形式，将它们分开。"

msgid "A more complex example::"
msgstr "一个更复杂的例子："

msgid ""
"When you use both the pluralization feature and bind values to local "
"variables in addition to the counter value, keep in mind that the "
"``blocktranslate`` construct is internally converted to an ``ngettext`` "
"call. This means the same :ref:`notes regarding ngettext variables "
"<pluralization-var-notes>` apply."
msgstr ""
"当你同时使用复数功能和将值绑定到本地变量上时，请记住，``blocktranslate`` 结构"
"在内部被转换为 ``ngettext`` 调用。这意味着同样的 :ref:`关于 ngettext 变量的注"
"释 <pluralization-var-notes>` 适用。"

msgid ""
"Reverse URL lookups cannot be carried out within the ``blocktranslate`` and "
"should be retrieved (and stored) beforehand::"
msgstr "反向 URL 查询不能在 ``blocktranslate`` 内进行，应事先检索（并存储）："

msgid ""
"In practice you'll use this to get a string you can use in multiple places "
"in a template or so you can use the output as an argument for other template "
"tags or filters."
msgstr ""
"事实上你可以使用这个办法来获取一个在模板中多处使用的字符串，或将输出作为其他"
"模板标签或过滤器的参数。"

msgid ""
"``{% blocktranslate %}`` also supports :ref:`contextual markers<contextual-"
"markers>` using the ``context`` keyword:"
msgstr ""
"``{% blocktranslate %}`` 也支持使用 ``context`` 关键字的 :ref:`上下文标记"
"<contextual-markers>` ："

msgid ""
"Another feature ``{% blocktranslate %}`` supports is the ``trimmed`` option. "
"This option will remove newline characters from the beginning and the end of "
"the content of the ``{% blocktranslate %}`` tag, replace any whitespace at "
"the beginning and end of a line and merge all lines into one using a space "
"character to separate them. This is quite useful for indenting the content "
"of a ``{% blocktranslate %}`` tag without having the indentation characters "
"end up in the corresponding entry in the PO file, which makes the "
"translation process easier."
msgstr ""
"``{% blocktranslate %}`` 支持的另一个功能是 ``trimmed`` 选项。这个选项将删除"
"换行字符的开头和结尾的内容的 ``{% blocktranslate %}`` 标签，取代任何空格的开"
"头和结尾的一行，并合并所有行成一个使用空格字符分开。这对于缩进 ``{% "
"blocktranslate %}`` 标签的内容是相当有用的，而不会让缩进字符最终出现在 PO 文"
"件的相应条目中，这使得翻译过程更容易。"

msgid "For instance, the following ``{% blocktranslate %}`` tag::"
msgstr "例如，以下 ``{% blocktranslate %}`` 标签："

msgid ""
"will result in the entry ``\"First sentence. Second paragraph.\"`` in the PO "
"file, compared to ``\"\\n  First sentence.\\n  Second paragraph.\\n\"``, if "
"the ``trimmed`` option had not been specified."
msgstr ""
"如果没有 ``trimmed`` 选项，那么 PO 文件中的条目 ``\"First sentence. Second "
"paragraph.\"`` 成为 ``\"\\n First sentence.\\n Second sentence.\\n\"``。"

msgid "String literals passed to tags and filters"
msgstr "传递字符串给标签和过滤器"

msgid ""
"You can translate string literals passed as arguments to tags and filters by "
"using the familiar ``_()`` syntax::"
msgstr "可以使用常见的 ``_()`` 语法将翻译的字符串作为参数传递给标签和过滤器："

msgid ""
"In this case, both the tag and the filter will see the translated string, so "
"they don't need to be aware of translations."
msgstr ""
"在这种情况下，标签和过滤器将看到翻译后的字符串，因此它们不需要知道翻译。"

msgid ""
"In this example, the translation infrastructure will be passed the string ``"
"\"yes,no\"``, not the individual strings ``\"yes\"`` and ``\"no\"``. The "
"translated string will need to contain the comma so that the filter parsing "
"code knows how to split up the arguments. For example, a German translator "
"might translate the string ``\"yes,no\"`` as ``\"ja,nein\"`` (keeping the "
"comma intact)."
msgstr ""
"在这个例子里，翻译基础结构将被传递字符串 ``\"yes,no\"`` ，而不是单独的字符 ``"
"\"yes\"`` 和 ``\"no\"`` 。翻译后的字符串需要包含逗号，以便过滤器解析代码时知"
"道如何分割参数。比如，一名德国翻译者可以将 ``\"yes,no\"`` 翻译为 ``\"ja,nein"
"\"`` （保持逗号不变）。"

msgid "Comments for translators in templates"
msgstr "模板内对翻译的注释"

msgid ""
"Just like with :ref:`Python code <translator-comments>`, these notes for "
"translators can be specified using comments, either with the :ttag:`comment` "
"tag:"
msgstr ""
"就像 Python 代码一样，对翻译者的提示可以使用注释来标注，使用 :ttag:`comment` "
"标签："

msgid ""
"or with the ``{#`` ... ``#}`` :ref:`one-line comment constructs <template-"
"comments>`:"
msgstr "或者使用 ``{#`` ... ``#}``  单行注释："

msgid ""
"Just for completeness, these are the corresponding fragments of the "
"resulting ``.po`` file:"
msgstr "为了完整起见，这些是生成 ``.po`` 文件的相应片段："

msgid "Switching language in templates"
msgstr "在模板中选择语言"

msgid ""
"If you want to select a language within a template, you can use the "
"``language`` template tag:"
msgstr "如果想在模板中选择语言，可以使用 ``language`` 模板标签："

msgid ""
"While the first occurrence of \"Welcome to our page\" uses the current "
"language, the second will always be in English."
msgstr ""
"第一次出现的 \"Welcome to our page\" 使用当前语言，后面出现的使用英语。"

msgid "Other tags"
msgstr "其他标签"

msgid "These tags also require a ``{% load i18n %}``."
msgstr "下面这些标签同样需要先引入 ``{% load i18n %}``."

msgid "``get_available_languages``"
msgstr "``get_available_languages``"

msgid ""
"``{% get_available_languages as LANGUAGES %}`` returns a list of tuples in "
"which the first element is the :term:`language code` and the second is the "
"language name (translated into the currently active locale)."
msgstr ""
"``{% get_available_languages as LANGUAGES %}`` 返回一个元组列表，其中第一个元"
"素是:term:`language code`，第二个元素是语言名称(翻译成当前活动的语言环境)。"

msgid "``get_current_language``"
msgstr "``get_current_language``"

msgid ""
"``{% get_current_language as LANGUAGE_CODE %}`` returns the current user's "
"preferred language as a string. Example: ``en-us``. See :ref:`how-django-"
"discovers-language-preference`."
msgstr ""
"``{% get_current_language as LANGUAGE_CODE %}`` 返回字符串类型的当前用户首选"
"语言. 类似: ``en-us``. 详情参阅 :ref:`how-django-discovers-language-"
"preference`."

msgid "``get_current_language_bidi``"
msgstr "``get_current_language_bidi``"

msgid ""
"``{% get_current_language_bidi as LANGUAGE_BIDI %}`` returns the current "
"locale's direction. If ``True``, it's a right-to-left language, e.g. Hebrew, "
"Arabic. If ``False`` it's a left-to-right language, e.g. English, French, "
"German, etc."
msgstr ""
"``{% get_current_language_bidi as LANGUAGE_BIDI %}`` 返回当前语言文字的阅读方"
"向。如果是 ``True`` ，则是从右向左阅读的语言，比如希伯来语，阿拉伯语。如果是 "
"``False`` ，则是从左向右阅读的语言，比如英语，法语，德语等。"

msgid "``i18n`` context processor"
msgstr "``i18n`` 上下文处理器"

msgid ""
"If you enable the :class:`django.template.context_processors.i18n` context "
"processor, then each ``RequestContext`` will have access to ``LANGUAGES``, "
"``LANGUAGE_CODE``, and ``LANGUAGE_BIDI`` as defined above."
msgstr ""
"如果启用了 :class:`django.template.context_processors.i18n` 上下文处理器，则"
"每个 ``RequestContext`` 都可以访问上面所定义的 ``LANGUAGES``, "
"``LANGUAGE_CODE`` 和 ``LANGUAGE_BIDI`` 。"

msgid "``get_language_info``"
msgstr "``get_language_info``"

msgid ""
"You can also retrieve information about any of the available languages using "
"provided template tags and filters. To get information about a single "
"language, use the ``{% get_language_info %}`` tag::"
msgstr ""
"你也可以查找关于任何使用支持模板标签和过滤器的可用语言的信息。为了得到单一语"
"言的信息，可以使用 ``{% get_language_info %}`` 标签："

msgid "You can then access the information::"
msgstr "然后，可以访问以下信息："

msgid "``get_language_info_list``"
msgstr "``get_language_info_list``"

msgid ""
"You can also use the ``{% get_language_info_list %}`` template tag to "
"retrieve information for a list of languages (e.g. active languages as "
"specified in :setting:`LANGUAGES`). See :ref:`the section about the "
"set_language redirect view <set_language-redirect-view>` for an example of "
"how to display a language selector using ``{% get_language_info_list %}``."
msgstr ""
"你也可以使用 ``{% get_language_info_list %}`` 模板标签来检索语言列表的信息"
"（例如，:setting:`LANGUAGES` 中指定的有效语言）。查看 :ref:`关于 "
"set_language 重定向视图的章节 <set_language-redirect-view>` 了解如何使用 "
"``{% get_language_info_list %}`` 来显示语言选择器。"

msgid ""
"In addition to :setting:`LANGUAGES` style list of tuples, ``{% "
"get_language_info_list %}`` supports lists of language codes. If you do this "
"in your view:"
msgstr ""
"除元组的 :setting:`LANGUAGES` 样式列表之外，``{% get_language_info_list %}`` "
"也支持语言代码列表。如果在视图中这么做："

msgid "you can iterate over those languages in the template::"
msgstr "你可以在模板中遍历这些语言："

msgid "There are also some filters available for convenience:"
msgstr "为方便起见，还提供了一些过滤器："

msgid "``{{ LANGUAGE_CODE|language_name }}`` (\"German\")"
msgstr "``{{ LANGUAGE_CODE|language_name }}`` (\"German\")"

msgid "``{{ LANGUAGE_CODE|language_name_local }}`` (\"Deutsch\")"
msgstr "``{{ LANGUAGE_CODE|language_name_local }}`` (\"Deutsch\")"

msgid "``{{ LANGUAGE_CODE|language_bidi }}`` (False)"
msgstr "``{{ LANGUAGE_CODE|language_bidi }}`` (False)"

msgid ""
"``{{ LANGUAGE_CODE|language_name_translated }}`` (\"německy\", when active "
"language is Czech)"
msgstr ""
"``{{ LANGUAGE_CODE|language_name_translated }}`` (\"německy\", 当活动语言为捷"
"克语时)"

msgid "Internationalization: in JavaScript code"
msgstr "国际化：在 JavaScript 代码里"

msgid "Adding translations to JavaScript poses some problems:"
msgstr "向 JavaScript 添加翻译会带来一些问题："

msgid "JavaScript code doesn't have access to a ``gettext`` implementation."
msgstr "JavaScript 代码无权访问 ``gettext`` 实现。"

msgid ""
"JavaScript code doesn't have access to ``.po`` or ``.mo`` files; they need "
"to be delivered by the server."
msgstr ""
"JavaScript 代码无权访问 ``.po`` 或 ``.mo`` 文件；它们需要通过服务器传递。"

msgid ""
"The translation catalogs for JavaScript should be kept as small as possible."
msgstr "JavaScript 的翻译目录应该尽可能小。"

msgid ""
"Django provides an integrated solution for these problems: It passes the "
"translations into JavaScript, so you can call ``gettext``, etc., from within "
"JavaScript."
msgstr ""
"Django 为这三个问题提供了解决方案：它将翻译传递给Javascript，因此你可以从 "
"JavaScript 内部调用 ``gettext`` 等。"

msgid ""
"The main solution to these problems is the following ``JavaScriptCatalog`` "
"view, which generates a JavaScript code library with functions that mimic "
"the ``gettext`` interface, plus an array of translation strings."
msgstr ""
"解决这三个问题的主要解决办法是下面的 ``JavaScriptCatalog`` 视图，该视图生成一"
"个JavaScript 库，该库具有模仿 ``gettext`` 接口的函数，外加一个翻译字符串数"
"组。"

msgid "The ``JavaScriptCatalog`` view"
msgstr "``JavaScriptCatalog`` 视图"

msgid ""
"A view that produces a JavaScript code library with functions that mimic the "
"``gettext`` interface, plus an array of translation strings."
msgstr ""
"一个视图，该视图生成一个 JavaScript 代码库，该库带有一个模仿 ``gettext`` 界面"
"的函数，外加一个翻译字符串的数组。"

msgid "**Attributes**"
msgstr "**属性**"

msgid ""
"Translation domain containing strings to add in the view output. Defaults to "
"``'djangojs'``."
msgstr "翻译域包含要添加到视图输出中的字符串。默认为 ``'djangojs'`` 。"

msgid ""
"A list of :attr:`application names <django.apps.AppConfig.name>` among "
"installed applications. Those apps should contain a ``locale`` directory. "
"All those catalogs plus all catalogs found in :setting:`LOCALE_PATHS` (which "
"are always included) are merged into one catalog. Defaults to ``None``, "
"which means that all available translations from all :setting:"
"`INSTALLED_APPS` are provided in the JavaScript output."
msgstr ""
"已安装的应用程序的程序名列表。这些 app 应包含一个 ``locale`` 目录。所有这些目"
"录加上  :setting:`LOCALE_PATHS`  里的目录会合并到一个目录里。默认是 "
"``None`` ，意味着在 JavaScript 输出中提供所有来自 :setting:`INSTALLED_APPS` "
"的可用翻译。"

msgid "**Example with default values**::"
msgstr "**默认值实例** ："

msgid "**Example with custom packages**::"
msgstr "**自定义包实例** ："

msgid ""
"If your root URLconf uses :func:`~django.conf.urls.i18n.i18n_patterns`, "
"``JavaScriptCatalog`` must also be wrapped by ``i18n_patterns()`` for the "
"catalog to be correctly generated."
msgstr ""
"如果你的根 URLconf 使用 :func:`~django.conf.urls.i18n.i18n_patterns` ，"
"``JavaScriptCatalog`` 也必须被 ``i18n_patterns()`` 包装，这样目录才会被正确的"
"生成。"

msgid "**Example with** ``i18n_patterns()``::"
msgstr "``i18n_patterns()`` 实例："

msgid ""
"The precedence of translations is such that the packages appearing later in "
"the ``packages`` argument have higher precedence than the ones appearing at "
"the beginning. This is important in the case of clashing translations for "
"the same literal."
msgstr ""
"后面出现的 ``packages`` 参数比前面出现的参数优先级更高。在相同文字出现冲突翻"
"译的时候，这点很重要。"

msgid ""
"If you use more than one ``JavaScriptCatalog`` view on a site and some of "
"them define the same strings, the strings in the catalog that was loaded "
"last take precedence."
msgstr ""
"如果你使用多个 ``JavaScriptCatalog`` 视图，并且它们中的某些视图定义了相同的字"
"符串，那么最后加载的目录中的字符串拥有优先级。"

msgid "Using the JavaScript translation catalog"
msgstr "使用 JavaScript 翻译目录"

msgid "To use the catalog, pull in the dynamically generated script like this:"
msgstr "要使用目录，请像这样引入动态生成的js："

msgid ""
"This uses reverse URL lookup to find the URL of the JavaScript catalog view. "
"When the catalog is loaded, your JavaScript code can use the following "
"methods:"
msgstr ""
"这使用反向 URL 查询来查找 JavaScript 目录视图。当加载目录后，JavaScript 代码"
"能使用以下方法："

msgid "``gettext``"
msgstr "``gettext``"

msgid "``ngettext``"
msgstr "``ngettext``"

msgid "``interpolate``"
msgstr "``interpolate``"

msgid "``get_format``"
msgstr "``get_format``"

msgid "``gettext_noop``"
msgstr "``gettext_noop``"

msgid "``pgettext``"
msgstr "``pgettext``"

msgid "``npgettext``"
msgstr "``npgettext``"

msgid "``pluralidx``"
msgstr "``pluralidx``"

msgid ""
"The ``gettext`` function behaves similarly to the standard ``gettext`` "
"interface within your Python code::"
msgstr "``gettext`` 函数的行为类似于 Python 代码中的标准 ``gettext`` 接口："

msgid ""
"The ``ngettext`` function provides an interface to pluralize words and "
"phrases::"
msgstr "``ngettext`` 函数提供一个接口来复数化词组和短语："

msgid ""
"The ``interpolate`` function supports dynamically populating a format "
"string. The interpolation syntax is borrowed from Python, so the "
"``interpolate`` function supports both positional and named interpolation:"
msgstr ""
"``interpolate`` 函数支持动态填充格式字符串(format string)。插值语法借鉴自 "
"Python，因此 ``interpolate`` 函数支持位置插值和命名插值。"

msgid ""
"Positional interpolation: ``obj`` contains a JavaScript Array object whose "
"elements values are then sequentially interpolated in their corresponding "
"``fmt`` placeholders in the same order they appear. For example::"
msgstr ""
"位置插入：``obj`` 包含一个 JavaScript 数组对象，它的元素值随后以相同的顺序依"
"次插值到相应的 ``fmt`` 占位符中。例如："

msgid ""
"Named interpolation: This mode is selected by passing the optional boolean "
"``named`` parameter as ``true``. ``obj`` contains a JavaScript object or "
"associative array. For example::"
msgstr ""
"命名插入：通过将可选的布尔 ``named`` 参数设为 ``true`` 来选择这个模式。"
"``obj`` 包含 JavaScript 对象或者关联数组。例如："

msgid ""
"You shouldn't go over the top with string interpolation, though: this is "
"still JavaScript, so the code has to make repeated regular-expression "
"substitutions. This isn't as fast as string interpolation in Python, so keep "
"it to those cases where you really need it (for example, in conjunction with "
"``ngettext`` to produce proper pluralizations)."
msgstr ""
"尽管如此，你不应该使用字符串插值：这仍然是 JavaScript，因此代码必须进行重复的"
"正则表达式替换。这并不像 Python 中的字符串插值那么快，所以请确保你真的需要这"
"么做（比如，与 ``ngettext`` 结合产生合适的复数形式）。"

msgid ""
"The ``get_format`` function has access to the configured i18n formatting "
"settings and can retrieve the format string for a given setting name::"
msgstr ""
"``get_format`` 函数可以访问已配置的 i18n 格式化设置，而且可以检索指定配置名称"
"的格式字符串："

msgid "It has access to the following settings:"
msgstr "它可以访问以下设置："

msgid ":setting:`DATE_FORMAT`"
msgstr ":setting:`DATE_FORMAT`"

msgid ":setting:`DATE_INPUT_FORMATS`"
msgstr ":setting:`DATE_INPUT_FORMATS`"

msgid ":setting:`DATETIME_FORMAT`"
msgstr ":setting:`DATETIME_FORMAT`"

msgid ":setting:`DATETIME_INPUT_FORMATS`"
msgstr ":setting:`DATETIME_INPUT_FORMATS`"

msgid ":setting:`DECIMAL_SEPARATOR`"
msgstr ":setting:`DECIMAL_SEPARATOR`"

msgid ":setting:`FIRST_DAY_OF_WEEK`"
msgstr ":setting:`FIRST_DAY_OF_WEEK`"

msgid ":setting:`MONTH_DAY_FORMAT`"
msgstr ":setting:`MONTH_DAY_FORMAT`"

msgid ":setting:`NUMBER_GROUPING`"
msgstr ":setting:`NUMBER_GROUPING`"

msgid ":setting:`SHORT_DATE_FORMAT`"
msgstr ":setting:`SHORT_DATE_FORMAT`"

msgid ":setting:`SHORT_DATETIME_FORMAT`"
msgstr ":setting:`SHORT_DATETIME_FORMAT`"

msgid ":setting:`THOUSAND_SEPARATOR`"
msgstr ":setting:`THOUSAND_SEPARATOR`"

msgid ":setting:`TIME_FORMAT`"
msgstr ":setting:`TIME_FORMAT`"

msgid ":setting:`TIME_INPUT_FORMATS`"
msgstr ":setting:`TIME_INPUT_FORMATS`"

msgid ":setting:`YEAR_MONTH_FORMAT`"
msgstr ":setting:`YEAR_MONTH_FORMAT`"

msgid ""
"This is useful for maintaining formatting consistency with the Python-"
"rendered values."
msgstr "这对于保持与Python呈现的值的格式一致性非常有用。"

msgid ""
"This emulates the ``gettext`` function but does nothing, returning whatever "
"is passed to it::"
msgstr ""
"这模拟了 ``gettext`` 函数，但不执行任何操作，返回那传递给它的所有内容："

msgid ""
"This is useful for stubbing out portions of the code that will need "
"translation in the future."
msgstr "这对于在将来需要翻译的代码中删除部分代码时很有用。"

msgid ""
"The ``pgettext`` function behaves like the Python variant (:func:`~django."
"utils.translation.pgettext()`), providing a contextually translated word::"
msgstr ""
"``pgettext`` 函数的行为类似于 Python 变体(:func:`~django.utils.translation."
"pgettext()`)，它提供了一个上下文相关的单词："

msgid ""
"The ``npgettext`` function also behaves like the Python variant (:func:"
"`~django.utils.translation.npgettext()`), providing a **pluralized** "
"contextually translated word::"
msgstr ""
"``npgettext`` 函数的行为类似于 Python 变体(:func:`~django.utils.translation."
"npgettext()`)，它提供了一个上下文相关的 **复数** 单词："

msgid ""
"The ``pluralidx`` function works in a similar way to the :tfilter:"
"`pluralize` template filter, determining if a given ``count`` should use a "
"plural form of a word or not::"
msgstr ""
"``pluralidx`` 函数的工作方式类似于 :tfilter:`pluralize` 模板过滤器，决定给定"
"的 ``count`` 是否应该使用单词的复数形式："

msgid ""
"In the simplest case, if no custom pluralization is needed, this returns "
"``false`` for the integer ``1`` and ``true`` for all other numbers."
msgstr ""
"在这种最简单的情况下，如果不需要自定义复数，那么会对整数 ``1`` 返回 "
"``false`` ，其他数返回 ``true`` 。"

msgid ""
"However, pluralization is not this simple in all languages. If the language "
"does not support pluralization, an empty value is provided."
msgstr ""
"然而，在所有语言中复数化并不是这么简单。如果语言不支持复数化，那么就需要提供"
"一个空值。"

msgid ""
"Additionally, if there are complex rules around pluralization, the catalog "
"view will render a conditional expression. This will evaluate to either a "
"``true`` (should pluralize) or ``false`` (should **not** pluralize) value."
msgstr ""
"此外，如果复数的规则复杂，目录视图将渲染一个条件表达式。它将返回  ``true`` "
"(如果是复数) 或 ``false`` (如果不是复数) 的值。"

msgid "The ``JSONCatalog`` view"
msgstr "``JSONCatalog`` 视图"

msgid ""
"In order to use another client-side library to handle translations, you may "
"want to take advantage of the ``JSONCatalog`` view. It's similar to :class:"
"`~django.views.i18n.JavaScriptCatalog` but returns a JSON response."
msgstr ""
"为了使用其他客户端的库来控制翻译，你可能需要利用 ``JSONCatalog`` 视图。它类似"
"于 :class:`~django.views.i18n.JavaScriptCatalog` ，但返回一个 JSON 响应。"

msgid ""
"See the documentation for :class:`~django.views.i18n.JavaScriptCatalog` to "
"learn about possible values and use of the ``domain`` and ``packages`` "
"attributes."
msgstr ""
"查看 :class:`~django.views.i18n.JavaScriptCatalog` 文档来了解关于 ``domain`` "
"和 ``packages`` 属性的可能值和使用。"

msgid "The response format is as follows:"
msgstr "响应格式如下："

msgid "Note on performance"
msgstr "性能说明"

msgid ""
"The various JavaScript/JSON i18n views generate the catalog from ``.mo`` "
"files on every request. Since its output is constant, at least for a given "
"version of a site, it's a good candidate for caching."
msgstr ""
"各种 JavaScript/JSON i18n 视图在每次请求时从 ``.mo`` 文件生成日历。因为其输出"
"是恒定的，至少对于给定版本的站点来说，它是缓存的一个很好的选择。"

msgid ""
"Server-side caching will reduce CPU load. It's easily implemented with the :"
"func:`~django.views.decorators.cache.cache_page` decorator. To trigger cache "
"invalidation when your translations change, provide a version-dependent key "
"prefix, as shown in the example below, or map the view at a version-"
"dependent URL::"
msgstr ""
"服务端缓存将减少 CPU 负载。使用 :func:`~django.views.decorators.cache."
"cache_page` 装饰器很容易实现。要在翻译变化时让缓存失效，需要提供一个版本相关"
"的键前缀，如下例所示，或将视图映射到版本相关的 URL ："

msgid ""
"Client-side caching will save bandwidth and make your site load faster. If "
"you're using ETags (:class:`~django.middleware.http."
"ConditionalGetMiddleware`), you're already covered. Otherwise, you can "
"apply :ref:`conditional decorators <conditional-decorators>`. In the "
"following example, the cache is invalidated whenever you restart your "
"application server::"
msgstr ""
"客户端缓存将节省带宽并让网站加载速度变快。如果你正在使用 ETags（:class:"
"`~django.middleware.http.ConditionalGetMiddleware`），那么你已经被覆盖了。否"
"则，你可以应用条件装饰器（:ref:`conditional decorators <conditional-"
"decorators>`）。在下面的例子中，当你重启应用程序服务时，缓存将失效。"

msgid ""
"You can even pre-generate the JavaScript catalog as part of your deployment "
"procedure and serve it as a static file. This radical technique is "
"implemented in django-statici18n_."
msgstr ""
"你甚至可以在部署过程中预先生成JavaScript目录，并将其作为静态文件。该技术已在 "
"django-statici18n_ 中实现。"

msgid "Internationalization: in URL patterns"
msgstr "国际化：在 URL 模式中"

msgid "Django provides two mechanisms to internationalize URL patterns:"
msgstr "Django 提供两种方式来国际化 URL 模式："

msgid ""
"Adding the language prefix to the root of the URL patterns to make it "
"possible for :class:`~django.middleware.locale.LocaleMiddleware` to detect "
"the language to activate from the requested URL."
msgstr ""
"将语言前缀添加到 URL 模式的根，来使得 :class:`~django.middleware.locale."
"LocaleMiddleware` 从请求的 URL 中检测要激活的语言。"

msgid ""
"Making URL patterns themselves translatable via the :func:`django.utils."
"translation.gettext_lazy()` function."
msgstr ""
"通过 :func:`django.utils.translation.gettext_lazy()` 函数使得 URL 模式本身可"
"翻译。"

msgid ""
"Using either one of these features requires that an active language be set "
"for each request; in other words, you need to have :class:`django.middleware."
"locale.LocaleMiddleware` in your :setting:`MIDDLEWARE` setting."
msgstr ""
"使用这些特性需要为每个请求设置一个激活的语言；换句话说，你需要在 :setting:"
"`MIDDLEWARE` 设置中包含 :class:`django.middleware.locale.LocaleMiddleware` 。"

msgid "Language prefix in URL patterns"
msgstr "URL 模式中的语言前缀"

msgid ""
"This function can be used in a root URLconf and Django will automatically "
"prepend the current active language code to all URL patterns defined within :"
"func:`~django.conf.urls.i18n.i18n_patterns`."
msgstr ""
"这个函数可以在根URLconf中使用，Django 会自动将当前激活的语言代码添加到 :func:"
"`~django.conf.urls.i18n.i18n_patterns` 中定义的所有 URL 模式中。"

msgid ""
"Setting ``prefix_default_language`` to ``False`` removes the prefix from the "
"default language (:setting:`LANGUAGE_CODE`). This can be useful when adding "
"translations to existing site so that the current URLs won't change."
msgstr ""
"设置 ``prefix_default_language`` 为 ``False`` 会从默认语言( :setting:"
"`LANGUAGE_CODE` )中删除前缀。这在向现有网站添加翻译时非常有用，这样当前的网址"
"就不会改变。"

msgid "Example URL patterns::"
msgstr "URL 模式举例："

msgid ""
"After defining these URL patterns, Django will automatically add the "
"language prefix to the URL patterns that were added by the ``i18n_patterns`` "
"function. Example::"
msgstr ""
"定义这些 URL 模式后，Django 会自动将语言前缀添加到由 ``i18n_patterns``  函数"
"添加的URL模式中。例如："

msgid ""
"With ``prefix_default_language=False`` and  ``LANGUAGE_CODE='en'``, the URLs "
"will be::"
msgstr ""
"如果 ``prefix_default_language=False`` 并且 ``LANGUAGE_CODE='en'`` ，URLs 将"
"会是："

msgid ""
":func:`~django.conf.urls.i18n.i18n_patterns` is only allowed in a root "
"URLconf. Using it within an included URLconf will throw an :exc:`~django."
"core.exceptions.ImproperlyConfigured` exception."
msgstr ""
"只允许 :func:`~django.conf.urls.i18n.i18n_patterns` 在根URLconf中运行。在包含"
"的URLconf中使用它时会弹出 :exc:`~django.core.exceptions."
"ImproperlyConfigured` 异常。"

msgid ""
"Ensure that you don't have non-prefixed URL patterns that might collide with "
"an automatically-added language prefix."
msgstr "确保没有可能与自动添加的语言前缀冲突的非前缀 URL 模式。"

msgid "Translating URL patterns"
msgstr "翻译URL模式"

msgid ""
"URL patterns can also be marked translatable using the :func:`~django.utils."
"translation.gettext_lazy` function. Example::"
msgstr ""
"URL模式也可以使用 :func:`~django.utils.translation.gettext_lazy` 函数标记。例"
"如："

msgid ""
"After you've created the translations, the :func:`~django.urls.reverse` "
"function will return the URL in the active language. Example::"
msgstr ""
"然后你可以创建翻译，:func:`~django.urls.reverse` 函数将以激活的语言返回URL。"
"例如："

msgid ""
"In most cases, it's best to use translated URLs only within a language code "
"prefixed block of patterns (using :func:`~django.conf.urls.i18n."
"i18n_patterns`), to avoid the possibility that a carelessly translated URL "
"causes a collision with a non-translated URL pattern."
msgstr ""
"在大多数情况下，最好只在带有语言代码前缀的模式块中使用翻译后的网址(使用  :"
"func:`~django.conf.urls.i18n.i18n_patterns` )，以避免无意中翻译的网址导致与未"
"翻译的网址模式冲突的可能性。"

msgid "Reversing in templates"
msgstr "在模板中反向解析URL"

msgid ""
"If localized URLs get reversed in templates they always use the current "
"language. To link to a URL in another language use the :ttag:`language` "
"template tag. It enables the given language in the enclosed template section:"
msgstr ""
"如果本地化的URLs在模板中解析，那么它们会始终使用当前的语言。要链接其他语言中"
"的URL，需使用 :ttag:`language` 模板标签。它可以在随附的模板部分中启用给定的语"
"言："

msgid ""
"The :ttag:`language` tag expects the language code as the only argument."
msgstr ":ttag:`language` 标签将语言代码作为唯一的参数。"

msgid "Localization: how to create language files"
msgstr "本地化：如何创建语言文件"

msgid ""
"Once the string literals of an application have been tagged for later "
"translation, the translation themselves need to be written (or obtained). "
"Here's how that works."
msgstr ""
"一旦标记了应用程序的字符串文字以供以后翻译，就需要写入（或获取）翻译。这里介"
"绍一下方法。"

msgid "Message files"
msgstr "消息文件"

msgid ""
"The first step is to create a :term:`message file` for a new language. A "
"message file is a plain-text file, representing a single language, that "
"contains all available translation strings and how they should be "
"represented in the given language. Message files have a ``.po`` file "
"extension."
msgstr ""
"首先需要为新语言创建 :term:`message file` 文件。消息文件是一个纯文本文件，代"
"表一种语言，它包含所有可用的翻译字段以及如何以给定语言表示。消息文件扩展名是 "
"``.po`` 文件。"

msgid ""
"Django comes with a tool, :djadmin:`django-admin makemessages "
"<makemessages>`, that automates the creation and upkeep of these files."
msgstr ""
"Django 附带的工具 :djadmin:`django-admin makemessages <makemessages>` 会自动"
"创建并保存这些文件。"

msgid "Gettext utilities"
msgstr "Gettext 实用程序"

msgid ""
"The ``makemessages`` command (and ``compilemessages`` discussed later) use "
"commands from the GNU gettext toolset: ``xgettext``, ``msgfmt``, "
"``msgmerge`` and ``msguniq``."
msgstr ""
"``makemessages`` 命令（和稍后讨论的 ``compilemessages`` ）使用来自 GNU 文字工"
"具集的命令行：``xgettext``, ``msgfmt``, ``msgmerge`` 和 ``msguniq`` 。"

msgid "The minimum version of the ``gettext`` utilities supported is 0.15."
msgstr "``gettext`` 实用工具集支持的最低版本是 0.15 。"

msgid "To create or update a message file, run this command::"
msgstr "要创建或更新消息文件，需执行这个命令："

msgid ""
"...where ``de`` is the :term:`locale name` for the message file you want to "
"create. For example, ``pt_BR`` for Brazilian Portuguese, ``de_AT`` for "
"Austrian German or ``id`` for Indonesian."
msgstr ""
"...其中 ``de`` 是你要创建的消息文件的 :term:`locale name` 。例如，``pt_BR`` "
"是葡萄牙语，``de_AT`` 是奥地利德语，``id`` 是印尼语。"

msgid "The script should be run from one of two places:"
msgstr "脚本应该从以下两个位置之一来运行："

msgid ""
"The root directory of your Django project (the one that contains ``manage."
"py``)."
msgstr "你的 Django 项目的根目录（就是包含 ``manage.py`` 的那个目录）。"

msgid "The root directory of one of your Django apps."
msgstr "Django app的根目录。"

msgid ""
"The script runs over your project source tree or your application source "
"tree and pulls out all strings marked for translation (see :ref:`how-django-"
"discovers-translations` and be sure :setting:`LOCALE_PATHS` is configured "
"correctly). It creates (or updates) a message file in the directory ``locale/"
"LANG/LC_MESSAGES``. In the ``de`` example, the file will be ``locale/de/"
"LC_MESSAGES/django.po``."
msgstr ""
"脚本会遍历你的项目源代码树或者应用程序源代码库，并抽出所有要被翻译的字符串"
"（查看 :ref:`how-django-discovers-translations` 并确保 :setting:"
"`LOCALE_PATHS` 被正确设置）。它在 ``locale/LANG/LC_MESSAGES`` 目录中创建（或"
"更新）消息文件。以德语为例，这个文件会是 ``locale/de/LC_MESSAGES/django."
"po`` 。"

msgid ""
"When you run ``makemessages`` from the root directory of your project, the "
"extracted strings will be automatically distributed to the proper message "
"files. That is, a string extracted from a file of an app containing a "
"``locale`` directory will go in a message file under that directory. A "
"string extracted from a file of an app without any ``locale`` directory will "
"either go in a message file under the directory listed first in :setting:"
"`LOCALE_PATHS` or will generate an error if :setting:`LOCALE_PATHS` is empty."
msgstr ""
"在项目的根目录执行 ``makemessages`` 命令时，提取的字符串将自动分发到合适的消"
"息文件。这就是说，从包含 ``locale`` 目录的 app 文件中提取的字符串将进入该目录"
"下的消息文件中。从不包含任何  ``locale`` 目录的 app 文件中提取的字符串将进"
"入 :setting:`LOCALE_PATHS` 中列出的第一个目录下的消息文件，如果 :setting:"
"`LOCALE_PATHS` 为空，则会报错。"

msgid ""
"By default :djadmin:`django-admin makemessages <makemessages>` examines "
"every file that has the ``.html``, ``.txt`` or ``.py`` file extension. If "
"you want to override that default, use the :option:`--extension "
"<makemessages --extension>` or ``-e`` option to specify the file extensions "
"to examine::"
msgstr ""
"默认情况下，  :djadmin:`django-admin makemessages <makemessages>` 会检查每一"
"个以  ``.html``, ``.txt`` or ``.py`` 为后缀的文件。如果想覆盖默认值，需使用 :"
"option:`--extension <makemessages --extension>` 或 ``-e`` 选项来指定要检查的"
"文件扩展名："

msgid ""
"Separate multiple extensions with commas and/or use ``-e`` or ``--"
"extension`` multiple times::"
msgstr "使用逗号和(或)多次使用 ``-e`` 或 ``--extension`` 来分隔多个扩展名："

msgid ""
"When :ref:`creating message files from JavaScript source code <creating-"
"message-files-from-js-code>` you need to use the special ``djangojs`` "
"domain, **not** ``-e js``."
msgstr ""
"从 JavaScript 源码中创建消息文件时（:ref:`creating message files from "
"JavaScript source code <creating-message-files-from-js-code>`），你需要使用特"
"别的 ``djangojs`` 域，而不是 ``-e js`` 。"

msgid "Using Jinja2 templates?"
msgstr "使用 Jinja2 模板？"

msgid ""
":djadmin:`makemessages` doesn't understand the syntax of Jinja2 templates. "
"To extract strings from a project containing Jinja2 templates, use `Message "
"Extracting`_ from Babel_ instead."
msgstr ""
":djadmin:`makemessages` 不识别Jinja2模板的语法。要从包含Jinja2模板的项目中提"
"取字符串，需要使用 Babel_ 的 `Message Extracting`_ 。"

msgid "Here's an example ``babel.cfg`` configuration file::"
msgstr "``babel.cfg`` 配置文件示例："

msgid ""
"Make sure you list all extensions you're using! Otherwise Babel won't "
"recognize the tags defined by these extensions and will ignore Jinja2 "
"templates containing them entirely."
msgstr ""
"确保列出所有正在使用的扩展名。否则Babel不会识别这些扩展名定义的标签，并会完全"
"忽略包含它们的Jinja2模板。"

msgid ""
"Babel provides similar features to :djadmin:`makemessages`, can replace it "
"in general, and doesn't depend on ``gettext``. For more information, read "
"its documentation about `working with message catalogs`_."
msgstr ""
"Babel提供了与 :djadmin:`makemessages` 类似的功能，通常可以替换它，并且不会依"
"赖 ``gettext`` 。获取更多信息，请查阅关于使用消息目录（ `working with "
"message catalogs`_ ）的文档。"

msgid "No gettext?"
msgstr "没有 gettext？"

msgid ""
"If you don't have the ``gettext`` utilities installed, :djadmin:"
"`makemessages` will create empty files. If that's the case, either install "
"the ``gettext`` utilities or copy the English message file (``locale/en/"
"LC_MESSAGES/django.po``) if available and use it as a starting point, which "
"is an empty translation file."
msgstr ""
"如果你还没有安装 ``gettext`` ，:djadmin:`makemessages` 将创建一个空文件。如果"
"是这种情况，要么安装 ``gettext`` ，要么复制英文消息文件(如果可用) (``locale/"
"en/LC_MESSAGES/django.po``) 并将其作为起点，即一个空的翻译文件。"

msgid "Working on Windows?"
msgstr "在 Windows 上工作？"

msgid ""
"If you're using Windows and need to install the GNU gettext utilities so :"
"djadmin:`makemessages` works, see :ref:`gettext_on_windows` for more "
"information."
msgstr ""
"如果你正在使用Windows并且需要安装 GNU gettext 程序以便 :djadmin:"
"`makemessages` 工作，请参阅 :ref:`gettext_on_windows` 了解更多信息。"

msgid ""
"Each ``.po`` file contains a small bit of metadata, such as the translation "
"maintainer's contact information, but the bulk of the file is a list of "
"**messages** -- mappings between translation strings and the actual "
"translated text for the particular language."
msgstr ""
"每个 ``.po`` 文件包含少量的元数据（例如翻译维护者的联系方式等等）以及大量的翻"
"译文件 —— 要翻译的字符串以及实际翻译的字段之间的映射。"

msgid ""
"For example, if your Django app contained a translation string for the text "
"``\"Welcome to my site.\"``, like so::"
msgstr ""
"例如，如果 Djanog 程序包含一段 ``\"Welcome to my site.\"`` 的翻译字符串，像这"
"样："

msgid ""
"...then :djadmin:`django-admin makemessages <makemessages>` will have "
"created a ``.po`` file containing the following snippet -- a message:"
msgstr ""
"... 然后 :djadmin:`django-admin makemessages <makemessages>` 将创建一个包含以"
"下代码片段的 ``.po`` 文件 —— 一条消息："

msgid "A quick explanation:"
msgstr "快速解释："

msgid ""
"``msgid`` is the translation string, which appears in the source. Don't "
"change it."
msgstr "``msgid`` 是显示在源代码中需要翻译的字符串。不要改动它。"

msgid ""
"``msgstr`` is where you put the language-specific translation. It starts out "
"empty, so it's your responsibility to change it. Make sure you keep the "
"quotes around your translation."
msgstr ""
"``msgstr`` 是你翻译后的字符串。一开始它是空的，因此你需要填充它。确保在翻译中"
"保留引号。"

msgid ""
"As a convenience, each message includes, in the form of a comment line "
"prefixed with ``#`` and located above the ``msgid`` line, the filename and "
"line number from which the translation string was gleaned."
msgstr ""
"为了方便，每个消息包含以前缀为 ``#`` 且位于 ``msgid`` 行上方的注释行的形式的"
"注释行，这个注释行报货文件名和需要翻译字符串的行号。"

msgid ""
"Long messages are a special case. There, the first string directly after the "
"``msgstr`` (or ``msgid``) is an empty string. Then the content itself will "
"be written over the next few lines as one string per line. Those strings are "
"directly concatenated. Don't forget trailing spaces within the strings; "
"otherwise, they'll be tacked together without whitespace!"
msgstr ""
"长消息是特殊的情况。这里，在 ``msgstr`` (or ``msgid``) 后的第一个字符串是空字"
"符串。然后内容本身就会在接下来的几行中以每行一串的形式写出来。这些字符串被直"
"接连接起来。不要忘了字符串中尾部的空格，否则，它们会被粘贴在一起而不留空白！"

msgid "Mind your charset"
msgstr "注意你的字符集"

msgid ""
"Due to the way the ``gettext`` tools work internally and because we want to "
"allow non-ASCII source strings in Django's core and your applications, you "
"**must** use UTF-8 as the encoding for your PO files (the default when PO "
"files are created).  This means that everybody will be using the same "
"encoding, which is important when Django processes the PO files."
msgstr ""
"由于 ``gettext`` 工具的内部工作方式，以及我们在 Django 内核以及你的项目中允"
"许 non-ASCII 源字符串，你 **必须** 使用 UTF-8作为你的PO文件的编码。这意味着每"
"个人将使用相同的编码，这在 Django 处理PO文件时很重要。"

msgid "Fuzzy entries"
msgstr "模糊条目"

msgid ""
":djadmin:`makemessages` sometimes generates translation entries marked as "
"fuzzy, e.g. when translations are inferred from previously translated "
"strings. By default, fuzzy entries are **not** processed by :djadmin:"
"`compilemessages`."
msgstr ""
"当翻译是从例如已翻译的字符串中推断出来的时候，:djadmin:`makemessages`有时会生"
"成标记为“模糊”的翻译条目。在默认情况下，模糊条目**不会**被 :djadmin:"
"`compilemessages`处理。"

msgid ""
"To reexamine all source code and templates for new translation strings and "
"update all message files for **all** languages, run this::"
msgstr ""
"要重新检查新翻译字符串的源代码和模板并更新所有语言的所有消息，运行这行："

msgid "Compiling message files"
msgstr "编译消息文件"

msgid ""
"After you create your message file -- and each time you make changes to it "
"-- you'll need to compile it into a more efficient form, for use by "
"``gettext``. Do this with the :djadmin:`django-admin compilemessages "
"<compilemessages>` utility."
msgstr ""
"创建消息文件后，以及每次修改它时，你需要把它编译成更有效的形式，以供 "
"``gettext`` 使用。使用 :djadmin:`django-admin compilemessages "
"<compilemessages>` 工具来执行此操作。"

msgid ""
"This tool runs over all available ``.po`` files and creates ``.mo`` files, "
"which are binary files optimized for use by ``gettext``. In the same "
"directory from which you ran :djadmin:`django-admin makemessages "
"<makemessages>`, run :djadmin:`django-admin compilemessages "
"<compilemessages>` like this::"
msgstr ""
"该工具运行所有可用的 ``.po`` 文件并创建 ``.mo`` 文件，这些文件是为 "
"``gettext`` 使用而优化的二进制文件。"

msgid "That's it. Your translations are ready for use."
msgstr "这就行了。可以使用你的翻译文件了。"

msgid ""
"If you're using Windows and need to install the GNU gettext utilities so :"
"djadmin:`django-admin compilemessages <compilemessages>` works see :ref:"
"`gettext_on_windows` for more information."
msgstr ""
"如果你正在使用Windows并且需要安装 GNU gettext 程序以便 :djadmin:`django-"
"admin compilemessages <compilemessages>` 工作，请参阅 :ref:"
"`gettext_on_windows` 了解更多信息。"

msgid ".po files: Encoding and BOM usage."
msgstr ".po files: Encoding 和 BOM 用法."

msgid ""
"Django only supports ``.po`` files encoded in UTF-8 and without any BOM "
"(Byte Order Mark) so if your text editor adds such marks to the beginning of "
"files by default then you will need to reconfigure it."
msgstr ""
"Django 只支持使用UTF-8编码的 ``.po`` 文件并且没有任何BOM(字节顺序标记),因此如"
"果文本编辑器默认在文件开头添加这个标记,那么你需要重新配置它."

msgid ""
"Troubleshooting: ``gettext()`` incorrectly detects ``python-format`` in "
"strings with percent signs"
msgstr ""
"疑难解答: ``gettext()`` 在带有百分号的字符串中错误地检测 ``python-format`` "

msgid ""
"In some cases, such as strings with a percent sign followed by a space and "
"a :ref:`string conversion type <old-string-formatting>` (e.g. ``_(\"10% "
"interest\")``), :func:`~django.utils.translation.gettext` incorrectly flags "
"strings with ``python-format``."
msgstr ""
"在某些情况下,带有百分号的字符串跟着一个空格和一个字符串转换换类型( :ref:"
"`string conversion type <old-string-formatting>` ) (例如 ``_(\"10% interest"
"\")`` ),:func:`~django.utils.translation.gettext` 会错误地使用 ``python-"
"format`` 标记字符串."

msgid ""
"If you try to compile message files with incorrectly flagged strings, you'll "
"get an error message like ``number of format specifications in 'msgid' and "
"'msgstr' does not match`` or ``'msgstr' is not a valid Python format string, "
"unlike 'msgid'``."
msgstr ""
"如果试着使用已被错误标记的字符串来编译消息文件,会得到一个消息,例如\" 'msgid' "
"和 'msgstr' 格式数量不匹配\"( number of format specifications in 'msgid' and "
"'msgstr' does not match ),或者\"'msgstr' 不是有效的 Python 格式字符串,"
"与'msgid'不同 \"( 'msgstr' is not a valid Python format string, unlike "
"'msgid')."

msgid ""
"To workaround this, you can escape percent signs by adding a second percent "
"sign::"
msgstr "要解决这个问题，可以通过添加第二个百分号来转义百分号："

msgid ""
"Or you can use ``no-python-format`` so that all percent signs are treated as "
"literals::"
msgstr ""
"或者可以使用非python格式（ ``no-python-format`` ），这样所有百分号会被视为文"
"字："

msgid "Creating message files from JavaScript source code"
msgstr "从 JavaScript 源码中创建消息文件"

msgid ""
"You create and update the message files the same way as the other Django "
"message files -- with the :djadmin:`django-admin makemessages "
"<makemessages>` tool. The only difference is you need to explicitly specify "
"what in gettext parlance is known as a domain in this case the ``djangojs`` "
"domain, by providing a ``-d djangojs`` parameter, like this::"
msgstr ""
"使用 :djadmin:`django-admin makemessages <makemessages>` ，你可以像其他Django"
"消息文件一样创建并更新消息文件。唯一的区别是，你需要提供一个 ``-d djangojs`` "
"参数，明确指定gettext术语中的域，本例中是 ``djangojs``  域，如下所示："

msgid ""
"This would create or update the message file for JavaScript for German. "
"After updating message files, run :djadmin:`django-admin compilemessages "
"<compilemessages>` the same way as you do with normal Django message files."
msgstr ""
"这会创建或更新德语的JavaScript 消息文件。更新消息文件后，像执行普通 Django 消"
"息文件那样运行  :djadmin:`django-admin compilemessages <compilemessages>` 即"
"可。"

msgid "``gettext`` on Windows"
msgstr "Windows 上的 ``gettext`` "

msgid ""
"This is only needed for people who either want to extract message IDs or "
"compile message files (``.po``). Translation work itself involves editing "
"existing files of this type, but if you want to create your own message "
"files, or want to test or compile a changed message file, download `a "
"precompiled binary installer <https://mlocati.github.io/articles/gettext-"
"iconv-windows.html>`_."
msgstr ""
"仅适用于需要提取消息ID或编译消息文件（``.po``）的场景。翻译工作本身涉及编辑这"
"种已存在的文件，但如果你想创建你自己的消息文件，或者想要测试或编译一个已改动"
"的消息文件，需下载一个预编译的二进制安装器（`a precompiled binary installer "
"<https://mlocati.github.io/articles/gettext-iconv-windows.html>`_）。"

msgid ""
"You may also use ``gettext`` binaries you have obtained elsewhere, so long "
"as the ``xgettext --version`` command works properly. Do not attempt to use "
"Django translation utilities with a ``gettext`` package if the command "
"``xgettext --version`` entered at a Windows command prompt causes a popup "
"window saying \"xgettext.exe has generated errors and will be closed by "
"Windows\"."
msgstr ""
"你可能也想使用在其他地方获得的 ``gettext`` 二进制文件，只要 ``xgettext --"
"version`` 命令工作正常即可。如果在命令行下输入 ``xgettext --version`` ，会导"
"致报错：\"xgettext.exe 生成错误，并将被 Windows 关闭。\"，所以请不要试图使用"
"带有 ``gettext`` 包的 Django 翻译工具。"

msgid "Customizing the ``makemessages`` command"
msgstr "自定义 ``makemessages`` 命令"

msgid ""
"If you want to pass additional parameters to ``xgettext``, you need to "
"create a custom :djadmin:`makemessages` command and override its "
"``xgettext_options`` attribute::"
msgstr ""
"如果要给 ``xgettext`` 传递额外的参数，则需要创建自定义的 :djadmin:"
"`makemessages` 命令，并覆盖它的 ``xgettext_options`` 属性："

msgid ""
"If you need more flexibility, you could also add a new argument to your "
"custom :djadmin:`makemessages` command::"
msgstr ""
"如果需要更多的灵活性，也可以给自定义的 :djadmin:`makemessages` 命令添加新的参"
"数："

msgid "Miscellaneous"
msgstr "杂项"

msgid "The ``set_language`` redirect view"
msgstr "``set_language`` 重定向试图"

msgid ""
"As a convenience, Django comes with a view, :func:`django.views.i18n."
"set_language`, that sets a user's language preference and redirects to a "
"given URL or, by default, back to the previous page."
msgstr ""
"方便起见，Django 附带了一个视图 :func:`django.views.i18n.set_language` ，它可"
"以设置用户语言首选项，并且重定向到一个给定的URL，或者默认情况下，会返回到上一"
"页。"

msgid "Activate this view by adding the following line to your URLconf::"
msgstr "要激活这个视图，需要在你的 URLconf 中添加下面这行代码："

msgid ""
"(Note that this example makes the view available at ``/i18n/setlang/``.)"
msgstr "（注意这个例子会使视图在 ``/i18n/setlang/`` 下可用。）"

msgid ""
"Make sure that you don't include the above URL within :func:`~django.conf."
"urls.i18n.i18n_patterns` - it needs to be language-independent itself to "
"work correctly."
msgstr ""
"确保在 :func:`~django.conf.urls.i18n.i18n_patterns` 中不包含上述 URL —— 它需"
"要独立于语言才能正常工作。"

msgid ""
"The view expects to be called via the ``POST`` method, with a ``language`` "
"parameter set in request. If session support is enabled, the view saves the "
"language choice in the user's session. It also saves the language choice in "
"a cookie that is named ``django_language`` by default. (The name can be "
"changed through the :setting:`LANGUAGE_COOKIE_NAME` setting.)"
msgstr ""
"视图期望通过 ``POST`` 方法调用，并在请求中设置 ``language`` 参数。如果 "
"session 支持是可用的，视图会在用户的 session 中保存语言选择。它也会将语言选择"
"保存在默认名为 ``django_language`` （名称可以通过 :setting:"
"`LANGUAGE_COOKIE_NAME` 设置改变）的 cookie 中。"

msgid ""
"After setting the language choice, Django looks for a ``next`` parameter in "
"the ``POST`` or ``GET`` data. If that is found and Django considers it to be "
"a safe URL (i.e. it doesn't point to a different host and uses a safe "
"scheme), a redirect to that URL will be performed. Otherwise, Django may "
"fall back to redirecting the user to the URL from the ``Referer`` header or, "
"if it is not set, to ``/``, depending on the nature of the request:"
msgstr ""
"在设置语言选择后，Django 会检查 ``POST`` 或 ``GET`` 数据中的 ``next`` 参数。"
"如果找到这个参数并且 Django 认为它是一个安全的链接（也就是说它不指向其他主机"
"并使用安全模式），将会重定向到这个链接。否则，Django 可能会重定向到 "
"``Referer`` header 里的 URL，如果没设置这个 URL，则会跳转到 ``/`` ，这取决于"
"请求的性质。"

msgid ""
"If the request accepts HTML content (based on its ``Accept`` HTTP header), "
"the fallback will always be performed."
msgstr "如果请求接受 HTML 内容（基于其 ``Accept`` HTTP头），将始终执行回退。"

msgid ""
"If the request doesn't accept HTML, the fallback will be performed only if "
"the ``next`` parameter was set. Otherwise a 204 status code (No Content) "
"will be returned."
msgstr ""
"如果请求不接受 HTML，只有在设置了 ``next`` 参数的情况下才会进行回退。否则将返"
"回 204 状态码（无内容）。"

msgid "Here's example HTML template code:"
msgstr "这里是一个模板代码的例子："

msgid ""
"In this example, Django looks up the URL of the page to which the user will "
"be redirected in the ``redirect_to`` context variable."
msgstr ""
"在这个例子中，Django 会在 ``redirect_to`` 变量中查找用户将要重定向的网址。"

msgid "Explicitly setting the active language"
msgstr "显式设置语言"

msgid ""
"You may want to set the active language for the current session explicitly. "
"Perhaps a user's language preference is retrieved from another system, for "
"example. You've already been introduced to :func:`django.utils.translation."
"activate()`. That applies to the current thread only. To persist the "
"language for the entire session in a cookie, set the :setting:"
"`LANGUAGE_COOKIE_NAME` cookie on the response::"
msgstr ""
"你可能想显式地为当前会话设置语言。例如，可能是从另一个系统检索用户的语言偏"
"好。你已经了解了 :func:`django.utils.translation.activate()` 。这只适用于当前"
"进程。要将整个会话的语言保留在 cookie 中，请在响应上设置 :setting:"
"`LANGUAGE_COOKIE_NAME` ："

msgid ""
"You would typically want to use both: :func:`django.utils.translation."
"activate()` changes the language for this thread, and setting the cookie "
"makes this preference persist in future requests."
msgstr ""
"通常你想同时使用这两者：:func:`django.utils.translation.activate()` 改变这个"
"线程的语言，并设置cookie使此首选项在以后的请求中保持不变。"

msgid "Using translations outside views and templates"
msgstr "使用视图和模板外的翻译"

msgid ""
"While Django provides a rich set of i18n tools for use in views and "
"templates, it does not restrict the usage to Django-specific code. The "
"Django translation mechanisms can be used to translate arbitrary texts to "
"any language that is supported by Django (as long as an appropriate "
"translation catalog exists, of course). You can load a translation catalog, "
"activate it and translate text to language of your choice, but remember to "
"switch back to original language, as activating a translation catalog is "
"done on per-thread basis and such change will affect code running in the "
"same thread."
msgstr ""
"虽然 Django 提供了一套丰富的i18n工具用于视图和模板，但它并不会限制 Django 特"
"定代码的使用。Django 翻译机制可用于将任何文本翻译成 Django 支持的语言（当然，"
"需要存在合适的翻译目录）。你可以加载翻译目录，激活它并翻译你选择的语言，但记"
"住要切换回原始语言，因为激活语言目录是在每个线程基础上完成的，这样的改变将影"
"响在同一线程中运行的代码。"

msgid ""
"Calling this function with the value ``'de'`` will give you ``\"Willkommen"
"\"``, regardless of :setting:`LANGUAGE_CODE` and language set by middleware."
msgstr ""
"不论 :setting:`LANGUAGE_CODE`  和中间件设置的是什么，用 ``'de'`` 值调用的这个"
"函数都会得到 ``\"Willkommen\"`` 。"

msgid ""
"Functions of particular interest are :func:`django.utils.translation."
"get_language()` which returns the language used in the current thread, :func:"
"`django.utils.translation.activate()` which activates a translation catalog "
"for the current thread, and :func:`django.utils.translation."
"check_for_language()` which checks if the given language is supported by "
"Django."
msgstr ""
":func:`django.utils.translation.get_language()` 会返回当前进程所使用的语言，:"
"func:`django.utils.translation.activate()` 会为当前进程激活翻译目录，:func:"
"`django.utils.translation.check_for_language()` 会检查 Django 是否支持给定的"
"语言。"

msgid ""
"To help write more concise code, there is also a context manager :func:"
"`django.utils.translation.override()` that stores the current language on "
"enter and restores it on exit. With it, the above example becomes::"
msgstr ""
"为了协助编写更简洁的代码，这里还有一个上下文管理器 :func:`django.utils."
"translation.override()` ，它会在输入时存储当前语言，并在退出时恢复它。有了"
"它，上面的例子可变为："

msgid "Language cookie"
msgstr "Language cookie"

msgid "A number of settings can be used to adjust language cookie options:"
msgstr "可以使用一些设置来调整语言cookie选项："

msgid ":setting:`LANGUAGE_COOKIE_NAME`"
msgstr ":setting:`LANGUAGE_COOKIE_NAME`"

msgid ":setting:`LANGUAGE_COOKIE_AGE`"
msgstr ":setting:`LANGUAGE_COOKIE_AGE`"

msgid ":setting:`LANGUAGE_COOKIE_DOMAIN`"
msgstr ":setting:`LANGUAGE_COOKIE_DOMAIN`"

msgid ":setting:`LANGUAGE_COOKIE_HTTPONLY`"
msgstr ":setting:`LANGUAGE_COOKIE_HTTPONLY`"

msgid ":setting:`LANGUAGE_COOKIE_PATH`"
msgstr ":setting:`LANGUAGE_COOKIE_PATH`"

msgid ":setting:`LANGUAGE_COOKIE_SAMESITE`"
msgstr ":setting:`LANGUAGE_COOKIE_SAMESITE`"

msgid ":setting:`LANGUAGE_COOKIE_SECURE`"
msgstr ":setting:`LANGUAGE_COOKIE_SECURE`"

msgid "Implementation notes"
msgstr "实施说明"

msgid "Specialties of Django translation"
msgstr "Django 翻译的特性"

msgid ""
"Django's translation machinery uses the standard ``gettext`` module that "
"comes with Python. If you know ``gettext``, you might note these specialties "
"in the way Django does translation:"
msgstr ""
"Django 翻译机制使用 Python 自带的标准 ``gettext`` 模块。如果你知道  "
"``gettext`` ，你可能注意到了 Django 翻译的这些特性："

msgid ""
"The string domain is ``django`` or ``djangojs``. This string domain is used "
"to differentiate between different programs that store their data in a "
"common message-file library (usually ``/usr/share/locale/``). The ``django`` "
"domain is used for Python and template translation strings and is loaded "
"into the global translation catalogs. The ``djangojs`` domain is only used "
"for JavaScript translation catalogs to make sure that those are as small as "
"possible."
msgstr ""
"字符串域为 ``django`` 或 ``djangojs`` 。这个字符串域用来区分在相同消息文件库"
"(message-file library,通常为 ``/usr/share/locale/`` )中存有数据的不同项目。"
"``django`` 域被用于 Python和模板翻译字符串，以及加载到全局翻译目录。"
"``djangojs`` 域只用于 JavaScript 的翻译目录来确保它们尽可能小。"

msgid ""
"Django doesn't use ``xgettext`` alone. It uses Python wrappers around "
"``xgettext`` and ``msgfmt``. This is mostly for convenience."
msgstr ""
"Django 不会单独使用 ``xgettext`` 。它在 ``xgettext`` 和 ``msgfmt`` 周围使用 "
"Python 装饰器。这主要是为了方便。"

msgid "How Django discovers language preference"
msgstr "Django 如何发现语言偏好"

msgid ""
"Once you've prepared your translations -- or, if you want to use the "
"translations that come with Django -- you'll need to activate translation "
"for your app."
msgstr ""
"一旦你准备好了翻译——或者，如果你想使用Django自带的翻译——那么你需要激活你的项"
"目的翻译。"

msgid ""
"Behind the scenes, Django has a very flexible model of deciding which "
"language should be used -- installation-wide, for a particular user, or both."
msgstr ""
"在后台，Django 有一个非常灵活的模型来决定使用哪一种语言——在全局使用，还是特定"
"用户使用，还是二者都有。"

msgid ""
"To set an installation-wide language preference, set :setting:"
"`LANGUAGE_CODE`. Django uses this language as the default translation -- the "
"final attempt if no better matching translation is found through one of the "
"methods employed by the locale middleware (see below)."
msgstr ""
"在全局范围内设置语言偏好，需要设置 :setting:`LANGUAGE_CODE` 。Django 使用这个"
"语言作为默认翻译 —— 如果通过 locale 中间件所使用的方法之一没有找到匹配的翻"
"译，那么这是最后的尝试（见下文）。"

msgid ""
"If all you want is to run Django with your native language all you need to "
"do is set :setting:`LANGUAGE_CODE` and make sure the corresponding :term:"
"`message files <message file>` and their compiled versions (``.mo``) exist."
msgstr ""
"如果你指向用你的母语运行 Django ，那么你需要做的就是设置 :setting:"
"`LANGUAGE_CODE` 并确保存在相应的消息文件及其编译版本 (``.mo``) 。"

msgid ""
"If you want to let each individual user specify which language they prefer, "
"then you also need to use the ``LocaleMiddleware``. ``LocaleMiddleware`` "
"enables language selection based on data from the request. It customizes "
"content for each user."
msgstr ""
"如果你想让每个独立用户指定他们想要的语言，则还需要使用 "
"``LocaleMiddleware`` 。``LocaleMiddleware`` 可以基于请求中的数据启用语言选"
"择。它为每个用户定制内容。"

msgid ""
"To use ``LocaleMiddleware``, add ``'django.middleware.locale."
"LocaleMiddleware'`` to your :setting:`MIDDLEWARE` setting. Because "
"middleware order matters, follow these guidelines:"
msgstr ""
"要使用 ``LocaleMiddleware``，请在你的 :setting:`MIDDLEWARE` 配置中添加 "
"``'django.middleware.locale.LocaleMiddleware'``。因为中间件的顺序很重要，所以"
"要遵循这些准则。"

msgid "Make sure it's one of the first middleware installed."
msgstr "确保它是最先安装的中间件之一。"

msgid ""
"It should come after ``SessionMiddleware``, because ``LocaleMiddleware`` "
"makes use of session data. And it should come before ``CommonMiddleware`` "
"because ``CommonMiddleware`` needs an activated language in order to resolve "
"the requested URL."
msgstr ""
"它应该在 ``SessionMiddleware`` 之后，因为 ``LocaleMiddleware`` 使用会话数据。"
"而且它应该在 ``CommonMiddleware`` 之前，因为 ``CommonMiddleware`` 需要激活的"
"语言来解析请求的 URL。"

msgid "If you use ``CacheMiddleware``, put ``LocaleMiddleware`` after it."
msgstr "如果你使用 ``CacheMiddleware``，把 ``LocaleMiddleware`` 放在它之后。"

msgid "For example, your :setting:`MIDDLEWARE` might look like this::"
msgstr "例如，你的 :setting:`MIDDLEWARE` 可能看起来像这样："

msgid ""
"(For more on middleware, see the :doc:`middleware documentation </topics/"
"http/middleware>`.)"
msgstr ""
"（关于中间件的更多信息，请参见 :doc:`中间件文档 </topics/http/"
"middleware>`。）"

msgid ""
"``LocaleMiddleware`` tries to determine the user's language preference by "
"following this algorithm:"
msgstr "``LocaleMiddleware`` 试图通过以下算法来确定用户的语言偏好。"

msgid ""
"First, it looks for the language prefix in the requested URL.  This is only "
"performed when you are using the ``i18n_patterns`` function in your root "
"URLconf. See :ref:`url-internationalization` for more information about the "
"language prefix and how to internationalize URL patterns."
msgstr ""
"首先，它在请求的URL中寻找语言前缀。 只有当你在你的根 URLconf 中使用 "
"``i18n_patterns`` 函数时，才会这样做。参见 :ref:`url-internationalization` 了"
"解更多关于语言前缀和如何国际化 URL 模式的信息。"

msgid "Failing that, it looks for a cookie."
msgstr "如果失败，它将查找 cookie。"

msgid ""
"The name of the cookie used is set by the :setting:`LANGUAGE_COOKIE_NAME` "
"setting. (The default name is ``django_language``.)"
msgstr ""
"所使用的 cookie 的名称由 :setting:`LANGUAGE_COOKIE_NAME` 设定。（默认名称是 "
"``django_language``）。"

msgid ""
"Failing that, it looks at the ``Accept-Language`` HTTP header. This header "
"is sent by your browser and tells the server which language(s) you prefer, "
"in order by priority. Django tries each language in the header until it "
"finds one with available translations."
msgstr ""
"如果失败了，它将查看 ``Accept-Language`` HTTP 头。这个头由你的浏览器发送，并"
"告诉服务器你喜欢哪种语言，按优先级排序。Django 会尝试每一种语言，直到找到可用"
"的翻译。"

msgid "Failing that, it uses the global :setting:`LANGUAGE_CODE` setting."
msgstr "如果不行，则使用全局 :setting:`LANGUAGE_CODE` 设置。"

msgid ""
"In each of these places, the language preference is expected to be in the "
"standard :term:`language format<language code>`, as a string. For example, "
"Brazilian Portuguese is ``pt-br``."
msgstr ""
"在每一个地方，语言偏好都应该是标准的 :term:`语言格式<language code>`，作为一"
"个字符串。例如，巴西葡萄牙语是 ``pt-br``。"

msgid ""
"If a base language is available but the sublanguage specified is not, Django "
"uses the base language. For example, if a user specifies ``de-at`` (Austrian "
"German) but Django only has ``de`` available, Django uses ``de``."
msgstr ""
"如果基本语言可用，但指定的子语言不可用，Django 就使用基本语言。例如，如果用户"
"指定了 ``de-at`` （奥地利德语），但 Django 只有 ``de`` 可用，Django 就使用 "
"``de``。"

msgid ""
"Only languages listed in the :setting:`LANGUAGES` setting can be selected. "
"If you want to restrict the language selection to a subset of provided "
"languages (because your application doesn't provide all those languages), "
"set :setting:`LANGUAGES` to a list of languages. For example::"
msgstr ""
"只有 :setting:`LANGUAGES` 设置中列出的语言才能被选择。如果你想将语言选择限制"
"在所提供的语言子集中（因为你的应用程序没有提供所有这些语言），请将 :setting:"
"`LANGUAGES` 设置为语言列表。例如："

msgid ""
"This example restricts languages that are available for automatic selection "
"to German and English (and any sublanguage, like ``de-ch`` or ``en-us``)."
msgstr ""
"这个例子将可供自动选择的语言限制为德语和英语（以及任何子语言，如 ``de-ch`` "
"或 ``en-us``）。"

msgid ""
"If you define a custom :setting:`LANGUAGES` setting, as explained in the "
"previous bullet, you can mark the language names as translation strings -- "
"but use :func:`~django.utils.translation.gettext_lazy` instead of :func:"
"`~django.utils.translation.gettext` to avoid a circular import."
msgstr ""
"如果你定义了一个自定义的 :setting:`LANGUAGES` 设置，就像上一弹所解释的那样，"
"你可以将语言名称标记为翻译字符串——但要使用 :func:`~django.utils.translation."
"gettext_lazy` 而不是 :func:`~django.utils.translation.gettext` 来避免循环导"
"入。"

msgid "Here's a sample settings file::"
msgstr "以下是一个实例配置文件::"

msgid ""
"Once ``LocaleMiddleware`` determines the user's preference, it makes this "
"preference available as ``request.LANGUAGE_CODE`` for each :class:`~django."
"http.HttpRequest`. Feel free to read this value in your view code. Here's an "
"example::"
msgstr ""
"一旦 ``LocaleMiddleware`` 确定了用户的偏好，它就会将这个偏好作为 ``request."
"LANGUAGE_CODE`` 提供给每一个  :class:`~django.http.HttpRequest`。在你的视图代"
"码中可以随意读取这个值。下面是一个例子："

msgid ""
"Note that, with static (middleware-less) translation, the language is in "
"``settings.LANGUAGE_CODE``, while with dynamic (middleware) translation, "
"it's in ``request.LANGUAGE_CODE``."
msgstr ""
"注意，静态（无中间件）翻译时，语言在 ``settings.LANGUAGE_CODE`` 中，而动态"
"（中间件）翻译时，语言在 ``request.LANGUAGE_CODE`` 中。"

msgid "How Django discovers translations"
msgstr "Django 如何发现翻译"

msgid ""
"At runtime, Django builds an in-memory unified catalog of literals-"
"translations. To achieve this it looks for translations by following this "
"algorithm regarding the order in which it examines the different file paths "
"to load the compiled :term:`message files <message file>` (``.mo``) and the "
"precedence of multiple translations for the same literal:"
msgstr ""
"在运行时，Django 会在内存中建立一个统一的字面翻译目录。为了达到这个目的，它通"
"过以下算法来查找翻译，关于它检查不同文件路径的顺序来加载编译的 :term:`消息文"
"件 <message file>` （``.mo``），以及同一字面意义的多个翻译的优先级。"

msgid ""
"The directories listed in :setting:`LOCALE_PATHS` have the highest "
"precedence, with the ones appearing first having higher precedence than the "
"ones appearing later."
msgstr ""
":setting:`LOCALE_PATHS` 中列出的目录优先级最高，先出现的比后出现的优先级高。"

msgid ""
"Then, it looks for and uses if it exists a ``locale`` directory in each of "
"the installed apps listed in :setting:`INSTALLED_APPS`.  The ones appearing "
"first have higher precedence than the ones appearing later."
msgstr ""
"然后，它会在 :setting:`INSTALLED_APPS` 中列出的每个已安装的应用程序中寻找并使"
"用是否存在 ``locale`` 目录。 先出现的比后出现的优先级高。"

msgid ""
"Finally, the Django-provided base translation in ``django/conf/locale`` is "
"used as a fallback."
msgstr "最后，在 ``django/conf/locale`` 中使用 Django 提供的基础翻译作为后备。"

msgid ""
"The translations for literals included in JavaScript assets are looked up "
"following a similar but not identical algorithm. See :class:`."
"JavaScriptCatalog` for more details."
msgstr ""
"JavaScript 资产中包含的字词的翻译是按照类似但不相同的算法来查找的。更多细节请"
"参见 :class:`.JavaScriptCatalog`。"

msgid ""
"You can also put :ref:`custom format files <custom-format-files>` in the :"
"setting:`LOCALE_PATHS` directories if you also set :setting:"
"`FORMAT_MODULE_PATH`."
msgstr ""
"如果你还设置了 :set:`FORMAT_MODULE_PATH`，你也可以把 :ref:`自定义格式文件 "
"<custom-format-files>` 放在 :set:`LOCALE_PATHS` 目录下。"

msgid ""
"In all cases the name of the directory containing the translation is "
"expected to be named using :term:`locale name` notation. E.g. ``de``, "
"``pt_BR``, ``es_AR``, etc. Untranslated strings for territorial language "
"variants use the translations of the generic language. For example, "
"untranslated ``pt_BR`` strings use ``pt`` translations."
msgstr ""
"在所有情况下，包含译文的目录名称应使用 :term:`locale name` 符号来命名，如 "
"``de``、``pt_BR``、``es_AR`` 等。未翻译的地域语言变体字符串使用通用语言的翻"
"译。例如，未翻译的 ``pt_BR`` 字符串使用 ``pt`` 翻译。"

msgid ""
"This way, you can write applications that include their own translations, "
"and you can override base translations in your project. Or, you can build a "
"big project out of several apps and put all translations into one big common "
"message file specific to the project you are composing. The choice is yours."
msgstr ""
"这样，你可以编写包含自己翻译的应用程序，你可以在你的项目中覆盖基础翻译。或"
"者，你可以用几个应用程序构建一个大项目，并将所有翻译放到一个大的通用消息文件"
"中，具体到你正在编写的项目。这是你的选择。"

msgid "All message file repositories are structured the same way. They are:"
msgstr "所有的消息文件库的结构都是一样的。它们是："

msgid ""
"All paths listed in :setting:`LOCALE_PATHS` in your settings file are "
"searched for ``<language>/LC_MESSAGES/django.(po|mo)``"
msgstr ""
"配置文件的 :setting:`LOCALE_PATHS` 中列出的所有路径都会被搜索到 ``<language>/"
"LC_MESSAGES/django.(po|mo)``"

msgid "``$APPPATH/locale/<language>/LC_MESSAGES/django.(po|mo)``"
msgstr "``$APPPATH/locale/<language>/LC_MESSAGES/django.(po|mo)``"

msgid ""
"``$PYTHONPATH/django/conf/locale/<language>/LC_MESSAGES/django.(po|mo)``"
msgstr ""
"``$PYTHONPATH/django/conf/locale/<language>/LC_MESSAGES/django.(po|mo)``"

msgid ""
"To create message files, you use the :djadmin:`django-admin makemessages "
"<makemessages>` tool. And you use :djadmin:`django-admin compilemessages "
"<compilemessages>` to produce the binary ``.mo`` files that are used by "
"``gettext``."
msgstr ""
"为了创建消息文件，你使用 :djadmin:`django-admin makemessages <makemessages>` "
"工具。并使用 :djadmin:`django-admin compilemessages <compilemessages>` 来生成"
"二进制的 ``.mo`` 文件，这些文件被 ``gettext`` 使用。"

msgid ""
"You can also run :djadmin:`django-admin compilemessages --settings=path.to."
"settings <compilemessages>` to make the compiler process all the directories "
"in your :setting:`LOCALE_PATHS` setting."
msgstr ""
"你也可以运行 :djadmin:`django-admin compilemessages --settings=path.to."
"settings <compilemessages>` 使编译器处理你 :settings:`LOCALE_PATHS` 设置中的"
"所有目录。"

msgid "Using a non-English base language"
msgstr "使用非英语基础语言"

msgid ""
"Django makes the general assumption that the original strings in a "
"translatable project are written in English. You can choose another "
"language, but you must be aware of certain limitations:"
msgstr ""
"Django 一般假设可翻译项目中的原始字符串是用英语编写的。你可以选择其他语言，但"
"你必须意识到某些限制。"

msgid ""
"``gettext`` only provides two plural forms for the original messages, so you "
"will also need to provide a translation for the base language to include all "
"plural forms if the plural rules for the base language are different from "
"English."
msgstr ""
"``gettext`` 只为原始信息提供两种复数形式，所以如果基础语言的复数规则与英语不"
"同，你还需要提供基础语言的翻译，以包括所有的复数形式。"

msgid ""
"When an English variant is activated and English strings are missing, the "
"fallback language will not be the :setting:`LANGUAGE_CODE` of the project, "
"but the original strings. For example, an English user visiting a site with :"
"setting:`LANGUAGE_CODE` set to Spanish and original strings written in "
"Russian will see Russian text rather than Spanish."
msgstr ""
"当英文变体被激活而英文字符串缺失时，后备语言将不是项目的 :setting:"
"`LANGUAGE_CODE`，而是原始字符串。例如，一个英语用户访问一个有 :setting:"
"`LANGUAGE_CODE` 设置为西班牙语的网站，而原来的字符串是用俄语写的，他看到的将"
"是俄语文本而不是西班牙语。"

msgid "Using Django"
msgstr "使用 Django"

msgid "Introductions to all the key parts of Django you'll need to know:"
msgstr "你需要知道的所有 Django 关键部分介绍："

msgid "How to install Django"
msgstr "如何安装 Django"

msgid "This document will get you up and running with Django."
msgstr "本文档将帮助您使用 Django。"

msgid "Install Python"
msgstr "安装 Python"

msgid ""
"Django is a Python web framework. See :ref:`faq-python-version-support` for "
"details."
msgstr ""

msgid ""
"Get the latest version of Python at https://www.python.org/downloads/ or "
"with your operating system's package manager."
msgstr ""
"可以通过 https://www.python.org/downloads/ 或者操作系统的包管理工具获取最新版"
"本的 Python。"

msgid "Python on Windows"
msgstr "Windows 上的 Python"

msgid ""
"If you are just starting with Django and using Windows, you may find :doc:`/"
"howto/windows` useful."
msgstr ""
"如果您刚刚开始学习 Django 并且使用 Windows，查看 :doc:`/howto/windows`  可能"
"对你有帮助。"

msgid "Install Apache and ``mod_wsgi``"
msgstr "安装 Apache 和 ``mod_wsgi``"

msgid ""
"If you just want to experiment with Django, skip ahead to the next section; "
"Django includes a lightweight web server you can use for testing, so you "
"won't need to set up Apache until you're ready to deploy Django in "
"production."
msgstr ""
"如果您只是想试验 Django，请跳到下一部分；Django 包含一个可用于测试的轻量级 "
"Web 服务器，因此在准备好在生产环境中部署 Django 之前，您不需要设置 Apache。"

msgid ""
"If you want to use Django on a production site, use `Apache`_ with "
"`mod_wsgi`_. mod_wsgi operates in one of two modes: embedded mode or daemon "
"mode. In embedded mode, mod_wsgi is similar to mod_perl -- it embeds Python "
"within Apache and loads Python code into memory when the server starts. Code "
"stays in memory throughout the life of an Apache process, which leads to "
"significant performance gains over other server arrangements. In daemon "
"mode, mod_wsgi spawns an independent daemon process that handles requests. "
"The daemon process can run as a different user than the web server, possibly "
"leading to improved security. The daemon process can be restarted without "
"restarting the entire Apache web server, possibly making refreshing your "
"codebase more seamless. Consult the mod_wsgi documentation to determine "
"which mode is right for your setup. Make sure you have Apache installed with "
"the mod_wsgi module activated. Django will work with any version of Apache "
"that supports mod_wsgi."
msgstr ""

msgid ""
"See :doc:`How to use Django with mod_wsgi </howto/deployment/wsgi/modwsgi>` "
"for information on how to configure mod_wsgi once you have it installed."
msgstr ""
"若已安装 mod_wsgi 模块，请查看 :doc:`Django 如何利用 mod_wsgi 工作 </howto/"
"deployment/wsgi/modwsgi>` 了解如何配置。"

msgid ""
"If you can't use mod_wsgi for some reason, fear not: Django supports many "
"other deployment options. One is :doc:`uWSGI </howto/deployment/wsgi/"
"uwsgi>`; it works very well with `nginx`_. Additionally, Django follows the "
"WSGI spec (:pep:`3333`), which allows it to run on a variety of server "
"platforms."
msgstr ""
"如果由于某种原因你不能使用 mod_wsgi，请不要担心： Django 支持许多其他部署选"
"项。一个是 :doc:`uWSGI </howto/deployment/wsgi/uwsgi>` ；它和 `nginx`_ 配合使"
"用很好。此外，Django 遵循 WSGI 规范（ :pep:`3333` ），允许它在各种服务器平台"
"上运行。"

msgid "Get your database running"
msgstr "运行你的数据库"

msgid ""
"If you plan to use Django's database API functionality, you'll need to make "
"sure a database server is running. Django supports many different database "
"servers and is officially supported with PostgreSQL_, MariaDB_, MySQL_, "
"Oracle_ and SQLite_."
msgstr ""
"如果你打算使用 Django 的数据库 API 功能，你需要确保一个数据库服务器正在运行。"
"Django 支持许多不同的数据库服务器，官方支持 PostgreSQL_、MariaDB_、MySQL_、"
"Oracle_ 和 SQLite_。"

msgid ""
"If you are developing a small project or something you don't plan to deploy "
"in a production environment, SQLite is generally the best option as it "
"doesn't require running a separate server. However, SQLite has many "
"differences from other databases, so if you are working on something "
"substantial, it's recommended to develop with the same database that you "
"plan on using in production."
msgstr ""
"如果你正在开发一个小项目或不打算在生产环境中部署的东西，SQLite 通常是最好的选"
"择，因为它不需要运行一个单独的服务器。然而，SQLite 与其他数据库有许多不同之"
"处，所以如果你正在开发一些实质性的东西，建议使用你计划在生产中使用的同一数据"
"库进行开发。"

msgid ""
"In addition to the officially supported databases, there are :ref:`backends "
"provided by 3rd parties <third-party-notes>` that allow you to use other "
"databases with Django."
msgstr ""
"除了官方支持的数据库，还有 :ref:`第三方提供的后端 <third-party-notes>` 允许你"
"在 Django 中使用其他数据库。"

msgid ""
"In addition to a database backend, you'll need to make sure your Python "
"database bindings are installed."
msgstr "除了数据库后端，你还要确保安装了 Python 数据库绑定。"

msgid ""
"If you're using PostgreSQL, you'll need the `psycopg2`_ package. Refer to "
"the :ref:`PostgreSQL notes <postgresql-notes>` for further details."
msgstr ""
"如果你正在使用 PostgreSQL，你需要 `psycopg2`_ 包。相关详细信息请参阅 :ref:"
"`PostgreSQL 笔记 <postgresql-notes>`。"

msgid ""
"If you're using MySQL or MariaDB, you'll need a :ref:`DB API driver <mysql-"
"db-api-drivers>` like ``mysqlclient``. See :ref:`notes for the MySQL backend "
"<mysql-notes>` for details."
msgstr ""
"如果你正在使用 MySQL 或 MariaDB，则需要一个像 ``mysqlclient`` 一样的 :ref:"
"`DB API 驱动 <mysql-db-api-drivers>`。 详细信息参见 :ref:`MySQL 后端注意事项 "
"<mysql-notes>`。"

msgid ""
"If you're using SQLite you might want to read the :ref:`SQLite backend notes "
"<sqlite-notes>`."
msgstr ""
"如果你正在使用 SQLite，则可能需要阅读 :ref:`SQLite 后端笔记 <sqlite-"
"notes>` 。"

msgid ""
"If you're using Oracle, you'll need a copy of cx_Oracle_, but please read "
"the :ref:`notes for the Oracle backend <oracle-notes>` for details regarding "
"supported versions of both Oracle and ``cx_Oracle``."
msgstr ""
"如果你正在使用 Oracle，则需要 cx_Oracle_ 的副本，但请阅读 :ref:`针对 Oracle "
"后端的笔记 <oracle-notes>` 以获取有关 Oracle 和 ``cx_Oracle`` 支持的版本的详"
"细信息。"

msgid ""
"If you're using an unofficial 3rd party backend, please consult the "
"documentation provided for any additional requirements."
msgstr "如果你使用的是非官方的第三方后端，请参阅提供的文档以了解任何其他要求。"

msgid ""
"If you plan to use Django's ``manage.py migrate`` command to automatically "
"create database tables for your models (after first installing Django and "
"creating a project), you'll need to ensure that Django has permission to "
"create and alter tables in the database you're using; if you plan to "
"manually create the tables, you can grant Django ``SELECT``, ``INSERT``, "
"``UPDATE`` and ``DELETE`` permissions. After creating a database user with "
"these permissions, you'll specify the details in your project's settings "
"file, see :setting:`DATABASES` for details."
msgstr ""
"如果你打算使用 Django 的 ``manage.py migrate`` 命令为你的模型自动创建数据库表"
"（首先安装 Django 并创建项目后），你需要确保 Django 有权限在你使用的数据库中"
"创建和修改表；如果你打算手动创建表，你可以授予 Django ``SELECT``、"
"``INSERT``、``UPDATE`` 和 ``DELETE`` 权限。创建具有这些权限的数据库用户后，你"
"将在项目的配置文件中指定详细信息，详细信息参见 :setting:`DATABASES`。"

msgid ""
"If you're using Django's :doc:`testing framework</topics/testing/index>` to "
"test database queries, Django will need permission to create a test database."
msgstr ""
"如果你正在使用 Django 的 :doc:`测试框架 </topics/testing/index>` 来测试数据库"
"查询，Django 将需要创建测试数据库的权限。"

msgid "Install the Django code"
msgstr "安装 Django 源码"

msgid ""
"Installation instructions are slightly different depending on whether you're "
"installing a distribution-specific package, downloading the latest official "
"release, or fetching the latest development version."
msgstr ""
"安装过程可能会有些许差异，这取决于你是否在安装一个发行版——某个特定的版本，下"
"载最新的正式发布包，或获取最新的开发版本。"

msgid "Installing an official release with ``pip``"
msgstr "通过 ``pip`` 安装正式发布版本"

msgid "This is the recommended way to install Django."
msgstr "以下是安装 Django 的推荐方式。"

msgid ""
"Install pip_. The easiest is to use the `standalone pip installer`_. If your "
"distribution already has ``pip`` installed, you might need to update it if "
"it's outdated. If it's outdated, you'll know because installation won't work."
msgstr ""
"安装 pip_。最简单的方式是使用 `独立 pip 安装器`_。若你的系统早已安装 "
"``pip``，你可能需要更新它，因为它可能过期了。如果它过期了，你会知道的，因为过"
"期的用不了。"

msgid ""
"Take a look at :doc:`venv <python:tutorial/venv>`. This tool provides "
"isolated Python environments, which are more practical than installing "
"packages systemwide. It also allows installing packages without "
"administrator privileges. The :doc:`contributing tutorial </intro/"
"contributing>` walks through how to create a virtual environment."
msgstr ""
"看一下 :doc:`venv <python:tutorial/venv>`。这个工具提供了隔离的Python环境，比"
"在系统内安装包更实用。它还允许在没有管理员权限的情况下安装包。:doc:`贡献指南 "
"</intro/contributing>` 介绍了如何创建一个虚拟环境。"

msgid ""
"After you've created and activated a virtual environment, enter the command:"
msgstr "在你已创建并激活一个虚拟环境后，输入以下命令："

msgid "Installing a distribution-specific package"
msgstr "安装特定发行版"

msgid ""
"Check the :doc:`distribution specific notes </misc/distributions>` to see if "
"your platform/distribution provides official Django packages/installers. "
"Distribution-provided packages will typically allow for automatic "
"installation of dependencies and supported upgrade paths; however, these "
"packages will rarely contain the latest release of Django."
msgstr ""
"查看 :doc:`特定发行版注意事项 </misc/distributions>` 以查看你的平台／发行版是"
"否提供了官方的 Django 软件包／安装程序。 发行版提供的软件包通常将允许自动安装"
"依赖项和且易于升级； 但是，这些软件包很少包含最新版本的 Django。"

msgid "Installing the development version"
msgstr "安装开发版本"

msgid "Tracking Django development"
msgstr "跟踪 Django 开发"

msgid ""
"If you decide to use the latest development version of Django, you'll want "
"to pay close attention to `the development timeline`_, and you'll want to "
"keep an eye on the :ref:`release notes for the upcoming release "
"<development_release_notes>`. This will help you stay on top of any new "
"features you might want to use, as well as any changes you'll need to make "
"to your code when updating your copy of Django. (For stable releases, any "
"necessary changes are documented in the release notes.)"
msgstr ""
"如果你决定使用 Django 的最新开发版，你需要关注 `开发版时间轴`_ 和 :ref:`即将"
"到来的新特性的发布说明 <development_release_notes>`。这将保证你能获取所有新特"
"性和最新的代码。（对于稳定发布版，所有必要的修改都在发布说明中记录。）"

msgid ""
"If you'd like to be able to update your Django code occasionally with the "
"latest bug fixes and improvements, follow these instructions:"
msgstr "如果你希望偶尔能获取最新的补丁和改进，遵循以下说明："

msgid ""
"Make sure that you have Git_ installed and that you can run its commands "
"from a shell. (Enter ``git help`` at a shell prompt to test this.)"
msgstr ""
"确保你已安装了 Git_，这样你就可以从 shell 运行对应命令。（在 shell 中输入 "
"``git help`` 测试是否安装。）"

msgid "Check out Django's main development branch like so:"
msgstr "像这样检出 Django 的主开发分支："

msgid "This will create a directory ``django`` in your current directory."
msgstr "这会在当前目录创建一个 ``django`` 目录。"

msgid ""
"Make sure that the Python interpreter can load Django's code. The most "
"convenient way to do this is to use a virtual environment and pip_. The :doc:"
"`contributing tutorial </intro/contributing>` walks through how to create a "
"virtual environment."
msgstr ""
"确保 Python 解释器可以加载 Django 的代码。最方便的方法是使用虚拟环境和 "
"pip_。 :doc:`贡献指南 </intro/contributing>` 简略介绍了如何创建虚拟环境。"

msgid ""
"After setting up and activating the virtual environment, run the following "
"command:"
msgstr "设置并激活虚拟环境后，运行以下命令："

msgid ""
"This will make Django's code importable, and will also make the ``django-"
"admin`` utility command available. In other words, you're all set!"
msgstr ""
"这会让 Django 的代码可导入，使得 ``django-admin`` 命令行工具可用。换句话说，"
"大事可为。"

msgid ""
"When you want to update your copy of the Django source code, run the command "
"``git pull`` from within the ``django`` directory. When you do this, Git "
"will download any changes."
msgstr ""
"当你想更新你的 Django 源代码时，在 ``django`` 目录下运行 ``git pull`` 命令。"
"当你这样做的时候，Git 会下载所有变更。"

msgid "Logging"
msgstr "日志"

msgid ":ref:`logging-how-to`"
msgstr ":ref:`logging-how-to`"

msgid ":ref:`Django logging reference <logging-ref>`"
msgstr ""

msgid ""
"Python programmers will often use ``print()`` in their code as a quick and "
"convenient debugging tool. Using the logging framework is only a little more "
"effort than that, but it's much more elegant and flexible. As well as being "
"useful for debugging, logging can also provide you with more - and better "
"structured - information about the state and health of your application."
msgstr ""

msgid ""
"Django uses and extends Python's builtin :mod:`logging` module to perform "
"system logging. This module is discussed in detail in Python's own "
"documentation; this section provides a quick overview."
msgstr ""

msgid "The cast of players"
msgstr "日志框架的组成元素"

msgid "A Python logging configuration consists of four parts:"
msgstr "一份 Python logging 配置有下面四个部分组成："

msgid ":ref:`topic-logging-parts-loggers`"
msgstr ":ref:`topic-logging-parts-loggers`"

msgid ":ref:`topic-logging-parts-handlers`"
msgstr ":ref:`topic-logging-parts-handlers`"

msgid ":ref:`topic-logging-parts-filters`"
msgstr ":ref:`topic-logging-parts-filters`"

msgid ":ref:`topic-logging-parts-formatters`"
msgstr ":ref:`topic-logging-parts-formatters`"

msgid "Loggers"
msgstr "Loggers"

msgid ""
"A *logger* is the entry point into the logging system. Each logger is a "
"named bucket to which messages can be written for processing."
msgstr ""

msgid ""
"A logger is configured to have a *log level*. This log level describes the "
"severity of the messages that the logger will handle. Python defines the "
"following log levels:"
msgstr ""
"logger 可以配置 *日志级别*。日志级别描述了由该 logger 处理的消息的严重性。"
"Python 定义了下面几种日志级别："

msgid "``DEBUG``: Low level system information for debugging purposes"
msgstr "``DEBUG``：排查故障时使用的低级别系统信息"

msgid "``INFO``: General system information"
msgstr "``INFO``：一般的系统信息"

msgid "``WARNING``: Information describing a minor problem that has occurred."
msgstr "``WARNING``：描述系统发生了一些小问题的信息"

msgid "``ERROR``: Information describing a major problem that has occurred."
msgstr "``ERROR``：描述系统发生了大问题的信息"

msgid ""
"``CRITICAL``: Information describing a critical problem that has occurred."
msgstr "``CRITICAL``：描述系统发生严重问题的信息"

msgid ""
"Each message that is written to the logger is a *Log Record*. Each log "
"record also has a *log level* indicating the severity of that specific "
"message. A log record can also contain useful metadata that describes the "
"event that is being logged. This can include details such as a stack trace "
"or an error code."
msgstr ""
"每一条写入 logger 的消息都是一条 *日志记录*。每一条日志记录也包含 *日志级别"
"*，代表对应消息的严重程度。日志记录还包含有用的元数据，来描述被记录了日志的事"
"件细节，例如堆栈跟踪或者错误码。"

msgid ""
"When a message is given to the logger, the log level of the message is "
"compared to the log level of the logger. If the log level of the message "
"meets or exceeds the log level of the logger itself, the message will "
"undergo further processing. If it doesn't, the message will be ignored."
msgstr ""
"当 logger 处理一条消息时，会将自己的日志级别和这条消息的日志级别做对比。如果"
"消息的日志级别匹配或者高于 logger 的日志级别，它就会被进一步处理。否则这条消"
"息就会被忽略掉。"

msgid ""
"Once a logger has determined that a message needs to be processed, it is "
"passed to a *Handler*."
msgstr "当 logger 确定了一条消息需要处理之后，会把它传给 *Handler*。"

msgid "Handlers"
msgstr "Handlers"

msgid ""
"The *handler* is the engine that determines what happens to each message in "
"a logger. It describes a particular logging behavior, such as writing a "
"message to the screen, to a file, or to a network socket."
msgstr ""

msgid ""
"Like loggers, handlers also have a log level. If the log level of a log "
"record doesn't meet or exceed the level of the handler, the handler will "
"ignore the message."
msgstr ""
"和 logger 一样，handler 也有日志级别的概念。如果一条日志记录的级别不匹配或者"
"低于 handler 的日志级别，对应的消息会被 handler 忽略。"

msgid ""
"A logger can have multiple handlers, and each handler can have a different "
"log level. In this way, it is possible to provide different forms of "
"notification depending on the importance of a message. For example, you "
"could install one handler that forwards ``ERROR`` and ``CRITICAL`` messages "
"to a paging service, while a second handler logs all messages (including "
"``ERROR`` and ``CRITICAL`` messages) to a file for later analysis."
msgstr ""
"一个 logger 可以有多个 handler，每一个 handler 可以有不同的日志级别。这样就可"
"以根据消息的重要性不同，来提供不同格式的输出。例如，你可以添加一个 handler "
"把  ``ERROR`` 和 ``CRITICAL`` 消息发到寻呼机，再添加另一个 handler 把所有的消"
"息（包括 ``ERROR`` 和 ``CRITICAL`` 消息）保存到文件里以便日后分析。"

msgid "Filters"
msgstr "过滤器"

msgid ""
"A *filter* is used to provide additional control over which log records are "
"passed from logger to handler."
msgstr ""

msgid ""
"By default, any log message that meets log level requirements will be "
"handled. However, by installing a filter, you can place additional criteria "
"on the logging process. For example, you could install a filter that only "
"allows ``ERROR`` messages from a particular source to be emitted."
msgstr ""
"默认情况下，只要级别匹配，任何日志消息都会被处理。不过，也可以通过添加 "
"filter 来给日志处理的过程增加额外条件。例如，可以添加一个 filter 只允许某个特"
"定来源的 ``ERROR`` 消息输出。"

msgid ""
"Filters can also be used to modify the logging record prior to being "
"emitted. For example, you could write a filter that downgrades ``ERROR`` log "
"records to ``WARNING`` records if a particular set of criteria are met."
msgstr ""
"Filter 还被用来在日志输出之前对日志记录做修改。例如，可以写一个 filter，当满"
"足一定条件时，把日志记录从 ``ERROR`` 降到 ``WARNING`` 级别。"

msgid ""
"Filters can be installed on loggers or on handlers; multiple filters can be "
"used in a chain to perform multiple filtering actions."
msgstr ""
"Filter 在 logger 和 handler 中都可以添加；多个 filter 可以链接起来使用，来做"
"多重过滤操作。"

msgid "Formatters"
msgstr "Formatters"

msgid ""
"Ultimately, a log record needs to be rendered as text. *Formatters* describe "
"the exact format of that text. A formatter usually consists of a Python "
"formatting string containing :ref:`LogRecord attributes <python:logrecord-"
"attributes>`; however, you can also write custom formatters to implement "
"specific formatting behavior."
msgstr ""

msgid "Security implications"
msgstr ""

msgid ""
"The logging system handles potentially sensitive information. For example, "
"the log record may contain information about a web request or a stack trace, "
"while some of the data you collect in your own loggers may also have "
"security implications. You need to be sure you know:"
msgstr ""

msgid "what information is collected"
msgstr ""

msgid "where it will subsequently be stored"
msgstr ""

msgid "how it will be transferred"
msgstr ""

msgid "who might have access to it."
msgstr ""

msgid ""
"To help control the collection of sensitive information, you can explicitly "
"designate certain sensitive information to be filtered out of error reports "
"-- read more about how to :ref:`filter error reports <filtering-error-"
"reports>`."
msgstr ""

msgid "``AdminEmailHandler``"
msgstr ""

msgid ""
"The built-in :class:`~django.utils.log.AdminEmailHandler` deserves a mention "
"in the context of security. If its ``include_html`` option is enabled, the "
"email message it sends will contain a full traceback, with names and values "
"of local variables at each level of the stack, plus the values of your "
"Django settings (in other words, the same level of detail that is exposed in "
"a web page when :setting:`DEBUG` is ``True``)."
msgstr ""

msgid ""
"It's generally not considered a good idea to send such potentially sensitive "
"information over email. Consider instead using one of the many third-party "
"services to which detailed logs can be sent to get the best of multiple "
"worlds -- the rich information of full tracebacks, clear management of who "
"is notified and has access to the information, and so on."
msgstr ""

msgid "Configuring logging"
msgstr "日志模块的配置"

msgid ""
"Python's logging library provides several techniques to configure logging, "
"ranging from a programmatic interface to configuration files. By default, "
"Django uses the :ref:`dictConfig format <logging-config-dictschema>`."
msgstr ""
"Python 的日志库提供了一些配置方法，可以使用编程接口或者配置文件。Django默认使"
"用 :ref:`dictConfig format <logging-config-dictschema>`。"

msgid ""
"In order to configure logging, you use :setting:`LOGGING` to define a "
"dictionary of logging settings. These settings describe the loggers, "
"handlers, filters and formatters that you want in your logging setup, and "
"the log levels and other properties that you want those components to have."
msgstr ""

msgid ""
"By default, the :setting:`LOGGING` setting is merged with :ref:`Django's "
"default logging configuration <default-logging-configuration>` using the "
"following scheme."
msgstr ""
"默认情况下 :setting:`LOGGING` 配置和 :ref:`Django 默认日志配置 <default-"
"logging-configuration>`  按照下面的方式合并在一起："

msgid ""
"If the ``disable_existing_loggers`` key in the :setting:`LOGGING` dictConfig "
"is set to ``True`` (which is the ``dictConfig`` default if the key is "
"missing) then all loggers from the default configuration will be disabled. "
"Disabled loggers are not the same as removed; the logger will still exist, "
"but will silently discard anything logged to it, not even propagating "
"entries to a parent logger. Thus you should be very careful using "
"``'disable_existing_loggers': True``; it's probably not what you want. "
"Instead, you can set ``disable_existing_loggers`` to ``False`` and redefine "
"some or all of the default loggers; or you can set :setting:`LOGGING_CONFIG` "
"to ``None`` and :ref:`handle logging config yourself <disabling-logging-"
"configuration>`."
msgstr ""
"如果 :setting:`LOGGING` dictConfig 中的 ``disable_existing_loggers`` 键被设置"
"为 ``True`` （如果该键缺失，则为 ``dictConfig`` 默认值），则默认配置中的所有"
"记录器都将被禁用。禁用的记录器与删除的记录器不同；记录器仍将存在，但会默默地"
"丢弃任何记录到它的内容，甚至不会将条目传播到父记录仪。因此，你应该非常小心地"
"使用 ``'disable_existing_loggers': True``；这可能不是你想要的。相反，你可以"
"将 ``disable_existing_loggers`` 设置为 ``False``，然后重新定义一些或所有的默"
"认日志记录器；或者你可以将 :setting:`LOGGING_CONFIG` 设置为 ``None``，然后 :"
"ref:`自己处理日志配置 <disabling-logging-configuration>`。"

msgid ""
"Logging is configured as part of the general Django ``setup()`` function. "
"Therefore, you can be certain that loggers are always ready for use in your "
"project code."
msgstr ""
"logging 被配置成了 Django  ``setup()`` 函数的一部分。因此，你可以确定的是，"
"logger 一直都可以在项目代码里使用。"

msgid ""
"The full documentation for :ref:`dictConfig format <logging-config-"
"dictschema>` is the best source of information about logging configuration "
"dictionaries. However, to give you a taste of what is possible, here are "
"several examples."
msgstr ""
":ref:`dictConfig format <logging-config-dictschema>` 文档是获取日志配置细节的"
"最好资料。不过，为了让你知道能做什么，下面有几个例子。"

msgid ""
"To begin, here's a small configuration that will allow you to output all log "
"messages to the console:"
msgstr "首先，这里有一个小配置，可以让你把所有的日志信息输出到控制台。"

msgid "settings.py"
msgstr "settings.py"

msgid ""
"This configures the parent ``root`` logger to send messages with the "
"``WARNING`` level and higher to the console handler. By adjusting the level "
"to ``INFO`` or ``DEBUG`` you can display more messages. This may be useful "
"during development."
msgstr ""
"这将配置父 ``root`` 记录器，以向控制台处理程序发送 ``WARNING`` 级别及以上的消"
"息。通过将级别调整为 ``INFO`` 或 ``DEBUG``，可以显示更多的消息。这在开发过程"
"中可能很有用。"

msgid ""
"Next we can add more fine-grained logging. Here's an example of how to make "
"the logging system print more messages from just the :ref:`django-logger` "
"named logger:"
msgstr ""
"接下来我们可以添加更多细粒度的日志记录。下面是一个例子，说明如何让日志系统只"
"从名为 logger 的 :ref:`django-logger` 中打印更多的消息。"

msgid ""
"By default, this config sends messages from the ``django`` logger of level "
"``INFO`` or higher to the console. This is the same level as Django's "
"default logging config, except that the default config only displays log "
"records when ``DEBUG=True``. Django does not log many such ``INFO`` level "
"messages. With this config, however, you can also set the environment "
"variable ``DJANGO_LOG_LEVEL=DEBUG`` to see all of Django's debug logging "
"which is very verbose as it includes all database queries."
msgstr ""
"默认情况下，这个配置会从 ``django`` 的日志记录器中发送级别为 ``INFO`` 或更高"
"的消息到控制台。这个级别和 Django 的默认日志配置是一样的，只是默认配置只在 "
"``DEBUG=True`` 时才显示日志记录。Django 不会记录很多这样的 ``INFO`` 级别的消"
"息。不过，有了这个配置，你也可以设置环境变量 ``DJANGO_LOG_LEVEL=DEBUG`` 来查"
"看 Django 所有的调试日志，因为它包括了所有的数据库查询，所以非常啰嗦。"

msgid ""
"You don't have to log to the console. Here's a configuration which writes "
"all logging from the :ref:`django-logger` named logger to a local file:"
msgstr ""
"你不需要把日志记录到控制台。下面是一个配置，它将所有来自 :ref:`django-"
"logger` 命名的记录器的日志记录写入本地文件。"

msgid ""
"If you use this example, be sure to change the ``'filename'`` path to a "
"location that's writable by the user that's running the Django application."
msgstr ""
"若你使用此例子，切记要将 ``'filename'`` 指向的路径改为当前运行 Django 应用的"
"用户可写的路径。"

msgid "Finally, here's an example of a fairly complex logging setup:"
msgstr "最后，这里是一个相当复杂的日志设置的例子。"

msgid "This logging configuration does the following things:"
msgstr "该日志配置做了以下事情："

msgid ""
"Identifies the configuration as being in 'dictConfig version 1' format. At "
"present, this is the only dictConfig format version."
msgstr ""
"识别配置为 'dictConfig 版本 1' 格式。目前，这是唯一的 dictConfig 格式版本。"

msgid "Defines two formatters:"
msgstr "定义两个格式化程序："

msgid ""
"``simple``, that outputs the log level name (e.g., ``DEBUG``) and the log "
"message."
msgstr "``simple``，输出日志级别名称（如 ``DEBUG``）和日志信息。"

msgid ""
"The ``format`` string is a normal Python formatting string describing the "
"details that are to be output on each logging line. The full list of detail "
"that can be output can be found in :ref:`formatter-objects`."
msgstr ""
"``format`` 字符串是一个普通的 Python 格式化字符串，它描述了每个日志行要输出的"
"细节。可以输出的完整细节列表可以在 :ref:`formatter-objects` 中找到。"

msgid ""
"``verbose``, that outputs the log level name, the log message, plus the "
"time, process, thread and module that generate the log message."
msgstr ""
"``verbose``，输出日志级别名称、日志信息，以及生成日志信息的时间、进程、线程和"
"模块。"

msgid "Defines two filters:"
msgstr "定义两个过滤器："

msgid ""
"``project.logging.SpecialFilter``, using the alias ``special``. If this "
"filter required additional arguments, they can be provided as additional "
"keys in the filter configuration dictionary. In this case, the argument "
"``foo`` will be given a value of ``bar`` when instantiating "
"``SpecialFilter``."
msgstr ""
"``project.logging.SpecialFilter``，使用别名 ``special``。如果这个过滤器需要额"
"外的参数，它们可以作为过滤器配置字典中的附加键提供。在这种情况下，当实例化 "
"``SpecialFilter`` 时，参数 ``foo`` 将被赋予一个 ``bar`` 的值。"

msgid ""
"``django.utils.log.RequireDebugTrue``, which passes on records when :setting:"
"`DEBUG` is ``True``."
msgstr ""
"``django.utils.log.RequireDebugTrue``，当 :setting:`DEBUG` 为 ``True`` 时，传"
"递记录。"

msgid "Defines two handlers:"
msgstr "定义两个处理程序："

msgid ""
"``console``, a :class:`~logging.StreamHandler`, which prints any ``INFO`` "
"(or higher) message to ``sys.stderr``. This handler uses the ``simple`` "
"output format."
msgstr ""
"``console``，一个 :class:`~logging.StreamHandler`，它将任何 ``INFO`` （或更"
"高）消息打印到 ``sys.stderr``。该处理程序使用 ``simple`` 输出格式。"

msgid ""
"``mail_admins``, an :class:`~django.utils.log.AdminEmailHandler`, which "
"emails any ``ERROR`` (or higher) message to the site :setting:`ADMINS`. This "
"handler uses the ``special`` filter."
msgstr ""

msgid "Configures three loggers:"
msgstr "配置三个记录器。"

msgid "``django``, which passes all messages to the ``console`` handler."
msgstr "``django``，将所有信息传递给 ``console`` 处理程序。"

msgid ""
"``django.request``, which passes all ``ERROR`` messages to the "
"``mail_admins`` handler. In addition, this logger is marked to *not* "
"propagate messages. This means that log messages written to ``django."
"request`` will not be handled by the ``django`` logger."
msgstr ""
"``django.request``，它将所有 ``ERROR`` 消息传递给 ``mail_admins`` 处理程序。"
"此外，这个记录器被标记为 *不* 传播消息。这意味着写给 ``django.request`` 的日"
"志信息不会被 ``django`` 日志处理程序处理。"

msgid ""
"``myproject.custom``, which passes all messages at ``INFO`` or higher that "
"also pass the ``special`` filter to two handlers -- the ``console``, and "
"``mail_admins``. This means that all ``INFO`` level messages (or higher) "
"will be printed to the console; ``ERROR`` and ``CRITICAL`` messages will "
"also be output via email."
msgstr ""
"``myproject.custom``，它将所有 ``INFO`` 或更高等级的消息传递给两个处理程序——"
"``console`` 和 ``mail_admins``。这意味着所有 ``INFO`` 级别（或更高）的消息将"
"被打印到控制台；``ERROR`` 和 ``CRITICAL`` 消息也将通过电子邮件输出。"

msgid "Custom logging configuration"
msgstr "自定义日志记录配置"

msgid ""
"If you don't want to use Python's dictConfig format to configure your "
"logger, you can specify your own configuration scheme."
msgstr ""
"如果你不想使用 Python 的 dictConfig 格式来配置记录器，你可以指定自己的配置方"
"案。"

msgid ""
"The :setting:`LOGGING_CONFIG` setting defines the callable that will be used "
"to configure Django's loggers. By default, it points at Python's :func:"
"`logging.config.dictConfig()` function. However, if you want to use a "
"different configuration process, you can use any other callable that takes a "
"single argument. The contents of :setting:`LOGGING` will be provided as the "
"value of that argument when logging is configured."
msgstr ""
":setting:`LOGGING_CONFIG` 设置定义了用于配置 Django 日志记录器的可调用对象，"
"默认情况下，它指向 Python 的 :func:`logging.config.dictConfig()` 函数。然而，"
"如果你想使用不同的配置过程，你可以使用其他任何一个接受单一参数的可调用。当配"
"置日志时， :setting:`LOGGING` 的内容将作为该参数的值提供。"

msgid "Disabling logging configuration"
msgstr "禁用日志记录配置"

msgid ""
"If you don't want to configure logging at all (or you want to manually "
"configure logging using your own approach), you can set :setting:"
"`LOGGING_CONFIG` to ``None``. This will disable the configuration process "
"for :ref:`Django's default logging <default-logging-configuration>`."
msgstr ""
"如果你根本不想配置日志记录（或者你想用自己的方法手动配置日志记录），你可以"
"将 :setting:`LOGGING_CONFIG` 设置为 ``None``。这将禁用 :ref:`Django 的默认日"
"志记录 <default-logging-configuration>` 的配置过程。"

msgid ""
"Setting :setting:`LOGGING_CONFIG` to ``None`` only means that the automatic "
"configuration process is disabled, not logging itself. If you disable the "
"configuration process, Django will still make logging calls, falling back to "
"whatever default logging behavior is defined."
msgstr ""
"将 :setting:`LOGGING_CONFIG` 设置为 ``None`` 只是意味着自动配置过程被禁用，而"
"不是日志本身。如果你禁用了配置过程，Django 仍然会进行日志调用，回到默认的日志"
"行为。"

msgid ""
"Here's an example that disables Django's logging configuration and then "
"manually configures logging:"
msgstr "下面是一个禁用 Django 的日志配置，然后手动配置日志的例子。"

msgid ""
"Note that the default configuration process only calls :setting:"
"`LOGGING_CONFIG` once settings are fully-loaded. In contrast, manually "
"configuring the logging in your settings file will load your logging config "
"immediately. As such, your logging config must appear *after* any settings "
"on which it depends."
msgstr ""
"请注意，默认的配置过程只有在设置完全加载后才会调用 :setting:"
"`LOGGING_CONFIG`。相反，在设置文件中手动配置日志记录将立即加载你的日志记录配"
"置。因此，你的日志配置必须出现在它所依赖的任何设置之后。"

msgid "Migrations"
msgstr "迁移"

msgid ""
"Migrations are Django's way of propagating changes you make to your models "
"(adding a field, deleting a model, etc.) into your database schema. They're "
"designed to be mostly automatic, but you'll need to know when to make "
"migrations, when to run them, and the common problems you might run into."
msgstr ""
"迁移是 Django 将你对模型的修改（例如增加一个字段，删除一个模型）应用至数据库"
"架构中的方式。它们被设计的尽可能自动化，但你仍需要知道何时构建和运行迁移，你"
"还需要了解一些常见问题。"

msgid "The Commands"
msgstr "命令"

msgid ""
"There are several commands which you will use to interact with migrations "
"and Django's handling of database schema:"
msgstr "以下是几个常用的与迁移交互的命令，即 Django 处理数据库架构的方式："

msgid ""
":djadmin:`migrate`, which is responsible for applying and unapplying "
"migrations."
msgstr ":djadmin:`migrate`，负责应用和撤销迁移。"

msgid ""
":djadmin:`makemigrations`, which is responsible for creating new migrations "
"based on the changes you have made to your models."
msgstr ":djadmin:`makemigrations`，基于模型的修改创建迁移。"

msgid ""
":djadmin:`sqlmigrate`, which displays the SQL statements for a migration."
msgstr ":djadmin:`sqlmigrate`，展示迁移使用的 SQL 语句。"

msgid ""
":djadmin:`showmigrations`, which lists a project's migrations and their "
"status."
msgstr ":djadmin:`showmigrations`，列出项目的迁移和迁移的状态。"

msgid ""
"You should think of migrations as a version control system for your database "
"schema. ``makemigrations`` is responsible for packaging up your model "
"changes into individual migration files - analogous to commits - and "
"``migrate`` is responsible for applying those to your database."
msgstr ""
"你应该将迁移看作是数据库架构的版本控制系统。 ``makemigrations`` 负责将模型修"
"改打包进独立的迁移文件中——类似提交修改，而 ``migrate`` 负责将其应用至数据库。"

msgid ""
"The migration files for each app live in a \"migrations\" directory inside "
"of that app, and are designed to be committed to, and distributed as part "
"of, its codebase. You should be making them once on your development machine "
"and then running the same migrations on your colleagues' machines, your "
"staging machines, and eventually your production machines."
msgstr ""
"每个应用的迁移文件位于该应用的 \"migrations\" 目录中，他们被设计成应用代码的"
"一部分，与应用代码一起被提交，被发布。你只需在开发机上构建一次，就可以在同事"
"的电脑或测试机上运行同样的迁移而保证结果一致。最后在生产环境运行同样的迁移。"

msgid ""
"It is possible to override the name of the package which contains the "
"migrations on a per-app basis by modifying the :setting:`MIGRATION_MODULES` "
"setting."
msgstr ""
"通过修改配置 :setting:`MIGRATION_MODULES` 可以重写包含迁移的应用的包名。"

msgid ""
"Migrations will run the same way on the same dataset and produce consistent "
"results, meaning that what you see in development and staging is, under the "
"same circumstances, exactly what will happen in production."
msgstr "从同样的数据集合运行迁移在开发、测试和生产环境都会生成同样的结果。"

msgid ""
"Django will make migrations for any change to your models or fields - even "
"options that don't affect the database - as the only way it can reconstruct "
"a field correctly is to have all the changes in the history, and you might "
"need those options in some data migrations later on (for example, if you've "
"set custom validators)."
msgstr ""
"Django 会在修改模型或字段时生成迁移——即便修改的是不会影响数据库的配置——因为唯"
"一能确保结果正确性的方法时完整记录修改历史，而且这些东西你以后可能在某些数据"
"迁移中用的到（例如，已设置了自定义验证器的时候）。"

msgid "Backend Support"
msgstr "后端支持"

msgid ""
"Migrations are supported on all backends that Django ships with, as well as "
"any third-party backends if they have programmed in support for schema "
"alteration (done via the :doc:`SchemaEditor </ref/schema-editor>` class)."
msgstr ""
"所有 Django 支持的数据库后端都支持迁移，还有些支持表修改（通过 :doc:"
"`SchemaEditor </ref/schema-editor>` 类实现）的第三方后端也支持。"

msgid ""
"However, some databases are more capable than others when it comes to schema "
"migrations; some of the caveats are covered below."
msgstr ""
"然而，有些数据库在表结构变更方面比其它数据库更强；下面介绍一些注意事项。"

msgid ""
"PostgreSQL is the most capable of all the databases here in terms of schema "
"support."
msgstr "PostgreSQL 在架构支持方面是所有数据库中是最强的。"

msgid ""
"The only caveat is that prior to PostgreSQL 11, adding columns with default "
"values causes a full rewrite of the table, for a time proportional to its "
"size. For this reason, it's recommended you always create new columns with "
"``null=True``, as this way they will be added immediately."
msgstr ""
"唯一需要注意的是，在 PostgreSQL 11 之前，添加具有默认值的列会导致表的完全重"
"写，时间长短与表的大小成正比。 因此，建议你始终使用 ``null=True`` 创建新列，"
"因为这样可以立即添加它们。"

msgid "MySQL"
msgstr "MySQL"

msgid ""
"MySQL lacks support for transactions around schema alteration operations, "
"meaning that if a migration fails to apply you will have to manually unpick "
"the changes in order to try again (it's impossible to roll back to an "
"earlier point)."
msgstr ""
"MySQL 缺乏对架构变更操作相关事务的支持，这意味着如果迁移失败，你将必须手动取"
"消更改才能重试（无法回滚到较早的时间）。"

msgid ""
"In addition, MySQL will fully rewrite tables for almost every schema "
"operation and generally takes a time proportional to the number of rows in "
"the table to add or remove columns. On slower hardware this can be worse "
"than a minute per million rows - adding a few columns to a table with just a "
"few million rows could lock your site up for over ten minutes."
msgstr ""
"此外，MySQL 几乎每一次架构操作都会完全重写表，一般来说，增加或删除列需要的时"
"间与表的行数成正比。在速度较慢的硬件上，这可能比每百万行一分钟还要糟糕——在一"
"个只有几百万行的表中添加几列，可能会让你的网站锁定十几分钟。"

msgid ""
"Finally, MySQL has relatively small limits on name lengths for columns, "
"tables and indexes, as well as a limit on the combined size of all columns "
"an index covers. This means that indexes that are possible on other backends "
"will fail to be created under MySQL."
msgstr ""
"最后，MySQL 对列、表和索引的名称长度有相对较小的限制，并且对索引涵盖的所有列"
"的组合大小也有限制。 这意味着在其他后端上创建的索引将可能无法在 MySQL 下创"
"建。"

msgid "SQLite"
msgstr "SQLite"

msgid ""
"SQLite has very little built-in schema alteration support, and so Django "
"attempts to emulate it by:"
msgstr ""
"SQLite 几乎没有内置的架构更改支持，因此 Django 尝试通过以下方式对其进行模拟："

msgid "Creating a new table with the new schema"
msgstr "使用新架构创建新表"

msgid "Copying the data across"
msgstr "复制数据"

msgid "Dropping the old table"
msgstr "删除旧表"

msgid "Renaming the new table to match the original name"
msgstr "重新命名新表，使之与原表名相匹配。"

msgid ""
"This process generally works well, but it can be slow and occasionally "
"buggy. It is not recommended that you run and migrate SQLite in a production "
"environment unless you are very aware of the risks and its limitations; the "
"support Django ships with is designed to allow developers to use SQLite on "
"their local machines to develop less complex Django projects without the "
"need for a full database."
msgstr ""
"此过程一般工作的很好，但它可能很慢，偶尔也会出现问题。除非你非常清楚风险和它"
"的局限性，否则不建议你在生产环境中运行和迁移 SQLite；Django 自带的支持是为了"
"让开发人员在本地计算机上使用 SQLite 来开发较不复杂的 Django 项目，而无需完整"
"的数据库。"

msgid "Workflow"
msgstr "工作流程"

msgid ""
"Django can create migrations for you. Make changes to your models - say, add "
"a field and remove a model - and then run :djadmin:`makemigrations`::"
msgstr ""
"Django 可以为你创建迁移。对你的模型进行修改——比如说，添加一个字段和删除一个模"
"型——然后运行 :djadmin:`makemigrations`："

msgid ""
"Your models will be scanned and compared to the versions currently contained "
"in your migration files, and then a new set of migrations will be written "
"out. Make sure to read the output to see what ``makemigrations`` thinks you "
"have changed - it's not perfect, and for complex changes it might not be "
"detecting what you expect."
msgstr ""
"你的模型将被扫描并与当前包含在你的迁移文件中的版本进行比较，然后将写出一组新"
"的迁移。请务必阅读输出，看看 ``makemigrations`` 认为你已更改的内容——它并不完"
"美，对于复杂的更改，可能无法检测到你所期望的。"

msgid ""
"Once you have your new migration files, you should apply them to your "
"database to make sure they work as expected::"
msgstr ""
"一旦有了新的迁移文件，就应该将它们应用于数据库，以确保它们可以按预期工作："

msgid ""
"Once the migration is applied, commit the migration and the models change to "
"your version control system as a single commit - that way, when other "
"developers (or your production servers) check out the code, they'll get both "
"the changes to your models and the accompanying migration at the same time."
msgstr ""
"一旦应用了迁移，将迁移和模型更改作为一个单一的提交来提交到您的版本控制系统——"
"这样，当其他开发人员（或你的生产服务器）检查代码时，他们将同时获得对你的模型"
"的更改和伴随的迁移。"

msgid ""
"If you want to give the migration(s) a meaningful name instead of a "
"generated one, you can use the :option:`makemigrations --name` option::"
msgstr ""
"如果您你给迁移赋予一个有意义的名称而不是生成的名称，则可以使用 :option:"
"`makemigrations --name` 选项："

msgid "Version control"
msgstr "版本控制"

msgid ""
"Because migrations are stored in version control, you'll occasionally come "
"across situations where you and another developer have both committed a "
"migration to the same app at the same time, resulting in two migrations with "
"the same number."
msgstr ""
"由于迁移存储在版本控制中，因此你有时会遇到这样的情况：你和另一个开发人员都同"
"时向同一应用提交了迁移，从而导致两次迁移的编号相同。"

msgid ""
"Don't worry - the numbers are just there for developers' reference, Django "
"just cares that each migration has a different name. Migrations specify "
"which other migrations they depend on - including earlier migrations in the "
"same app - in the file, so it's possible to detect when there's two new "
"migrations for the same app that aren't ordered."
msgstr ""
"别担心——这些数字只是给开发者参考的，Django 只在乎每个迁移都有不同的名称。 迁"
"移在文件中指定了它们所依赖的其他哪些迁移——包括同一应用中的早期迁移，所以可以"
"检测到同一应用有两个新的迁移没有排序。"

msgid ""
"When this happens, Django will prompt you and give you some options. If it "
"thinks it's safe enough, it will offer to automatically linearize the two "
"migrations for you. If not, you'll have to go in and modify the migrations "
"yourself - don't worry, this isn't difficult, and is explained more in :ref:"
"`migration-files` below."
msgstr ""
"当这种情况发生时，Django 会提示你，并给你一些选项。如果它认为足够安全，它将为"
"你自动线性化两个迁移。如果不安全，你就得自己去修改迁移——别担心，这并不难，有"
"关更多信息，请参见下面的 :ref:`migration-files`。"

msgid ""
"On databases that support DDL transactions (SQLite and PostgreSQL), all "
"migration operations will run inside a single transaction by default. In "
"contrast, if a database doesn't support DDL transactions (e.g. MySQL, "
"Oracle) then all operations will run without a transaction."
msgstr ""
"在支持 DDL 事务的数据库上（SQLite 和 PostgreSQL），所有的迁移操作默认都会在一"
"个事务中运行。相反，如果一个数据库不支持 DDL 事务（如 MySQL、Oracle），那么所"
"有的操作将在没有事务的情况下运行。"

msgid ""
"You can prevent a migration from running in a transaction by setting the "
"``atomic`` attribute to ``False``. For example::"
msgstr ""
"你可以通过将 ``atomic`` 属性设置为 ``False`` 来防止迁移在事务中运行。例如："

msgid ""
"It's also possible to execute parts of the migration inside a transaction "
"using :func:`~django.db.transaction.atomic()` or by passing ``atomic=True`` "
"to :class:`~django.db.migrations.operations.RunPython`. See :ref:`non-atomic-"
"migrations` for more details."
msgstr ""
"也可以使用 :func:`~django.db.transaction.atomic()` 或者通过传递 "
"``atomic=True`` 到 :class:`~django.db.migrations.operations.RunPython` 来在事"
"务中执行部分迁移。更多细节请参见 :ref:`non-atomic-migrations`。"

msgid "Dependencies"
msgstr "依赖"

msgid ""
"While migrations are per-app, the tables and relationships implied by your "
"models are too complex to be created for one app at a time. When you make a "
"migration that requires something else to run - for example, you add a "
"``ForeignKey`` in your ``books`` app to your ``authors`` app - the resulting "
"migration will contain a dependency on a migration in ``authors``."
msgstr ""
"虽然迁移是按应用进行的，但你的模型所隐含的表和关系太复杂，不可能同时为一个应"
"用创建。当你进行迁移时，需要运行其他的东西——例如，你在你的 ``books`` 应用中添"
"加了一个指向 ``authors`` 应用的 ``ForeignKey``——最终的迁移将包含对 "
"``authors`` 中迁移的依赖。"

msgid ""
"This means that when you run the migrations, the ``authors`` migration runs "
"first and creates the table the ``ForeignKey`` references, and then the "
"migration that makes the ``ForeignKey`` column runs afterward and creates "
"the constraint. If this didn't happen, the migration would try to create the "
"``ForeignKey`` column without the table it's referencing existing and your "
"database would throw an error."
msgstr ""

msgid ""
"This dependency behavior affects most migration operations where you "
"restrict to a single app. Restricting to a single app (either in "
"``makemigrations`` or ``migrate``) is a best-efforts promise, and not a "
"guarantee; any other apps that need to be used to get dependencies correct "
"will be."
msgstr ""
"这种依赖性行为会影响大多数只限于单个应用的迁移操作。仅限于单个应用（无论是 "
"``makemigrations`` 还是 ``migrate``）是尽最大努力的承诺，而不是保证；任何其他"
"需要用来正确获取依赖关系的应用程序都将是。"

msgid ""
"Apps without migrations must not have relations (``ForeignKey``, "
"``ManyToManyField``, etc.) to apps with migrations. Sometimes it may work, "
"but it's not supported."
msgstr ""
"没有迁移的应用不得与有迁移的应用有关系（``ForeignKey``，``ManyToManyField`` "
"等）。有时可能可行，但不受支持。"

msgid "Migration files"
msgstr "迁移文件"

msgid ""
"Migrations are stored as an on-disk format, referred to here as \"migration "
"files\". These files are actually normal Python files with an agreed-upon "
"object layout, written in a declarative style."
msgstr ""
"迁移以磁盘格式存储，这里称为“迁移文件”。这些文件实际上是普通的 Python 文件，"
"具有约定的对象布局，以声明式风格编写。"

msgid "A basic migration file looks like this::"
msgstr "基本的迁移文件如下所示："

msgid ""
"What Django looks for when it loads a migration file (as a Python module) is "
"a subclass of ``django.db.migrations.Migration`` called ``Migration``. It "
"then inspects this object for four attributes, only two of which are used "
"most of the time:"
msgstr ""
"Django 在加载迁移文件（作为 Python 模块）时寻找的是 ``django.db.migrations."
"Migration`` 的子类，称为 ``Migration``。然后，它将检查此对象的四个属性，大多"
"数情况下仅使用其中两个："

msgid "``dependencies``, a list of migrations this one depends on."
msgstr "``dependencies``，所依赖的迁移列表。"

msgid ""
"``operations``, a list of ``Operation`` classes that define what this "
"migration does."
msgstr "``operations``，定义了此次迁移操作的 ``Operation`` 类的列表。"

msgid ""
"The operations are the key; they are a set of declarative instructions which "
"tell Django what schema changes need to be made. Django scans them and "
"builds an in-memory representation of all of the schema changes to all apps, "
"and uses this to generate the SQL which makes the schema changes."
msgstr ""
"操作是关键；它们是一组声明性指令，它们告诉 Django 需要对哪些架构变更。Django "
"扫描它们并构建所有应用的所有架构变更的内存表示形式，然后使用它生成进行架构变"
"更的 SQL。"

msgid ""
"That in-memory structure is also used to work out what the differences are "
"between your models and the current state of your migrations; Django runs "
"through all the changes, in order, on an in-memory set of models to come up "
"with the state of your models last time you ran ``makemigrations``. It then "
"uses these models to compare against the ones in your ``models.py`` files to "
"work out what you have changed."
msgstr ""
"该内存结构还用于确定模型与迁移当前状态之间的差异；Django 按顺序在内存中的模型"
"集上运行所有的变更，得出你上次运行 ``makemigrations`` 时模型的状态。然后，它"
"使用这些模型与你的 ``models.py`` 文件中的模型进行比较，以计算出你改变了什么。"

msgid ""
"You should rarely, if ever, need to edit migration files by hand, but it's "
"entirely possible to write them manually if you need to. Some of the more "
"complex operations are not autodetectable and are only available via a hand-"
"written migration, so don't be scared about editing them if you have to."
msgstr ""
"你应该很少需要手动编辑迁移文件，但如果需要，完全可以手动编写。有些更复杂的操"
"作是无法自动检测的，只能通过手写的迁移来实现，所以如果必须手写它们，也不要害"
"怕。"

msgid "Custom fields"
msgstr "自定义字段"

msgid ""
"You can't modify the number of positional arguments in an already migrated "
"custom field without raising a ``TypeError``. The old migration will call "
"the modified ``__init__`` method with the old signature. So if you need a "
"new argument, please create a keyword argument and add something like "
"``assert 'argument_name' in kwargs`` in the constructor."
msgstr ""
"你不能修改一个已经迁移的自定义字段中的位置参数的数量，否则会引发 "
"``TypeError``。旧的迁移会用旧的签名调用修改后的 ``__init__`` 方法。所以如果你"
"需要一个新的参数，请创建一个关键字参数，并在构造函数中添加类似 ``assert "
"'argument_name' in kwargs`` 的内容。"

msgid "Model managers"
msgstr "模型管理器"

msgid ""
"You can optionally serialize managers into migrations and have them "
"available in :class:`~django.db.migrations.operations.RunPython` operations. "
"This is done by defining a ``use_in_migrations`` attribute on the manager "
"class::"
msgstr ""
"你可以选择将管理器序列化为迁移，并在 :class:`~django.db.migrations."
"operations.RunPython` 操作中使用它们。这是通过在 manager 类上定义一个 "
"``use_in_migrations`` 属性来实现的："

msgid ""
"If you are using the :meth:`~django.db.models.from_queryset` function to "
"dynamically generate a manager class, you need to inherit from the generated "
"class to make it importable::"
msgstr ""
"如果你使用 :meth:`~django.db.models.from_queryset` 函数动态生成管理器类，则需"
"要从生成的类继承以使其可导入："

msgid ""
"Please refer to the notes about :ref:`historical-models` in migrations to "
"see the implications that come along."
msgstr ""
"请参考关于 :ref:`historical-models` 在迁移中的说明，以了解随之而来的影响。"

msgid "Initial migrations"
msgstr "初始迁移"

msgid ""
"The \"initial migrations\" for an app are the migrations that create the "
"first version of that app's tables. Usually an app will have one initial "
"migration, but in some cases of complex model interdependencies it may have "
"two or more."
msgstr ""
"应用的“初始迁移”是创建该应用首版表的迁移。 通常，一个应用有一个初始迁移，但是"
"在某些情况下，复杂的模型依赖可能会导致两个或更多。"

msgid ""
"Initial migrations are marked with an ``initial = True`` class attribute on "
"the migration class. If an ``initial`` class attribute isn't found, a "
"migration will be considered \"initial\" if it is the first migration in the "
"app (i.e. if it has no dependencies on any other migration in the same app)."
msgstr ""
"初始迁移在迁移类上标有 ``initial = True`` 类属性。如果未找到 ``initial`` 类属"
"性，则如果迁移是应用程序中的第一个迁移（即，如果它不依赖于同一应用程序中的任"
"何其他迁移）则将被视为“初始”。"

msgid ""
"When the :option:`migrate --fake-initial` option is used, these initial "
"migrations are treated specially. For an initial migration that creates one "
"or more tables (``CreateModel`` operation), Django checks that all of those "
"tables already exist in the database and fake-applies the migration if so. "
"Similarly, for an initial migration that adds one or more fields "
"(``AddField`` operation), Django checks that all of the respective columns "
"already exist in the database and fake-applies the migration if so. Without "
"``--fake-initial``, initial migrations are treated no differently from any "
"other migration."
msgstr ""
"当使用 :option:`migrate --fake-initial` 选项时，将对这些初始迁移进行特殊处"
"理。对于创建一个或多个表（``CreateModel`` 操作）的初始迁移，Django 会检查所有"
"这些表是否已经存在于数据库中，如果是，则对迁移进行假应用。 类似地，对于添加了"
"一个或多个字段（``AddField`` 操作）的初始迁移，Django 检查数据库中是否已存在"
"所有相应的列，如果存在，则对迁移进行假应用。如果没有 ``--fake-initial``，初始"
"迁移的处理方式和其他迁移没有区别。"

msgid "History consistency"
msgstr "历史一致性"

msgid ""
"As previously discussed, you may need to linearize migrations manually when "
"two development branches are joined. While editing migration dependencies, "
"you can inadvertently create an inconsistent history state where a migration "
"has been applied but some of its dependencies haven't. This is a strong "
"indication that the dependencies are incorrect, so Django will refuse to run "
"migrations or make new migrations until it's fixed. When using multiple "
"databases, you can use the :meth:`allow_migrate` method of :ref:`database "
"routers <topics-db-multi-db-routing>` to control which databases :djadmin:"
"`makemigrations` checks for consistent history."
msgstr ""
"历史一致性前面已经讨论过，当两个开发分支加入时，你可能需要手动线性化迁移。在"
"编辑迁移依赖关系时，你可能会无意中创建一个不一致的历史状态，即一个迁移已经被"
"应用，但它的一些依赖关系还没有应用。这强烈地表明依赖关系不正确，所以 Django "
"会拒绝运行迁移或进行新的迁移，直到它被修复。当使用多个数据库时，可以使用 :"
"ref:`database routers <topics-db-multi-db-routing>` 的 :meth:`allow_migrate` "
"方法来控制 :djadmin:`makemigrations` 检查哪些数据库的历史一致。"

msgid "Adding migrations to apps"
msgstr "向应用添加迁移"

msgid ""
"New apps come preconfigured to accept migrations, and so you can add "
"migrations by running :djadmin:`makemigrations` once you've made some "
"changes."
msgstr ""
"新的应用已预先配置为接受迁移，因此你可以在进行一些更改后通过运行 :djadmin:"
"`makemigrations` 添加迁移。"

msgid ""
"If your app already has models and database tables, and doesn't have "
"migrations yet (for example, you created it against a previous Django "
"version), you'll need to convert it to use migrations by running::"
msgstr ""
"如果你的应用已经具有模型和数据库表，并且还没有迁移（例如，你是在先前的 "
"Django 版本中创建的），则需要通过运行以下命令将其转换为使用迁移："

msgid ""
"This will make a new initial migration for your app. Now, run ``python "
"manage.py migrate --fake-initial``, and Django will detect that you have an "
"initial migration *and* that the tables it wants to create already exist, "
"and will mark the migration as already applied. (Without the :option:"
"`migrate --fake-initial` flag, the command would error out because the "
"tables it wants to create already exist.)"
msgstr ""
"这将为你的应用程序进行新的初始迁移。现在，运行 ``python manage.py migrate --"
"fake-initial``，Django 将检测到你有一个初始迁移 *并且* 它要创建的表已经存在，"
"而将迁移标记为已应用。（如果没有 :option:`migrate --fake-initial` 标志，该命"
"令将出错，因为它要创建的表已经存在。）"

msgid "Note that this only works given two things:"
msgstr "请注意，这只适用于以下两种情况："

msgid ""
"You have not changed your models since you made their tables. For migrations "
"to work, you must make the initial migration *first* and then make changes, "
"as Django compares changes against migration files, not the database."
msgstr ""
"自从你建立了表之后，你就没有改变过你的模型。要使迁移生效，你必须 *首先* 进行"
"初始迁移，然后再进行更改，因为 Django 将变更与迁移文件（而不是数据库）进行比"
"较。"

msgid ""
"You have not manually edited your database - Django won't be able to detect "
"that your database doesn't match your models, you'll just get errors when "
"migrations try to modify those tables."
msgstr ""
"你尚未手动编辑数据库——Django 无法检测到你的数据库与你的模型不匹配，当迁移尝试"
"修改这些表时，你只会得到错误。"

msgid "Reversing migrations"
msgstr "撤销迁移"

msgid ""
"Migrations can be reversed with :djadmin:`migrate` by passing the number of "
"the previous migration. For example, to reverse migration ``books.0003``:"
msgstr ""
"可以通过 :djadmin:`migrate` 传递上一次迁移的编号来撤销迁移。例如，要撤销迁移 "
"``books.0003``："

msgid ""
"If you want to reverse all migrations applied for an app, use the name "
"``zero``:"
msgstr "如果要撤消应用于一个应用的所有迁移，请使用名称 ``zero``："

msgid ""
"A migration is irreversible if it contains any irreversible operations. "
"Attempting to reverse such migrations will raise ``IrreversibleError``:"
msgstr ""
"如果迁移包含任何不可逆的操作，则该迁移是不可逆的。 试图撤销这种迁移将引发 "
"``IrreversibleError``："

msgid "Historical models"
msgstr "历史模型"

msgid ""
"When you run migrations, Django is working from historical versions of your "
"models stored in the migration files. If you write Python code using the :"
"class:`~django.db.migrations.operations.RunPython` operation, or if you have "
"``allow_migrate`` methods on your database routers, you **need to use** "
"these historical model versions rather than importing them directly."
msgstr ""
"当你运行迁移时，Django 正在使用存储在迁移文件中的模型的历史版本。如果你使用 :"
"class:`~django.db.migrations.operations.RunPython` 操作编写 Python 代码，或者"
"你的数据库路由上有 ``allow_migrate`` 方法，则你 **需要使用** 这些模型的历史版"
"本而不是直接导入它们。"

msgid ""
"If you import models directly rather than using the historical models, your "
"migrations *may work initially* but will fail in the future when you try to "
"re-run old migrations (commonly, when you set up a new installation and run "
"through all the migrations to set up the database)."
msgstr ""
"如果你直接导入模型而不是使用历史模型，则迁移 *最初可能会工作* 但将来在尝试重"
"新运行旧迁移时会失败（通常，当你设置新安装并运行所有迁移时 以建立数据库时）。"

msgid ""
"This means that historical model problems may not be immediately obvious. If "
"you run into this kind of failure, it's OK to edit the migration to use the "
"historical models rather than direct imports and commit those changes."
msgstr ""
"这意味着历史模型的问题可能不会立即显现。如果遇到这种故障，可以编辑迁移以使用"
"历史模型，而不是直接导入并提交这些更改。"

msgid ""
"Because it's impossible to serialize arbitrary Python code, these historical "
"models will not have any custom methods that you have defined. They will, "
"however, have the same fields, relationships, managers (limited to those "
"with ``use_in_migrations = True``) and ``Meta`` options (also versioned, so "
"they may be different from your current ones)."
msgstr ""
"因为不可能序列化任意的 Python 代码，这些历史模型不会有你定义的任何自定义方"
"法。然而，它们将具有相同的字段、关系、管理器（仅限于那些具有 "
"``use_in_migrations = True``）和 ``Meta`` 选项（也有版本控制，因此它们可能与"
"当前的不同）。"

msgid ""
"This means that you will NOT have custom ``save()`` methods called on "
"objects when you access them in migrations, and you will NOT have any custom "
"constructors or instance methods. Plan appropriately!"
msgstr ""
"这意味着在迁移中访问对象时，将不会对对象调用自定义的 ``save()`` 方法，也不会"
"有任何自定义构造函数或实例方法。适当的计划一下吧！"

msgid ""
"References to functions in field options such as ``upload_to`` and "
"``limit_choices_to`` and model manager declarations with managers having "
"``use_in_migrations = True`` are serialized in migrations, so the functions "
"and classes will need to be kept around for as long as there is a migration "
"referencing them. Any :doc:`custom model fields </howto/custom-model-"
"fields>` will also need to be kept, since these are imported directly by "
"migrations."
msgstr ""
"字段选项中对函数的引用，例如 ``upload_to`` 和 ``limit_choices_to`` 以及具有 "
"``use_in_migrations = True`` 的模型管理器声明，都会在迁移中序列化，因此只要有"
"迁移引用它们，这些函数和类就需要保留。任何 :doc:`自定义模型字段 </howto/"
"custom-model-fields>` 也需要保留，因为这些都是直接由迁移导入的。"

msgid ""
"In addition, the concrete base classes of the model are stored as pointers, "
"so you must always keep base classes around for as long as there is a "
"migration that contains a reference to them. On the plus side, methods and "
"managers from these base classes inherit normally, so if you absolutely need "
"access to these you can opt to move them into a superclass."
msgstr ""
"此外，模型的具体基类是以指针的形式存储的，所以只要有一个包含对它们的引用的迁"
"移，你就必须始终将基类保留在身边。从好的方面来说，这些基类的方法和管理器都是"
"正常继承的，所以如果你一定需要访问这些，你可以选择将它们移到一个父类中。"

msgid ""
"To remove old references, you can :ref:`squash migrations <migration-"
"squashing>` or, if there aren't many references, copy them into the "
"migration files."
msgstr ""
"要删除旧的引用，你可以 :ref:`压缩迁移 <migration-squashing>` 或者，如果引用不"
"多，把它们复制到迁移文件中。"

msgid "Considerations when removing model fields"
msgstr "删除模型字段时的注意事项"

msgid ""
"Similar to the \"references to historical functions\" considerations "
"described in the previous section, removing custom model fields from your "
"project or third-party app will cause a problem if they are referenced in "
"old migrations."
msgstr ""
"与上一节中描述的“引用历史函数”注意事项类似，如果在旧迁移中引用了自定义模型字"
"段，则从项目或第三方应用中删除这些字段将导致问题。"

msgid ""
"To help with this situation, Django provides some model field attributes to "
"assist with model field deprecation using the :doc:`system checks framework "
"</topics/checks>`."
msgstr ""
"为了解决这种情况，Django 提供了一些模型字段属性，使用 :doc:`系统检查框架 </"
"topics/checks>` 来协助弃用模型字段。"

msgid ""
"Add the ``system_check_deprecated_details`` attribute to your model field "
"similar to the following::"
msgstr ""
"将 ``system_check_deprecated_details`` 属性添加到你的模型字段中，类似于："

msgid ""
"After a deprecation period of your choosing (two or three feature releases "
"for fields in Django itself), change the ``system_check_deprecated_details`` "
"attribute to ``system_check_removed_details`` and update the dictionary "
"similar to::"
msgstr ""
"在你选择的弃用期（Django 本身的字段有两个或三个功能版本）之后，将 "
"``system_check_deprecated_details`` 属性改为 "
"``system_check_removed_details`` 并更新类似于以下内容的字典："

msgid ""
"You should keep the field's methods that are required for it to operate in "
"database migrations such as ``__init__()``, ``deconstruct()``, and "
"``get_internal_type()``. Keep this stub field for as long as any migrations "
"which reference the field exist. For example, after squashing migrations and "
"removing the old ones, you should be able to remove the field completely."
msgstr ""
"你应该保留该字段在数据库迁移中操作所需的方法，如 ``__init__()``，"
"``deconstruct()``，和 ``get_internal_type()``。只要任何引用该字段的迁移存在，"
"就保留这个存根字段。例如，在压缩迁移并删除旧的迁移后，你应该可以完全删除该字"
"段。"

msgid "Data Migrations"
msgstr "数据迁移"

msgid ""
"As well as changing the database schema, you can also use migrations to "
"change the data in the database itself, in conjunction with the schema if "
"you want."
msgstr ""
"除了改变数据库架构外，你还可以使用迁移来改变数据库本身的数据，如果你想的话，"
"还可以结合架构来改变。"

msgid ""
"Migrations that alter data are usually called \"data migrations\"; they're "
"best written as separate migrations, sitting alongside your schema "
"migrations."
msgstr ""
"更改数据的迁移通常称为“数据迁移”；最好将它们写成单独的迁移，与架构迁移放在一"
"起。"

msgid ""
"Django can't automatically generate data migrations for you, as it does with "
"schema migrations, but it's not very hard to write them. Migration files in "
"Django are made up of :doc:`Operations </ref/migration-operations>`, and the "
"main operation you use for data migrations is :class:`~django.db.migrations."
"operations.RunPython`."
msgstr ""
"Django 无法像架构迁移那样自动为您生成数据迁移，但是编写它们并不难。Django 中"
"的迁移文件是由 :doc:`Operations </ref/migration-operations>` 组成的，你用于数"
"据迁移的主要操作是 :class:`~django.db.migrations.operations.RunPython`。"

msgid ""
"To start, make an empty migration file you can work from (Django will put "
"the file in the right place, suggest a name, and add dependencies for you)::"
msgstr ""
"首先，制作一个可以使用的空迁移文件（Django 会将文件放在正确的位置，提供一个名"
"称，并为你添加依赖项）："

msgid "Then, open up the file; it should look something like this::"
msgstr "然后，打开文件；它应该是这样的："

msgid ""
"Now, all you need to do is create a new function and have :class:`~django.db."
"migrations.operations.RunPython` use it. :class:`~django.db.migrations."
"operations.RunPython` expects a callable as its argument which takes two "
"arguments - the first is an :doc:`app registry </ref/applications/>` that "
"has the historical versions of all your models loaded into it to match where "
"in your history the migration sits, and the second is a :doc:`SchemaEditor </"
"ref/schema-editor>`, which you can use to manually effect database schema "
"changes (but beware, doing this can confuse the migration autodetector!)"
msgstr ""
"现在，你需要做的就是创建一个新的函数，让 :class:`~django.db.migrations."
"operations.RunPython` 使用它。:class:`~django.db.migrations.operations."
"RunPython` 需要一个可调用对象作为它的参数，这个可调用对象需要两个参数——第一个"
"是 :doc:`应用注册表 </ref/applications/>` ，其中加载了所有模型的历史版本，以"
"匹配迁移所在的位置，第二个是 :doc:`SchemaEditor </ref/schema-editor>`，你可以"
"用它来手动实现数据库架构的变更（但要注意，这样做会混淆迁移自动检测器！）"

msgid ""
"Let's write a migration that populates our new ``name`` field with the "
"combined values of ``first_name`` and ``last_name`` (we've come to our "
"senses and realized that not everyone has first and last names). All we need "
"to do is use the historical model and iterate over the rows::"
msgstr ""
"让我们编写一个迁移，使用 ``first_name`` 和 ``last_name`` 的组合值填充新的 "
"``name`` 字段（我们已经意识到，并不是每个人都有名字和姓氏）。 我们需要做的就"
"是使用历史模型并对行进行迭代："

msgid ""
"Once that's done, we can run ``python manage.py migrate`` as normal and the "
"data migration will run in place alongside other migrations."
msgstr ""
"完成后，我们可以像往常一样运行 ``python manage.py migrate``，数据迁移将与其他"
"迁移一起运行。"

msgid ""
"You can pass a second callable to :class:`~django.db.migrations.operations."
"RunPython` to run whatever logic you want executed when migrating backwards. "
"If this callable is omitted, migrating backwards will raise an exception."
msgstr ""
"您可以将第二个可调用对象传递给 :class:`~django.db.migrations.operations."
"RunPython` 以运行撤销迁移时要执行的任何逻辑。 如果忽略此可调用对象，则撤销迁"
"移将引发异常。"

msgid "Accessing models from other apps"
msgstr "从其他应用访问模型"

msgid ""
"When writing a ``RunPython`` function that uses models from apps other than "
"the one in which the migration is located, the migration's ``dependencies`` "
"attribute should include the latest migration of each app that is involved, "
"otherwise you may get an error similar to: ``LookupError: No installed app "
"with label 'myappname'`` when you try to retrieve the model in the "
"``RunPython`` function using ``apps.get_model()``."
msgstr ""
"在编写使用来自迁移所在应用以外的其他应用模型的 ``RunPython`` 函数时，迁移的 "
"``dependencies`` 属性应包括所涉及的每个应用程序的最新迁移，否则当你尝试使用 "
"``apps.get_model()`` 在 ``RunPython`` 函数中获取模型时，你可能会得到 "
"``LookupError: No installed app with label 'myappname'``。"

msgid ""
"In the following example, we have a migration in ``app1`` which needs to use "
"models in ``app2``. We aren't concerned with the details of ``move_m1`` "
"other than the fact it will need to access models from both apps. Therefore "
"we've added a dependency that specifies the last migration of ``app2``::"
msgstr ""
"在下面的例子中，我们在 ``app1`` 中进行迁移，需要使用 ``app2`` 中的模型。我们"
"不关心 ``move_m1`` 的细节，只关心它需要访问两个应用程序的模型。因此，我们添加"
"了一个依赖关系，指定 ``app2`` 最后一次迁移："

msgid "More advanced migrations"
msgstr "更高级的迁移"

msgid ""
"If you're interested in the more advanced migration operations, or want to "
"be able to write your own, see the :doc:`migration operations reference </"
"ref/migration-operations>` and the \"how-to\" on :doc:`writing migrations </"
"howto/writing-migrations>`."
msgstr ""
"如果你对更高级的迁移操作感兴趣，或者希望能够编写自己的迁移操作，请参阅 :doc:`"
"迁移操作参考 </ref/migration-operations>` 和“如何” :doc:`编写操作 </howto/"
"writing-migrations>`。"

msgid "Squashing migrations"
msgstr "压缩迁移"

msgid ""
"You are encouraged to make migrations freely and not worry about how many "
"you have; the migration code is optimized to deal with hundreds at a time "
"without much slowdown. However, eventually you will want to move back from "
"having several hundred migrations to just a few, and that's where squashing "
"comes in."
msgstr ""
"我们鼓励你自由地进行迁移，而不要担心你有多少迁移；迁移代码经过优化，可以一次"
"处理几百个迁移，而不会有太多的减速。然而，最终你会希望从几百个迁移回归到只有"
"几个，这就是压缩的作用。"

msgid ""
"Squashing is the act of reducing an existing set of many migrations down to "
"one (or sometimes a few) migrations which still represent the same changes."
msgstr ""
"压缩是将一组现有的多个迁移减少到一个（有时是几个）迁移，这些迁移仍然代表相同"
"的更改。"

msgid ""
"Django does this by taking all of your existing migrations, extracting their "
"``Operation``\\s and putting them all in sequence, and then running an "
"optimizer over them to try and reduce the length of the list - for example, "
"it knows that :class:`~django.db.migrations.operations.CreateModel` and :"
"class:`~django.db.migrations.operations.DeleteModel` cancel each other out, "
"and it knows that :class:`~django.db.migrations.operations.AddField` can be "
"rolled into :class:`~django.db.migrations.operations.CreateModel`."
msgstr ""
"Django通过获取所有现有迁移，提取它们的 ``Operation`` 并将它们按顺序排列，然后"
"对它们运行一个优化器，以尝试减少列表的长度——例如，它知道 :class:`~django.db."
"migrations.operations.CreateModel` 和 :class:`~django.db.migrations."
"operations.DeleteModel` 相互抵消，它还知道 :class:`~django.db.migrations."
"operations.AddField` 可以卷入 :class:`~django.db.migrations.operations."
"CreateModel`。"

msgid ""
"Once the operation sequence has been reduced as much as possible - the "
"amount possible depends on how closely intertwined your models are and if "
"you have any :class:`~django.db.migrations.operations.RunSQL` or :class:"
"`~django.db.migrations.operations.RunPython` operations (which can't be "
"optimized through unless they are marked as ``elidable``) - Django will then "
"write it back out into a new set of migration files."
msgstr ""
"一旦操作序列被尽可能地减少——可能的数量取决于你的模型有多紧密交织，如果你有任"
"何 :class:`~django.db.migrations.operations.RunSQL` 或 :class:`~django.db."
"migrations.operations.RunPython` 操作（除非它们被标记为 ``elidable``，否则无"
"法被优化），Django就会把它写回一组新的迁移文件中。"

msgid ""
"These files are marked to say they replace the previously-squashed "
"migrations, so they can coexist with the old migration files, and Django "
"will intelligently switch between them depending where you are in the "
"history. If you're still part-way through the set of migrations that you "
"squashed, it will keep using them until it hits the end and then switch to "
"the squashed history, while new installs will use the new squashed migration "
"and skip all the old ones."
msgstr ""
"这些文件被标记为替换了先前压缩的迁移，因此它们可以与旧迁移文件共存，Django 将"
"根据你在历史记录中的位置智能地在它们之间切换。如果你仍处于压缩过程中，则它将"
"继续使用它们直到结束，然后切换到压缩历史记录，而新安装将使用新压缩后的迁移并"
"跳过所有旧迁移。"

msgid ""
"This enables you to squash and not mess up systems currently in production "
"that aren't fully up-to-date yet. The recommended process is to squash, "
"keeping the old files, commit and release, wait until all systems are "
"upgraded with the new release (or if you're a third-party project, ensure "
"your users upgrade releases in order without skipping any), and then remove "
"the old files, commit and do a second release."
msgstr ""
"这样你就可以压缩而不至于把目前还没有完全更新的生产系统搞乱。推荐的流程是压"
"缩，保留旧文件，提交并发布，等到所有系统都升级到新版本（或者如果你是第三方项"
"目，确保你的用户按顺序升级版本，不跳过任何一个版本），然后删除旧文件，提交并"
"进行第二次发布。"

msgid ""
"The command that backs all this is :djadmin:`squashmigrations` - pass it the "
"app label and migration name you want to squash up to, and it'll get to "
"work::"
msgstr ""
"支持这一切的命令是 :djadmin:`squashmigrations`——把你想压缩的应用标签和迁移名"
"称传给它，它就会开始工作："

msgid ""
"Use the :option:`squashmigrations --squashed-name` option if you want to set "
"the name of the squashed migration rather than use an autogenerated one."
msgstr ""
"如果要设置压缩迁移的名称而不是使用自动生成的迁移名称，请使用 :option:"
"`squashmigrations --squashed-name` 选项。"

msgid ""
"Note that model interdependencies in Django can get very complex, and "
"squashing may result in migrations that do not run; either mis-optimized (in "
"which case you can try again with ``--no-optimize``, though you should also "
"report an issue), or with a ``CircularDependencyError``, in which case you "
"can manually resolve it."
msgstr ""
"请注意，Django 中的模型相互依赖可能会变得非常复杂，压缩可能会导致迁移无法运"
"行；要么是优化错误（在这种情况下，你可以用 ``--no-optimize`` 再试一次，不过你"
"也应该报告这个问题），要么是 ``CircularDependencyError``，在这种情况下，你可"
"以手动解决它。"

msgid ""
"To manually resolve a ``CircularDependencyError``, break out one of the "
"ForeignKeys in the circular dependency loop into a separate migration, and "
"move the dependency on the other app with it. If you're unsure, see how :"
"djadmin:`makemigrations` deals with the problem when asked to create brand "
"new migrations from your models. In a future release of Django, :djadmin:"
"`squashmigrations` will be updated to attempt to resolve these errors itself."
msgstr ""
"要手动解决 ``CircularDependencyError`` 问题，请将循环依赖中的外键分离到单独的"
"迁移中，并将依赖项移到另一个应用上。如果你不确定，请参见 :djadmin:"
"`makemigrations` 在被要求从模型创建全新的迁移时如何处理问题。在未来的 Django "
"版本中，:djadmin:`squashmigrations` 将被更新以尝试自己解决这些错误。"

msgid ""
"Once you've squashed your migration, you should then commit it alongside the "
"migrations it replaces and distribute this change to all running instances "
"of your application, making sure that they run ``migrate`` to store the "
"change in their database."
msgstr ""
"一旦你压缩了你的迁移，你应该把它和它所替代的迁移一起提交，并把这个更改分发到"
"你的应用程序的所有运行中的实例，确保它们运行 ``migrate`` 来将更改存储在它们的"
"数据库中。"

msgid ""
"You must then transition the squashed migration to a normal migration by:"
msgstr "然后，你必须通过以下方法将压缩的迁移过渡到正常迁移："

msgid "Deleting all the migration files it replaces."
msgstr "删除它替换的所有迁移文件。"

msgid ""
"Updating all migrations that depend on the deleted migrations to depend on "
"the squashed migration instead."
msgstr "将所有依赖被删除迁移的迁移更新为依赖被压缩的迁移。"

msgid ""
"Removing the ``replaces`` attribute in the ``Migration`` class of the "
"squashed migration (this is how Django tells that it is a squashed "
"migration)."
msgstr ""
"删除压缩迁移的 ``Migration`` 类的 ``replaces`` 属性（这就是 Django 告诉它是压"
"缩迁移的方式）。"

msgid ""
"Once you've squashed a migration, you should not then re-squash that "
"squashed migration until you have fully transitioned it to a normal "
"migration."
msgstr ""
"压缩迁移后，在完全将其转换为正常迁移之前，你不应该再重新压缩该压缩的迁移。"

msgid "Serializing values"
msgstr "序列化值"

msgid ""
"Migrations are Python files containing the old definitions of your models - "
"thus, to write them, Django must take the current state of your models and "
"serialize them out into a file."
msgstr ""
"迁移是包含模型旧定义的 Python 文件，因此，要编写它们，Django 必须获取模型的当"
"前状态并将它们序列化到一个文件中。"

msgid ""
"While Django can serialize most things, there are some things that we just "
"can't serialize out into a valid Python representation - there's no Python "
"standard for how a value can be turned back into code (``repr()`` only works "
"for basic values, and doesn't specify import paths)."
msgstr ""
"虽然 Django 可以序列化大多数内容，但有些内容我们无法序列化为有效的 Python 表"
"示形式——对于如何将值转换回代码，没有 Python 标准（``repr()`` 只适用于基本的"
"值，而且没有指定导入路径）。"

msgid "Django can serialize the following:"
msgstr "Django 可以序列化以下内容："

msgid ""
"``int``, ``float``, ``bool``, ``str``, ``bytes``, ``None``, ``NoneType``"
msgstr ""
"``int``，``float``，``bool``，``str``，``bytes``，``None``，``NoneType``"

msgid "``list``, ``set``, ``tuple``, ``dict``, ``range``."
msgstr "``list``，``set``，``tuple``，``dict``，``range``。"

msgid ""
"``datetime.date``, ``datetime.time``, and ``datetime.datetime`` instances "
"(include those that are timezone-aware)"
msgstr ""
"``datetime.date``，``datetime.time`` 和 ``datetime.datetime`` 实例（包括可识"
"别时区的实例）"

msgid "``decimal.Decimal`` instances"
msgstr "``decimal.Decimal`` 实例"

msgid "``enum.Enum`` instances"
msgstr "``enum.Enum`` 实例"

msgid "``uuid.UUID`` instances"
msgstr "``uuid.UUID`` 实例"

msgid ""
":func:`functools.partial` and :class:`functools.partialmethod` instances "
"which have serializable ``func``, ``args``, and ``keywords`` values."
msgstr ""
":func:`functools.partial`  和具有可序列化 ``func``、``args`` 和 ``keywords`` "
"值的 :class:`functools.partialmethod` 实例。"

msgid ""
"Pure and concrete path objects from :mod:`pathlib`. Concrete paths are "
"converted to their pure path equivalent, e.g. :class:`pathlib.PosixPath` to :"
"class:`pathlib.PurePosixPath`."
msgstr ""

msgid ""
":class:`os.PathLike` instances, e.g. :class:`os.DirEntry`, which are "
"converted to ``str`` or ``bytes`` using :func:`os.fspath`."
msgstr ""

msgid "``LazyObject`` instances which wrap a serializable value."
msgstr "包含可序列化值的 ``LazyObject`` 实例。"

msgid ""
"Enumeration types (e.g. ``TextChoices`` or ``IntegerChoices``) instances."
msgstr "枚举类型（例如 ``TextChoices`` 或 ``IntegerChoices``）实例。"

msgid "Any Django field"
msgstr "任何 Django 字段"

msgid ""
"Any function or method reference (e.g. ``datetime.datetime.today``) (must be "
"in module's top-level scope)"
msgstr ""
"任何函数或方法引用（如 ``datetime.datetime.today``）（必须在模块的顶层范围"
"内）"

msgid "Unbound methods used from within the class body"
msgstr "在类主体内部使用的未绑定方法"

msgid "Any class reference (must be in module's top-level scope)"
msgstr "任何类引用（必须在模块的顶层范围内）"

msgid ""
"Anything with a custom ``deconstruct()`` method (:ref:`see below <custom-"
"deconstruct-method>`)"
msgstr ""
"具有自定义 ``deconstruct()`` 方法的任何东西（:ref:`见下文 <custom-"
"deconstruct-method>`）"

msgid ""
"Serialization support for pure and concrete path objects from :mod:"
"`pathlib`, and :class:`os.PathLike` instances was added."
msgstr ""

msgid "Django cannot serialize:"
msgstr "Django 不能序列化："

msgid "Nested classes"
msgstr "嵌套类"

msgid "Arbitrary class instances (e.g. ``MyClass(4.3, 5.7)``)"
msgstr "任何类实例（例如 ``MyClass(4.3, 5.7)``）"

msgid "Lambdas"
msgstr "匿名函数"

msgid "Custom serializers"
msgstr "自定义序列化"

msgid ""
"You can serialize other types by writing a custom serializer. For example, "
"if Django didn't serialize :class:`~decimal.Decimal` by default, you could "
"do this::"
msgstr ""
"你可以通过编写一个自定义的序列化器来序列化其他类型。例如，如果 Django 默认没"
"有序列化 :class:`~decimal.Decimal` 你可以这样做："

msgid ""
"The first argument of ``MigrationWriter.register_serializer()`` is a type or "
"iterable of types that should use the serializer."
msgstr ""
"``MigrationWriter.register_serializer()`` 的第一个参数想要使用序列化器的程序"
"类型或类型的可迭代对象。"

msgid ""
"The ``serialize()`` method of your serializer must return a string of how "
"the value should appear in migrations and a set of any imports that are "
"needed in the migration."
msgstr ""
"序列化器的 ``serialize()`` 方法必须返回一个字符串，说明该值在迁移中应如何显示"
"以及迁移中需要的一组导入。"

msgid "Adding a ``deconstruct()`` method"
msgstr "添加 ``deconstruct()`` 方法"

msgid ""
"You can let Django serialize your own custom class instances by giving the "
"class a ``deconstruct()`` method. It takes no arguments, and should return a "
"tuple of three things ``(path, args, kwargs)``:"
msgstr ""
"你可以通过给类一个 ``deconstruct()`` 方法来让Django序列化你的自定义类实例。它"
"不带任何参数，应该返回一个三个项目组成的元组 ``(path, args, kwargs)``："

msgid ""
"``path`` should be the Python path to the class, with the class name "
"included as the last part (for example, ``myapp.custom_things.MyClass``). If "
"your class is not available at the top level of a module it is not "
"serializable."
msgstr ""
"``path`` 应该是该类的 Python 路径，并且类名作为最后一部分包括在内（例如，"
"``myapp.custom_things.MyClass``）。如果你的类在模块的顶层不可用，那么它就不能"
"被序列化。"

msgid ""
"``args`` should be a list of positional arguments to pass to your class' "
"``__init__`` method. Everything in this list should itself be serializable."
msgstr ""
"``args`` 应该是一个位置参数的列表，用来传递给你的类的 ``__init__`` 方法。这个"
"列表中的所有内容本身应该是可序列化的。"

msgid ""
"``kwargs`` should be a dict of keyword arguments to pass to your class' "
"``__init__`` method. Every value should itself be serializable."
msgstr ""
"``kwargs`` 应该是一个关键字参数的字典，用来传递给你的类的 ``__init__`` 方法。"
"每个值本身应该是可序列化的。"

msgid ""
"This return value is different from the ``deconstruct()`` method :ref:`for "
"custom fields <custom-field-deconstruct-method>` which returns a tuple of "
"four items."
msgstr ""
"此返回值与 :ref:`自定义字段 <custom-field-deconstruct-method>` 的 "
"``deconstruct()`` 方法不同，后者返回四个项组成的元组。"

msgid ""
"Django will write out the value as an instantiation of your class with the "
"given arguments, similar to the way it writes out references to Django "
"fields."
msgstr ""
"Django 会用给定的参数将值作为你的类的实例化写出来，类似于它写出对 Django 字段"
"的引用的方式。"

msgid ""
"To prevent a new migration from being created each time :djadmin:"
"`makemigrations` is run, you should also add a ``__eq__()`` method to the "
"decorated class. This function will be called by Django's migration "
"framework to detect changes between states."
msgstr ""
"为了防止每次运行 :djadmin:`makemigrations` 时都会创建一个新的迁移，你还应该在"
"装饰类中添加一个 ``__eq__()`` 方法。这个函数将被 Django 的迁移框架调用，以检"
"测状态之间的变化。"

msgid ""
"As long as all of the arguments to your class' constructor are themselves "
"serializable, you can use the ``@deconstructible`` class decorator from "
"``django.utils.deconstruct`` to add the ``deconstruct()`` method::"
msgstr ""
"只要类构造函数的所有参数本身都是可序列化的，就可以使用 ``django.utils."
"deconstruct`` 的 ``@deconstructible`` 类装饰器添加 ``deconstruct()`` 方法："

msgid ""
"The decorator adds logic to capture and preserve the arguments on their way "
"into your constructor, and then returns those arguments exactly when "
"deconstruct() is called."
msgstr ""
"装饰器添加逻辑以捕获并保留进入构造函数的参数，然后在调用 deconstruct() 时准确"
"返回这些参数。"

msgid "Supporting multiple Django versions"
msgstr "支持多个 Django 版本"

msgid ""
"If you are the maintainer of a third-party app with models, you may need to "
"ship migrations that support multiple Django versions. In this case, you "
"should always run :djadmin:`makemigrations` **with the lowest Django version "
"you wish to support**."
msgstr ""
"如果你是具有模型的第三方应用的维护者，你可能需要发布支持多个 Django 版本的迁"
"移。在这种情况下，你应该始终 **使用你希望支持的最低Django版本** 运行 :"
"djadmin:`makemigrations`。"

msgid ""
"The migrations system will maintain backwards-compatibility according to the "
"same policy as the rest of Django, so migration files generated on Django X."
"Y should run unchanged on Django X.Y+1. The migrations system does not "
"promise forwards-compatibility, however. New features may be added, and "
"migration files generated with newer versions of Django may not work on "
"older versions."
msgstr ""
"迁移系统会按照与 Django 其他部分相同的策略保持向后兼容，所以在 Django X.Y 上"
"生成的迁移文件在 Django X.Y+1 上运行时应该没有变化。但是，迁移系统并不保证向"
"前兼容。新的功能可能会被添加，而且用新版本的 Django 生成的迁移文件可能无法在"
"旧版本上运行。"

msgid ":doc:`The Migrations Operations Reference </ref/migration-operations>`"
msgstr ":doc:`迁移操作参考 </ref/migration-operations>`"

msgid ""
"Covers the schema operations API, special operations, and writing your own "
"operations."
msgstr "涵盖架构操作 API，特殊操作以及编写自己的操作。"

msgid ":doc:`The Writing Migrations \"how-to\" </howto/writing-migrations>`"
msgstr ":doc:`编写迁移的“方法” </howto/writing-migrations>`"

msgid ""
"Explains how to structure and write database migrations for different "
"scenarios you might encounter."
msgstr "介绍如何为你可能遇到的不同情况构建和编写数据库迁移。"

msgid "Pagination"
msgstr "分页"

msgid ""
"Django provides high-level and low-level ways to help you manage paginated "
"data -- that is, data that's split across several pages, with \"Previous/Next"
"\" links."
msgstr ""
"Django 提供了高级和低级的方法来帮助你管理分页数据——也就是说，数据被分割在几个"
"页面上，并带有“上一页／下一页”链接。"

msgid "The ``Paginator`` class"
msgstr "``Paginator`` 类"

msgid ""
"Under the hood, all methods of pagination use the :class:`~django.core."
"paginator.Paginator` class. It does all the heavy lifting of actually "
"splitting a ``QuerySet`` into :class:`~django.core.paginator.Page` objects."
msgstr ""
"在幕后，所有分页方法都使用：:class:`~django.core.paginator.Paginator` 类。它"
"完成了将 ``QuerySet`` 拆分为 :class:`~django.core.paginator.Page` 对象的所有"
"繁重工作。"

msgid ""
"Give :class:`~django.core.paginator.Paginator` a list of objects, plus the "
"number of items you'd like to have on each page, and it gives you methods "
"for accessing the items for each page::"
msgstr ""
"给 :class:`~django.core.paginator.Paginator` 一个对象列表，以及你希望在每个页"
"面上拥有的项目数，它提供了访问每页项目的方法："

msgid ""
"Note that you can give ``Paginator`` a list/tuple, a Django ``QuerySet``, or "
"any other object with a ``count()`` or ``__len__()`` method. When "
"determining the number of objects contained in the passed object, "
"``Paginator`` will first try calling ``count()``, then fallback to using "
"``len()`` if the passed object has no ``count()`` method. This allows "
"objects such as Django's ``QuerySet`` to use a more efficient ``count()`` "
"method when available."
msgstr ""
"请注意，你可以给 ``Paginator`` 一个列表／元组，一个 Django 的 ``QuerySet``，"
"或者任何其它具有 ``count()`` 或 ``__len__()`` 方法的对象。在确定传递的对象中"
"包含的对象数时，``Paginator`` 将首先尝试调用 ``count()``，如果传入的对象没有 "
"``count()`` 方法则回退到使用 ``len()``。这允许像 Django 的 ``QuerySet`` 之类"
"的对象在可用的情况下使用更高效的 ``count()`` 方法。"

msgid "Paginating a ``ListView``"
msgstr "``ListView`` 分页"

msgid ""
":class:`django.views.generic.list.ListView` provides a builtin way to "
"paginate the displayed list. You can do this by adding a :attr:`~django."
"views.generic.list.MultipleObjectMixin.paginate_by` attribute to your view "
"class, for example::"
msgstr ""
":class:`django.views.generic.list.ListView` 提供了一种内置的方式来对显示的列"
"表进行分页。你可以通过在你的视图类中添加：:attr:`~django.views.generic.list."
"MultipleObjectMixin.paginate_by` 属性来实现此目的，例如："

msgid ""
"This limits the number of objects per page and adds a ``paginator`` and "
"``page_obj`` to the ``context``. To allow your users to navigate between "
"pages, add links to the next and previous page, in your template like this:"
msgstr ""
"这限制了每页的对象数量，并在 ``context`` 中添加了 ``paginator`` 和 "
"``page_obj``。要允许用户在页面之间导航，请在模板中添加指向下一页和上一页的链"
"接，如下所示："

msgid "Using ``Paginator`` in a view function"
msgstr "在视图函数中使用 ``Paginator``"

msgid ""
"Here's an example using :class:`~django.core.paginator.Paginator` in a view "
"function to paginate a queryset::"
msgstr ""
"下面是在视图函数中使用 :class:`~django.core.paginator.Paginator` 对查询结果集"
"分页的例子："

msgid ""
"In the template :file:`list.html`, you can include navigation between pages "
"in the same way as in the template for the ``ListView`` above."
msgstr ""
"在模板 :file:`list.html` 中，你可以像上面 ``ListView`` 的模板一样，在页面之间"
"加入导航。"

msgid "Performance and optimization"
msgstr "性能和优化"

msgid ""
"This document provides an overview of techniques and tools that can help get "
"your Django code running more efficiently - faster, and using fewer system "
"resources."
msgstr ""
"本文档概述了一些技术和工具，这些技术和工具可以帮助您更有效地运行Django代码——"
"更快，并且使用更少的系统资源。"

msgid ""
"Generally one's first concern is to write code that *works*, whose logic "
"functions as required to produce the expected output. Sometimes, however, "
"this will not be enough to make the code work as *efficiently* as one would "
"like."
msgstr ""
"通常，首先要考虑的是编写 *能工作的* 代码，它的逻辑功能与产生预期输出所需的逻"
"辑功能相同。然而，有时，这并不足以使代码像人们所希望的那样 *高效地* 工作。"

msgid ""
"In this case, what's needed is something - and in practice, often a "
"collection of things - to improve the code's performance without, or only "
"minimally, affecting its behavior."
msgstr ""
"在这种情况下，需要的是一些东西——在实践中，通常是一组东西——以提高代码的性能，"
"而不影响或只影响其行为。"

msgid "General approaches"
msgstr "一般方法"

msgid "What are you optimizing *for*?"
msgstr "你在为 *什么* 而优化？"

msgid ""
"It's important to have a clear idea what you mean by 'performance'. There is "
"not just one metric of it."
msgstr "清楚地理解你所说的“绩效”是什么很重要，因为它不仅仅是一个指标。"

msgid ""
"Improved speed might be the most obvious aim for a program, but sometimes "
"other performance improvements might be sought, such as lower memory "
"consumption or fewer demands on the database or network."
msgstr ""
"提高速度可能是程序最明显的目标，但有时可能会寻求其他性能改进，例如降低内存消"
"耗或减少对数据库或网络的要求。"

msgid ""
"Improvements in one area will often bring about improved performance in "
"another, but not always; sometimes one can even be at the expense of "
"another. For example, an improvement in a program's speed might cause it to "
"use more memory. Even worse, it can be self-defeating - if the speed "
"improvement is so memory-hungry that the system starts to run out of memory, "
"you'll have done more harm than good."
msgstr ""
"一个领域的改进通常会提高另一个领域的性能，但并不总是如此；有时甚至会牺牲另一"
"个领域的性能。例如，一个程序速度的提高可能会导致它使用更多的内存。更糟糕的"
"是，如果速度提高太过内存不足，以致于系统开始耗尽内存，那么你所做的弊大于利。"

msgid ""
"There are other trade-offs to bear in mind. Your own time is a valuable "
"resource, more precious than CPU time. Some improvements might be too "
"difficult to be worth implementing, or might affect the portability or "
"maintainability of the code. Not all performance improvements are worth the "
"effort."
msgstr ""
"还有其他的权衡。你自己的时间是一个宝贵的资源，比CPU时间更宝贵。一些改进可能太"
"难实现，或者可能影响代码的可移植性或可维护性。并非所有的性能改进都值得付出努"
"力。"

msgid ""
"So, you need to know what performance improvements you are aiming for, and "
"you also need to know that you have a good reason for aiming in that "
"direction - and for that you need:"
msgstr ""
"所以，你需要知道你的目标是什么样的性能改进，你也需要知道你有一个很好的理由去"
"瞄准那个方向——而且你需要："

msgid "Performance benchmarking"
msgstr "性能标竿"

msgid ""
"It's no good just guessing or assuming where the inefficiencies lie in your "
"code."
msgstr "仅仅猜测或假设代码中存在效率低下的原因是没有好处的。"

msgid "Django tools"
msgstr "Django工具"

msgid ""
"`django-debug-toolbar <https://github.com/jazzband/django-debug-toolbar/>`_ "
"is a very handy tool that provides insights into what your code is doing and "
"how much time it spends doing it. In particular it can show you all the SQL "
"queries your page is generating, and how long each one has taken."
msgstr ""
"`django-debug-toolbar <https://github.com/jazzband/django-debug-toolbar/>`_ "
"是一个非常方便的工具，它可以深入了解你的代码正在做什么以及花费了多少时间。特"
"别是它可以显示您的页面生成的所有 SQL 查询，以及每个查询所用的时间。"

msgid ""
"Third-party panels are also available for the toolbar, that can (for "
"example) report on cache performance and template rendering times."
msgstr "第三方面板也可用于工具栏，可以（例如）报告缓存性能和模板呈现时间。"

msgid "Third-party services"
msgstr "第三方服务"

msgid ""
"There are a number of free services that will analyze and report on the "
"performance of your site's pages from the perspective of a remote HTTP "
"client, in effect simulating the experience of an actual user."
msgstr ""
"有许多免费服务可以从远程 HTTP 客户端的角度分析并报告你站点页面的性能，从而有"
"效地模拟实际用户的体验。"

msgid ""
"These can't report on the internals of your code, but can provide a useful "
"insight into your site's overall performance, including aspects that can't "
"be adequately measured from within Django environment. Examples include:"
msgstr ""
"它们不能报告代码的内部情况，但可以提供站点总体性能的有用见解，包括在 Django "
"环境中无法充分衡量的方面。示例包括："

msgid "`Yahoo's Yslow <http://yslow.org/>`_"
msgstr "`Yahoo's Yslow <http://yslow.org/>`_"

msgid "`Google PageSpeed <https://developers.google.com/speed/>`_"
msgstr "`Google PageSpeed <https://developers.google.com/speed/>`_"

msgid ""
"There are also several paid-for services that perform a similar analysis, "
"including some that are Django-aware and can integrate with your codebase to "
"profile its performance far more comprehensively."
msgstr ""
"还有一些付费服务可以执行类似的分析，包括一些支持 Django 的服务，可以与你的代"
"码库集成以更全面地分析其性能。"

msgid "Get things right from the start"
msgstr "从一开始就把事情做好"

msgid ""
"Some work in optimization involves tackling performance shortcomings, but "
"some of the work can be built-in to what you'd do anyway, as part of the "
"good practices you should adopt even before you start thinking about "
"improving performance."
msgstr ""
"优化中的一些工作涉及到解决性能缺陷，但有些工作可以包括在你将要做的事情中，作"
"为甚至在你开始考虑提高性能之前就应该采用的良好实践的一部分。"

msgid ""
"In this respect Python is an excellent language to work with, because "
"solutions that look elegant and feel right usually are the best performing "
"ones. As with most skills, learning what \"looks right\" takes practice, but "
"one of the most useful guidelines is:"
msgstr ""
"在这方面，Python 是一种优秀的语言，因为外观优美且感觉正确的解决方案通常是性能"
"最好的解决方案。 与大多数技能一样，学习“看起来正确”的内容需要练习，但是最有用"
"的准则之一是："

msgid "Work at the appropriate level"
msgstr "在适当的级别工作"

msgid ""
"Django offers many different ways of approaching things, but just because "
"it's possible to do something in a certain way doesn't mean that it's the "
"most appropriate way to do it. For example, you might find that you could "
"calculate the same thing - the number of items in a collection, perhaps - in "
"a ``QuerySet``, in Python, or in a template."
msgstr ""
"Django 提供了许多不同的方法来处理事情，但仅仅因为它可以用某种方式来做某件事，"
"并不意味着它是最合适的方式。例如，你可能会发现可以在 ``QuerySet``、Python 或"
"模板中计算相同的东西——集合中的项目数。"

msgid ""
"However, it will almost always be faster to do this work at lower rather "
"than higher levels. At higher levels the system has to deal with objects "
"through multiple levels of abstraction and layers of machinery."
msgstr ""
"但是，在较低级别而不是较高级别进行此工作几乎总是会更快。 在更高级别上，系统必"
"须通过多层抽象和更多机器层来处理对象。"

msgid ""
"That is, the database can typically do things faster than Python can, which "
"can do them faster than the template language can::"
msgstr "也就是说，数据库通常比 Python 快，Python 比模板语言快："

msgid ""
"Generally speaking, the most appropriate level for the job is the lowest-"
"level one that it is comfortable to code for."
msgstr "一般来说，最适合工作的级别是能够舒服编写代码的最低级别。"

msgid "The example above is merely illustrative."
msgstr "上面的示例仅是说明性的。"

msgid ""
"Firstly, in a real-life case you need to consider what is happening before "
"and after your count to work out what's an optimal way of doing it *in that "
"particular context*. The database optimization documents describes :ref:`a "
"case where counting in the template would be better "
"<overuse_of_count_and_exists>`."
msgstr ""
"首先，在实际案例中你需要考虑你的计数前后发生了什么，以确定 *在特定情况下* 的"
"最佳做法。数据库优化文档描述了 :ref:`在模板中计数会更好的一种情况 "
"<overuse_of_count_and_exists>`。"

msgid ""
"Secondly, there are other options to consider: in a real-life case, "
"``{{ my_bicycles.count }}``, which invokes the ``QuerySet`` ``count()`` "
"method directly from the template, might be the most appropriate choice."
msgstr ""
"其次，还有其他的选择可以考虑：在现实生活中，``{{ my_bicycles.count }}``，它直"
"接从模板调用 ``QuerySet`` 的 ``count()`` 方法，可能是最合适的选择。"

msgid ""
"Often it is expensive (that is, resource-hungry and slow) to compute a "
"value, so there can be huge benefit in saving the value to a quickly "
"accessible cache, ready for the next time it's required."
msgstr ""
"通常情况下，计算一个值是很昂贵的（也就是耗费资源，而且速度很慢），所以把这个"
"值保存到快速访问的缓存中，为下次需要时做好准备，会有巨大的好处。"

msgid ""
"It's a sufficiently significant and powerful technique that Django includes "
"a comprehensive caching framework, as well as other smaller pieces of "
"caching functionality."
msgstr ""
"Django 具有完善的缓存框架以及其他较小的缓存功能，这是一项非常重要且功能强大的"
"技术。"

msgid ":doc:`The caching framework </topics/cache>`"
msgstr ":doc:`缓存框架 </topics/cache>`"

msgid ""
"Django's :doc:`caching framework </topics/cache>` offers very significant "
"opportunities for performance gains, by saving dynamic content so that it "
"doesn't need to be calculated for each request."
msgstr ""
"Django 的 :doc:`缓存框架 </topics/cache>` 通过保存动态内容使其不需要为每个请"
"求计算，从而为性能提升提供了非常重要的机会。"

msgid ""
"For convenience, Django offers different levels of cache granularity: you "
"can cache the output of specific views, or only the pieces that are "
"difficult to produce, or even an entire site."
msgstr ""
"为了方便起见，Django 提供了不同级别的缓存粒度：你可以缓存特定视图的输出，或者"
"只缓存难以生成的部分，甚至可以缓存整个站点。"

msgid ""
"Implementing caching should not be regarded as an alternative to improving "
"code that's performing poorly because it has been written badly. It's one of "
"the final steps toward producing well-performing code, not a shortcut."
msgstr ""
"实施缓存不应该被看作是改进那些因为写得不好而表现不佳的代码的一种替代方法。它"
"是产生性能良好的代码的最终步骤之一，而不是一条捷径。"

msgid ":class:`~django.utils.functional.cached_property`"
msgstr ":class:`~django.utils.functional.cached_property`"

msgid ""
"It's common to have to call a class instance's method more than once. If "
"that function is expensive, then doing so can be wasteful."
msgstr ""
"通常必须多次调用一个类实例的方法。 如果该方法很昂贵，那么这样做会很浪费。"

msgid ""
"Using the :class:`~django.utils.functional.cached_property` decorator saves "
"the value returned by a property; the next time the function is called on "
"that instance, it will return the saved value rather than re-computing it. "
"Note that this only works on methods that take ``self`` as their only "
"argument and that it changes the method to a property."
msgstr ""
"使用 :class:`~django.utils.functional.cached_property` 装饰器保存属性返回的"
"值； 下次在该实例上调用该函数时，它将返回保存的值，而不是重新计算它。 请注"
"意，这仅适用于将 ``self`` 作为唯一参数的方法，并将该方法更改为属性。"

msgid ""
"Certain Django components also have their own caching functionality; these "
"are discussed below in the sections related to those components."
msgstr ""
"某些 Django 组件也具有自己的缓存功能； 这些将在下面与那些组件相关的部分中讨"
"论。"

msgid "Understanding laziness"
msgstr "理解惰性"

msgid ""
"*Laziness* is a strategy complementary to caching. Caching avoids "
"recomputation by saving results; laziness delays computation until it's "
"actually required."
msgstr ""
"*惰性* 是一种与缓存互补的策略。 缓存通过保存结果来避免重新计算； 惰性会延迟计"
"算，直到真正需要它为止。"

msgid ""
"Laziness allows us to refer to things before they are instantiated, or even "
"before it's possible to instantiate them. This has numerous uses."
msgstr ""
"惰性允许我们在事物被实例化之前，甚至在有可能实例化之前，就对其进行引用。这有"
"很多用途。"

msgid ""
"For example, :ref:`lazy translation <lazy-translations>` can be used before "
"the target language is even known, because it doesn't take place until the "
"translated string is actually required, such as in a rendered template."
msgstr ""
"例如，:ref:`惰性翻译 <lazy-translations>` 可以在甚至不知道目标语言之前就使"
"用，因为它直到真正需要翻译后的字符串（例如在渲染的模板中）时才发生。"

msgid ""
"Laziness is also a way to save effort by trying to avoid work in the first "
"place. That is, one aspect of laziness is not doing anything until it has to "
"be done, because it may not turn out to be necessary after all. Laziness can "
"therefore have performance implications, and the more expensive the work "
"concerned, the more there is to gain through laziness."
msgstr ""
"惰性也是一种省力的方法，它首先要避免工作。也就是说，惰性的一个方面是在必须做"
"的时候才做任何事情，因为它可能最终不是必须的。因此，惰性可能有性能影响，相关"
"工作的成本越高，从惰性中获得的收益就越多。"

msgid ""
"Python provides a number of tools for lazy evaluation, particularly through "
"the :py:term:`generator` and :py:term:`generator expression` constructs. "
"It's worth reading up on laziness in Python to discover opportunities for "
"making use of lazy patterns in your code."
msgstr ""
"Python 提供了许多用于惰性求值的工具，特别是通过 :py:term:`generator` 和 :py:"
"term:`generator expression` 构造。值得阅读 Python 的惰性，以发现在代码中利用"
"惰性模式的机会。"

msgid "Laziness in Django"
msgstr "Django 中的惰性"

msgid ""
"Django is itself quite lazy. A good example of this can be found in the "
"evaluation of ``QuerySets``. :ref:`QuerySets are lazy <querysets-are-lazy>`. "
"Thus a ``QuerySet`` can be created, passed around and combined with other "
"``QuerySets``, without actually incurring any trips to the database to fetch "
"the items it describes. What gets passed around is the ``QuerySet`` object, "
"not the collection of items that - eventually - will be required from the "
"database."
msgstr ""
"Django 本身就很惰性。一个很好的例子可以在 ``QuerySets`` 的计算中找到。:ref:"
"`QuerySets 是懒惰的<querysets-are-lazy>`。因此，一个 ``QuerySet`` 以被创建、"
"传递，并与其他 ``QuerySets`` 组合，而不需要实际到数据库中去获取它所描述的项"
"目。被传来传去的是 ``QuerySet`` 对象，而不是最终需要从数据库中获取的项目集"
"合。"

msgid ""
"On the other hand, :ref:`certain operations will force the evaluation of a "
"QuerySet <when-querysets-are-evaluated>`. Avoiding the premature evaluation "
"of a ``QuerySet`` can save making an expensive and unnecessary trip to the "
"database."
msgstr ""
"另一方面，:ref:`某些操作将强制计算 QuerySet <when-querysets-are-evaluated>`。"
"避免过早地对 ``QuerySet`` 进行计算，可以节省对数据库进行一次昂贵而不必要的访"
"问。"

msgid ""
"Django also offers a :meth:`~django.utils.functional.keep_lazy` decorator. "
"This allows a function that has been called with a lazy argument to behave "
"lazily itself, only being evaluated when it needs to be. Thus the lazy "
"argument - which could be an expensive one - will not be called upon for "
"evaluation until it's strictly required."
msgstr ""
"Django 还提供了一个 :meth:`~django.utils.functional.keep_lazy` 这允许使用惰性"
"参数调用的函数本身表现为惰性，仅在需要时才进行计算。因此，懒惰参数——可能是一"
"个昂贵的参数——在真正需要的时候才会被调用计算。"

msgid "Databases"
msgstr "数据库"

msgid "Database optimization"
msgstr "数据库优化"

msgid ""
"Django's database layer provides various ways to help developers get the "
"best performance from their databases. The :doc:`database optimization "
"documentation </topics/db/optimization>` gathers together links to the "
"relevant documentation and adds various tips that outline the steps to take "
"when attempting to optimize your database usage."
msgstr ""
"Django 的数据库层提供了多种方法来帮助开发者从其数据库中获得最佳性能。:doc:`数"
"据库优化文档 </topics/db/optimization>` 收集了相关文档的链接，并添加了各种技"
"巧，概述了尝试优化数据库使用率时要采取的步骤。"

msgid "Other database-related tips"
msgstr "其他与数据库相关的技巧"

msgid ""
"Enabling :ref:`persistent-database-connections` can speed up connections to "
"the database accounts for a significant part of the request processing time."
msgstr ""
"启用 :ref:`持久数据库连接` 可以在大部分请求处理时间中加快与数据库帐户的连接。"

msgid ""
"This helps a lot on virtualized hosts with limited network performance, for "
"example."
msgstr "例如，这对网络性能有限的虚拟主机有很大帮助。"

msgid "HTTP performance"
msgstr "HTTP 性能"

msgid ""
"Django comes with a few helpful pieces of :doc:`middleware </ref/"
"middleware>` that can help optimize your site's performance. They include:"
msgstr ""
"Django自带了一些有用的 :doc:`中间件 </ref/middleware>` ，可以帮助优化你的网站"
"的性能。它们包括："

msgid ":class:`~django.middleware.http.ConditionalGetMiddleware`"
msgstr ":class:`~django.middleware.http.ConditionalGetMiddleware`"

msgid ""
"Adds support for modern browsers to conditionally GET responses based on the "
"``ETag`` and ``Last-Modified`` headers. It also calculates and sets an ETag "
"if needed."
msgstr ""
"增加对现代浏览器的支持，根据 ``ETag`` 和 ``Last-Modified`` 头有条件的 GET 响"
"应。如果需要，它还可以计算和设置 ETag。"

msgid ":class:`~django.middleware.gzip.GZipMiddleware`"
msgstr ":class:`~django.middleware.gzip.GZipMiddleware`"

msgid ""
"Compresses responses for all modern browsers, saving bandwidth and transfer "
"time. Note that GZipMiddleware is currently considered a security risk, and "
"is vulnerable to attacks that nullify the protection provided by TLS/SSL. "
"See the warning in :class:`~django.middleware.gzip.GZipMiddleware` for more "
"information."
msgstr ""
"压缩对所有现代浏览器的响应，节省带宽和传输时间。请注意，GZipMiddleware 目前被"
"认为是一个安全风险，容易受到攻击，使TLS／SSL提供的保护失效。更多信息请参见 :"
"class:`~django.middleware.gzip.GZipMiddleware` 中的警告。"

msgid "Sessions"
msgstr "会话"

msgid ""
":ref:`Using cached sessions <cached-sessions-backend>` may be a way to "
"increase performance by eliminating the need to load session data from a "
"slower storage source like the database and instead storing frequently used "
"session data in memory."
msgstr ""
":ref:`使用缓存会话 <cached-sessions-backend>` 可能是一种提高性能的方法，因为"
"不需要从数据库等较慢的存储源加载会话数据，而是将经常使用的会话数据存储在内存"
"中。"

msgid "Static files"
msgstr "静态文件"

msgid ""
"Static files, which by definition are not dynamic, make an excellent target "
"for optimization gains."
msgstr "静态文件，根据定义不是动态的，是优化增益的理想目标。"

msgid ":class:`~django.contrib.staticfiles.storage.ManifestStaticFilesStorage`"
msgstr ""
":class:`~django.contrib.staticfiles.storage.ManifestStaticFilesStorage`"

msgid ""
"By taking advantage of web browsers' caching abilities, you can eliminate "
"network hits entirely for a given file after the initial download."
msgstr ""
"通过利用网络浏览器的缓存功能，你可以在初始下载后完全消除对给定文件的网络访"
"问。"

msgid ""
":class:`~django.contrib.staticfiles.storage.ManifestStaticFilesStorage` "
"appends a content-dependent tag to the filenames of :doc:`static files </ref/"
"contrib/staticfiles>` to make it safe for browsers to cache them long-term "
"without missing future changes - when a file changes, so will the tag, so "
"browsers will reload the asset automatically."
msgstr ""
":class:`~django.contrib.staticfiles.storage.ManifestStaticFilesStorage` 为 :"
"doc:`静态文件 </ref/contrib/staticfiles>` 的文件名后附加一个与内容相关的标"
"记，使浏览器可以安全地长期缓存这些文件，而不会丢失将来的更改——当文件更改时，"
"标记也会更改，因此浏览器将自动重新加载文件。"

msgid "\"Minification\""
msgstr "“最小化”"

msgid ""
"Several third-party Django tools and packages provide the ability to \"minify"
"\" HTML, CSS, and JavaScript. They remove unnecessary whitespace, newlines, "
"and comments, and shorten variable names, and thus reduce the size of the "
"documents that your site publishes."
msgstr ""
"一些第三方 Django 工具和包提供了“最小化”HTML、CSS 和 JavaScript 的能力。它们"
"删除不必要的空白、换行符和注释，并缩短变量名，从而减小站点发布的文档的大小。"

msgid "Template performance"
msgstr "模板性能"

msgid "Note that:"
msgstr "注意："

msgid "using ``{% block %}`` is faster than using ``{% include %}``"
msgstr "使用 ``{% block %}`` 比使用 ``{% include %}`` 快"

msgid ""
"heavily-fragmented templates, assembled from many small pieces, can affect "
"performance"
msgstr "由许多小块组装而成的严重碎片化的模板会影响性能"

msgid "The cached template loader"
msgstr "缓存的模板加载器"

msgid ""
"Enabling the :class:`cached template loader <django.template.loaders.cached."
"Loader>` often improves performance drastically, as it avoids compiling each "
"template every time it needs to be rendered."
msgstr ""
"启用 :class:`缓存的模板加载器<django.template.loaders.cached.Loader>` 通常会"
"大幅提高性能，因为它避免了每次需要渲染时都编译模板。"

msgid "Using different versions of available software"
msgstr "使用现有软件的不同版本"

msgid ""
"It can sometimes be worth checking whether different and better-performing "
"versions of the software that you're using are available."
msgstr "有时不妨检查一下你所使用的软件是否有不同的、性能更好的版本。"

msgid ""
"These techniques are targeted at more advanced users who want to push the "
"boundaries of performance of an already well-optimized Django site."
msgstr "这些技术是针对那些想要提升已经充分优化的 Django 网站性能的高级用户。"

msgid ""
"However, they are not magic solutions to performance problems, and they're "
"unlikely to bring better than marginal gains to sites that don't already do "
"the more basic things the right way."
msgstr ""
"然而，它们并不是解决性能问题的灵丹妙药，它们也不太可能给那些还没有正确完成更"
"基本的事情的网站带来比边际收益更好的收益。"

msgid ""
"It's worth repeating: **reaching for alternatives to software you're already "
"using is never the first answer to performance problems**. When you reach "
"this level of optimization, you need a formal benchmarking solution."
msgstr ""
"值得重复的是：**寻找你已经在使用的软件的替代品从来不是解决性能问题的第一个办"
"法**。当达到此优化级别时，你需要一个正式的基准测试解决方案。"

msgid "Newer is often - but not always - better"
msgstr "较新的往往是——但并不总是——更好。"

msgid ""
"It's fairly rare for a new release of well-maintained software to be less "
"efficient, but the maintainers can't anticipate every possible use-case - so "
"while being aware that newer versions are likely to perform better, don't "
"assume that they always will."
msgstr ""
"维护良好的软件的新版本效率较低是相当罕见的，但维护者不可能预料到每一个可能的"
"用例——所以要注意新版本可能会有更好的表现，但不要假设它们总是会有更好的表现。"

msgid ""
"This is true of Django itself. Successive releases have offered a number of "
"improvements across the system, but you should still check the real-world "
"performance of your application, because in some cases you may find that "
"changes mean it performs worse rather than better."
msgstr ""
"Django 本身也是如此。 后续的发行版对整个系统进行了许多改进，但是你仍应检查应"
"用程序的实际性能，因为在某些情况下，你可能会发现更改意味着性能较差而不是更"
"好。"

msgid ""
"Newer versions of Python, and also of Python packages, will often perform "
"better too - but measure, rather than assume."
msgstr ""
"Python 的新版本，以及 Python 包的新版本，通常也会有更好的表现——但要衡量，而不"
"是假设。"

msgid ""
"Unless you've encountered an unusual performance problem in a particular "
"version, you'll generally find better features, reliability, and security in "
"a new release and that these benefits are far more significant than any "
"performance you might win or lose."
msgstr ""
"除非你在特定版本中遇到了异常的性能问题，否则你通常会在新版本中找到更好的特"
"性、可靠性和安全性，而且这些好处远比你可能赢得或失去的任何性能都重要。"

msgid "Alternatives to Django's template language"
msgstr "Django 模板语言的替代方案"

msgid ""
"For nearly all cases, Django's built-in template language is perfectly "
"adequate. However, if the bottlenecks in your Django project seem to lie in "
"the template system and you have exhausted other opportunities to remedy "
"this, a third-party alternative may be the answer."
msgstr ""
"对于几乎所有的情况来说，Django 内置的模板语言是完全足够的。然而，如果你的 "
"Django 项目中的瓶颈似乎在于模板系统，而你已经用尽了其他机会来补救，那么第三方"
"的替代方案可能就是答案。"

msgid ""
"Jinja2_ can offer performance improvements, particularly when it comes to "
"speed."
msgstr ""

msgid ""
"Alternative template systems vary in the extent to which they share Django's "
"templating language."
msgstr "其他模板系统在共享 Django 模板语言的程度上有所不同。"

msgid ""
"*If* you experience performance issues in templates, the first thing to do "
"is to understand exactly why. Using an alternative template system may prove "
"faster, but the same gains may also be available without going to that "
"trouble - for example, expensive processing and logic in your templates "
"could be done more efficiently in your views."
msgstr ""
"*如果* 你在模板中遇到性能问题，首先要做的是了解具体原因。使用替代的模板系统可"
"能会更快，但同样的收益也可能不费吹灰之力，例如，模板中昂贵的处理和逻辑可以在"
"视图中更有效地完成。"

msgid "Alternative software implementations"
msgstr "替代软件实现"

msgid ""
"It may be worth checking whether Python software you're using has been "
"provided in a different implementation that can execute the same code faster."
msgstr ""
"也许值得检查一下你正在使用的 Python 软件是否已经提供了不同的实现，可以更快地"
"执行同样的代码。"

msgid ""
"However: most performance problems in well-written Django sites aren't at "
"the Python execution level, but rather in inefficient database querying, "
"caching, and templates. If you're relying on poorly-written Python code, "
"your performance problems are unlikely to be solved by having it execute "
"faster."
msgstr ""
"然而：大多数写得好的 Django 网站的性能问题并不在 Python 执行层面，而是在低效"
"的数据库查询、缓存和模板上。如果你依赖于编写得不好的 Python 代码，你的性能问"
"题不可能通过让它执行得更快来解决。"

msgid ""
"Using an alternative implementation may introduce compatibility, deployment, "
"portability, or maintenance issues. It goes without saying that before "
"adopting a non-standard implementation you should ensure it provides "
"sufficient performance gains for your application to outweigh the potential "
"risks."
msgstr ""
"使用替代实现可能会带来兼容性、部署、可移植性或维护问题。不言而喻，在采用非标"
"准实现之前，你应该确保它为你的应用程序提供足够的性能收益，以抵消潜在的风险。"

msgid "With these caveats in mind, you should be aware of:"
msgstr "有了这些注意事项，你就应该知道："

msgid "`PyPy <https://www.pypy.org/>`_"
msgstr "`PyPy <https://www.pypy.org/>`_"

msgid ""
"`PyPy <https://www.pypy.org/>`_ is an implementation of Python in Python "
"itself (the 'standard' Python implementation is in C). PyPy can offer "
"substantial performance gains, typically for heavyweight applications."
msgstr ""
"`PyPy <https://www.pypy.org/>`_ 是 Python 本身的一个实现（“标准” Python 实现"
"是用 C 语言）。PyPy 可以提供可观的性能提升，通常用于重量级应用。"

msgid ""
"A key aim of the PyPy project is `compatibility <https://www.pypy.org/compat."
"html>`_ with existing Python APIs and libraries. Django is compatible, but "
"you will need to check the compatibility of other libraries you rely on."
msgstr ""
"PyPy 项目的一个关键目标是 `与现有的 Python API 和库兼容 <https://www.pypy."
"org/compat.html>`_ 。Django 是兼容的，但你需要检查你依赖的其他库的兼容性。"

msgid "C implementations of Python libraries"
msgstr "Python 库的 C 语言实现"

msgid ""
"Some Python libraries are also implemented in C, and can be much faster. "
"They aim to offer the same APIs. Note that compatibility issues and behavior "
"differences are not unknown (and not always immediately evident)."
msgstr ""
"有些 Python 库也是用 C 语言实现的，速度可以快得多。他们的目标是提供相同的 "
"API。请注意，兼容性问题和行为差异并非未知（也并非总是立竿见影的）。"

msgid "Security in Django"
msgstr "Django 的安全性"

msgid ""
"This document is an overview of Django's security features. It includes "
"advice on securing a Django-powered site."
msgstr ""
"此文档是对 Django 安全特性的概述。包含保障那些用 Django 建立的网站的安全性建"
"议。"

msgid "Cross site scripting (XSS) protection"
msgstr "防御跨站脚本攻击（XSS）"

msgid ""
"XSS attacks allow a user to inject client side scripts into the browsers of "
"other users. This is usually achieved by storing the malicious scripts in "
"the database where it will be retrieved and displayed to other users, or by "
"getting users to click a link which will cause the attacker's JavaScript to "
"be executed by the user's browser. However, XSS attacks can originate from "
"any untrusted source of data, such as cookies or web services, whenever the "
"data is not sufficiently sanitized before including in a page."
msgstr ""
"XSS 攻击允许用户将客户端脚本注入到其他用户的浏览器中。这通常是通过将恶意脚本"
"存储在数据库中，在那里它将被检索并显示给其他用户，或者通过让用户点击一个链"
"接，使攻击者的 JavaScript 被用户的浏览器执行来实现。然而，XSS 攻击可以来自任"
"何不受信任的数据源，如 cookie 或网络服务，只要数据在被纳入页面之前没有被充分"
"净化。"

msgid ""
"Using Django templates protects you against the majority of XSS attacks. "
"However, it is important to understand what protections it provides and its "
"limitations."
msgstr ""
"Django 模板可以保护您免受大多数 XSS 攻击。但是了解它提供了怎样的保护，以及有"
"什么限制是很重要的。"

msgid ""
"Django templates :ref:`escape specific characters <automatic-html-escaping>` "
"which are particularly dangerous to HTML. While this protects users from "
"most malicious input, it is not entirely foolproof. For example, it will not "
"protect the following:"
msgstr ""
"对于 HTML 来说，Django 模板中的 :ref:`转义特殊字符 <automatic-html-"
"escaping>`  是尤其危险的。虽然它保护用户免受大多数恶意输入的攻击，但并非万无"
"一失。比如，出现下面这种情况就会保护失效："

msgid ""
"If ``var`` is set to ``'class1 onmouseover=javascript:func()'``, this can "
"result in unauthorized JavaScript execution, depending on how the browser "
"renders imperfect HTML. (Quoting the attribute value would fix this case.)"
msgstr ""
"如果 ``var`` 被设置为 ``'class1 onmouseover=javascript:func()'`` ，将导致未经"
"授权的  JavaScript 脚本执行，这取决于浏览器如何渲染有缺陷的HTML。（引用属性值"
"可以解决这个问题）"

msgid ""
"It is also important to be particularly careful when using ``is_safe`` with "
"custom template tags, the :tfilter:`safe` template tag, :mod:`mark_safe "
"<django.utils.safestring>`, and when autoescape is turned off."
msgstr ""
"与此不相上下的还有在使用带有自定义模板标签的 ``is_safe`` ，:tfilter:`safe` 模"
"板标签，:mod:`mark_safe <django.utils.safestring>`，以及关闭自动转义时要特别"
"小心。"

msgid ""
"In addition, if you are using the template system to output something other "
"than HTML, there may be entirely separate characters and words which require "
"escaping."
msgstr ""
"此外，如果使用模板系统输出了除 HTML 之外的内容，可能会有完全独立的字符和单词"
"需要转义。"

msgid ""
"You should also be very careful when storing HTML in the database, "
"especially when that HTML is retrieved and displayed."
msgstr ""
"您在将 HTML 储存到数据库中时也要非常小心，特别是在检索和显示 HTML 的时候。"

msgid "Cross site request forgery (CSRF) protection"
msgstr "防御跨站点请求伪造（CSRF）"

msgid ""
"CSRF attacks allow a malicious user to execute actions using the credentials "
"of another user without that user's knowledge or consent."
msgstr ""
"发起 CSRF 攻击的人可以使用其他用户的证书执行操作，且是在其不知情或不同意的情"
"况下。"

msgid ""
"Django has built-in protection against most types of CSRF attacks, providing "
"you have :ref:`enabled and used it <using-csrf>` where appropriate. However, "
"as with any mitigation technique, there are limitations. For example, it is "
"possible to disable the CSRF module globally or for particular views. You "
"should only do this if you know what you are doing. There are other :ref:"
"`limitations <csrf-limitations>` if your site has subdomains that are "
"outside of your control."
msgstr ""
"Django 内置了保护措施来防御大多数 CSRF 攻击，您需要在合适的地方 :ref:`授权并"
"使用它 <using-csrf>`  。但和多数缓解性技术一样，它是有局限性的。比如可以全局"
"禁用 CSRF 模块或者特定的视图。请三思而后行。如果您的网页还有脱离您控制的子"
"域，还将会有其他 :ref:`限制 <csrf-limitations>` 。"

msgid ""
":ref:`CSRF protection works <how-csrf-works>` by checking for a secret in "
"each POST request. This ensures that a malicious user cannot \"replay\" a "
"form POST to your website and have another logged in user unwittingly submit "
"that form. The malicious user would have to know the secret, which is user "
"specific (using a cookie)."
msgstr ""
":ref:`CSRF 保护机制 <how-csrf-works>` 通过检查每一个 POST 请求中的密文来实"
"现。这保证恶意用户不能“复现”一个表单并用 POST 提交到你的网页，并让一个已登录"
"用户无意中提交该表单。恶意用户必须知道特定于用户的密文（使用 cookie）。"

msgid ""
"When deployed with :ref:`HTTPS <security-recommendation-ssl>`, "
"``CsrfViewMiddleware`` will check that the HTTP referer header is set to a "
"URL on the same origin (including subdomain and port). Because HTTPS "
"provides additional security, it is imperative to ensure connections use "
"HTTPS where it is available by forwarding insecure connection requests and "
"using HSTS for supported browsers."
msgstr ""
"在部署 :ref:`HTTPS <security-recommendation-ssl>` 时，``CsrfViewMiddleware`` "
"会检查 HTTP 报文的 referer 首部是否设置为同源的 URL（包括子域和端口）。因为 "
"HTTPS 提供了额外的安全性，所有通过转发不安全连接请求并在支持的浏览器中使用 "
"HSTS 来确保连接在可用的地方使用了 HTTPS ，这一点是很重要的。"

msgid ""
"Be very careful with marking views with the ``csrf_exempt`` decorator unless "
"it is absolutely necessary."
msgstr "除非绝对需要，否则对视图进行标记 ``csrf_exempt`` 装饰器时要极其慎重。"

msgid "SQL injection protection"
msgstr "防御 SQL 注入"

msgid ""
"SQL injection is a type of attack where a malicious user is able to execute "
"arbitrary SQL code on a database. This can result in records being deleted "
"or data leakage."
msgstr ""
"SQL 注入能让恶意用户能在数据库中执行任意 SQL 代码。这将导致记录被删除或泄露。"

msgid ""
"Django's querysets are protected from SQL injection since their queries are "
"constructed using query parameterization. A query's SQL code is defined "
"separately from the query's parameters. Since parameters may be user-"
"provided and therefore unsafe, they are escaped by the underlying database "
"driver."
msgstr ""
"Django 的 querysets 在被参数化查询构建出来时就被保护而免于 SQL 注入。查询的 "
"SQL 代码与查询的参数是分开定义的。参数可能来自用户从而不安全，因此它们由底层"
"数据库引擎进行转义。"

msgid ""
"Django also gives developers power to write :ref:`raw queries <executing-raw-"
"queries>` or execute :ref:`custom sql <executing-custom-sql>`. These "
"capabilities should be used sparingly and you should always be careful to "
"properly escape any parameters that the user can control. In addition, you "
"should exercise caution when using :meth:`~django.db.models.query.QuerySet."
"extra` and :class:`~django.db.models.expressions.RawSQL`."
msgstr ""
"Django 也为开发者提供了书写 :ref:`原始查询 <executing-raw-queries>` 或执行 :"
"ref:`自定义 sql <executing-custom-sql>` 的权力。应当尽可能少地使用这些方法，"
"并且您应该小心并准确地转义一切用户可控的参数。另外，在使用 :meth:`~django.db."
"models.query.QuerySet.extra` 和 :class:`~django.db.models.expressions."
"RawSQL` 时应当小心谨慎。"

msgid "Clickjacking protection"
msgstr "防御访问劫持"

msgid ""
"Clickjacking is a type of attack where a malicious site wraps another site "
"in a frame. This attack can result in an unsuspecting user being tricked "
"into performing unintended actions on the target site."
msgstr ""
"访问劫持能让恶意网页覆盖另一个网页。可能会有毫不知情的用户被骗入目标网页并执"
"行意料之外的操作。"

msgid ""
"Django contains :ref:`clickjacking protection <clickjacking-prevention>` in "
"the form of the :mod:`X-Frame-Options middleware <django.middleware."
"clickjacking.XFrameOptionsMiddleware>` which in a supporting browser can "
"prevent a site from being rendered inside a frame. It is possible to disable "
"the protection on a per view basis or to configure the exact header value "
"sent."
msgstr ""
"Django 包含 :ref:`访问劫持保护 <clickjacking-prevention>` ，以 :mod:`X-Frame-"
"Options middleware <django.middleware.clickjacking.XFrameOptionsMiddleware>` "
"的形式在支持它的浏览器中阻止一个网页被渲染在 frame 的内部。可在每个视图的基础"
"上禁用保护，也可配置发送的确切头部值。"

msgid ""
"The middleware is strongly recommended for any site that does not need to "
"have its pages wrapped in a frame by third party sites, or only needs to "
"allow that for a small section of the site."
msgstr ""
"对于任何不会被第三方网站嵌入 frame 的网页，或者只允许使用一小部分的网页来说，"
"强烈建议使用中间件。"

msgid "SSL/HTTPS"
msgstr "SSL/HTTPS"

msgid ""
"It is always better for security to deploy your site behind HTTPS. Without "
"this, it is possible for malicious network users to sniff authentication "
"credentials or any other information transferred between client and server, "
"and in some cases -- **active** network attackers -- to alter data that is "
"sent in either direction."
msgstr ""
"通过 HTTPS 部署您的网页是保障安全的最佳办法。没有它，恶意用户就可以在客户端和"
"服务器之间嗅探验证资格或其他信息，在某些情况下 -- 比如 **主动** 网络攻击者 "
"-- 会修改发送中的数据。"

msgid ""
"If you want the protection that HTTPS provides, and have enabled it on your "
"server, there are some additional steps you may need:"
msgstr ""
"如果您想得到 HTTPS 的保护，且已经在您的服务器上启用了，下面还有一些额外的步骤"
"需要执行："

msgid ""
"If necessary, set :setting:`SECURE_PROXY_SSL_HEADER`, ensuring that you have "
"understood the warnings there thoroughly. Failure to do this can result in "
"CSRF vulnerabilities, and failure to do it correctly can also be dangerous!"
msgstr ""
"如有必要，设置 :setting:`SECURE_PROXY_SSL_HEADER`，确保您已经彻底的了解了它的"
"警告提示。如果不这么做，将会导致 CSRF 漏洞，如果操作不正确，也是非常危险的。"

msgid ""
"Set :setting:`SECURE_SSL_REDIRECT` to ``True``, so that requests over HTTP "
"are redirected to HTTPS."
msgstr ""
"设置 :setting:`SECURE_SSL_REDIRECT` 为  ``True``，这样 HTTP 的请求就会被重定"
"向到 HTTPS。"

msgid ""
"Please note the caveats under :setting:`SECURE_PROXY_SSL_HEADER`. For the "
"case of a reverse proxy, it may be easier or more secure to configure the "
"main web server to do the redirect to HTTPS."
msgstr ""
"请注意 :setting:`SECURE_PROXY_SSL_HEADER` 下的注意事项。对于反向代理的情况，"
"配置主 Web 服务器来做重定向到 HTTPS 可能更容易或更安全。"

msgid "Use 'secure' cookies."
msgstr "使用 'secure' cookies。"

msgid ""
"If a browser connects initially via HTTP, which is the default for most "
"browsers, it is possible for existing cookies to be leaked. For this reason, "
"you should set your :setting:`SESSION_COOKIE_SECURE` and :setting:"
"`CSRF_COOKIE_SECURE` settings to ``True``. This instructs the browser to "
"only send these cookies over HTTPS connections. Note that this will mean "
"that sessions will not work over HTTP, and the CSRF protection will prevent "
"any POST data being accepted over HTTP (which will be fine if you are "
"redirecting all HTTP traffic to HTTPS)."
msgstr ""
"如果浏览器使用默认的 HTTP 来实现初始连接，可能会导致已有的 cookies 泄露。因"
"此，您应当将 :setting:`CSRF_COOKIE_SECURE` 和 :setting:`CSRF_COOKIE_SECURE` "
"设置为 ``True``。这样浏览器就会仅用 HTTPS 连接来发送 cookies。注意，这会使得 "
"sessions 不能再通过 HTTP 工作，且 CSRF 防御机制将会阻止任何通过 HTTP 接收到"
"的 POST 数据（当然把所有 HTTP 都弄成 HTTPS 是最好的）。"

msgid "Use :ref:`http-strict-transport-security` (HSTS)"
msgstr "使用 :ref:`http-strict-transport-security` （HSTS）"

msgid ""
"HSTS is an HTTP header that informs a browser that all future connections to "
"a particular site should always use HTTPS. Combined with redirecting "
"requests over HTTP to HTTPS, this will ensure that connections always enjoy "
"the added security of SSL provided one successful connection has occurred. "
"HSTS may either be configured with :setting:`SECURE_HSTS_SECONDS`, :setting:"
"`SECURE_HSTS_INCLUDE_SUBDOMAINS`, and :setting:`SECURE_HSTS_PRELOAD`, or on "
"the web server."
msgstr ""
"HSTS 是一个 HTTP 标头，它通知浏览器，所有未来连接到一个特定的网站应该始终使"
"用 HTTPS。结合重定向 HTTP 请求到 HTTPS，这将确保连接总是享受 SSL 的额外安全，"
"只要有一个成功的连接发生。HSTS 可以通过 :setting:`SECURE_HSTS_SECONDS`、 :"
"setting:`SECURE_HSTS_INCLUDE_SUBDOMAINS` 和 :setting:`SECURE_HSTS_PRELOAD` 来"
"配置，或者在网络服务器上配置。"

msgid "Host header validation"
msgstr "Host 头部验证"

msgid ""
"Django uses the ``Host`` header provided by the client to construct URLs in "
"certain cases. While these values are sanitized to prevent Cross Site "
"Scripting attacks, a fake ``Host`` value can be used for Cross-Site Request "
"Forgery, cache poisoning attacks, and poisoning links in emails."
msgstr ""
"在某些情况下，Django 使用客户端提供的 ``Host`` 头部来构造 URLs。这些值虽被清"
"理以阻止跨站脚本攻击，但伪造 ``Host`` 值还是可以用于跨站请求伪造，缓存毒化攻"
"击，以及电子邮件中的有毒链接。"

msgid ""
"Because even seemingly-secure web server configurations are susceptible to "
"fake ``Host`` headers, Django validates ``Host`` headers against the :"
"setting:`ALLOWED_HOSTS` setting in the :meth:`django.http.HttpRequest."
"get_host()` method."
msgstr ""
"因为即使看起来安全的服务器配置也容易受到假的 ``Host`` 头部信息的影响，Django "
"依靠定义在 :meth:`django.http.HttpRequest.get_host()` 方法中的 :setting:"
"`ALLOWED_HOSTS` 来验证 ``Host`` 头部。"

msgid ""
"This validation only applies via :meth:`~django.http.HttpRequest."
"get_host()`; if your code accesses the ``Host`` header directly from "
"``request.META`` you are bypassing this security protection."
msgstr ""
"这些验证仅通过 :meth:`~django.http.HttpRequest.get_host()` 来实现；如果您的代"
"码直接从 ``request.META`` 得到 ``Host`` 头部，您就绕过了这种安全保护机制。"

msgid "For more details see the full :setting:`ALLOWED_HOSTS` documentation."
msgstr "更多细节请参照完整的 :setting:`ALLOWED_HOSTS` 文档。"

msgid ""
"Previous versions of this document recommended configuring your web server "
"to ensure it validates incoming HTTP ``Host`` headers. While this is still "
"recommended, in many common web servers a configuration that seems to "
"validate the ``Host`` header may not in fact do so. For instance, even if "
"Apache is configured such that your Django site is served from a non-default "
"virtual host with the ``ServerName`` set, it is still possible for an HTTP "
"request to match this virtual host and supply a fake ``Host`` header. Thus, "
"Django now requires that you set :setting:`ALLOWED_HOSTS` explicitly rather "
"than relying on web server configuration."
msgstr ""
"本文档的较早版本建议配置你的网络服务器，以确保它验证传入的 HTTP ``Host`` 头。"
"虽然我们现在还是这样建议，但在许多常见 Web 服务器中，看似验证了 ``Host`` 头的"
"配置，实际上却没有验证。例如，即使 Apache 的配置是让你的 Django 网站从一个非"
"默认的虚拟主机上运行，并设置了 \"ServerName\"，HTTP 请求仍然有可能匹配这个虚"
"拟主机，并提供一个假的 \"Host \" 头。因此，Django 现在要求你显式地设置 :"
"setting:`ALLOWED_HOSTS`，而不是依赖 Web 服务器的配置。"

msgid ""
"Additionally, Django requires you to explicitly enable support for the ``X-"
"Forwarded-Host`` header (via the :setting:`USE_X_FORWARDED_HOST` setting) if "
"your configuration requires it."
msgstr ""
"另外，如果您的配置需要，Django 要求您明确启用对 ``X-Forwarded-Host`` 标头的支"
"持（通过 :setting:`USE_X_FORWARDED_HOST` 配置）。"

msgid "Referrer policy"
msgstr "Referrer 策略"

msgid ""
"Browsers use the ``Referer`` header as a way to send information to a site "
"about how users got there. By setting a *Referrer Policy* you can help to "
"protect the privacy of your users, restricting under which circumstances the "
"``Referer`` header is set. See :ref:`the referrer policy section of the "
"security middleware reference <referrer-policy>` for details."
msgstr ""
"浏览器使用 ``Referer`` 头部来把关于用户是如何到达那里的信息发送到网站。通过设"
"置 *Referrer 策略*，限制在哪些情况下设置 ``Referer`` 头部，可以保护您用户的隐"
"私。请看 :ref:`安全中间件参考中的 referrer 策略部分 <referrer-policy>` 了解更"
"多细节。"

msgid "Cross-origin opener policy"
msgstr "跨源弹出式窗口策略"

msgid ""
"The cross-origin opener policy (COOP) header allows browsers to isolate a "
"top-level window from other documents by putting them in a different context "
"group so that they cannot directly interact with the top-level window. If a "
"document protected by COOP opens a cross-origin popup window, the popup’s "
"``window.opener`` property will be ``null``. COOP protects against cross-"
"origin attacks. See :ref:`the cross-origin opener policy section of the "
"security middleware reference <cross-origin-opener-policy>` for details."
msgstr ""
"跨源弹出式窗口策略（COOP）头允许浏览器将一个顶级窗口与其他文档隔离，把它们放"
"在不同的上下文组中，使它们不能直接与顶级窗口交互。如果一个受 COOP 保护的文档"
"打开了一个跨源弹出窗口，该弹出窗口的 ``window.opener`` 属性将为 ``null``。"
"COOP 可以防止跨源攻击。详情请看 :ref:`安全中间件参考资料中的跨源弹出式窗口策"
"略部分 <cross-origin-opener-policy>`。"

msgid ""
"Similar to the :ref:`CSRF limitations <csrf-limitations>` requiring a site "
"to be deployed such that untrusted users don't have access to any "
"subdomains, :mod:`django.contrib.sessions` also has limitations. See :ref:"
"`the session topic guide section on security <topics-session-security>` for "
"details."
msgstr ""
"类似于 :ref:`CSRF 限制 <csrf-limitations>` 要求一个被部署的网页应让不受信任的"
"用户不能访问任何子域，:mod:`django.contrib.sessions` 也有限制。参照 :ref:`会"
"话主题指南中关于安全的部分 <topics-session-security>` 获取更多细节。"

msgid "User-uploaded content"
msgstr "用户上传内容"

msgid ""
"Consider :ref:`serving static files from a cloud service or CDN <staticfiles-"
"from-cdn>` to avoid some of these issues."
msgstr "考虑从云服务或 CDN 提供静态文件服务来避免此类问题。"

msgid ""
"If your site accepts file uploads, it is strongly advised that you limit "
"these uploads in your web server configuration to a reasonable size in order "
"to prevent denial of service (DOS) attacks. In Apache, this can be easily "
"set using the LimitRequestBody_ directive."
msgstr ""
"如果你的网站接受文件上传，强烈建议你在你的网络服务器配置中把这些上传文件限制"
"在一个合理的大小，以防止拒绝服务（DOS）攻击。在 Apache 中，可以使用 "
"LimitRequestBody_ 指令轻松设置。"

msgid ""
"If you are serving your own static files, be sure that handlers like "
"Apache's ``mod_php``, which would execute static files as code, are "
"disabled. You don't want users to be able to execute arbitrary code by "
"uploading and requesting a specially crafted file."
msgstr ""
"如果您为自己的静态文件提供服务，确保像 Apache 的 ``mod_php`` 这种能把静态文件"
"当作代码来执行的处理程序已经关闭。您绝不会希望用户能够通过上传并请求特制文件"
"来执行任意的代码。"

msgid ""
"Django's media upload handling poses some vulnerabilities when that media is "
"served in ways that do not follow security best practices. Specifically, an "
"HTML file can be uploaded as an image if that file contains a valid PNG "
"header followed by malicious HTML. This file will pass verification of the "
"library that Django uses for :class:`~django.db.models.ImageField` image "
"processing (Pillow). When this file is subsequently displayed to a user, it "
"may be displayed as HTML depending on the type and configuration of your web "
"server."
msgstr ""
"如果媒体文件没有遵循安全性最佳惯例，Django 的媒体上传处理会产生一些漏洞。特别"
"的，如果一个 HTML 文件包含合法的 PNG 格式头部并附加一些恶意的 HTML，它是可以"
"作为一个图片文件上传的。该文件将会通过 Django 用于 :class:`~django.db.models."
"ImageField` 图片处理（Pillow）库的验证。当此文件随后被展示给用户时，它可以被"
"显示为 HTML，这取决于您的服务器类型于配置。"

msgid ""
"No bulletproof technical solution exists at the framework level to safely "
"validate all user uploaded file content, however, there are some other steps "
"you can take to mitigate these attacks:"
msgstr ""
"在框架级别上没有防护技术方案可以安全地验证所有用户上传的文件内容，但是您可以"
"采取其他步骤来减轻这些攻击："

msgid ""
"One class of attacks can be prevented by always serving user uploaded "
"content from a distinct top-level or second-level domain. This prevents any "
"exploit blocked by `same-origin policy`_ protections such as cross site "
"scripting. For example, if your site runs on ``example.com``, you would want "
"to serve uploaded content (the :setting:`MEDIA_URL` setting) from something "
"like ``usercontent-example.com``. It's *not* sufficient to serve content "
"from a subdomain like ``usercontent.example.com``."
msgstr ""
"通过一直为来自不同顶级域名或二级域名的用户提供上传内容可以防御一类的攻击。这"
"可以防止被 `same-origin policy`_ 保护机制阻止的任何攻击，比如跨站脚本攻击。例"
"如您的网站是 ``example.com``，您应当通过形如 ``usercontent-example.com`` 的方"
"式来提供上传内容服务（配置 :setting:`MEDIA_URL`）。仅仅从像 ``usercontent."
"example.com`` 这样的子域提供内容是*不够*的。"

msgid ""
"Beyond this, applications may choose to define a list of allowable file "
"extensions for user uploaded files and configure the web server to only "
"serve such files."
msgstr ""
"除此之外，应用可以选择定义一个列表来限制允许用户上传的文件的扩展名，并将 Web "
"服务器配置为仅为此类文件服务。"

msgid "Additional security topics"
msgstr "其他安全性相关主题"

msgid ""
"While Django provides good security protection out of the box, it is still "
"important to properly deploy your application and take advantage of the "
"security protection of the web server, operating system and other components."
msgstr ""
"虽然 Django 开箱即提供了良好的安全保护，但正确部署你的应用程序并利用网络服务"
"器、操作系统和其他组件的安全保护仍然很重要。"

msgid ""
"Make sure that your Python code is outside of the web server's root. This "
"will ensure that your Python code is not accidentally served as plain text "
"(or accidentally executed)."
msgstr ""
"确保你的 Python 代码是在网络服务器的根目录之外。这将确保你的 Python 代码不会"
"被意外地作为纯文本提供（或意外地执行）。"

msgid "Take care with any :ref:`user uploaded files <file-upload-security>`."
msgstr "小心一切 :ref:`用户上传的文件 <file-upload-security>`。"

msgid ""
"Django does not throttle requests to authenticate users. To protect against "
"brute-force attacks against the authentication system, you may consider "
"deploying a Django plugin or web server module to throttle these requests."
msgstr ""
"Django 不会对认证用户的请求进行节流。为了防止针对认证系统的暴力攻击，你可以考"
"虑部署一个 Django 插件或网络服务器模块来节制这些请求。"

msgid "Keep your :setting:`SECRET_KEY` a secret."
msgstr "保密 :setting:`SECRET_KEY`。"

msgid ""
"It is a good idea to limit the accessibility of your caching system and "
"database using a firewall."
msgstr "用防火墙限制缓存系统和数据库的可访问性是个好主意。"

msgid ""
"Take a look at the Open Web Application Security Project (OWASP) `Top 10 "
"list`_ which identifies some common vulnerabilities in web applications. "
"While Django has tools to address some of the issues, other issues must be "
"accounted for in the design of your project."
msgstr ""
"看一下开源 Web 应用安全计划（OWASP） `Top 10 list`_ ，它指定了网络应用程序中"
"一些常见的漏洞。尽管 Django 拥有解决某些问题的工具，但在项目设计中必须考虑其"
"他问题。"

msgid ""
"Mozilla discusses various topics regarding `web security`_. Their pages also "
"include security principles that apply to any system."
msgstr ""
"Mozilla 讨论了很多与 `web security`_ 相关的主题。他们的网页还包括适用于任何系"
"统的安全原则。"

msgid "Serializing Django objects"
msgstr "序列化 Django 对象"

msgid ""
"Django's serialization framework provides a mechanism for \"translating\" "
"Django models into other formats. Usually these other formats will be text-"
"based and used for sending Django data over a wire, but it's possible for a "
"serializer to handle any format (text-based or not)."
msgstr ""
"Django 的序列化框架提供了一种将 Django 模型“翻译”为其他格式的机制。通常，这些"
"其他格式将基于文本，并用于在网络上发送 Django 数据，但是序列化程序可以处理任"
"何格式（无论是否基于文本）。"

msgid ""
"If you just want to get some data from your tables into a serialized form, "
"you could use the :djadmin:`dumpdata` management command."
msgstr ""
"如果你只是想将表中的某些数据转换为序列化形式，你可以使用 :djadmin:`dumpdata` "
"管理命令。"

msgid "Serializing data"
msgstr "序列化数据"

msgid "At the highest level, you can serialize data like this::"
msgstr "在最高层面，你可以像这样序列化数据："

msgid ""
"The arguments to the ``serialize`` function are the format to serialize the "
"data to (see `Serialization formats`_) and a :class:`~django.db.models.query."
"QuerySet` to serialize. (Actually, the second argument can be any iterator "
"that yields Django model instances, but it'll almost always be a QuerySet)."
msgstr ""
"``serialize`` 函数的参数是数据序列化的目标格式 （查看 `序列化格式`_）和用来序"
"列化的 :class:`~django.db.models.query.QuerySet`。（实际上，第二个参数可以是"
"任何生成 Django 模型实例的迭代器，但它几乎总是一个QuerySet）。"

msgid "You can also use a serializer object directly::"
msgstr "你也可以直接使用序列化器对象："

msgid ""
"This is useful if you want to serialize data directly to a file-like object "
"(which includes an :class:`~django.http.HttpResponse`)::"
msgstr ""
"如果要将数据直接序列化到类似文件的对象（包括 :class:`~django.http."
"HttpResponse`）这将很有用："

msgid ""
"Calling :func:`~django.core.serializers.get_serializer` with an unknown :ref:"
"`format <serialization-formats>` will raise a ``django.core.serializers."
"SerializerDoesNotExist`` exception."
msgstr ""
"以未知 :ref:`格式 <serialization-formats>` 调用 :func:`~django.core."
"serializers.get_serializer` 将引发 ``django.core.serializers."
"SerializerDoesNotExist`` 异常。"

msgid "Subset of fields"
msgstr "字段子集"

msgid ""
"If you only want a subset of fields to be serialized, you can specify a "
"``fields`` argument to the serializer::"
msgstr "如果你只希望序列化字段的子集，则可以为序列化程序指定 ``fields`` 参数："

msgid ""
"In this example, only the ``name`` and ``size`` attributes of each model "
"will be serialized. The primary key is always serialized as the ``pk`` "
"element in the resulting output; it never appears in the ``fields`` part."
msgstr ""
"在此示例中，将仅序列化每个模型的 ``name`` 和 ``size`` 属性。主键总是序列化为"
"结果输出中的 ``pk`` 元素；它永远不会出现在 ``fields`` 部分。"

msgid ""
"Depending on your model, you may find that it is not possible to deserialize "
"a model that only serializes a subset of its fields. If a serialized object "
"doesn't specify all the fields that are required by a model, the "
"deserializer will not be able to save deserialized instances."
msgstr ""
"根据你的模型，你可能会发现无法反序列化一个仅序列化了其字段子集的模型。如果已"
"序列化的对象未指定模型所需的所有字段，则反序列化器将无法保存反序列化的实例。"

msgid "Inherited models"
msgstr "继承来的模型"

msgid ""
"If you have a model that is defined using an :ref:`abstract base class "
"<abstract-base-classes>`, you don't have to do anything special to serialize "
"that model. Call the serializer on the object (or objects) that you want to "
"serialize, and the output will be a complete representation of the "
"serialized object."
msgstr ""
"如果你有一个使用 :ref:`抽象基类 <abstract-base-classes>` 定义的模型，那么你不"
"必做任何特殊的事情来序列化该模型。对要序列化的一个（或多个）对象调用序列化程"
"序，输出将是序列化对象的完整表示形式。"

msgid ""
"However, if you have a model that uses :ref:`multi-table inheritance <multi-"
"table-inheritance>`, you also need to serialize all of the base classes for "
"the model. This is because only the fields that are locally defined on the "
"model will be serialized. For example, consider the following models::"
msgstr ""
"但是，如果你有一个使用 :ref:`多表继承 <multi-table-inheritance>` 的模型， 则"
"还需要序列化该模型的所有基类。这是因为只有在模型上本地定义的字段才会被序列"
"化。例如，考虑以下模型："

msgid "If you only serialize the Restaurant model::"
msgstr "如果你只序列化 Restaurant 模型："

msgid ""
"the fields on the serialized output will only contain the "
"``serves_hot_dogs`` attribute. The ``name`` attribute of the base class will "
"be ignored."
msgstr ""
"序列化输出上的字段将仅包含 ``serves_hot_dogs`` 属性。基类的 ``name`` 属性将被"
"忽略。"

msgid ""
"In order to fully serialize your ``Restaurant`` instances, you will need to "
"serialize the ``Place`` models as well::"
msgstr ""
"为了完全序列化你的 ``Restaurant`` 实例，你还需要将 ``Place`` 模型序列化："

msgid "Deserializing data"
msgstr "反序列化数据"

msgid "Deserializing data is very similar to serializing it::"
msgstr "反序列化数据与序列化数据非常相似："

msgid ""
"As you can see, the ``deserialize`` function takes the same format argument "
"as ``serialize``, a string or stream of data, and returns an iterator."
msgstr ""
"如你所见，``deserialize`` 函数与 ``serialize`` 函数采用相同的格式参数，字符串"
"或数据流，并返回一个迭代器。"

msgid ""
"However, here it gets slightly complicated. The objects returned by the "
"``deserialize`` iterator *aren't* regular Django objects. Instead, they are "
"special ``DeserializedObject`` instances that wrap a created -- but unsaved "
"-- object and any associated relationship data."
msgstr ""
"不过，这里有点复杂。``deserialize`` 迭代器返回的对象 *不是* 常规的 Django 对"
"象。相反，它们是特殊的 ``DeserializedObject`` 实例，实例封装了一个已创建 -- "
"但未保存 -- 的对象和任何相关联的数据。"

msgid "Calling ``DeserializedObject.save()`` saves the object to the database."
msgstr "调用 ``DeserializedObject.save()`` 保存对象到数据库。"

msgid ""
"If the ``pk`` attribute in the serialized data doesn't exist or is null, a "
"new instance will be saved to the database."
msgstr ""
"如果序列化数据中的 ``pk`` 属性不存在或为 null，则会将新实例保存到数据库中。"

msgid ""
"This ensures that deserializing is a non-destructive operation even if the "
"data in your serialized representation doesn't match what's currently in the "
"database. Usually, working with these ``DeserializedObject`` instances looks "
"something like::"
msgstr ""
"这可以确保反序列化是一个非破坏性操作，即使序列化表示中的数据与数据库中当前的"
"数据不匹配。通常，使用这些 ``DeserializedObject`` 实例看起来像："

msgid ""
"In other words, the usual use is to examine the deserialized objects to make "
"sure that they are \"appropriate\" for saving before doing so. If you trust "
"your data source you can instead save the object directly and move on."
msgstr ""
"换句话说，通常的用途是检查反序列化的对象，以确保它们“适合”保存。如果你信任数"
"据源，则可以直接保存对象并继续前进。"

msgid ""
"The Django object itself can be inspected as ``deserialized_object.object``. "
"If fields in the serialized data do not exist on a model, a "
"``DeserializationError`` will be raised unless the ``ignorenonexistent`` "
"argument is passed in as ``True``::"
msgstr ""
"Django 对象本身可以被像 ``deserialized_object.object`` 一样检查。如果模型中不"
"存在序列化字段，将引发 ``DeserializationError`` 错误，除非将 "
"``ignorenonexistent`` 参数为 ``True`` 传入："

msgid "Serialization formats"
msgstr "序列化格式"

msgid ""
"Django supports a number of serialization formats, some of which require you "
"to install third-party Python modules:"
msgstr "Django 支持多种序列化格式，其中一些格式要求你安装第三方 Python 模块："

msgid "Identifier"
msgstr "标识符"

msgid "Information"
msgstr "信息"

msgid "``xml``"
msgstr "``xml``"

msgid "Serializes to and from a simple XML dialect."
msgstr "序列化和反序列化为一种简单地 XML 方言。"

msgid "``json``"
msgstr "``json``"

msgid "Serializes to and from JSON_."
msgstr "序列化和反序列化为 JSON_。"

msgid "``jsonl``"
msgstr "``jsonl``"

msgid "Serializes to and from JSONL_."
msgstr ""

msgid "``yaml``"
msgstr "``yaml``"

msgid ""
"Serializes to YAML (YAML Ain't a Markup Language). This serializer is only "
"available if PyYAML_ is installed."
msgstr ""
"序列化为 YAML（YAML 不是标记语言）。此序列化器仅在 PyYAML_ 安装后可用。"

msgid "XML"
msgstr "XML"

msgid "The basic XML serialization format looks like this::"
msgstr "基本的 XML 序列化格式如下所示："

msgid ""
"The whole collection of objects that is either serialized or deserialized is "
"represented by a ``<django-objects>``-tag which contains multiple "
"``<object>``-elements. Each such object has two attributes: \"pk\" and "
"\"model\", the latter being represented by the name of the app (\"sessions"
"\") and the lowercase name of the model (\"session\") separated by a dot."
msgstr ""
"序列化或反序列化的整个对象集合由一个包含多个 ``<object>`` - 元素的 ``<django-"
"objects>`` - 标签标识。每个这样的对象都有两个属性：“pk”和“model”，后者由用点"
"号分隔的 app 名称（“sessions”）和模型的小写名称（“session”）来代替。"

msgid ""
"Each field of the object is serialized as a ``<field>``-element sporting the "
"fields \"type\" and \"name\". The text content of the element represents the "
"value that should be stored."
msgstr ""
"对象的每个字段都序列化为一个具有“type”和“name”的 ``<field>``- 元素 。元素的文"
"本内容表示应该存储的值。"

msgid ""
"Foreign keys and other relational fields are treated a little bit "
"differently::"
msgstr "外键和其他关系字段的处理方式稍有不同："

msgid ""
"In this example we specify that the ``auth.Permission`` object with the PK "
"27 has a foreign key to the ``contenttypes.ContentType`` instance with the "
"PK 9."
msgstr ""
"在本例中，我们指定具有 PK 27 的 ``auth.Permission`` 对象有一个指向 PK 9 的 "
"``contenttypes.ContentType`` 实例的外键。"

msgid ""
"ManyToMany-relations are exported for the model that binds them. For "
"instance, the ``auth.User`` model has such a relation to the ``auth."
"Permission`` model::"
msgstr ""
"多对多关系是为绑定它们的模型导出的。例如，``auth.User`` 模型与 ``auth."
"Permission`` 模型有这样的关系："

msgid ""
"This example links the given user with the permission models with PKs 46 and "
"47."
msgstr "此示例将给定用户与 PK 46 和 47 的权限模型链接起来。"

msgid "Control characters"
msgstr "控制字符"

msgid ""
"If the content to be serialized contains control characters that are not "
"accepted in the XML 1.0 standard, the serialization will fail with a :exc:"
"`ValueError` exception. Read also the W3C's explanation of `HTML, XHTML, XML "
"and Control Codes <https://www.w3.org/International/questions/qa-controls>`_."
msgstr ""
"如果要序列化的内容包含 XML 1.0 标准不接受的控制字符，则序列化将失败，并出现 :"
"exc:`ValueError` 异常。另请阅读 W3C 对 `HTML, XHTML, XML and Control Codes "
"<https://www.w3.org/International/questions/qa-controls>`_ 的解释。"

msgid "JSON"
msgstr "JSON"

msgid ""
"When staying with the same example data as before it would be serialized as "
"JSON in the following way::"
msgstr "当与之前相同的示例数据保持不变时，它将按以下方式序列化为 JSON："

msgid ""
"The formatting here is a bit simpler than with XML. The whole collection is "
"just represented as an array and the objects are represented by JSON objects "
"with three properties: \"pk\", \"model\" and \"fields\". \"fields\" is again "
"an object containing each field's name and value as property and property-"
"value respectively."
msgstr ""
"这里的格式比 XML 简单一些。整个集合只是表示为一个数组，对象由具有三个属性的 "
"JSON 对象表示：“pk”，“model”和“fields”。“fields”又是一个对象，其中分别包含每"
"个字段的名称和值作为属性和属性值。"

msgid ""
"Foreign keys have the PK of the linked object as property value. ManyToMany-"
"relations are serialized for the model that defines them and are represented "
"as a list of PKs."
msgstr ""
"外键将链接对象的 PK 作为属性值。多对多关系对于定义它们的模型进行了序列化，并"
"表示为 PK 列表。"

msgid ""
"Be aware that not all Django output can be passed unmodified to :mod:`json`. "
"For example, if you have some custom type in an object to be serialized, "
"you'll have to write a custom :mod:`json` encoder for it. Something like "
"this will work::"
msgstr ""
"请注意，并非所有的Django输出都可以不经修改地传递到 :mod:`json`。例如，如果要"
"序列化对象中的某个自定义类型，则必须为其编写一个自定义 :mod:`json` 编码器。这"
"样的方法会奏效的："

msgid ""
"You can then pass ``cls=LazyEncoder`` to the ``serializers.serialize()`` "
"function::"
msgstr "你可以将 ``cls=LazyEncoder`` 传入 ``serializers.serialize()`` 函数："

msgid ""
"Also note that GeoDjango provides a :doc:`customized GeoJSON serializer </"
"ref/contrib/gis/serializers>`."
msgstr ""
"还要注意 GeoDjango 提供了一个 :doc:`定制的 GeoJSON 序列化器 </ref/contrib/"
"gis/serializers>`."

msgid "``DjangoJSONEncoder``"
msgstr "``DjangoJSONEncoder``"

msgid ""
"The JSON serializer uses ``DjangoJSONEncoder`` for encoding. A subclass of :"
"class:`~json.JSONEncoder`, it handles these additional types:"
msgstr ""
"JSON 序列化器使用 ``DjangoJSONEncoder`` 进行编码。作为 :class:`~json."
"JSONEncoder` 的子类，它可以处理这些附加类型："

msgid ":class:`~datetime.datetime`"
msgstr ":class:`~datetime.datetime`"

msgid ""
"A string of the form ``YYYY-MM-DDTHH:mm:ss.sssZ`` or ``YYYY-MM-DDTHH:mm:ss."
"sss+HH:MM`` as defined in `ECMA-262`_."
msgstr ""
"格式为 ``YYYY-MM-DDTHH:mm:ss.sssZ`` 或 ``YYYY-MM-DDTHH:mm:ss.sss+HH:MM`` 的字"
"符串，如 `ECMA-262`_ 中定义。"

msgid ":class:`~datetime.date`"
msgstr ":class:`~datetime.date`"

msgid "A string of the form ``YYYY-MM-DD`` as defined in `ECMA-262`_."
msgstr "格式为 ``YYYY-MM-DD`` 的字符串，如 `ECMA-262`_ 中定义。"

msgid ":class:`~datetime.time`"
msgstr ":class:`~datetime.time`"

msgid "A string of the form ``HH:MM:ss.sss`` as defined in `ECMA-262`_."
msgstr "格式为 ``HH:MM:ss.sss`` 的字符串，如 `ECMA-262`_ 中定义。"

msgid ":class:`~datetime.timedelta`"
msgstr ":class:`~datetime.timedelta`"

msgid ""
"A string representing a duration as defined in ISO-8601. For example, "
"``timedelta(days=1, hours=2, seconds=3.4)`` is represented as "
"``'P1DT02H00M03.400000S'``."
msgstr ""
"代表 ISO-8601 中定义的持续时间的字符串。例如，``timedelta(days=1, hours=2, "
"seconds=3.4)`` 代表 ``'P1DT02H00M03.400000S'``。"

msgid ""
":class:`~decimal.Decimal`, ``Promise`` (``django.utils.functional.lazy()`` "
"objects), :class:`~uuid.UUID`"
msgstr ""
":class:`~decimal.Decimal`，``Promise`` （ ``django.utils.functional.lazy()`` "
"对象），:class:`~uuid.UUID`"

msgid "A string representation of the object."
msgstr "对象的字符串表示形式。"

msgid "JSONL"
msgstr "JSONL"

msgid ""
"*JSONL* stands for *JSON Lines*. With this format, objects are separated by "
"new lines, and each line contains a valid JSON object. JSONL serialized data "
"looks like this::"
msgstr ""

msgid ""
"JSONL can be useful for populating large databases, since the data can be "
"processed line by line, rather than being loaded into memory all at once."
msgstr ""

msgid "YAML"
msgstr "YAML"

msgid ""
"YAML serialization looks quite similar to JSON. The object list is "
"serialized as a sequence mappings with the keys \"pk\", \"model\" and "
"\"fields\". Each field is again a mapping with the key being name of the "
"field and the value the value::"
msgstr ""
"YAML 序列化看起来与 JSON 非常相似。对象列表通过映射"
"键“pk”，“model”和“fields”为序列进行序列化。每个字段还是一个映射，键为字段名"
"称，值为字段值："

msgid "Referential fields are again represented by the PK or sequence of PKs."
msgstr "引用字段再次由 PK 或 PK 序列表示。"

msgid "Natural keys"
msgstr "自然键"

msgid ""
"The default serialization strategy for foreign keys and many-to-many "
"relations is to serialize the value of the primary key(s) of the objects in "
"the relation. This strategy works well for most objects, but it can cause "
"difficulty in some circumstances."
msgstr ""
"外键和多对多关系的默认序列化策略是序列化在关系中对象主键的值。这种策略对大多"
"数对象都有效，但在某些情况下可能会造成困难。"

msgid ""
"Consider the case of a list of objects that have a foreign key referencing :"
"class:`~django.contrib.contenttypes.models.ContentType`. If you're going to "
"serialize an object that refers to a content type, then you need to have a "
"way to refer to that content type to begin with. Since ``ContentType`` "
"objects are automatically created by Django during the database "
"synchronization process, the primary key of a given content type isn't easy "
"to predict; it will depend on how and when :djadmin:`migrate` was executed. "
"This is true for all models which automatically generate objects, notably "
"including :class:`~django.contrib.auth.models.Permission`, :class:`~django."
"contrib.auth.models.Group`, and :class:`~django.contrib.auth.models.User`."
msgstr ""
"考虑一个对象列表，这些对象的外键引用 :class:`~django.contrib.contenttypes."
"models.ContentType`。如果要序列化引用内容类型的对象，那么首先需要有一种引用该"
"内容类型的方法。由于 ``ContentType`` 对象是由 Django 在数据库同步过程中自动创"
"建的，所以给定内容类型的主键不容易预测；这将取决于 :djadmin:`migrate` 的执行"
"方式和时间。对于自动生成对象的所有模型都是如此，特别是包括 :class:`~django."
"contrib.auth.models.Permission`，:class:`~django.contrib.auth.models.Group`，"
"和 :class:`~django.contrib.auth.models.User`。"

msgid ""
"You should never include automatically generated objects in a fixture or "
"other serialized data. By chance, the primary keys in the fixture may match "
"those in the database and loading the fixture will have no effect. In the "
"more likely case that they don't match, the fixture loading will fail with "
"an :class:`~django.db.IntegrityError`."
msgstr ""
"永远不要在辅助工具和其它序列化数据中包含自动生成的对象。偶尔，辅助工具中加载"
"的主键可能与数据库中的相匹配而加载的辅助工具可能没有起到任何作用。更可能的情"
"况是它们并不匹配，辅助工具将加载失败，并出现 :class:`~django.db."
"IntegrityError` 错误。"

msgid ""
"There is also the matter of convenience. An integer id isn't always the most "
"convenient way to refer to an object; sometimes, a more natural reference "
"would be helpful."
msgstr ""
"还有一个便捷性的问题。整数 id 并不总是引用对象的最方便方式；有时，更自然的引"
"用会有所帮助。"

msgid ""
"It is for these reasons that Django provides *natural keys*. A natural key "
"is a tuple of values that can be used to uniquely identify an object "
"instance without using the primary key value."
msgstr ""
"正是由于这些原因 Django 提供了 *自然键*。自然键是一组值，可以用来唯一标识对象"
"实例，而不使用主键值。"

msgid "Deserialization of natural keys"
msgstr "自然键反序列化"

msgid "Consider the following two models::"
msgstr "考虑以下两种模型："

msgid ""
"Ordinarily, serialized data for ``Book`` would use an integer to refer to "
"the author. For example, in JSON, a Book might be serialized as::"
msgstr ""
"通常，序列化 ``Book`` 会使用一个整数来指代作者。例如，在 JSON 中，一个 Book "
"可以序列化为："

msgid ""
"This isn't a particularly natural way to refer to an author. It requires "
"that you know the primary key value for the author; it also requires that "
"this primary key value is stable and predictable."
msgstr ""
"这不是一个特别自然的方式来指代作者。它要求你知道作者的主键值；它还要求这个主"
"键值是稳定的和可预测的。"

msgid ""
"However, if we add natural key handling to Person, the fixture becomes much "
"more humane. To add natural key handling, you define a default Manager for "
"Person with a ``get_by_natural_key()`` method. In the case of a Person, a "
"good natural key might be the pair of first and last name::"
msgstr ""
"然而，如果我们向 Person 添加自然键处理，则辅助工具将变得更加人性化。要添加自"
"然键处理， 你可以为 Person 定义一个有着 ``get_by_natural_key()`` 方法的默认 "
"Manager。对于 Person 来说，一个好的自然键可能是姓名："

msgid "Now books can use that natural key to refer to ``Person`` objects::"
msgstr "现在书籍可以使用自然键来指代 ``Person`` 对象："

msgid ""
"When you try to load this serialized data, Django will use the "
"``get_by_natural_key()`` method to resolve ``[\"Douglas\", \"Adams\"]`` into "
"the primary key of an actual ``Person`` object."
msgstr ""
"当你试图加载此序列化数据时，Django 将使用 ``get_by_natural_key()`` 方法将 "
"``[\"Douglas\", \"Adams\"]`` 解析为 ``Person`` 对象实际的主键。"

msgid ""
"Whatever fields you use for a natural key must be able to uniquely identify "
"an object. This will usually mean that your model will have a uniqueness "
"clause (either unique=True on a single field, or ``unique_together`` over "
"multiple fields) for the field or fields in your natural key. However, "
"uniqueness doesn't need to be enforced at the database level. If you are "
"certain that a set of fields will be effectively unique, you can still use "
"those fields as a natural key."
msgstr ""
"无论使用什么字段作为自然键，都必须能够唯一地标识对象。这通常意味着你的模型将"
"为你的自然键中的一个或多个字段使用unique子句 （unique=True 在单个字段上，或 "
"``unique_together`` 在多个字段上）。但是，不需要在数据库级别强制执行唯一性。"
"如果你确定一组字段实际上是唯一的，那么仍然可以将这些字段用作自然键。"

msgid ""
"Deserialization of objects with no primary key will always check whether the "
"model's manager has a ``get_by_natural_key()`` method and if so, use it to "
"populate the deserialized object's primary key."
msgstr ""
"对没有主键的对象的反序列化将始终检查模型的管理器是否具有 "
"``get_by_natural_key()`` 方法，如果有，则使用它填充反序列化对象的主键。"

msgid "Serialization of natural keys"
msgstr "自然键序列化"

msgid ""
"So how do you get Django to emit a natural key when serializing an object? "
"Firstly, you need to add another method -- this time to the model itself::"
msgstr ""
"那么如何在序列化对象时让 Django 发出自然键？首先，你需要添加另一种方法，这一"
"次是向模型本身添加："

msgid ""
"That method should always return a natural key tuple -- in this example, "
"``(first name, last name)``. Then, when you call ``serializers."
"serialize()``, you provide ``use_natural_foreign_keys=True`` or "
"``use_natural_primary_keys=True`` arguments::"
msgstr ""
"该方法应该始终返回一个自然键元组——在本例中为 ``(first name, last name)``。接"
"着当你调用 ``serializers.serialize()`` 时，提供 "
"``use_natural_foreign_keys=True`` 或 ``use_natural_primary_keys=True`` 参数："

msgid ""
"When ``use_natural_foreign_keys=True`` is specified, Django will use the "
"``natural_key()`` method to serialize any foreign key reference to objects "
"of the type that defines the method."
msgstr ""
"当指定 ``use_natural_foreign_keys=True`` 时，Django 将使用 ``natural_key()`` "
"方法将任何外键引用序列化为定义该方法的类型的对象。"

msgid ""
"When ``use_natural_primary_keys=True`` is specified, Django will not provide "
"the primary key in the serialized data of this object since it can be "
"calculated during deserialization::"
msgstr ""
"当指定 ``use_natural_primary_keys=True`` 时，Django 不会在该对象的序列化数据"
"中提供主键，因为它可以在反序列化期间进行计算："

msgid ""
"This can be useful when you need to load serialized data into an existing "
"database and you cannot guarantee that the serialized primary key value is "
"not already in use, and do not need to ensure that deserialized objects "
"retain the same primary keys."
msgstr ""
"当需要将序列化数据加载到现有数据库中，并且无法保证序列化的主键值尚未使用，并"
"且不需要确保反序列化对象保留相同的主键时，这一点非常有用。"

msgid ""
"If you are using :djadmin:`dumpdata` to generate serialized data, use the :"
"option:`dumpdata --natural-foreign` and :option:`dumpdata --natural-primary` "
"command line flags to generate natural keys."
msgstr ""
"如果你使用 :djadmin:`dumpdata` 生成序列化数据，使用 :option:`dumpdata --"
"natural-foreign` 和 :option:`dumpdata --natural-primary` 命令行标志生成自然"
"键。"

msgid ""
"You don't need to define both ``natural_key()`` and "
"``get_by_natural_key()``. If you don't want Django to output natural keys "
"during serialization, but you want to retain the ability to load natural "
"keys, then you can opt to not implement the ``natural_key()`` method."
msgstr ""
"你不需要同时定义 ``natural_key()`` 和 ``get_by_natural_key()``。如果你不想要 "
"Django 在序列化期间输出自然键，但希望保留加载自然键的能力，那你可以选择不实"
"现 ``natural_key()`` 方法。"

msgid ""
"Conversely, if (for some strange reason) you want Django to output natural "
"keys during serialization, but *not* be able to load those key values, just "
"don't define the ``get_by_natural_key()`` method."
msgstr ""
"相反，如果（出于某些奇怪的原因）你想要 Django 在序列化时输出自然键，但是 *不"
"* 加载那些键值，只需要不定义 ``get_by_natural_key()`` 方法。"

msgid "Natural keys and forward references"
msgstr "自然键和前向引用"

msgid ""
"Sometimes when you use :ref:`natural foreign keys <topics-serialization-"
"natural-keys>` you'll need to deserialize data where an object has a foreign "
"key referencing another object that hasn't yet been deserialized. This is "
"called a \"forward reference\"."
msgstr ""
"有时当你使用 :ref:`自然外键 <topics-serialization-natural-keys>` 时，您需要反"
"序列化数据，其中一个对象的外键引用了另一个尚未反序列化的对象。这称之为“前向引"
"用”。"

msgid "For instance, suppose you have the following objects in your fixture::"
msgstr "例如，假设辅助工具中有以下对象："

msgid ""
"In order to handle this situation, you need to pass "
"``handle_forward_references=True`` to ``serializers.deserialize()``. This "
"will set the ``deferred_fields`` attribute on the ``DeserializedObject`` "
"instances. You'll need to keep track of ``DeserializedObject`` instances "
"where this attribute isn't ``None`` and later call "
"``save_deferred_fields()`` on them."
msgstr ""
"为了处理这种情况，你需要将 ``handle_forward_references=True`` 传入 "
"``serializers.deserialize()``。这将在 ``DeserializedObject`` 实例上设置 "
"``deferred_fields`` 属性。你需要保持追踪该属性不是 ``None`` 的 "
"``DeserializedObject`` 实例并在之后调用它们的 ``save_deferred_fields()``。"

msgid "Typical usage looks like this::"
msgstr "典型用法如下："

msgid ""
"For this to work, the ``ForeignKey`` on the referencing model must have "
"``null=True``."
msgstr "要使其工作，引用模型上的 ``ForeignKey`` 必须具有 ``null=True``。"

msgid "Dependencies during serialization"
msgstr "序列化期间的依赖项"

msgid ""
"It's often possible to avoid explicitly having to handle forward references "
"by taking care with the ordering of objects within a fixture."
msgstr "通过注意辅助工具中中对象的顺序，通常可以避免显式地处理前向引用。"

msgid ""
"To help with this, calls to :djadmin:`dumpdata` that use the :option:"
"`dumpdata --natural-foreign` option will serialize any model with a "
"``natural_key()`` method before serializing standard primary key objects."
msgstr ""
"为了帮助实现这一点，在序列化标准主键对象之前，使用 :option:`dumpdata --"
"natural-foreign` 选项对 :djadmin:`dumpdata`  的调用将使用 ``natural_key()`` "
"方法对任何模型进行序列化。"

msgid ""
"However, this may not always be enough. If your natural key refers to "
"another object (by using a foreign key or natural key to another object as "
"part of a natural key), then you need to be able to ensure that the objects "
"on which a natural key depends occur in the serialized data before the "
"natural key requires them."
msgstr ""
"但是，这可能并不总是足够的。如果您的自然键引用了另一个对象（通过使用外键或另"
"一个对象的自然键作为自然键的一部分），那么你需要确保自然键所依赖的对象出现在"
"序列化数据中在自然键要求它们之前。"

msgid ""
"To control this ordering, you can define dependencies on your "
"``natural_key()`` methods. You do this by setting a ``dependencies`` "
"attribute on the ``natural_key()`` method itself."
msgstr ""
"要控制此顺序，你可以在 ``natural_key()`` 方法中定义依赖。为此可以在  "
"``natural_key()`` 方法本身上设置一个 ``dependencies`` 属性。"

msgid ""
"For example, let's add a natural key to the ``Book`` model from the example "
"above::"
msgstr "例如，让我们为上面示例中的 ``Book`` 模型添加一个自然键："

msgid ""
"The natural key for a ``Book`` is a combination of its name and its author. "
"This means that ``Person`` must be serialized before ``Book``. To define "
"this dependency, we add one extra line::"
msgstr ""
"``Book`` 的自然键是书名和作者的组合。这意味着 ``Person`` 必须在 ``Book`` 之前"
"序列化。为了定义这个依赖，我们增加一行："

msgid ""
"This definition ensures that all ``Person`` objects are serialized before "
"any ``Book`` objects. In turn, any object referencing ``Book`` will be "
"serialized after both ``Person`` and ``Book`` have been serialized."
msgstr ""
"这个定义确保了所有 ``Person`` 对象在任何 ``Book`` 对象之前序列化。反过来，任"
"何对象引用了 ``Book`` 都将在 ``Person`` 和 ``Book`` 被序列化完后再序列化。"

msgid "Django settings"
msgstr "Django 配置"

msgid ""
"A Django settings file contains all the configuration of your Django "
"installation. This document explains how settings work and which settings "
"are available."
msgstr ""
"Django 的配置文件包含 Django 应用的所有配置项。本文档介绍配置是如何生效的，以"
"及哪些设置项是可配置的。"

msgid "The basics"
msgstr "基础"

msgid "A settings file is just a Python module with module-level variables."
msgstr "配置文件只是一个使用模块级变量的一个 Python 模块。"

msgid "Here are a couple of example settings::"
msgstr "一组配置例子::"

msgid ""
"If you set :setting:`DEBUG` to ``False``, you also need to properly set the :"
"setting:`ALLOWED_HOSTS` setting."
msgstr ""
"如果你将 :setting:`DEBUG` 设置为 ``False``，同时你需要正确的设置 :setting:"
"`ALLOWED_HOSTS`。"

msgid "Because a settings file is a Python module, the following apply:"
msgstr "因为配置文件是一个 Python 模块，所以要注意以下几项:"

msgid "It doesn't allow for Python syntax errors."
msgstr "不能有 Python 语法错误"

msgid ""
"It can assign settings dynamically using normal Python syntax. For example::"
msgstr "可以用 Python 语法实现动态配置，例如::"

msgid "It can import values from other settings files."
msgstr "可以从其他配置文件中引入变量"

msgid "Designating the settings"
msgstr "指定配置文件"

msgid ""
"When you use Django, you have to tell it which settings you're using. Do "
"this by using an environment variable, :envvar:`DJANGO_SETTINGS_MODULE`."
msgstr ""
"当你使用 Django 的时候，你必须告诉它你正在使用哪些设置。通过使用环境变量 :"
"envvar:`DJANGO_SETTINGS_MODULE` 来实现。"

msgid ""
"The value of :envvar:`DJANGO_SETTINGS_MODULE` should be in Python path "
"syntax, e.g. ``mysite.settings``. Note that the settings module should be on "
"the Python `import search path`_."
msgstr ""
":envvar:`DJANGO_SETTINGS_MODULE` 的值是一个符合 Python 语法的路径，例如 "
"``mysite.settings``。要注意配置模块应位于 Python 的 `import 搜索路径`_ 中。"

msgid "The ``django-admin`` utility"
msgstr "``django-admin`` 工具"

msgid ""
"When using :doc:`django-admin </ref/django-admin>`, you can either set the "
"environment variable once, or explicitly pass in the settings module each "
"time you run the utility."
msgstr ""
"使用 :doc:`django-admin </ref/django-admin>` 时，你可以一次性设定环境变量，也"
"可以在运行此工具时，显式地传入配置模块。"

msgid "Example (Unix Bash shell)::"
msgstr "例子（Unix Bash shell）::"

msgid "Example (Windows shell)::"
msgstr "例子（Windows shell）::"

msgid ""
"Use the ``--settings`` command-line argument to specify the settings "
"manually::"
msgstr "使用 ``--settings`` 命令行参数指定配置模块路径::"

msgid "On the server (``mod_wsgi``)"
msgstr "服务器端 (``mode_wsgi``)"

msgid ""
"In your live server environment, you'll need to tell your WSGI application "
"what settings file to use. Do that with ``os.environ``::"
msgstr ""
"在服务器环境下，要通知WSGI应用当前使用的是哪个配置文件，用到 ``os.environ``::"

msgid ""
"Read the :doc:`Django mod_wsgi documentation </howto/deployment/wsgi/"
"modwsgi>` for more information and other common elements to a Django WSGI "
"application."
msgstr ""
"阅读 :doc:`Django mod_wsgi 文档 </howto/deployment/wsgi/modwsgi>` 了解更多关"
"于 Django WSGI 应用的信息和常见设置。"

msgid "Default settings"
msgstr "默认配置"

msgid ""
"A Django settings file doesn't have to define any settings if it doesn't "
"need to. Each setting has a sensible default value. These defaults live in "
"the module :file:`django/conf/global_settings.py`."
msgstr ""
"在无需配置的情况下，Django配置文件没必要定义任何配置项。因为每个配置项都有一"
"个明确的默认值。默认值都保存在模块 :file:`django/conf/global_settings.py` "
"中。"

msgid "Here's the algorithm Django uses in compiling settings:"
msgstr "Django按如下算法编译配置模块:"

msgid "Load settings from ``global_settings.py``."
msgstr "从 ``global_settings.py`` 中加载配置项。"

msgid ""
"Load settings from the specified settings file, overriding the global "
"settings as necessary."
msgstr "从指定的配置文件中加载配置项，覆盖对应的全局配置项。"

msgid ""
"Note that a settings file should *not* import from ``global_settings``, "
"because that's redundant."
msgstr ""
"注意: 配置文件中不要再重复引用 ``global_settings``，因为这样做是多余的。"

msgid "Seeing which settings you've changed"
msgstr "查看你已经更改了哪个配置项"

msgid ""
"The command ``python manage.py diffsettings`` displays differences between "
"the current settings file and Django's default settings."
msgstr ""
"命令 ``python manage.py diffsettings`` 显示当前配置文件与 Django 默认配置的差"
"异。"

msgid "For more, see the :djadmin:`diffsettings` documentation."
msgstr "想了解更多, 可以查看 :djadmin:`diffsettings` 文档."

msgid "Using settings in Python code"
msgstr "在 Python 代码中使用 settings"

msgid ""
"In your Django apps, use settings by importing the object ``django.conf."
"settings``. Example::"
msgstr "在具体的Django应用中, 通过引入 ``django.conf.settings`` 使用配置, 例::"

msgid ""
"Note that ``django.conf.settings`` isn't a module -- it's an object. So "
"importing individual settings is not possible::"
msgstr ""
"注意 ``django.conf.settings`` 并不是一个模块！-- 而是一个对象！所以引入某个单"
"独的设置项是不可能的::"

msgid ""
"Also note that your code should *not* import from either ``global_settings`` "
"or your own settings file. ``django.conf.settings`` abstracts the concepts "
"of default settings and site-specific settings; it presents a single "
"interface. It also decouples the code that uses settings from the location "
"of your settings."
msgstr ""
"还要注意 *不应该* 直接引入 ``global_settings`` 和你自己的配置文件。 ``django."
"conf.settings`` 整合了默认配置和网站指定配置，从而只提供一个接口读取配置。它"
"也解耦了使用自定义配置文件的代码。"

msgid "Altering settings at runtime"
msgstr "运行时更改设置"

msgid ""
"You shouldn't alter settings in your applications at runtime. For example, "
"don't do this in a view::"
msgstr "不建议在运行时更改设置. 比如, 不要在view中这样用::"

msgid "The only place you should assign to settings is in a settings file."
msgstr "应该只在 settings 文件中更改设置。"

msgid "Security"
msgstr "安全"

msgid ""
"Because a settings file contains sensitive information, such as the database "
"password, you should make every attempt to limit access to it. For example, "
"change its file permissions so that only you and your web server's user can "
"read it. This is especially important in a shared-hosting environment."
msgstr ""

msgid "Available settings"
msgstr "可用的配置项"

msgid ""
"For a full list of available settings, see the :doc:`settings reference </"
"ref/settings>`."
msgstr "查看 :doc:`settings 参考 </ref/settings>` 了解完整的配置项列表。"

msgid "Creating your own settings"
msgstr "创建你自己的配置文件"

msgid ""
"There's nothing stopping you from creating your own settings, for your own "
"Django apps, but follow these guidelines:"
msgstr ""
"没有什么可以阻止你为你的的 Django 应用创建自己的配置，但请遵循以下原则："

msgid "Setting names must be all uppercase."
msgstr "所有配置项名称都应大写。"

msgid "Don't reinvent an already-existing setting."
msgstr "不要重新设置已存在的配置项。"

msgid ""
"For settings that are sequences, Django itself uses lists, but this is only "
"a convention."
msgstr "由于配置文件是序列化的，Django 使用列表，但仅是约定俗成。"

msgid "Using settings without setting :envvar:`DJANGO_SETTINGS_MODULE`"
msgstr "不设置 :envvar:`DJANGO_SETTINGS_MODULE` 时使用配置"

msgid ""
"In some cases, you might want to bypass the :envvar:`DJANGO_SETTINGS_MODULE` "
"environment variable. For example, if you're using the template system by "
"itself, you likely don't want to have to set up an environment variable "
"pointing to a settings module."
msgstr ""
"在某些情况下，你可能希望绕过：:envvar:`DJANGO_SETTINGS_MODULE` 环境变量。例"
"如，如果你单独使用模板系统，则可能不需要设置指向配置模块的环境变量。"

msgid ""
"In these cases, you can configure Django's settings manually. Do this by "
"calling:"
msgstr "在这种情况下，可以手动设定 Django 的配置项。要用到下面这个方法:"

msgid ""
"Pass ``configure()`` as many keyword arguments as you'd like, with each "
"keyword argument representing a setting and its value. Each argument name "
"should be all uppercase, with the same name as the settings described above. "
"If a particular setting is not passed to ``configure()`` and is needed at "
"some later point, Django will use the default setting value."
msgstr ""
"通过 ``configure()`` 可以设置任何配置项，每个参数对应一个值。参数名称必须大"
"写，而且参数名必须是真实存在。没有在 ``configure()`` 中出现的设置项在随后用到"
"时，仍会使用默认值。"

msgid ""
"Configuring Django in this fashion is mostly necessary -- and, indeed, "
"recommended -- when you're using a piece of the framework inside a larger "
"application."
msgstr ""
"如果你并不想使用整个框架，仅仅是其中一小部分时，如上述这般配置 Django 是非常"
"必要的。事实上，我们建议您这样做。"

msgid ""
"Consequently, when configured via ``settings.configure()``, Django will not "
"make any modifications to the process environment variables (see the "
"documentation of :setting:`TIME_ZONE` for why this would normally occur). "
"It's assumed that you're already in full control of your environment in "
"these cases."
msgstr ""
"因此，通过 ``settings.configure()`` 配置 Django 时，并不会对当前进程的环境变"
"量做任何修改。（可以查看 :setting:`TIME_ZONE` 了解为什么要这么做）。这意味着"
"在上述情况下你仍然完全掌控着当前环境。"

msgid "Custom default settings"
msgstr "定制默认配置项"

msgid ""
"If you'd like default values to come from somewhere other than ``django.conf."
"global_settings``, you can pass in a module or class that provides the "
"default settings as the ``default_settings`` argument (or as the first "
"positional argument) in the call to ``configure()``."
msgstr ""
"如果你实在不想使用 ``django.conf.global_settings``，而想自定义配置默认值，你"
"可以在调用 ``configure()`` 时使用 ``default_settings`` 参数（或是默认做为第一"
"个参数传入）。该参数是一个提供默认值的模块或是类。"

msgid ""
"In this example, default settings are taken from ``myapp_defaults``, and "
"the :setting:`DEBUG` setting is set to ``True``, regardless of its value in "
"``myapp_defaults``::"
msgstr ""
"在下面这个例子中，由 ``myapp_defaults`` 提供默认值，并令 :setting:`DEBUG` 被"
"置为 ``True`` 而不是从 ``myapp_defaults`` 中获取::"

msgid ""
"The following example, which uses ``myapp_defaults`` as a positional "
"argument, is equivalent::"
msgstr ""
"接下来例子使用 ``myapp_defaults`` 做为一个位置参数，这和上面的效果是等同的::"

msgid ""
"Normally, you will not need to override the defaults in this fashion. The "
"Django defaults are sufficiently tame that you can safely use them. Be aware "
"that if you do pass in a new default module, it entirely *replaces* the "
"Django defaults, so you must specify a value for every possible setting that "
"might be used in that code you are importing. Check in ``django.conf."
"settings.global_settings`` for the full list."
msgstr ""
"一般来说，没必要自行设置默认值。Django 的默认设置是比较宽松的，你可以放心地使"
"用。要注意的是，如果你传入了新的默认模块，那它就会完全 *替换* Django 本身的默"
"认设置。因此，你必须为接下来可能会用到的所有设置项都重新指定默认值。查看 "
"``django.conf.settings.global_settings`` 了解全部默认值。"

msgid "Either ``configure()`` or :envvar:`DJANGO_SETTINGS_MODULE` is required"
msgstr "``configure()`` 或 :envvar:`DJANGO_SETTINGS_MODULE` 二者必用其一"

msgid ""
"If you're not setting the :envvar:`DJANGO_SETTINGS_MODULE` environment "
"variable, you *must* call ``configure()`` at some point before using any "
"code that reads settings."
msgstr ""
"如果你没有设置  :envvar:`DJANGO_SETTINGS_MODULE` 环境变量，就 *必须* 在运行读"
"取配置项的代码之前调用 ``configure()``。"

msgid ""
"If you don't set :envvar:`DJANGO_SETTINGS_MODULE` and don't call "
"``configure()``, Django will raise an ``ImportError`` exception the first "
"time a setting is accessed."
msgstr ""
"如果你没有设置 :envvar:`DJANGO_SETTINGS_MODULE` 也没有调用 ``configure()``，"
"那么 Django 会在第一次访问配置项时抛出 ``ImportError`` 异常。"

msgid ""
"If you set :envvar:`DJANGO_SETTINGS_MODULE`, access settings values somehow, "
"*then* call ``configure()``, Django will raise a ``RuntimeError`` indicating "
"that settings have already been configured. There is a property for this "
"purpose:"
msgstr ""
"如果设置了 :envvar:`DJANGO_SETTINGS_MODULE`，以某种方式访问配置的值，*再* 调"
"用 ``configure()`` 的话，Django 将会抛出一个 ``RuntimeError`` 异常，表明已经"
"设置了配置。"

msgid ""
"Also, it's an error to call ``configure()`` more than once, or to call "
"``configure()`` after any setting has been accessed."
msgstr ""
"重复调用 ``configure()`` 或是在访问任何一个配置项后再调用 ``configure()``，也"
"会引起错误。"

msgid ""
"It boils down to this: Use exactly one of either ``configure()`` or :envvar:"
"`DJANGO_SETTINGS_MODULE`. Not both, and not neither."
msgstr ""
"这意味着：确保要使用 ``configure()`` 或 :envvar:`DJANGO_SETTINGS_MODULE` 其中"
"一个，不要多，也不要少。"

msgid "Calling ``django.setup()`` is required for \"standalone\" Django usage"
msgstr "“独立的” Django 应用要求调用 ``django.setup()``"

msgid ""
"If you're using components of Django \"standalone\" -- for example, writing "
"a Python script which loads some Django templates and renders them, or uses "
"the ORM to fetch some data -- there's one more step you'll need in addition "
"to configuring settings."
msgstr ""
"如果你使用了“独立” Django 的组件——比如，编写一个 Python 脚本，它加载了一些 "
"Django 模板并渲染了它们，或使用 ORM 获取数据——你需要额外的配置一下设置文件。"

msgid ""
"After you've either set :envvar:`DJANGO_SETTINGS_MODULE` or called "
"``configure()``, you'll need to call :func:`django.setup()` to load your "
"settings and populate Django's application registry. For example::"
msgstr ""
"在你已经配置 :envvar:`DJANGO_SETTINGS_MODULE` 或调用 ``configure()`` 后，你需"
"要调用 :func:`django.setup()` 来加载你的设置，并填写的 Django 的应用注册表。"
"例子::"

msgid ""
"Note that calling ``django.setup()`` is only necessary if your code is truly "
"standalone. When invoked by your web server, or through :doc:`django-admin </"
"ref/django-admin>`, Django will handle this for you."
msgstr ""

msgid "``django.setup()`` may only be called once."
msgstr "``django.setup()`` 只需调用一次。"

msgid ""
"Therefore, avoid putting reusable application logic in standalone scripts so "
"that you have to import from the script elsewhere in your application. If "
"you can't avoid that, put the call to ``django.setup()`` inside an ``if`` "
"block::"
msgstr ""
"因此，避免将可服用的应用逻辑代码放入独立脚本中。是故，你必须在你的应用中从此"
"脚本中导入。若你无法避免这样做，将 ``django.setup()`` 调用至于 ``if`` 块内::"

msgid ":doc:`The Settings Reference </ref/settings>`"
msgstr ":doc:`配置参考 </ref/settings>`"

msgid "Contains the complete list of core and contrib app settings."
msgstr "包含对于 core 和 contrib 的完整应用配置列表。"

msgid "Signals"
msgstr "信号"

msgid ""
"Django includes a \"signal dispatcher\" which helps decoupled applications "
"get notified when actions occur elsewhere in the framework. In a nutshell, "
"signals allow certain *senders* to notify a set of *receivers* that some "
"action has taken place. They're especially useful when many pieces of code "
"may be interested in the same events."
msgstr ""
"Django有一个“信号调度器(signal dispatcher)”，用来帮助解耦的应用获知框架内任何"
"其他地方发生了操作。简单地说，信号允许某些 *发送器* 去通知一组 *接收器* 某些"
"操作发生了。当许多代码段都可能对同一事件感兴趣时，信号特别有用。"

msgid ""
"Django provides a :doc:`set of built-in signals </ref/signals>` that let "
"user code get notified by Django itself of certain actions. These include "
"some useful notifications:"
msgstr ""
"Django 提供了 :doc:`内置信号集 </ref/signals>` 使用户代码能够获得 Django 自身"
"某些操作的通知。其中包括一些有用的通知："

msgid ""
":data:`django.db.models.signals.pre_save` & :data:`django.db.models.signals."
"post_save`"
msgstr ""
":data:`django.db.models.signals.pre_save` & :data:`django.db.models.signals."
"post_save`"

msgid ""
"Sent before or after a model's :meth:`~django.db.models.Model.save` method "
"is called."
msgstr ""
"一个模型的 :meth:`~django.db.models.Model.save` 方法被调用之前或之后发出。"

msgid ""
":data:`django.db.models.signals.pre_delete` & :data:`django.db.models."
"signals.post_delete`"
msgstr ""
":data:`django.db.models.signals.pre_delete` & :data:`django.db.models."
"signals.post_delete`"

msgid ""
"Sent before or after a model's :meth:`~django.db.models.Model.delete` method "
"or queryset's :meth:`~django.db.models.query.QuerySet.delete` method is "
"called."
msgstr ""
"一个模型的 :meth:`~django.db.models.Model.delete` 方法或查询结果集的 :meth:"
"`~django.db.models.query.QuerySet.delete` 方法被调用之前或之后发出。"

msgid ":data:`django.db.models.signals.m2m_changed`"
msgstr ":data:`django.db.models.signals.m2m_changed`"

msgid ""
"Sent when a :class:`~django.db.models.ManyToManyField` on a model is changed."
msgstr "一个模型的 :class:`~django.db.models.ManyToManyField` 更改后发出。"

msgid ""
":data:`django.core.signals.request_started` & :data:`django.core.signals."
"request_finished`"
msgstr ""
":data:`django.core.signals.request_started` & :data:`django.core.signals."
"request_finished`"

msgid "Sent when Django starts or finishes an HTTP request."
msgstr "Django 发起或结束一个 HTTP 请求后发出。"

msgid ""
"See the :doc:`built-in signal documentation </ref/signals>` for a complete "
"list, and a complete explanation of each signal."
msgstr ""
"查看 :doc:`内置信号文档 </ref/signals>` 以获取每个信号的完整列表和说明。"

msgid "You can also `define and send your own custom signals`_; see below."
msgstr "你还可以 `定义和发送自定义信号`_；见下文。"

msgid "Listening to signals"
msgstr "监听信号"

msgid ""
"To receive a signal, register a *receiver* function using the :meth:`Signal."
"connect` method. The receiver function is called when the signal is sent. "
"All of the signal's receiver functions are called one at a time, in the "
"order they were registered."
msgstr ""
"要接收信号，使用 :meth:`Signal.connect` 方法注册一个 *接收器* 函数。当发送信"
"号时调用接收器。信号的所有接收器函数都按照注册时的顺序一个接一个调用。"

msgid ""
"The callback function which will be connected to this signal. See :ref:"
"`receiver-functions` for more information."
msgstr "将连接到此信号的回调函数。查看 :ref:`接收器函数` 获取更多信息。"

msgid ""
"Specifies a particular sender to receive signals from. See :ref:`connecting-"
"to-specific-signals` for more information."
msgstr ""
"指定要从其接收信号的特定发送方。查看 :ref:`连接到特定信号` 获取更多信息。"

msgid ""
"Django stores signal handlers as weak references by default. Thus, if your "
"receiver is a local function, it may be garbage collected. To prevent this, "
"pass ``weak=False`` when you call the signal's ``connect()`` method."
msgstr ""
"Django 默认将信号处理程序存储为弱引用。因此，如果你的接收器是本地函数，则可能"
"会对其进行垃圾回收。要防止这种情况发生，当你要调用 ``connect()`` 方法时请传"
"入 ``weak=False``。"

msgid ""
"A unique identifier for a signal receiver in cases where duplicate signals "
"may be sent. See :ref:`preventing-duplicate-signals` for more information."
msgstr ""
"在可能发送重复信号的情况下，信号接收器的唯一标识符。查看 :ref:`preventing-"
"duplicate-signals` 获取更多信息。"

msgid ""
"Let's see how this works by registering a signal that gets called after each "
"HTTP request is finished. We'll be connecting to the :data:`~django.core."
"signals.request_finished` signal."
msgstr ""
"让我们通过注册一个在每个HTTP请求完成后被调用的信号来看看这是如何工作的。我们"
"将连接到 :data:`~django.core.signals.request_finished` 信号。"

msgid "Receiver functions"
msgstr "接收器函数"

msgid ""
"First, we need to define a receiver function. A receiver can be any Python "
"function or method::"
msgstr ""
"首先，我们需要定义一个接收器函数。一个接收器可以是任何 Python 函数或方法："

msgid ""
"Notice that the function takes a ``sender`` argument, along with wildcard "
"keyword arguments (``**kwargs``); all signal handlers must take these "
"arguments."
msgstr ""
"注意，该函数接收一个 ``sender`` 参数以及关键字参数 (``**kwargs``)；所有信号处"
"理程序都必须接受这些参数。"

msgid ""
"We'll look at senders :ref:`a bit later <connecting-to-specific-signals>`, "
"but right now look at the ``**kwargs`` argument. All signals send keyword "
"arguments, and may change those keyword arguments at any time. In the case "
"of :data:`~django.core.signals.request_finished`, it's documented as sending "
"no arguments, which means we might be tempted to write our signal handling "
"as ``my_callback(sender)``."
msgstr ""

msgid ""
"This would be wrong -- in fact, Django will throw an error if you do so. "
"That's because at any point arguments could get added to the signal and your "
"receiver must be able to handle those new arguments."
msgstr ""
"这是错误的——事实上，如果这样做，Django 将抛出一个错误。这是因为在任何时候，参"
"数都可能被添加到信号中，而你的接收器必须能够处理这些新的参数。"

msgid "Connecting receiver functions"
msgstr "连接接收器函数"

msgid ""
"There are two ways you can connect a receiver to a signal. You can take the "
"manual connect route::"
msgstr "有两种方法可以将接收器连接到信号。你可以选择手动连接线路："

msgid "Alternatively, you can use a :func:`receiver` decorator:"
msgstr "或者，你可以使用一个 :func:`receiver` 装饰器："

msgid "A signal or a list of signals to connect a function to."
msgstr "一个用于连接函数的信号或包含多个信号的列表。"

msgid "Here's how you connect with the decorator::"
msgstr "以下是你如何使用装饰器连接："

msgid ""
"Now, our ``my_callback`` function will be called each time a request "
"finishes."
msgstr "现在，我们的 ``my_callback`` 函数将在每次请求完成时被调用。"

msgid "Where should this code live?"
msgstr "我的代码该放在哪？"

msgid ""
"Strictly speaking, signal handling and registration code can live anywhere "
"you like, although it's recommended to avoid the application's root module "
"and its ``models`` module to minimize side-effects of importing code."
msgstr ""
"严格来说，信号处理和注册的代码可以放在任何你喜欢的地方，但是推荐避免放在应用"
"程序的根目录和 ``models`` 模块内以尽量减少导入代码的副作用。"

msgid ""
"In practice, signal handlers are usually defined in a ``signals`` submodule "
"of the application they relate to. Signal receivers are connected in the :"
"meth:`~django.apps.AppConfig.ready` method of your application :ref:"
"`configuration class <configuring-applications-ref>`. If you're using the :"
"func:`receiver` decorator, import the ``signals`` submodule inside :meth:"
"`~django.apps.AppConfig.ready`, this will implicitly connect signal "
"handlers::"
msgstr ""

msgid ""
"The :meth:`~django.apps.AppConfig.ready` method may be executed more than "
"once during testing, so you may want to :ref:`guard your signals from "
"duplication <preventing-duplicate-signals>`, especially if you're planning "
"to send them within tests."
msgstr ""
":meth:`~django.apps.AppConfig.ready` 方法在测试过程中可能会多次执行，因此你可"
"能需要 :ref:`防止重复信号 <preventing-duplicate-signals>`，尤其是当您计划在测"
"试中发送信号时。"

msgid "Connecting to signals sent by specific senders"
msgstr "连接到特定发送器发送的信号"

msgid ""
"Some signals get sent many times, but you'll only be interested in receiving "
"a certain subset of those signals. For example, consider the :data:`django."
"db.models.signals.pre_save` signal sent before a model gets saved. Most of "
"the time, you don't need to know when *any* model gets saved -- just when "
"one *specific* model is saved."
msgstr ""
"有些信号被多次发送，但你只对接收这些信号的某个子集感兴趣。例如，仔细考虑 :"
"data:`django.db.models.signals.pre_save` 在模型保存之前发送的信号。大多数时"
"候，你不需要知道 *任何* 模型何时被保存——只需要知道某个 *特定* 模型何时被保"
"存。"

msgid ""
"In these cases, you can register to receive signals sent only by particular "
"senders. In the case of :data:`django.db.models.signals.pre_save`, the "
"sender will be the model class being saved, so you can indicate that you "
"only want signals sent by some model::"
msgstr ""
"在这些情况下，您可以注册以接收仅由特定发送者发送的信号。在接收 :data:`django."
"db.models.signals.pre_save` 信号时 ，发送器会是要保存的模型类，因此你就可以表"
"明你想要某个模型发送的信号："

msgid ""
"The ``my_handler`` function will only be called when an instance of "
"``MyModel`` is saved."
msgstr "``my_handler`` 函数将仅在 ``MyModel`` 实例保存后被调用。"

msgid ""
"Different signals use different objects as their senders; you'll need to "
"consult the :doc:`built-in signal documentation </ref/signals>` for details "
"of each particular signal."
msgstr ""
"不同的信号使用不同的对象作为它们的发送者；你需要查阅 :doc:`内置信号文档 </"
"ref/signals>` 了解每个特定信号的详细信息。"

msgid "Preventing duplicate signals"
msgstr "防止重复信号"

msgid ""
"In some circumstances, the code connecting receivers to signals may run "
"multiple times. This can cause your receiver function to be registered more "
"than once, and thus called as many times for a signal event. For example, "
"the :meth:`~django.apps.AppConfig.ready` method may be executed more than "
"once during testing. More generally, this occurs everywhere your project "
"imports the module where you define the signals, because signal registration "
"runs as many times as it is imported."
msgstr ""
"在某些情况下，连接接收器到信号的代码可能被执行多次。这可能会导致接收器函数被"
"注册多次，因此对于一个信号事件调用同样多次。例如，:meth:`~django.apps."
"AppConfig.ready` 方法在测试期间可能被多次执行。更普遍的是，在项目的任何地方导"
"入定义信号的模块都会发生这种情况，因为信号注册的运行次数与导入的次数相同。"

msgid ""
"If this behavior is problematic (such as when using signals to send an email "
"whenever a model is saved), pass a unique identifier as the ``dispatch_uid`` "
"argument to identify your receiver function. This identifier will usually be "
"a string, although any hashable object will suffice. The end result is that "
"your receiver function will only be bound to the signal once for each unique "
"``dispatch_uid`` value::"
msgstr ""
"如果此行为会产生问题（例如在保存模型时使用信号发送电子邮件），则传递一个唯一"
"标识符作为 ``dispatch_uid`` 参数来标识接收方函数。这个标识符通常是一个字符"
"串，尽管任何可散列对象都可以。最终的结果是，对于每个唯一的 ``dispatch_uid`` "
"值，接收器函数只与信号绑定一次："

msgid "Defining and sending signals"
msgstr "定义和发送信号"

msgid ""
"Your applications can take advantage of the signal infrastructure and "
"provide its own signals."
msgstr "您的应用程序可以利用信号基础设施并提供自己的信号。"

msgid "When to use custom signals"
msgstr "何时使用自定义信号"

msgid ""
"Signals are implicit function calls which make debugging harder. If the "
"sender and receiver of your custom signal are both within your project, "
"you're better off using an explicit function call."
msgstr ""
"信号是隐式函数调用，这使得调试更加困难。如果你的自定义信号的发送器和接收器都"
"在你的项目内，最好使用显式函数调用。"

msgid "Defining signals"
msgstr "定义信号"

msgid "All signals are :class:`django.dispatch.Signal` instances."
msgstr "所有的信号都是 :class:`django.dispatch.Signal` 的实例。"

msgid "This declares a ``pizza_done`` signal."
msgstr "这声明了一个 ``pizza_done`` 信号。"

msgid "Sending signals"
msgstr "发送信号"

msgid "There are two ways to send signals in Django."
msgstr "在 Django 中有两种发送信号的方法。"

msgid ""
"To send a signal, call either :meth:`Signal.send` (all built-in signals use "
"this) or :meth:`Signal.send_robust`. You must provide the ``sender`` "
"argument (which is a class most of the time) and may provide as many other "
"keyword arguments as you like."
msgstr ""
"要发送信号，调用 :meth:`Signal.send` （所有内置信号使用这个）或者 :meth:"
"`Signal.send_robust`。你必须提供 ``sender`` 参数（大多数情况下是一个类），还"
"可以根据需要提供任意多个其他关键字参数。"

msgid "For example, here's how sending our ``pizza_done`` signal might look::"
msgstr "例如，发送 ``pizza_done`` 信号可能看起来如下："

msgid ""
"Both ``send()`` and ``send_robust()`` return a list of tuple pairs "
"``[(receiver, response), ... ]``, representing the list of called receiver "
"functions and their response values."
msgstr ""
"``send()`` 和 ``send_robust()`` 都返回一个元组对列表 ``[(receiver, "
"response), ... ]``，表示被调用的接收器函数及其响应值的列表。"

msgid ""
"``send()`` differs from ``send_robust()`` in how exceptions raised by "
"receiver functions are handled. ``send()`` does *not* catch any exceptions "
"raised by receivers; it simply allows errors to propagate. Thus not all "
"receivers may be notified of a signal in the face of an error."
msgstr ""
"``send()`` 和 ``send_robust()`` 在处理接收器函数所引发异常的方式上有所不同。 "
"``send()`` *不* 捕获接收器引起的任何异常；它只是允许错误传播。因此，并非所有"
"的接收器都会在出现错误时被通知信号。"

msgid ""
"``send_robust()`` catches all errors derived from Python's ``Exception`` "
"class, and ensures all receivers are notified of the signal. If an error "
"occurs, the error instance is returned in the tuple pair for the receiver "
"that raised the error."
msgstr ""
"``send_robust()`` 捕获从 Python的 ``Exception`` 类派生的所有错误，并确保所有"
"接收器都收到信号通知。如果发生错误，将在引发错误的接收器的元组对中返回错误实"
"例。"

msgid ""
"The tracebacks are present on the ``__traceback__`` attribute of the errors "
"returned when calling ``send_robust()``."
msgstr ""
"回溯出现在调用 ``send_robust()`` 时返回的错误中的 ``__traceback__`` 属性中。"

msgid "Disconnecting signals"
msgstr "断开信号"

msgid ""
"To disconnect a receiver from a signal, call :meth:`Signal.disconnect`. The "
"arguments are as described in :meth:`.Signal.connect`. The method returns "
"``True`` if a receiver was disconnected and ``False`` if not. When "
"``sender`` is passed as a lazy reference to ``<app label>.<model>``, this "
"method always returns ``None``."
msgstr ""

msgid ""
"The ``receiver`` argument indicates the registered receiver to disconnect. "
"It may be ``None`` if ``dispatch_uid`` is used to identify the receiver."
msgstr ""
"``receiver`` 参数表明要断开的接收器。它可以是 ``None`` 如果 ``dispatch_uid`` "
"已经被用来标识接收器。"

msgid "Cryptographic signing"
msgstr "加密签名"

msgid ""
"The golden rule of web application security is to never trust data from "
"untrusted sources. Sometimes it can be useful to pass data through an "
"untrusted medium. Cryptographically signed values can be passed through an "
"untrusted channel safe in the knowledge that any tampering will be detected."
msgstr ""

msgid ""
"Django provides both a low-level API for signing values and a high-level API "
"for setting and reading signed cookies, one of the most common uses of "
"signing in web applications."
msgstr ""

msgid "You may also find signing useful for the following:"
msgstr "你可能还发现签名对以下方面很有用："

msgid ""
"Generating \"recover my account\" URLs for sending to users who have lost "
"their password."
msgstr "生成“找回我的账户”URL 以发送给丢失密码的用户。"

msgid "Ensuring data stored in hidden form fields has not been tampered with."
msgstr "确认存储在表单隐藏字段中的数据未被篡改。"

msgid ""
"Generating one-time secret URLs for allowing temporary access to a protected "
"resource, for example a downloadable file that a user has paid for."
msgstr ""
"生成一次性的秘密 URL，允许临时访问受保护的资源，例如用户付费下载的文件。"

msgid "Protecting the ``SECRET_KEY``"
msgstr "保护 ``SECRET_KEY``"

msgid ""
"When you create a new Django project using :djadmin:`startproject`, the "
"``settings.py`` file is generated automatically and gets a random :setting:"
"`SECRET_KEY` value. This value is the key to securing signed data -- it is "
"vital you keep this secure, or attackers could use it to generate their own "
"signed values."
msgstr ""
"当你使用 :djadmin:`startproject` 创建一个新的Django项目时，``settings.py`` 文"
"件会自动生成，并随机得到一个 :setting:`SECRET_KEY` 值。这个值是保证签名数据安"
"全的关键——你必须保证这个值的安全，否则攻击者可以用它来生成自己的签名值。"

msgid "Using the low-level API"
msgstr "使用低级 API"

msgid ""
"Django's signing methods live in the ``django.core.signing`` module. To sign "
"a value, first instantiate a ``Signer`` instance::"
msgstr ""
"Django 的签名方法位于 ``django.core.signing`` 模块中。要签署一个值，首先要实"
"例化一个 ``Signer`` 实例："

msgid ""
"The signature is appended to the end of the string, following the colon. You "
"can retrieve the original value using the ``unsign`` method::"
msgstr ""
"签名被附加在字符串的结尾，在冒号之后。你可以使用 ``unsign`` 方法检索原始值："

msgid ""
"If you pass a non-string value to ``sign``, the value will be forced to "
"string before being signed, and the ``unsign`` result will give you that "
"string value::"
msgstr ""
"如果你将非字符串值传递给 ``sign``，该值将在被签署前被强制变成字符串，并且 "
"``unsign`` 结果将返回此字符串值："

msgid ""
"If you wish to protect a list, tuple, or dictionary you can do so using the "
"``sign_object()`` and ``unsign_object()`` methods::"
msgstr ""

msgid "See :ref:`signing-complex-data` for more details."
msgstr ""

msgid ""
"If the signature or value have been altered in any way, a ``django.core."
"signing.BadSignature`` exception will be raised::"
msgstr ""
"如果签名或值被以任何方式修改，将引发 ``django.core.signing.BadSignature`` 异"
"常："

msgid ""
"By default, the ``Signer`` class uses the :setting:`SECRET_KEY` setting to "
"generate signatures. You can use a different secret by passing it to the "
"``Signer`` constructor::"
msgstr ""
"默认情况下，``Signer`` 类使用 :setting:`SECRET_KEY` 配置来生成签名。你可以使"
"用不同的密钥传入 ``Signer`` 构造函数生成不同的签名："

msgid ""
"Returns a signer which uses ``key`` to generate signatures and ``sep`` to "
"separate values. ``sep`` cannot be in the :rfc:`URL safe base64 alphabet "
"<4648#section-5>`. This alphabet contains alphanumeric characters, hyphens, "
"and underscores. ``algorithm`` must be an algorithm supported by :py:mod:"
"`hashlib`, it defaults to ``'sha256'``."
msgstr ""
"返回一个使用 ``key`` 生成签名并使用 ``sep`` 分隔值的签名器。``sep`` 不能在 :"
"rfc:`URL 安全 base64 字母表 <4648#section-5>` 中。这个字母表包含字母数字字"
"符、连字符和下划线。``algorithm`` 必须是 :py:mod:`hashlib` 支持的算法。默认"
"为 ``'sha256'``。"

msgid "The ``sign_object()`` and ``unsign_object()`` methods were added."
msgstr ""

msgid "Using the ``salt`` argument"
msgstr "使用 ``salt`` 参数"

msgid ""
"If you do not wish for every occurrence of a particular string to have the "
"same signature hash, you can use the optional ``salt`` argument to the "
"``Signer`` class. Using a salt will seed the signing hash function with both "
"the salt and your :setting:`SECRET_KEY`::"
msgstr ""
"如果你不希望一个特定字符串的每一次出现都有相同的签名哈希值，你可以使用 "
"``Signer`` 类的可选 ``salt`` 参数。使用盐会将盐和你的 :setting:`SECRET_KEY` "
"作为签名哈希函数的种子。"

msgid ""
"Using salt in this way puts the different signatures into different "
"namespaces.  A signature that comes from one namespace (a particular salt "
"value) cannot be used to validate the same plaintext string in a different "
"namespace that is using a different salt setting. The result is to prevent "
"an attacker from using a signed string generated in one place in the code as "
"input to another piece of code that is generating (and verifying) signatures "
"using a different salt."
msgstr ""
"以这种方式使用盐，会将不同的签名放入不同的命名空间。 来自一个命名空间的签名"
"（一个特定的盐值）不能用于验证在使用不同盐值设置的不同命名空间中的同一明文字"
"符串。这样做的结果是防止攻击者将代码中某个地方生成的签名字符串作为输入，输入"
"到使用不同盐值生成（和验证）签名的另一段代码中。"

msgid ""
"Unlike your :setting:`SECRET_KEY`, your salt argument does not need to stay "
"secret."
msgstr "与你的 :setting:`SECRET_KEY` 不同，你的盐参数不需要保密。"

msgid "Verifying timestamped values"
msgstr "验证时间戳值"

msgid ""
"``TimestampSigner`` is a subclass of :class:`~Signer` that appends a signed "
"timestamp to the value. This allows you to confirm that a signed value was "
"created within a specified period of time::"
msgstr ""
"``TimestampSigner`` 是 :class:`~Signer` 的子类，它给值附加一个签名的时间戳。"
"这允许你确认一个签名的值是在特定时间内创建的："

msgid "Sign ``value`` and append current timestamp to it."
msgstr "签名 ``value`` 并附加当前时间戳。"

msgid ""
"Checks if ``value`` was signed less than ``max_age`` seconds ago, otherwise "
"raises ``SignatureExpired``. The ``max_age`` parameter can accept an integer "
"or a :py:class:`datetime.timedelta` object."
msgstr ""
"检查 ``value`` 是否在 ``max_age`` 秒前被签署，否则引发 ``SignatureExpired``。"
"``max_age`` 参数可以接受一个整数或一个 :py:class:`datetime.timedelta` 对象。"

msgid ""
"Encode, optionally compress, append current timestamp, and sign complex data "
"structure (e.g. list, tuple, or dictionary)."
msgstr ""

msgid ""
"Checks if ``signed_obj`` was signed less than ``max_age`` seconds ago, "
"otherwise raises ``SignatureExpired``. The ``max_age`` parameter can accept "
"an integer or a :py:class:`datetime.timedelta` object."
msgstr ""

msgid "Protecting complex data structures"
msgstr "保护复杂的数据结构"

msgid ""
"If you wish to protect a list, tuple or dictionary you can do so using the "
"``Signer.sign_object()`` and ``unsign_object()`` methods, or signing "
"module's ``dumps()`` or ``loads()`` functions (which are shortcuts for "
"``TimestampSigner(salt='django.core.signing').sign_object()/"
"unsign_object()``). These use JSON serialization under the hood. JSON "
"ensures that even if your :setting:`SECRET_KEY` is stolen an attacker will "
"not be able to execute arbitrary commands by exploiting the pickle format::"
msgstr ""

msgid ""
"Because of the nature of JSON (there is no native distinction between lists "
"and tuples) if you pass in a tuple, you will get a list from ``signing."
"loads(object)``::"
msgstr ""
"由于 JSON 的特性（列表和元组之间没有原生的区别），如果你传入一个元组，你将从 "
"``signing.loads(object)`` 得到一个列表："

msgid ""
"Returns URL-safe, signed base64 compressed JSON string. Serialized object is "
"signed using :class:`~TimestampSigner`."
msgstr ""
"返回 URL 安全的，经过签名的 base64 压缩 JSON 字符串。使用 :class:"
"`~TimestampSigner` 对序列化对象进行签名。"

msgid ""
"Reverse of ``dumps()``, raises ``BadSignature`` if signature fails. Checks "
"``max_age`` (in seconds) if given."
msgstr ""
"与 ``dumps()`` 相反，如果签名失败引发 ``BadSignature``。如果给定，则检查 "
"``max_age`` （以秒为单位）。"

msgid "Templates"
msgstr "模板"

msgid ""
"Being a web framework, Django needs a convenient way to generate HTML "
"dynamically. The most common approach relies on templates. A template "
"contains the static parts of the desired HTML output as well as some special "
"syntax describing how dynamic content will be inserted. For a hands-on "
"example of creating HTML pages with templates, see :doc:`Tutorial 3 </intro/"
"tutorial03>`."
msgstr ""
"作为一个网络框架，Django 需要一种方便的方式来动态生成 HTML。最常见的方法是依"
"靠模板。一个模板包含了所需 HTML 输出的静态部分，以及一些特殊的语法，描述了如"
"何插入动态内容。关于使用模板创建 HTML 页面的实战例子，请看 :doc:`教程 3 </"
"intro/tutorial03>`。"

msgid ""
"A Django project can be configured with one or several template engines (or "
"even zero if you don't use templates). Django ships built-in backends for "
"its own template system, creatively called the Django template language "
"(DTL), and for the popular alternative Jinja2_. Backends for other template "
"languages may be available from third-parties. You can also write your own "
"custom backend, see :doc:`Custom template backend </howto/custom-template-"
"backend>`"
msgstr ""
"一个 Django 项目可以配置一个或多个模板引擎（如果你不使用模板，甚至可以不配置"
"模板）。Django 内置了自己的模板系统后端，创造性地称为 Django 模板语言"
"（DTL），以及流行的替代版本 Jinja2_。其他模板语言的后端可以从第三方获得。你也"
"可以编写自己的自定义后端，参见：:doc:`自定义模板后端 </howto/custom-template-"
"backend>`"

msgid ""
"Django defines a standard API for loading and rendering templates regardless "
"of the backend. Loading consists of finding the template for a given "
"identifier and preprocessing it, usually compiling it to an in-memory "
"representation. Rendering means interpolating the template with context data "
"and returning the resulting string."
msgstr ""
"Django 定义了一个标准的API，用于加载和渲染模板，而不考虑后端。加载包括为给定"
"的标识符找到模板并对其进行预处理，通常是将其编译成内存中的表示形式。渲染是指"
"将上下文数据插入模板，并返回结果字符串。"

msgid ""
"The :doc:`Django template language </ref/templates/language>` is Django's "
"own template system. Until Django 1.8 it was the only built-in option "
"available. It's a good template library even though it's fairly opinionated "
"and sports a few idiosyncrasies. If you don't have a pressing reason to "
"choose another backend, you should use the DTL, especially if you're writing "
"a pluggable application and you intend to distribute templates. Django's "
"contrib apps that include templates, like :doc:`django.contrib.admin </ref/"
"contrib/admin/index>`, use the DTL."
msgstr ""
":doc:`Django 模板语言 </ref/templates/language>` 是 Django 自己的模板系统。"
"在 Django 1.8 之前，它是唯一的内置选项。它是一个很好的模板库，尽管它是相当有"
"主见的，并且有一些特殊的地方。如果你没有迫切的理由选择另一个后端，你应该使用 "
"DTL，特别是当你正在编写一个可插拔的应用程序，并且你打算发布模板时。Django 的 "
"contrib 应用如果包含模板，比如 :doc:`django.contrib.admin </ref/contrib/"
"admin/index>`，就使用 DTL。"

msgid ""
"For historical reasons, both the generic support for template engines and "
"the implementation of the Django template language live in the ``django."
"template`` namespace."
msgstr ""
"由于历史原因，模板引擎的通用支持和 Django 模板语言的实现都在 ``django."
"template`` 的命名空间中。"

msgid ""
"The template system isn't safe against untrusted template authors. For "
"example, a site shouldn't allow its users to provide their own templates, "
"since template authors can do things like perform XSS attacks and access "
"properties of template variables that may contain sensitive information."
msgstr ""
"模板系统对于不受信任的模板作者并不安全。例如，一个网站不应该允许其用户提供自"
"己的模板，因为模板作者可以做一些事情，如执行 XSS 攻击和访问可能包含敏感信息的"
"模板变量的属性。"

msgid "The Django template language"
msgstr "Django 模板语言"

msgid "Syntax"
msgstr "语法"

msgid "About this section"
msgstr "关于本节"

msgid ""
"This is an overview of the Django template language's syntax. For details "
"see the :doc:`language syntax reference </ref/templates/language>`."
msgstr ""
"这是对 Django 模板语言语法的概述。详细信息请参见 :doc:`语言语法参考 </ref/"
"templates/language>`。"

msgid ""
"A Django template is a text document or a Python string marked-up using the "
"Django template language. Some constructs are recognized and interpreted by "
"the template engine. The main ones are variables and tags."
msgstr ""
"Django 模板是使用 Django 模板语言标记的一个文本文档或Python字符串。模板引擎可"
"以识别和解释一些构造。主要是变量和标签。"

msgid ""
"A template is rendered with a context. Rendering replaces variables with "
"their values, which are looked up in the context, and executes tags. "
"Everything else is output as is."
msgstr ""
"模板是通过上下文来渲染的。渲染用变量的值替换变量，变量的值在上下文中查找，并"
"执行标签。其他的一切都按原样输出。"

msgid "The syntax of the Django template language involves four constructs."
msgstr "Django 模板语言的语法涉及四个构造。"

msgid "Variables"
msgstr "变量"

msgid ""
"A variable outputs a value from the context, which is a dict-like object "
"mapping keys to values."
msgstr "变量从上下文中输出一个值，上下文是一个类似于字典的对象，将键映射到值。"

msgid "Variables are surrounded by ``{{`` and ``}}`` like this::"
msgstr "变量被 ``{{`` 和 ``}}`` 包围，如下所示："

msgid ""
"With a context of ``{'first_name': 'John', 'last_name': 'Doe'}``, this "
"template renders to::"
msgstr ""
"在上下文为 ``{'first_name': 'John', 'last_name': 'Doe'}`` 的情况下，该模板渲"
"染为："

msgid ""
"Dictionary lookup, attribute lookup and list-index lookups are implemented "
"with a dot notation::"
msgstr "字典查找，属性查找和列表索引查找均以点符号实现："

msgid ""
"If a variable resolves to a callable, the template system will call it with "
"no arguments and use its result instead of the callable."
msgstr ""
"如果变量解析为可调用对象，则模板系统将不带任何参数的情况下调用它，并使用其结"
"果代替可调用对象。"

msgid "Tags"
msgstr "标签"

msgid "Tags provide arbitrary logic in the rendering process."
msgstr "标签在渲染过程中提供了任意逻辑。"

msgid ""
"This definition is deliberately vague. For example, a tag can output "
"content, serve as a control structure e.g. an \"if\" statement or a \"for\" "
"loop, grab content from a database, or even enable access to other template "
"tags."
msgstr ""
"这个定义是故意含糊的。例如，标签可以输出内容，或用作控制结构如 “if” 语句和 "
"“for” 循环，或从数据库中抓取内容，甚至可以访问其他模板标签。"

msgid "Tags are surrounded by ``{%`` and ``%}`` like this::"
msgstr "标签被 ``{%`` 和 ``%}`` 包围，如下所示："

msgid "Most tags accept arguments::"
msgstr "大多数标签都接受参数："

msgid "Some tags require beginning and ending tags::"
msgstr "一些标签需要开始和结束标签："

msgid ""
"A :ref:`reference of built-in tags <ref-templates-builtins-tags>` is "
"available as well as :ref:`instructions for writing custom tags <howto-"
"writing-custom-template-tags>`."
msgstr ""
"提供 :ref:`内置标签参考 <ref-templates-builtins-tags>` 以及 :ref:`自定义标签"
"编写指南 <howto-writing-custom-template-tags>`。"

msgid "Filters transform the values of variables and tag arguments."
msgstr "过滤器转换变量和标签参数的值。"

msgid "They look like this::"
msgstr "它们看起来像这样："

msgid ""
"With a context of ``{'django': 'the web framework for perfectionists with "
"deadlines'}``, this template renders to::"
msgstr ""
"在 ``{'django': 'the web framework for perfectionists with deadlines'}`` 的上"
"下文中，这个模板渲染为："

msgid "Some filters take an argument::"
msgstr "有些过滤器需要一个参数："

msgid ""
"A :ref:`reference of built-in filters <ref-templates-builtins-filters>` is "
"available as well as :ref:`instructions for writing custom filters <howto-"
"writing-custom-template-filters>`."
msgstr ""
"提供 :ref:`内建过滤器参考 <ref-templates-builtins-filters>` 以及 :ref:`自定义"
"过滤器编写指南 <howto-writing-custom-template-filters>`."

msgid "Comments look like this::"
msgstr "注释看起来像这样："

msgid "A :ttag:`{% comment %} <comment>` tag provides multi-line comments."
msgstr ":ttag:`{% comment %} <comment>` 标签提供多行注释。"

msgid "Components"
msgstr "组件"

msgid ""
"This is an overview of the Django template language's APIs. For details see "
"the :doc:`API reference </ref/templates/api>`."
msgstr ""
"这是对 Django 模板语言 API 的概述。详细信息请参见 :doc:`API 参考 </ref/"
"templates/api>`。"

msgid "Engine"
msgstr "引擎"

msgid ""
":class:`django.template.Engine` encapsulates an instance of the Django "
"template system. The main reason for instantiating an :class:`~django."
"template.Engine` directly is to use the Django template language outside of "
"a Django project."
msgstr ""
":class:`django.template.Engine` 封装了 Django 模板系统的实例。直接实例化 :"
"class:`~django.template.Engine` 的主要原因是为了在 Django 项目之外使用 "
"Django 模板语言。"

msgid ""
":class:`django.template.backends.django.DjangoTemplates` is a thin wrapper "
"adapting :class:`django.template.Engine` to Django's template backend API."
msgstr ""
":class:`django.template.backends.django.DjangoTemplates` 是一个简单封装，使 :"
"class:`django.template.Engine` 适应 Django 的模板后端API。"

msgid "Template"
msgstr "模板"

msgid ""
":class:`django.template.Template` represents a compiled template. Templates "
"are obtained with :meth:`.Engine.get_template` or :meth:`.Engine."
"from_string`."
msgstr ""
":class:`django.template.Template` 代表已编译的模板。模板可以通过 :meth:`."
"Engine.get_template` 或 :meth:`.Engine.from_string` 获得。"

msgid ""
"Likewise ``django.template.backends.django.Template`` is a thin wrapper "
"adapting :class:`django.template.Template` to the common template API."
msgstr ""
"同样 ``django.template.backends.django.Template`` 是一个简单封装，使 :class:"
"`django.template.Template` 适应通用模板 API。"

msgid "Context"
msgstr "上下文"

msgid ""
":class:`django.template.Context` holds some metadata in addition to the "
"context data. It is passed to :meth:`.Template.render` for rendering a "
"template."
msgstr ""
":class:`django.template.Context` 除了上下文数据外，还保存了一些元数据。它被传"
"递给 :meth:`.Template.render` 来渲染模板。"

msgid ""
":class:`django.template.RequestContext` is a subclass of :class:`~django."
"template.Context` that stores the current :class:`~django.http.HttpRequest` "
"and runs template context processors."
msgstr ""
":class:`django.template.RequestContext` 是 :class:`~django.template.Context` "
"的子类，它储存当前的 :class:`~django.http.HttpRequest` 并运行模板上下文处理"
"器。"

msgid ""
"The common API doesn't have an equivalent concept. Context data is passed in "
"a plain :class:`dict` and the current :class:`~django.http.HttpRequest` is "
"passed separately if needed."
msgstr ""
"通用 API 没有对应的概念。上下文数据以普通的 :class:`dict` 传递，而当前的 :"
"class:`~django.http.HttpRequest` 则根据需要单独传递。"

msgid "Loaders"
msgstr "加载器"

msgid ""
"Template loaders are responsible for locating templates, loading them, and "
"returning :class:`~django.template.Template` objects."
msgstr ""
"模板加载器负责定位模板，加载模板，并返回 :class:`~django.template.Template` "
"对象。"

msgid ""
"Django provides several :ref:`built-in template loaders <template-loaders>` "
"and supports :ref:`custom template loaders <custom-template-loaders>`."
msgstr ""
"Django 提供了几个 :ref:`内建模板加载器 <template-loaders>` 并且支持 :ref:`自"
"定义模板加载器 <custom-template-loaders>`。"

msgid "Context processors"
msgstr "上下文处理器"

msgid ""
"Context processors are functions that receive the current :class:`~django."
"http.HttpRequest` as an argument and return a :class:`dict` of data to be "
"added to the rendering context."
msgstr ""
"上下文处理器是接收当前的 :class:`~django.http.HttpRequest` 作为参数，并返回一"
"个 :class:`dict` 的数据添加到渲染上下文的函数。"

msgid ""
"Their main use is to add common data shared by all templates to the context "
"without repeating code in every view."
msgstr ""
"它们的主要用途是将所有模板共享的通用数据添加到上下文中，而无需在每个视图中重"
"复代码。"

msgid ""
"Django provides many :ref:`built-in context processors <context-"
"processors>`, and you can implement your own additional context processors, "
"too."
msgstr ""
"Django 提供了许多 :ref:`内置上下文处理器 <context-processors>`，你也可以实现"
"自己的其他上下文处理器。"

msgid "Support for template engines"
msgstr "模板引擎的支持"

msgid "Configuration"
msgstr "配置"

msgid ""
"Templates engines are configured with the :setting:`TEMPLATES` setting. It's "
"a list of configurations, one for each engine. The default value is empty. "
"The ``settings.py`` generated by the :djadmin:`startproject` command defines "
"a more useful value::"
msgstr ""
"模板引擎是通过 :setting:`TEMPLATES` 进行配置。这是一个配置列表，每个引擎都有"
"一个。默认值为空。:djadmin:`startproject` 命令生成的 ``settings.py``  定义了"
"一个更有用的值："

msgid ""
":setting:`BACKEND <TEMPLATES-BACKEND>` is a dotted Python path to a template "
"engine class implementing Django's template backend API. The built-in "
"backends are :class:`django.template.backends.django.DjangoTemplates` and :"
"class:`django.template.backends.jinja2.Jinja2`."
msgstr ""
":setting:`BACKEND <TEMPLATES-BACKEND>` 是实现 Django 模板后端 API 的模板引擎"
"类的点分隔 Python 路径。内置的后端有 :class:`django.template.backends.django."
"DjangoTemplates` 和 :class:`django.template.backends.jinja2.Jinja2`。"

msgid ""
"Since most engines load templates from files, the top-level configuration "
"for each engine contains two common settings:"
msgstr ""
"由于大多数引擎都是从文件中加载模板，因此每个引擎的顶层配置都包含两个常见的配"
"置："

msgid ""
":setting:`DIRS <TEMPLATES-DIRS>` defines a list of directories where the "
"engine should look for template source files, in search order."
msgstr ""
":setting:`DIRS <TEMPLATES-DIRS>` 定义了目录列表，引擎应在其中按搜索顺序查找模"
"板源文件。"

msgid ""
":setting:`APP_DIRS <TEMPLATES-APP_DIRS>` tells whether the engine should "
"look for templates inside installed applications. Each backend defines a "
"conventional name for the subdirectory inside applications where its "
"templates should be stored."
msgstr ""
":setting:`APP_DIRS <TEMPLATES-APP_DIRS>` 告诉引擎是否应该在已安装的应用程序中"
"寻找模板。每个后端都为应用程序中存储模板的子目录定义了一个惯用名称。"

msgid ""
"While uncommon, it's possible to configure several instances of the same "
"backend with different options. In that case you should define a unique :"
"setting:`NAME <TEMPLATES-NAME>` for each engine."
msgstr ""
"虽然不常见，但可以使用不同的选项配置同一后端的多个实例。 在这种情况下，你应该"
"为每个引擎定义一个唯一的 :setting:`NAME <TEMPLATES-NAME>`。"

msgid ""
":setting:`OPTIONS <TEMPLATES-OPTIONS>` contains backend-specific settings."
msgstr ":setting:`OPTIONS <TEMPLATES-OPTIONS>` 包含特定于后端的配置。"

msgid ""
"The ``django.template.loader`` module defines two functions to load "
"templates."
msgstr "``django.template.loader`` 模块定义了两个加载模板的函数。"

msgid ""
"This function loads the template with the given name and returns a "
"``Template`` object."
msgstr "此函数使用给定名称加载模板并返回 ``Template`` 对象。"

msgid ""
"The exact type of the return value depends on the backend that loaded the "
"template. Each backend has its own ``Template`` class."
msgstr ""
"返回值的确切类型取决于加载模板的后端。 每个后端都有自己的 ``Template`` 类。"

msgid ""
"``get_template()`` tries each template engine in order until one succeeds. "
"If the template cannot be found, it raises :exc:`~django.template."
"TemplateDoesNotExist`. If the template is found but contains invalid syntax, "
"it raises :exc:`~django.template.TemplateSyntaxError`."
msgstr ""
"``get_template()`` 依次尝试每个模板引擎，直到成功为止。如果找不到模板，则会引"
"发 :exc:`~django.template.TemplateDoesNotExist` 错误。如果找到模板但包含无效"
"语法，则会引发 :exc:`~django.template.TemplateSyntaxError` 错误。"

msgid ""
"How templates are searched and loaded depends on each engine's backend and "
"configuration."
msgstr "搜索和加载模板的方式取决于每个引擎的后端和配置。"

msgid ""
"If you want to restrict the search to a particular template engine, pass the "
"engine's :setting:`NAME <TEMPLATES-NAME>` in the ``using`` argument."
msgstr ""
"如果你想把搜索限制在一个特定的模板引擎上，在 ``using`` 参数中传递该引擎的 :"
"setting:`NAME <TEMPLATES-NAME>`。"

msgid ""
"``select_template()`` is just like ``get_template()``, except it takes a "
"list of template names. It tries each name in order and returns the first "
"template that exists."
msgstr ""
"``select_template()`` 就像 ``get_template()``，不同的是，它接受一个模板名称的"
"列表。它按顺序尝试每个名字，并返回第一个存在的模板。"

msgid ""
"If loading a template fails, the following two exceptions, defined in "
"``django.template``, may be raised:"
msgstr ""
"如果加载模板失败，则可能会引发在 ``django.template`` 中定义的以下两个异常："

msgid ""
"This exception is raised when a template cannot be found. It accepts the "
"following optional arguments for populating the :ref:`template postmortem "
"<template-postmortem>` on the debug page:"
msgstr ""
"当找不到模板时引发此异常。 它接受以下可选参数在调试页面上填充 :ref:`模板事后"
"检验 <template-postmortem>` ："

msgid "``backend``"
msgstr "``backend``"

msgid "The template backend instance from which the exception originated."
msgstr "产生异常的模板后端实例。"

msgid "``tried``"
msgstr "``tried``"

msgid ""
"A list of sources that were tried when finding the template. This is "
"formatted as a list of tuples containing ``(origin, status)``, where "
"``origin`` is an :ref:`origin-like <template-origin-api>` object and "
"``status`` is a string with the reason the template wasn't found."
msgstr ""
"查找模板时尝试过的来源列表。它的格式为包含 ``(origin, status)`` 的元组列表，"
"其中 ``origin`` 是一个 :ref:`类 origin <template-origin-api>` 对象而 "
"``status`` 是一个说明找不到模板原因的字符串。"

msgid "``chain``"
msgstr "``chain``"

msgid ""
"A list of intermediate :exc:`~django.template.TemplateDoesNotExist` "
"exceptions raised when trying to load a template. This is used by functions, "
"such as :func:`~django.template.loader.get_template`, that try to load a "
"given template from multiple engines."
msgstr ""
"尝试加载模板时引发的一系列中间 :exc:`~django.template.TemplateDoesNotExist` "
"异常列表。这由函数使用，例如：:func:`~django.template.loader.get_template`，"
"这些函数尝试从多个引擎加载给定的模板。"

msgid "This exception is raised when a template was found but contains errors."
msgstr "当找到模板但包含错误时，将引发此异常。"

msgid ""
"``Template`` objects returned by ``get_template()`` and "
"``select_template()`` must provide a ``render()`` method with the following "
"signature:"
msgstr ""
"由 ``get_template()`` 和 ``select_template()`` 返回的 ``Template`` 对象必须提"
"供具有以下签名的 `render()`` 方法："

msgid "Renders this template with a given context."
msgstr "使用给定的上下文渲染此模板。"

msgid ""
"If ``context`` is provided, it must be a :class:`dict`. If it isn't "
"provided, the engine will render the template with an empty context."
msgstr ""
"如果提供了 ``context`` ，则必须是 :class:`dict`。如果未提供，则引擎将使用空上"
"下文渲染模板。"

msgid ""
"If ``request`` is provided, it must be an :class:`~django.http.HttpRequest`. "
"Then the engine must make it, as well as the CSRF token, available in the "
"template. How this is achieved is up to each backend."
msgstr ""
"如果提供了 ``request``，它必须是 :class:`~django.http.HttpRequest`。同时引擎"
"必须使它和 CSRF 令牌在模板中可用。如何实现这一点由每个后端决定。"

msgid ""
"Here's an example of the search algorithm. For this example the :setting:"
"`TEMPLATES` setting is::"
msgstr "下面是一个搜索算法的例子。在这个例子中 :setting:`TEMPLATES` 设置为："

msgid ""
"If you call ``get_template('story_detail.html')``, here are the files Django "
"will look for, in order:"
msgstr ""
"如果你调用 ``get_template('story_detail.html')``，以下是 Django 将按顺序查找"
"的文件："

msgid "``/home/html/example.com/story_detail.html`` (``'django'`` engine)"
msgstr "``/home/html/example.com/story_detail.html`` （``'django'`` 引擎）"

msgid "``/home/html/default/story_detail.html`` (``'django'`` engine)"
msgstr "``/home/html/default/story_detail.html`` （``'django'`` 引擎）"

msgid "``/home/html/jinja2/story_detail.html`` (``'jinja2'`` engine)"
msgstr "``/home/html/jinja2/story_detail.html`` （``'jinja2'`` 引擎）"

msgid ""
"If you call ``select_template(['story_253_detail.html', 'story_detail."
"html'])``, here's what Django will look for:"
msgstr ""
"如果你调用 ``select_template(['story_253_detail.html', 'story_detail."
"html'])``，Django 将寻找以下内容："

msgid "``/home/html/example.com/story_253_detail.html`` (``'django'`` engine)"
msgstr "``/home/html/example.com/story_253_detail.html`` （``'django'`` 引擎）"

msgid "``/home/html/default/story_253_detail.html`` (``'django'`` engine)"
msgstr "``/home/html/default/story_253_detail.html`` （``'django'`` 引擎）"

msgid "``/home/html/jinja2/story_253_detail.html`` (``'jinja2'`` engine)"
msgstr "``/home/html/jinja2/story_253_detail.html`` （``'jinja2'`` 引擎）"

msgid "When Django finds a template that exists, it stops looking."
msgstr "当 Django 发现一个模板存在时，它就会停止寻找。"

msgid "Tip"
msgstr "提示"

msgid ""
"You can use :func:`~django.template.loader.select_template()` for flexible "
"template loading. For example, if you've written a news story and want some "
"stories to have custom templates, use something like "
"``select_template(['story_%s_detail.html' % story.id, 'story_detail."
"html'])``. That'll allow you to use a custom template for an individual "
"story, with a fallback template for stories that don't have custom templates."
msgstr ""
"你可以使用 :func:`~django.template.loader.select_template()` 灵活的加载模板。"
"例如，如果你写了一个新闻故事，并希望一些故事有自定义模板，使用类似 "
"``select_template(['story_%s_detail.html' % story.id, 'story_detail."
"html'])`` 。这将允许你为单个故事使用自定义模板，为没有自定义模板的故事使用备"
"用模板。"

msgid ""
"It's possible -- and preferable -- to organize templates in subdirectories "
"inside each directory containing templates. The convention is to make a "
"subdirectory for each Django app, with subdirectories within those "
"subdirectories as needed."
msgstr ""
"可以——而且最好是——在每个包含模板的目录内的子目录中组织模板。惯例是为每个 "
"Django 应用程序创建一个子目录，根据需要在这些子目录中包含子目录。"

msgid ""
"Do this for your own sanity. Storing all templates in the root level of a "
"single directory gets messy."
msgstr "这样做是为了你自己的理智。将所有模板存储在一个目录的根级别会很麻烦。"

msgid "To load a template that's within a subdirectory, use a slash, like so::"
msgstr "要加载子目录中的模板，请使用斜杠，如下所示："

msgid ""
"Using the same :setting:`TEMPLATES` option as above, this will attempt to "
"load the following templates:"
msgstr "使用与上述相同的 :setting:`TEMPLATES` 选项，这将尝试加载以下模板："

msgid "``/home/html/example.com/news/story_detail.html`` (``'django'`` engine)"
msgstr ""
"``/home/html/example.com/news/story_detail.html`` （``'django'`` 引擎）"

msgid "``/home/html/default/news/story_detail.html`` (``'django'`` engine)"
msgstr "``/home/html/default/news/story_detail.html`` （``'django'`` 引擎）"

msgid "``/home/html/jinja2/news/story_detail.html`` (``'jinja2'`` engine)"
msgstr "``/home/html/jinja2/news/story_detail.html`` （``'jinja2'`` 引擎）"

msgid ""
"In addition, to cut down on the repetitive nature of loading and rendering "
"templates, Django provides a shortcut function which automates the process."
msgstr ""
"此外，为了减少加载和渲染模板的重复性，Django 提供了一个自动处理的快捷函数。"

msgid ""
"``render_to_string()`` loads a template like :func:`get_template` and calls "
"its ``render()`` method immediately. It takes the following arguments."
msgstr ""
"``render_to_string()`` 加载一个模板 :func:`get_template` ，并立即调用它的 "
"``render()`` 方法。它需要下面的参数。"

msgid ""
"The name of the template to load and render. If it's a list of template "
"names, Django uses :func:`select_template` instead of :func:`get_template` "
"to find the template."
msgstr ""
"加载和呈现模板的名称。如果是模板名称列表，Django 使用 :func:"
"`select_template` ，而不是 :func:`get_template` 找到模板。"

msgid "A :class:`dict` to be used as the template's context for rendering."
msgstr " :class:`dict` 用作模板的渲染上下文。"

msgid ""
"An optional :class:`~django.http.HttpRequest` that will be available during "
"the template's rendering process."
msgstr " 可选项 :class:`~django.http.HttpRequest` 在模板的渲染过程中可用。"

msgid ""
"An optional template engine :setting:`NAME <TEMPLATES-NAME>`. The search for "
"the template will be restricted to that engine."
msgstr ""
"可选的模板引擎 :setting:`NAME <TEMPLATES-NAME>`。对模板的搜索将限于该引擎。"

msgid "Usage example::"
msgstr "使用实例："

msgid ""
"See also the :func:`~django.shortcuts.render()` shortcut which calls :func:"
"`render_to_string()` and feeds the result into an :class:`~django.http."
"HttpResponse` suitable for returning from a view."
msgstr ""
"还可以参看 :func:`~django.shortcuts.render()` 快捷函数，它调用 :func:"
"`render_to_string()` ，并将结果提供给 :class:`~django.http.HttpResponse` ，适"
"合从视图返回。"

msgid "Finally, you can use configured engines directly:"
msgstr "最后，您可以直接使用配置好的引擎："

msgid "Template engines are available in ``django.template.engines``::"
msgstr "模板引擎可在 ``django.template.engines`` 中使用："

msgid ""
"The lookup key — ``'django'`` in this example — is the engine's :setting:"
"`NAME <TEMPLATES-NAME>`."
msgstr ""
"在这个例子中，查找关键字“django”是引擎的 :setting:`NAME <TEMPLATES-NAME>`。"

msgid "Built-in backends"
msgstr "内置后端"

msgid ""
"Set :setting:`BACKEND <TEMPLATES-BACKEND>` to ``'django.template.backends."
"django.DjangoTemplates'`` to configure a Django template engine."
msgstr ""
"设置 :setting:`BACKEND <TEMPLATES-BACKEND>` 为 ``'django.template.backends."
"django.DjangoTemplates'``，以配置 Django 模板引擎。"

msgid ""
"When :setting:`APP_DIRS <TEMPLATES-APP_DIRS>` is ``True``, "
"``DjangoTemplates`` engines look for templates in the ``templates`` "
"subdirectory of installed applications. This generic name was kept for "
"backwards-compatibility."
msgstr ""
"当 :setting:`APP_DIRS <TEMPLATES-APP_DIRS>` 为 ``True`` 时，"
"``DjangoTemplates`` 引擎会在已安装应用程序的 ``templates`` 子目录中寻找模板。"
"这个通用名称是为了向后兼容而保留的。"

msgid ""
"``DjangoTemplates`` engines accept the following :setting:`OPTIONS "
"<TEMPLATES-OPTIONS>`:"
msgstr ""
"``DjangoTemplates`` 引擎接受以下 :setting:`OPTIONS <TEMPLATES-OPTIONS>`:"

msgid ""
"``'autoescape'``: a boolean that controls whether HTML autoescaping is "
"enabled."
msgstr "``'autoescape'``：一个布尔值，控制是否启用 HTML 自动转义。"

msgid "It defaults to ``True``."
msgstr "默认为 ``True``。"

msgid "Only set it to ``False`` if you're rendering non-HTML templates!"
msgstr "只有当你渲染非 HTML 模板时，才将其设置为 ``False``！"

msgid ""
"``'context_processors'``: a list of dotted Python paths to callables that "
"are used to populate the context when a template is rendered with a request. "
"These callables take a request object as their argument and return a :class:"
"`dict` of items to be merged into the context."
msgstr ""
"``'context_processors'``：当模板被请求渲染时，用于填充上下文的可调用项的点分"
"隔 Python 路径列表。这些可调用的对象以一个请求对象作为参数，并返回一个 :"
"class:`dict` 的项目，这些项目将被合并到上下文中。"

msgid "It defaults to an empty list."
msgstr "默认为空列表。"

msgid "See :class:`~django.template.RequestContext` for more information."
msgstr "查看 :class:`~django.template.RequestContext` 获取更多信息。"

msgid ""
"``'debug'``: a boolean that turns on/off template debug mode. If it is "
"``True``, the fancy error page will display a detailed report for any "
"exception raised during template rendering. This report contains the "
"relevant snippet of the template with the appropriate line highlighted."
msgstr ""
"``'debug'``：开启／关闭模板调试模式的布尔值。如果是 ``True``，错误页面将显示"
"模板渲染过程中出现的任何异常的详细报告。该报告包含模板的相关片段，并突出显示"
"相应的行。"

msgid "It defaults to the value of the :setting:`DEBUG` setting."
msgstr "默认为 :setting:`DEBUG` 配置的值。"

msgid ""
"``'loaders'``: a list of dotted Python paths to template loader classes. "
"Each ``Loader`` class knows how to import templates from a particular "
"source. Optionally, a tuple can be used instead of a string. The first item "
"in the tuple should be the ``Loader`` class name, and subsequent items are "
"passed to the ``Loader`` during initialization."
msgstr ""
"``'loaders'``：模板加载器类的点分隔 Python 路径列表。每个 ``Loader`` 类都知道"
"如何从特定源导入模板。可以选择使用元组来代替字符串。元组中的第一项应该是 "
"``Loader`` 类名，随后的项在初始化期间传递给 ``Loader``。"

msgid ""
"The default depends on the values of :setting:`DIRS <TEMPLATES-DIRS>` and :"
"setting:`APP_DIRS <TEMPLATES-APP_DIRS>`."
msgstr ""
"默认值取决于 :setting:`DIRS <TEMPLATES-DIRS>` 和 :setting:`APP_DIRS "
"<TEMPLATES-APP_DIRS>` 的值。"

msgid "See :ref:`template-loaders` for details."
msgstr "查看 :ref:`template-loaders` 获取详细信息。"

msgid ""
"``'string_if_invalid'``: the output, as a string, that the template system "
"should use for invalid (e.g. misspelled) variables."
msgstr ""
"``'string_if_invalid'``：模板系统对无效变量（如拼写错误）应将此字符串输出。"

msgid "It defaults to an empty string."
msgstr "默认为空字符串。"

msgid "See :ref:`invalid-template-variables` for details."
msgstr "查看 :ref:`invalid-template-variables` 获取更多信息。"

msgid "``'file_charset'``: the charset used to read template files on disk."
msgstr "``'file_charset'``：用于读取磁盘上模板文件的字符集。"

msgid "It defaults to ``'utf-8'``."
msgstr "默认为 ``'utf-8'``。"

msgid ""
"``'libraries'``: A dictionary of labels and dotted Python paths of template "
"tag modules to register with the template engine. This can be used to add "
"new libraries or provide alternate labels for existing ones. For example::"
msgstr ""
"``'libraries'``：模板标签模块的标签字典和点分隔 Python 路径，用于向模板引擎注"
"册。 这可用于添加新库或为现有库提供替代标签。例如："

msgid ""
"Libraries can be loaded by passing the corresponding dictionary key to the :"
"ttag:`{% load %}<load>` tag."
msgstr "可以通过将相应的字典键传递到 :ttag:`{% load %}<load>` 标签来加载库。"

msgid ""
"``'builtins'``: A list of dotted Python paths of template tag modules to add "
"to :doc:`built-ins </ref/templates/builtins>`. For example::"
msgstr ""
"``'builtins'``：要添加的 :doc:`内置模板标签和过滤器 </ref/templates/"
"builtins>` 的点分隔 Python 路径列表。例如："

msgid ""
"Tags and filters from built-in libraries can be used without first calling "
"the :ttag:`{% load %} <load>` tag."
msgstr ""
"可以使用内置库中的标签和过滤器，而不需要先调用 :ttag:`{% load %} <load>` 标"
"签。"

msgid "Requires Jinja2_ to be installed:"
msgstr "需要安装 Jinja2_："

msgid ""
"Set :setting:`BACKEND <TEMPLATES-BACKEND>` to ``'django.template.backends."
"jinja2.Jinja2'`` to configure a Jinja2_ engine."
msgstr ""
"设置 :setting:`BACKEND <TEMPLATES-BACKEND>` 为 ``'django.template.backends."
"jinja2.Jinja2'`` 以配置一个 Jinja2_ 引擎。"

msgid ""
"When :setting:`APP_DIRS <TEMPLATES-APP_DIRS>` is ``True``, ``Jinja2`` "
"engines look for templates in the ``jinja2`` subdirectory of installed "
"applications."
msgstr ""
"当 :setting:`APP_DIRS <TEMPLATES-APP_DIRS>` 为 ``True`` 时，``Jinja2`` 引擎会"
"在安装的应用程序的 ``jinja2`` 子目录中查找模板。"

msgid ""
"The most important entry in :setting:`OPTIONS <TEMPLATES-OPTIONS>` is "
"``'environment'``. It's a dotted Python path to a callable returning a "
"Jinja2 environment. It defaults to ``'jinja2.Environment'``. Django invokes "
"that callable and passes other options as keyword arguments. Furthermore, "
"Django adds defaults that differ from Jinja2's for a few options:"
msgstr ""
":setting:`OPTIONS <TEMPLATES-OPTIONS>` 中最重要的条目是 ``'environment'``。它"
"是一个点分隔 Python 路径，指向一个返回 Jinja2 环境的可调用对象。默认为 "
"``'jinja2.Environment'``。Django 调用该可调用对象并传递其他选项作为关键字参"
"数。此外，Django 为一些选项添加了不同于 Jinja2 的默认值。"

msgid "``'autoescape'``: ``True``"
msgstr "``'autoescape'``：``True``"

msgid ""
"``'loader'``: a loader configured for :setting:`DIRS <TEMPLATES-DIRS>` and :"
"setting:`APP_DIRS <TEMPLATES-APP_DIRS>`"
msgstr ""
"``'loader'``：为 :setting:`DIRS <TEMPLATES-DIRS>` 和 :setting:`APP_DIRS "
"<TEMPLATES-APP_DIRS>` 配置的加载器"

msgid "``'auto_reload'``: ``settings.DEBUG``"
msgstr "``'auto_reload'``：``settings.DEBUG``"

msgid "``'undefined'``: ``DebugUndefined if settings.DEBUG else Undefined``"
msgstr "``'undefined'``：``DebugUndefined if settings.DEBUG else Undefined``"

msgid ""
"``Jinja2`` engines also accept the following :setting:`OPTIONS <TEMPLATES-"
"OPTIONS>`:"
msgstr "``Jinja2`` 引擎也接受以下 :setting:`OPTIONS <TEMPLATES-OPTIONS>`："

msgid "Using context processors with Jinja2 templates is discouraged."
msgstr "不建议将上下文处理器与 Jinja2 模板一起使用。"

msgid ""
"Context processors are useful with Django templates because Django templates "
"don't support calling functions with arguments. Since Jinja2 doesn't have "
"that limitation, it's recommended to put the function that you would use as "
"a context processor in the global variables available to the template using "
"``jinja2.Environment`` as described below. You can then call that function "
"in the template:"
msgstr ""
"上下文处理器在 Django 模板中很有用，因为 Django 模板不支持调用带参数的函数。"
"由于 Jinja2 没有此限制，因此建议将你要用作上下文处理器的函数放在模板的全局变"
"量 ``jinja2.Environment`` 中使用，如下所述。然后你可以在模板中调用该函数。"

msgid ""
"Some Django templates context processors return a fixed value. For Jinja2 "
"templates, this layer of indirection isn't necessary since you can add "
"constants directly in ``jinja2.Environment``."
msgstr ""
"有些 Django 模板的上下文处理器会返回一个固定的值。对于 Jinja2 模板，不需要这"
"一层间接操作，因为您可以直接在 ``jinja2.Environment`` 中添加常量。"

msgid ""
"The original use case for adding context processors for Jinja2 involved:"
msgstr "最初为 Jinja2 增加上下文处理器的用例涉及："

msgid "Making an expensive computation that depends on the request."
msgstr "根据请求进行昂贵的计算。"

msgid "Needing the result in every template."
msgstr "在每个模板中都需要结果。"

msgid "Using the result multiple times in each template."
msgstr "在每个模板中多次使用结果。"

msgid ""
"Unless all of these conditions are met, passing a function to the template "
"is more in line with the design of Jinja2."
msgstr "除非满足所有这些条件，否则将函数传递给模板更符合 Jinja2 的设计。"

msgid ""
"The default configuration is purposefully kept to a minimum. If a template "
"is rendered with a request (e.g. when using :py:func:`~django.shortcuts."
"render`), the ``Jinja2`` backend adds the globals ``request``, "
"``csrf_input``, and ``csrf_token`` to the context. Apart from that, this "
"backend doesn't create a Django-flavored environment. It doesn't know about "
"Django filters and tags. In order to use Django-specific APIs, you must "
"configure them into the environment."
msgstr ""
"默认配置被有意地保持为最低。如果一个模板被请求渲染（例如，当使用 :py:func:"
"`~django.shortcuts.render`），``Jinja2`` 后端会在上下文中添加 ``request``，"
"``csrf_input`` 和 ``csrf_token``。除此之外，此后端不会创建 Django 风格的环"
"境。 它不知道 Django 过滤器和标签。 为了使用 Django 特有的 API，你必须将它们"
"配置到环境中。"

msgid "For example, you can create ``myproject/jinja2.py`` with this content::"
msgstr "例如，您可以使用以下内容创建 ``myproject/jinja2.py`` ："

msgid ""
"and set the ``'environment'`` option to ``'myproject.jinja2.environment'``."
msgstr "并将 ``'environment'`` 选项设置为 ``'myproject.jinja2.environment'``。"

msgid "Then you could use the following constructs in Jinja2 templates:"
msgstr "这样你就可以在 Jinja2 模板中使用以下构造："

msgid ""
"The concepts of tags and filters exist both in the Django template language "
"and in Jinja2 but they're used differently. Since Jinja2 supports passing "
"arguments to callables in templates, many features that require a template "
"tag or filter in Django templates can be achieved by calling a function in "
"Jinja2 templates, as shown in the example above. Jinja2's global namespace "
"removes the need for template context processors. The Django template "
"language doesn't have an equivalent of Jinja2 tests."
msgstr ""
"Django 模板语言和 Jinja2 中都存在标签和过滤器的概念，但使用方式不同。由于 "
"Jinja2 支持在模板中向可调用对象传递参数，所以很多在 Django 模板中需要模板标签"
"或过滤器的功能都可以通过在 Jinja2 模板中调用函数来实现，如上例所示。Jinja2 的"
"全局命名空间消除了对模板上下文处理器的需求。Django 模板语言并没有与 Jinja2 测"
"试相对应的功能。"

msgid "Advanced testing topics"
msgstr "进阶测试主题"

msgid "The request factory"
msgstr "请求工厂"

msgid ""
"The :class:`~django.test.RequestFactory` shares the same API as the test "
"client. However, instead of behaving like a browser, the RequestFactory "
"provides a way to generate a request instance that can be used as the first "
"argument to any view. This means you can test a view function the same way "
"as you would test any other function -- as a black box, with exactly known "
"inputs, testing for specific outputs."
msgstr ""
":class:`~django.test.RequestFactory` 与测试客户端共享相同的 API。 但是，"
"RequestFactory 不能像浏览器那样运行，而是提供一种生成请求实例的方法，该实例可"
"用作任何视图的第一个参数。 这意味着您可以像测试任何其他功能一样测试视图函数——"
"就像一个黑匣子一样，具有确切已知的输入，可以测试特定的输出。"

msgid ""
"The API for the :class:`~django.test.RequestFactory` is a slightly "
"restricted subset of the test client API:"
msgstr ""
":class:`~django.test.RequestFactory` 的 API 是测试客户端 API 的一个稍加限制的"
"子集。"

msgid ""
"It only has access to the HTTP methods :meth:`~Client.get()`, :meth:`~Client."
"post()`, :meth:`~Client.put()`, :meth:`~Client.delete()`, :meth:`~Client."
"head()`, :meth:`~Client.options()`, and :meth:`~Client.trace()`."
msgstr ""
"它只能访问 HTTP 的 :meth:`~Client.get()`、:meth:`~Client.post()`、:meth:"
"`~Client.put()`、:meth:`~Client.delete()`、:meth:`~Client.head()`、:meth:"
"`~Client.options()` 和 :meth:`~Client.trace()` 方法。"

msgid ""
"These methods accept all the same arguments *except* for ``follow``. Since "
"this is just a factory for producing requests, it's up to you to handle the "
"response."
msgstr ""
"这些方法接受所有相同的参数，*除了* ``follow``。因为这只是一个产生请求的工厂，"
"所以由你来处理响应。"

msgid ""
"It does not support middleware. Session and authentication attributes must "
"be supplied by the test itself if required for the view to function properly."
msgstr ""
"它不支持中间件。如果需要视图正常运行，会话和认证属性必须由测试本身提供。"

msgid "The following is a unit test using the request factory::"
msgstr "下面是一个使用请求工厂的单元测试："

msgid "AsyncRequestFactory"
msgstr "AsyncRequestFactory"

msgid ""
"``RequestFactory`` creates WSGI-like requests. If you want to create ASGI-"
"like requests, including having a correct ASGI ``scope``, you can instead "
"use ``django.test.AsyncRequestFactory``."
msgstr ""
"``RequestFactory`` 创建 WSGI 类的请求。如果你想创建 ASGI 类的请求，包括有一个"
"正确的 ASGI ``scope``，你可以使用 ``django.test.AsyncRequestFactory``。"

msgid ""
"This class is directly API-compatible with ``RequestFactory``, with the only "
"difference being that it returns ``ASGIRequest`` instances rather than "
"``WSGIRequest`` instances. All of its methods are still synchronous "
"callables."
msgstr ""
"该类与 ``RequestFactory`` 直接 API 兼容，唯一的区别是它返回 ``ASGIRequest`` "
"实例，而不是 ``WSGIRequest`` 实例。它的所有方法仍然是可同步调用的。"

msgid "Testing class-based views"
msgstr "测试基于类的视图"

msgid ""
"In order to test class-based views outside of the request/response cycle you "
"must ensure that they are configured correctly, by calling :meth:`~django."
"views.generic.base.View.setup` after instantiation."
msgstr ""
"为了在请求／响应周期之外测试基于类的视图，你必须确保它们配置正确，在实例化之"
"后调用 :meth:`~django.view.generic.base.View.setup`。"

msgid "For example, assuming the following class-based view:"
msgstr "例如，假设基于类的视图如下："

msgid ""
"You may directly test the ``get_context_data()`` method by first "
"instantiating the view, then passing a ``request`` to ``setup()``, before "
"proceeding with your test's code:"
msgstr ""
"你可以直接测试 ``get_context_data()`` 方法，首先实例化视图，然后向 "
"``setup()`` 传递一个 ``request``，然后再进行测试代码。"

msgid "tests.py"
msgstr "tests.py"

msgid "Tests and multiple host names"
msgstr "测试与多主机名"

msgid ""
"The :setting:`ALLOWED_HOSTS` setting is validated when running tests. This "
"allows the test client to differentiate between internal and external URLs."
msgstr ""
":setting:`ALLOWED_HOSTS` 配置在运行测试时被验证。这允许测试客户端区分内部和外"
"部 URL。"

msgid ""
"Projects that support multitenancy or otherwise alter business logic based "
"on the request's host and use custom host names in tests must include those "
"hosts in :setting:`ALLOWED_HOSTS`."
msgstr ""
"支持多租户或根据请求的主机改变业务逻辑的项目，以及在测试中使用自定义主机名的"
"项目，必须在 :setting:`ALLOWED_HOSTS` 中包含这些主机。"

msgid ""
"The first option to do so is to add the hosts to your settings file. For "
"example, the test suite for docs.djangoproject.com includes the following::"
msgstr ""
"第一个选项是将主机添加到你的配置文件中。例如，docs.djangoproject.com 的测试套"
"件包括以下内容："

msgid ""
"and the settings file includes a list of the domains supported by the "
"project::"
msgstr "同时配置文件包含项目支持的域列表："

msgid ""
"Another option is to add the required hosts to :setting:`ALLOWED_HOSTS` "
"using :meth:`~django.test.override_settings()` or :attr:`~django.test."
"SimpleTestCase.modify_settings()`. This option may be preferable in "
"standalone apps that can't package their own settings file or for projects "
"where the list of domains is not static (e.g., subdomains for multitenancy). "
"For example, you could write a test for the domain ``http://otherserver/`` "
"as follows::"
msgstr ""
"另一个选项是使用 :meth:`~django.test.override_settings()` 或 :attr:`~django."
"test.SimpleTestCase.modify_settings()` 将所需的主机添加到 :setting:"
"`ALLOWED_HOSTS` 中。这个选项在不能打包自己配置文件的独立应用中可能比较好，或"
"者对于域列表不是静态的项目（例如，多租户的子域）。例如，你可以为域 ``http://"
"otherserver/`` 写一个测试，如下所示："

msgid ""
"Disabling :setting:`ALLOWED_HOSTS` checking (``ALLOWED_HOSTS = ['*']``) when "
"running tests prevents the test client from raising a helpful error message "
"if you follow a redirect to an external URL."
msgstr ""
"当运行测试时，禁用 :setting:`ALLOWED_HOSTS` 检查（``ALLOWED_HOSTS = "
"['*']``），可以防止测试客户端在遵循重定向到外部 URL 时发出有用的错误信息。"

msgid "Tests and multiple databases"
msgstr "测试与多数据库"

msgid "Testing primary/replica configurations"
msgstr "测试主／副配置"

msgid ""
"If you're testing a multiple database configuration with primary/replica "
"(referred to as master/slave by some databases) replication, this strategy "
"of creating test databases poses a problem. When the test databases are "
"created, there won't be any replication, and as a result, data created on "
"the primary won't be seen on the replica."
msgstr ""
"如果你使用主／副本（某些数据库称为主／从）复制来测试多数据库配置，那么这种创"
"建测试数据库的策略会带来问题。当创建测试数据库时，不会有任何复制，因此，在主"
"服务器上创建的数据在副本上看不到。"

msgid ""
"To compensate for this, Django allows you to define that a database is a "
"*test mirror*. Consider the following (simplified) example database "
"configuration::"
msgstr ""
"为了弥补这一点，Django 允许你定义一个数据库是 *测试镜像*。考虑以下（简化的）"
"数据库配置示例："

msgid ""
"In this setup, we have two database servers: ``dbprimary``, described by the "
"database alias ``default``, and ``dbreplica`` described by the alias "
"``replica``. As you might expect, ``dbreplica`` has been configured by the "
"database administrator as a read replica of ``dbprimary``, so in normal "
"activity, any write to ``default`` will appear on ``replica``."
msgstr ""
"在这个设置中，我们有两个数据库服务器。``dbprimary``，用数据库别名 "
"``default`` 描述，``dbreplica`` 用别名 ``replica`` 描述。正如你所期望的那样，"
"``dbreplica`` 被数据库管理员配置为 ``dbprimary`` 的读副本，因此在正常活动中，"
"对 ``default`` 的任何写入都会出现在 ``replica`` 上。"

msgid ""
"If Django created two independent test databases, this would break any tests "
"that expected replication to occur. However, the ``replica`` database has "
"been configured as a test mirror (using the :setting:`MIRROR <TEST_MIRROR>` "
"test setting), indicating that under testing, ``replica`` should be treated "
"as a mirror of ``default``."
msgstr ""
"如果 Django 创建了两个独立的测试数据库，就会破坏任何期望复制发生的测试。然"
"而，``replica`` 数据库已经被配置为测试镜像（使用 :setting:`MIRROR "
"<TEST_MIRROR>` 测试设置），表明在测试中，``replica`` 应该被当作 ``default`` "
"的镜像。"

msgid ""
"When the test environment is configured, a test version of ``replica`` will "
"*not* be created. Instead the connection to ``replica`` will be redirected "
"to point at ``default``. As a result, writes to ``default`` will appear on "
"``replica`` -- but because they are actually the same database, not because "
"there is data replication between the two databases."
msgstr ""
"在配置测试环境时，``replica`` 的测试版本将 *不会* 被创建。相反，与"
"``replica`` 的连接将被重定向为指向 ``default``。因此，对 ``default`` 的写入将"
"出现在 ``replica`` 上——但这是因为它们实际上是同一个数据库，而不是因为两个数据"
"库之间有数据复制。"

msgid "Controlling creation order for test databases"
msgstr "控制测试数据库的创建顺序"

msgid ""
"By default, Django will assume all databases depend on the ``default`` "
"database and therefore always create the ``default`` database first. "
"However, no guarantees are made on the creation order of any other databases "
"in your test setup."
msgstr ""
"默认情况下，Django 会假设所有的数据库都依赖于 ``default`` 数据库，因此总是先"
"创建 ``default`` 数据库。但是，我们不保证测试配置中其他数据库的创建顺序。"

msgid ""
"If your database configuration requires a specific creation order, you can "
"specify the dependencies that exist using the :setting:`DEPENDENCIES "
"<TEST_DEPENDENCIES>` test setting. Consider the following (simplified) "
"example database configuration::"
msgstr ""
"如果你的数据库配置需要特定的创建顺序，你可以使用 :setting:`DEPENDENCIES "
"<TEST_DEPENDENCIES>` 测试设置指定存在的依赖关系。考虑以下（简化的）数据库配置"
"示例："

msgid ""
"Under this configuration, the ``diamonds`` database will be created first, "
"as it is the only database alias without dependencies. The ``default`` and "
"``clubs`` alias will be created next (although the order of creation of this "
"pair is not guaranteed), then ``hearts``, and finally ``spades``."
msgstr ""
"在这种配置下，将首先创建 ``diamonds`` 数据库，因为它是唯一没有依赖性的数据"
"库。接下来将创建 ``default`` 和 ``clubs`` 数据库（尽管这两个数据库的创建顺序"
"没有保证），然后是 ``hearts``，最后是 ``spades``。"

msgid ""
"If there are any circular dependencies in the :setting:`DEPENDENCIES "
"<TEST_DEPENDENCIES>` definition, an :exc:`~django.core.exceptions."
"ImproperlyConfigured` exception will be raised."
msgstr ""
"如果在 :setting:`DEPENDENCIES <TEST_DEPENDENCIES>` 定义中存在任何循环依赖关"
"系，将引发 :exc:`~django.core.exceptions.ImproperlyConfigured` 异常。"

msgid "Advanced features of ``TransactionTestCase``"
msgstr "``TransactionTestCase`` 高级特性"

msgid ""
"This attribute is a private API. It may be changed or removed without a "
"deprecation period in the future, for instance to accommodate changes in "
"application loading."
msgstr ""
"这个属性是一个私有的 API。它可能会在未来被更改或删除，而不会有废弃期，例如为"
"了适应应用程序加载的变化。"

msgid ""
"It's used to optimize Django's own test suite, which contains hundreds of "
"models but no relations between models in different applications."
msgstr ""
"它用来优化 Django 自己的测试套件，其中包含数百个模型，但不同应用中的模型之间"
"没有关系。"

msgid ""
"By default, ``available_apps`` is set to ``None``. After each test, Django "
"calls :djadmin:`flush` to reset the database state. This empties all tables "
"and emits the :data:`~django.db.models.signals.post_migrate` signal, which "
"recreates one content type and four permissions for each model. This "
"operation gets expensive proportionally to the number of models."
msgstr ""
"默认情况下，``available_apps`` 是设置为 ``None``。每次测试后，Django 都会调"
"用 :djadmin:`flush` 来重置数据库状态。这将清空所有表，并发出 :data:`~django."
"db.models.signals.post_migrate` 信号，为每个模型重新创建一个内容类型和四个权"
"限。这个操作的花费和模型的数量成正比。"

msgid ""
"Setting ``available_apps`` to a list of applications instructs Django to "
"behave as if only the models from these applications were available. The "
"behavior of ``TransactionTestCase`` changes as follows:"
msgstr ""
"将 ``available_apps`` 设置为应用程序列表会指示 Django 的行为就像只有这些应用"
"程序的模型是可用的一样。``TransactionTestCase`` 的行为改变如下："

msgid ""
":data:`~django.db.models.signals.post_migrate` is fired before each test to "
"create the content types and permissions for each model in available apps, "
"in case they're missing."
msgstr ""
":data:`~django.db.models.signals.post_migrate` 在每次测试前都会被触发，以创建"
"可用应用中每个模型的内容类型和权限，以防它们缺失。"

msgid ""
"After each test, Django empties only tables corresponding to models in "
"available apps. However, at the database level, truncation may cascade to "
"related models in unavailable apps. Furthermore :data:`~django.db.models."
"signals.post_migrate` isn't fired; it will be fired by the next "
"``TransactionTestCase``, after the correct set of applications is selected."
msgstr ""
"每次测试后，Django 只清空可用应用中模型对应的表。但在数据库层面，清空表可能会"
"级联到不可用应用中的相关模型。此外 :data:`~django.db.models.signals."
"post_migrate` 并没有被触发，它将在选择了正确的应用集后，由下一个 "
"``TransactionTestCase`` 触发。"

msgid ""
"Since the database isn't fully flushed, if a test creates instances of "
"models not included in ``available_apps``, they will leak and they may cause "
"unrelated tests to fail. Be careful with tests that use sessions; the "
"default session engine stores them in the database."
msgstr ""
"由于数据库没有完全刷新，如果测试创建了没有包含在 ``available_apps`` 中的模型"
"实例，它们就会泄漏，并可能导致不相关的测试失败。小心使用了会话的测试；默认的"
"会话引擎将它们存储在数据库中。"

msgid ""
"Since :data:`~django.db.models.signals.post_migrate` isn't emitted after "
"flushing the database, its state after a ``TransactionTestCase`` isn't the "
"same as after a ``TestCase``: it's missing the rows created by listeners to :"
"data:`~django.db.models.signals.post_migrate`. Considering the :ref:`order "
"in which tests are executed <order-of-tests>`, this isn't an issue, provided "
"either all ``TransactionTestCase`` in a given test suite declare "
"``available_apps``, or none of them."
msgstr ""
"由于 :data:`~django.db.models.signals.post_migrate` 在刷新数据库后并没有发"
"出，所以它在一个 ``TransactionTestCase`` 后的状态与一个 ``TestCase`` 后的状态"
"是不一样的：它丢失了由 :data:`~django.db.models.signals.post_migrate` 监听器"
"创建的行。考虑到 :ref:`执行测试的顺序 <order-of-tests>`，这并不是一个问题，只"
"要给定的测试套件中的所有 ``TransactionTestCase`` 都声明 ``available_apps``，"
"或者都没有声明。"

msgid "``available_apps`` is mandatory in Django's own test suite."
msgstr "``available_apps`` 在 Django 自己的测试套件中是强制性的。"

msgid ""
"Setting ``reset_sequences = True`` on a ``TransactionTestCase`` will make "
"sure sequences are always reset before the test run::"
msgstr ""
"在 ``TransactionTestCase`` 上设置 ``reset_sequences = True`` 将确保队列在测试"
"运行前总是被重置："

msgid ""
"Unless you are explicitly testing primary keys sequence numbers, it is "
"recommended that you do not hard code primary key values in tests."
msgstr "除非明确测试主键序列号，否则建议你不要在测试中硬编码主键值。"

msgid ""
"Using ``reset_sequences = True`` will slow down the test, since the primary "
"key reset is a relatively expensive database operation."
msgstr ""
"使用 ``reset_sequences = True`` 会减慢测试速度，因为主键重置是一个相对昂贵的"
"数据库操作。"

msgid "Enforce running test classes sequentially"
msgstr "强制按顺序运行测试类"

msgid ""
"If you have test classes that cannot be run in parallel (e.g. because they "
"share a common resource), you can use ``django.test.testcases."
"SerializeMixin`` to run them sequentially. This mixin uses a filesystem "
"``lockfile``."
msgstr ""
"如果你有一些测试类不能并行运行（例如，因为它们共享一个公共资源），你可以使用 "
"``django.test.testcases.SerializeMixin`` 来依次运行它们。这个 mixin 使用一个"
"文件系统 ``lockfile``。"

msgid ""
"For example, you can use ``__file__`` to determine that all test classes in "
"the same file that inherit from ``SerializeMixin`` will run sequentially::"
msgstr ""
"例如，你可以使用 ``__file__`` 来确定同一文件中所有继承自 ``SerializeMixin`` "
"的测试类将依次运行："

msgid "Using the Django test runner to test reusable applications"
msgstr "使用 Django 测试运行器测试可重用的应用程序"

msgid ""
"If you are writing a :doc:`reusable application </intro/reusable-apps>` you "
"may want to use the Django test runner to run your own test suite and thus "
"benefit from the Django testing infrastructure."
msgstr ""
"如果你正在编写一个 :doc:`可重用的应用程序 </intro/reusable-apps>`，你可能想使"
"用 Django 测试运行器来运行你自己的测试套件，从而从 Django 测试基础设施中获"
"益。"

msgid ""
"A common practice is a *tests* directory next to the application code, with "
"the following structure::"
msgstr "常见的做法是在应用代码旁边有一个 *tests* 目录，结构如下："

msgid "Let's take a look inside a couple of those files:"
msgstr "让我们看一下其中的两个文件："

msgid "runtests.py"
msgstr "runtests.py"

msgid ""
"This is the script that you invoke to run the test suite. It sets up the "
"Django environment, creates the test database and runs the tests."
msgstr "这是运行测试套件的脚本。它设置 Django 环境，创建测试数据库并运行测试。"

msgid ""
"For the sake of clarity, this example contains only the bare minimum "
"necessary to use the Django test runner. You may want to add command-line "
"options for controlling verbosity, passing in specific test labels to run, "
"etc."
msgstr ""
"为了清楚起见，这个例子只包含了使用 Django 测试运行器所需的最基本的内容。你可"
"能会要添加命令行选项来控制详细程度，传递要运行的特定测试标签等。"

msgid "tests/test_settings.py"
msgstr "tests/test_settings.py"

msgid ""
"This file contains the :doc:`Django settings </topics/settings>` required to "
"run your app's tests."
msgstr ""
"该文件包含运行应用程序测试所需的 :doc:`Django 配置 </topics/settings>`。"

msgid ""
"Again, this is a minimal example; your tests may require additional settings "
"to run."
msgstr "再次，这是一个最小的例子；你的测试可能需要其他设置才能运行。"

msgid ""
"Since the *tests* package is included in :setting:`INSTALLED_APPS` when "
"running your tests, you can define test-only models in its ``models.py`` "
"file."
msgstr ""
"由于 *tests* 包在运行测试时被包含在 :setting:`INSTALLED_APPS` 中，你可以在它"
"的 ``models.py`` 文件中定义只用于测试的模型。"

msgid "Using different testing frameworks"
msgstr "使用不同的测试框架"

msgid ""
"Clearly, :mod:`unittest` is not the only Python testing framework. While "
"Django doesn't provide explicit support for alternative frameworks, it does "
"provide a way to invoke tests constructed for an alternative framework as if "
"they were normal Django tests."
msgstr ""
"显然，:mod:`unittest` 并不是唯一的 Python 测试框架。虽然 Django 并没有提供对"
"替代框架的明确支持，但它确实提供了一种方法来调用为替代框架构建的测试，就像它"
"们是正常的 Django 测试一样。"

msgid ""
"When you run ``./manage.py test``, Django looks at the :setting:"
"`TEST_RUNNER` setting to determine what to do. By default, :setting:"
"`TEST_RUNNER` points to ``'django.test.runner.DiscoverRunner'``. This class "
"defines the default Django testing behavior. This behavior involves:"
msgstr ""
"当你运行 ``./manage.py test`` 时，Django 会查看 :setting:`TEST_RUNNER` 的配置"
"来决定做什么。默认情况下， :setting:`TEST_RUNNER` 指向 ``'django.test.runner."
"DiscoverRunner'``。这个类定义了默认的 Django 测试行为。这个行为包括："

msgid "Performing global pre-test setup."
msgstr "进行全局性的测试前设置。"

msgid ""
"Looking for tests in any file below the current directory whose name matches "
"the pattern ``test*.py``."
msgstr "在当前目录下的任何文件中寻找名称符合 ``test*.py`` 模式的测试。"

msgid "Creating the test databases."
msgstr "创建测试数据库。"

msgid ""
"Running ``migrate`` to install models and initial data into the test "
"databases."
msgstr "运行 ``migrate`` 将模型和初始数据安装到测试数据库中。"

msgid "Running the :doc:`system checks </topics/checks>`."
msgstr "运行 :doc:`系统检查 </topics/checks>`。"

msgid "Running the tests that were found."
msgstr "运行找到的测试。"

msgid "Destroying the test databases."
msgstr "销毁测试数据库。"

msgid "Performing global post-test teardown."
msgstr "进行全局性的测试后拆解。"

msgid ""
"If you define your own test runner class and point :setting:`TEST_RUNNER` at "
"that class, Django will execute your test runner whenever you run ``./manage."
"py test``. In this way, it is possible to use any test framework that can be "
"executed from Python code, or to modify the Django test execution process to "
"satisfy whatever testing requirements you may have."
msgstr ""
"如果你定义了自己的测试运行器类，并将 :setting:`TEST_RUNNER` 指向该类，那么每"
"当你运行 ``./manage.py test`` 时，Django 就会执行你的测试运行器。通过这种方"
"式，可以使用任何可以从 Python 代码中执行的测试框架，也可以修改 Django 测试执"
"行过程来满足你的任何测试需求。"

msgid "Defining a test runner"
msgstr "定义测试运行器"

msgid ""
"A test runner is a class defining a ``run_tests()`` method. Django ships "
"with a ``DiscoverRunner`` class that defines the default Django testing "
"behavior. This class defines the ``run_tests()`` entry point, plus a "
"selection of other methods that are used by ``run_tests()`` to set up, "
"execute and tear down the test suite."
msgstr ""
"测试运行器是一个类，他定义了 ``run_tests()`` 方法。Django 自带一个 "
"``DiscoverRunner`` 类，它定义了默认的 Django 测试行为。该类定义了进入点 "
"``run_tests()``，再加上对 ``run_tests()`` 所使用的其他方法的选择，以此来建"
"立，执行和拆除测试套件。"

msgid ""
"``DiscoverRunner`` will search for tests in any file matching ``pattern``."
msgstr "``DiscoverRunner`` 将在任何符合 ``pattern`` 的文件中搜索测试。"

msgid ""
"``top_level`` can be used to specify the directory containing your top-level "
"Python modules. Usually Django can figure this out automatically, so it's "
"not necessary to specify this option. If specified, it should generally be "
"the directory containing your ``manage.py`` file."
msgstr ""
"``top_level`` 可以用来指定包含顶级 Python 模块的目录。通常 Django 会自动计算"
"出这个目录，所以不需要指定这个选项。如果指定了这个选项，一般来说，它应该是包"
"含你的 ``manage.py`` 文件的目录。"

msgid ""
"``verbosity`` determines the amount of notification and debug information "
"that will be printed to the console; ``0`` is no output, ``1`` is normal "
"output, and ``2`` is verbose output."
msgstr ""
"``verbosity`` 决定将打印到控制台的通知和调试信息的数量；``0`` 为无输出，"
"``1`` 为正常输出，``2`` 为详细输出。"

msgid ""
"If ``interactive`` is ``True``, the test suite has permission to ask the "
"user for instructions when the test suite is executed. An example of this "
"behavior would be asking for permission to delete an existing test database. "
"If ``interactive`` is ``False``, the test suite must be able to run without "
"any manual intervention."
msgstr ""
"如果 ``interactive`` 是 ``True``，则测试套件在执行测试套件时，有权限向用户请"
"求指令。这种行为的一个例子是要求允许删除一个现有的测试数据库。如果 "
"``interactive`` 为 ``False``，测试套件必须能够在没有任何人工干预的情况下运"
"行。"

msgid ""
"If ``failfast`` is ``True``, the test suite will stop running after the "
"first test failure is detected."
msgstr ""
"如果 ``failfast`` 为 ``True``，测试套件将在检测到第一次测试失败后停止运行。"

msgid ""
"If ``keepdb`` is ``True``, the test suite will use the existing database, or "
"create one if necessary. If ``False``, a new database will be created, "
"prompting the user to remove the existing one, if present."
msgstr ""
"如果 ``keepdb`` 为 ``True``，测试套件将使用现有数据库，或在必要时创建一个数据"
"库。如果 ``False``，将创建一个新的数据库，并提示用户删除现有的数据库。"

msgid ""
"If ``reverse`` is ``True``, test cases will be executed in the opposite "
"order. This could be useful to debug tests that aren't properly isolated and "
"have side effects. :ref:`Grouping by test class <order-of-tests>` is "
"preserved when using this option. This option can be used in conjunction "
"with ``--shuffle`` to reverse the order for a particular random seed."
msgstr ""

msgid ""
"``debug_mode`` specifies what the :setting:`DEBUG` setting should be set to "
"prior to running tests."
msgstr ""
"``debug_mode`` 指定 :setting:`DEBUG` 设置在运行测试之前应该设置成什么。"

msgid ""
"``parallel`` specifies the number of processes.  If ``parallel`` is greater "
"than ``1``, the test suite will run in ``parallel`` processes. If there are "
"fewer test cases than configured processes, Django will reduce the number of "
"processes accordingly. Each process gets its own database. This option "
"requires the third-party ``tblib`` package to display tracebacks correctly."
msgstr ""
"``parallel`` 指定进程数。如果 ``parallel`` 大于 1，则测试套件会在 "
"``parallel`` （平行）进程下运行。如果测试用例比配置的进程少，Django 将会相应"
"地减少进程数量。每一个进程都有自己的数据库。该选择要求使用第三方包 ``tblib`` "
"来正确地显示回溯信息。"

msgid ""
"``tags`` can be used to specify a set of :ref:`tags for filtering tests "
"<topics-tagging-tests>`. May be combined with ``exclude_tags``."
msgstr ""
"``tags`` 用于指定一系列 :ref:`测试标签 <topics-tagging-tests>`。可以与 "
"``exclude_tags`` 结合使用。"

msgid ""
"``exclude_tags`` can be used to specify a set of :ref:`tags for excluding "
"tests <topics-tagging-tests>`. May be combined with ``tags``."
msgstr ""
"``exclude_tags`` 用于指定一系列 :ref:`排除测试标签 <topics-tagging-tests>`。"
"可以与 ``tags`` 结合使用。"

msgid ""
"If ``debug_sql`` is ``True``, failing test cases will output SQL queries "
"logged to the :ref:`django.db.backends logger <django-db-logger>` as well as "
"the traceback. If ``verbosity`` is ``2``, then queries in all tests are "
"output."
msgstr ""
"如果 ``debug_sql`` 为 ``True``，失败的测试用例会输出 SQL 查询记录到 :ref:"
"`django.db.backends logger <django-db-logger>` 以及回溯。如果 ``verbosity`` "
"是 ``2``，那么所有测试中的查询都会输出。"

msgid ""
"``test_name_patterns`` can be used to specify a set of patterns for "
"filtering test methods and classes by their names."
msgstr ""
"``test_name_patterns`` 可以用来指定一套模式，通过名称过滤测试方法和类。"

msgid ""
"If ``pdb`` is ``True``, a debugger (``pdb`` or ``ipdb``) will be spawned at "
"each test error or failure."
msgstr ""
"如果 ``pdb`` 为 ``True``，则每次测试错误或失败时都会产生一个调试器（``pdb`` "
"或 ``ipdb``）。"

msgid ""
"If ``buffer`` is ``True``, outputs from passing tests will be discarded."
msgstr "如果 ``buffer`` 为 ``True``，通过测试的输出将被丢弃。"

msgid ""
"If ``enable_faulthandler`` is ``True``, :py:mod:`faulthandler` will be "
"enabled."
msgstr ""
"如果 ``enable_faulthandler`` 是 ``True``，那么 :py:mod:`faulthandler` 将被启"
"用。"

msgid ""
"If ``timing`` is ``True``, test timings, including database setup and total "
"run time, will be shown."
msgstr ""
"如果 ``timing`` 是 ``True``，将显示测试时间，包括数据库设置和总运行时间。"

msgid ""
"If ``shuffle`` is an integer, test cases will be shuffled in a random order "
"prior to execution, using the integer as a random seed. If ``shuffle`` is "
"``None``, the seed will be generated randomly. In both cases, the seed will "
"be logged and set to ``self.shuffle_seed`` prior to running tests. This "
"option can be used to help detect tests that aren't properly isolated. :ref:"
"`Grouping by test class <order-of-tests>` is preserved when using this "
"option."
msgstr ""

msgid ""
"``logger`` can be used to pass a Python :py:ref:`Logger object <logger>`. If "
"provided, the logger will be used to log messages instead of printing to the "
"console. The logger object will respect its logging level rather than the "
"``verbosity``."
msgstr ""

msgid ""
"Django may, from time to time, extend the capabilities of the test runner by "
"adding new arguments. The ``**kwargs`` declaration allows for this "
"expansion. If you subclass ``DiscoverRunner`` or write your own test runner, "
"ensure it accepts ``**kwargs``."
msgstr ""
"Django 可能会不时地通过添加新的参数来扩展测试运行器的功能。``**kwargs`` 声明"
"允许这种扩展。如果你将 ``DiscoverRunner`` 子类化，或者编写你自己的测试运行"
"器，确保它接受 ``**kwargs``。"

msgid ""
"Your test runner may also define additional command-line options. Create or "
"override an ``add_arguments(cls, parser)`` class method and add custom "
"arguments by calling ``parser.add_argument()`` inside the method, so that "
"the :djadmin:`test` command will be able to use those arguments."
msgstr ""
"你的测试运行器也可以定义额外的命令行选项。创建或覆盖一个 "
"``add_arguments(cls, parser)`` 类方法，并通过在该方法中调用 ``parser."
"add_argument()`` 来添加自定义参数，这样 :djadmin:`test` 命令就可以使用这些参"
"数。"

msgid "The ``enable_faulthandler`` and ``timing`` arguments were added."
msgstr "增加了 ``enable_faulthandler`` 和 ``timing`` 参数。"

msgid "The ``logger`` and ``shuffle`` arguments were added."
msgstr ""

msgid "Attributes"
msgstr "属性"

msgid ""
"The class used to build the test suite. By default it is set to ``unittest."
"TestSuite``. This can be overridden if you wish to implement different logic "
"for collecting tests."
msgstr ""
"用于构建测试套件的类。默认情况下，它被设置为 ``unittest.TestSuite``。如果你想"
"实现不同的测试收集逻辑，可以重写这个类。"

msgid ""
"This is the class of the low-level test runner which is used to execute the "
"individual tests and format the results. By default it is set to ``unittest."
"TextTestRunner``. Despite the unfortunate similarity in naming conventions, "
"this is not the same type of class as ``DiscoverRunner``, which covers a "
"broader set of responsibilities. You can override this attribute to modify "
"the way tests are run and reported."
msgstr ""
"这是低级测试运行器的类，用于执行各个测试和格式化结果。默认情况下，它被设置为 "
"``unittest.TextTestRunner``。尽管在命名习惯上有不幸的相似之处，但这与 "
"``DiscoverRunner`` 不是同一类型的类，后者涵盖了更广泛的职责。你可以覆盖这个属"
"性来修改测试运行和报告的方式。"

msgid ""
"This is the class that loads tests, whether from TestCases or modules or "
"otherwise and bundles them into test suites for the runner to execute. By "
"default it is set to ``unittest.defaultTestLoader``. You can override this "
"attribute if your tests are going to be loaded in unusual ways."
msgstr ""
"这是一个加载测试的类，无论是从 TestCases 还是模块或其他方面加载测试，并将它们"
"捆绑成测试套件供运行者执行。默认情况下，它被设置为 ``unittest."
"defaultTestLoader``。如果你的测试要以不寻常的方式加载，你可以重写这个属性。"

msgid "Methods"
msgstr "方法"

msgid "Run the test suite."
msgstr "运行测试套件。"

msgid ""
"``test_labels`` allows you to specify which tests to run and supports "
"several formats (see :meth:`DiscoverRunner.build_suite` for a list of "
"supported formats)."
msgstr ""
"``test_labels`` 允许你指定要运行的测试，并支持多种格式（参见 :meth:"
"`DiscoverRunner.build_suite` 获取支持的格式列表）。"

msgid ""
"``extra_tests`` is a list of extra ``TestCase`` instances to add to the "
"suite that is executed by the test runner. These extra tests are run in "
"addition to those discovered in the modules listed in ``test_labels``."
msgstr ""
"``extra_tests`` 是一个额外的 ``TestCase`` 实例列表，用于添加到测试运行器执行"
"的套件中。这些额外的测试是在 ``test_labels`` 中列出的模块中发现的测试之外运行"
"的。"

msgid "This method should return the number of tests that failed."
msgstr "这个方法应该返回失败的测试次数。"

msgid ""
"Override this class method to add custom arguments accepted by the :djadmin:"
"`test` management command. See :py:meth:`argparse.ArgumentParser."
"add_argument()` for details about adding arguments to a parser."
msgstr ""
"重写这个类方法来添加 :djadmin:`test` 管理命令接受的自定义参数。参见 :py:meth:"
"`argparse.ArgumentParser.add_argument()` 了解关于向解析器添加参数的详细信息。"

msgid ""
"Sets up the test environment by calling :func:`~django.test.utils."
"setup_test_environment` and setting :setting:`DEBUG` to ``self.debug_mode`` "
"(defaults to ``False``)."
msgstr ""
"通过调用 :func:`~django.test.utils.setup_test_environment` 和设置 :setting:"
"`DEBUG` 为 ``self.debug_mode`` （默认为 ``False``）来设置测试环境。"

msgid "Constructs a test suite that matches the test labels provided."
msgstr "构建一个与提供的测试标签相匹配的测试套件。"

msgid ""
"``test_labels`` is a list of strings describing the tests to be run. A test "
"label can take one of four forms:"
msgstr ""
"``test_labels`` 是描述要运行的测试的字符串列表。测试标签可以采取以下四种形式"
"之一："

msgid ""
"``path.to.test_module.TestCase.test_method`` -- Run a single test method in "
"a test case."
msgstr ""
"``path.to.test_module.TestCase.test_method``——在测试用例中运行一个测试方法。"

msgid ""
"``path.to.test_module.TestCase`` -- Run all the test methods in a test case."
msgstr "``path.to.test_module.TestCase``——运行测试用例中的所有测试方法。"

msgid ""
"``path.to.module`` -- Search for and run all tests in the named Python "
"package or module."
msgstr "``path.to.module``——搜索并运行命名的 Python 包或模块中的所有测试。"

msgid ""
"``path/to/directory`` -- Search for and run all tests below the named "
"directory."
msgstr "``path/to/directory``——搜索并运行指定目录下的所有测试。"

msgid ""
"If ``test_labels`` has a value of ``None``, the test runner will search for "
"tests in all files below the current directory whose names match its "
"``pattern`` (see above)."
msgstr ""
"如果 ``test_labels`` 的值为 ``None``，测试运行器将在当前目录下所有文件中搜索"
"名称符合 ``pattern`` 的测试（见上文）。"

msgid "Returns a ``TestSuite`` instance ready to be run."
msgstr "返回一个准备运行的 ``TestSuite`` 实例。"

msgid ""
"Creates the test databases by calling :func:`~django.test.utils."
"setup_databases`."
msgstr "通过调用 :func:`~django.test.utils.setup_databases` 创建测试数据库。"

msgid ""
"Runs the :doc:`system checks </topics/checks>` on the test ``databases``."
msgstr "在测试的 ``databases`` 上运行 :doc:`系统检查 </topics/checks>`。"

msgid "Runs the test suite."
msgstr "运行测试套件。"

msgid "Returns the result produced by the running the test suite."
msgstr "返回运行测试套件所产生的结果。"

msgid ""
"Returns the keyword arguments to instantiate the ``DiscoverRunner."
"test_runner`` with."
msgstr "返回实例化 ``DiscoverRunner.test_runner`` 的关键字参数。"

msgid ""
"Destroys the test databases, restoring pre-test conditions by calling :func:"
"`~django.test.utils.teardown_databases`."
msgstr ""
"通过调用 :func:`~django.test.utils.trapdown_databases` 来销毁测试数据库，恢复"
"测试前的条件。"

msgid "Restores the pre-test environment."
msgstr "恢复测试前的环境。"

msgid ""
"Computes and returns a return code based on a test suite, and the result "
"from that test suite."
msgstr "计算并返回一个返回码，基于测试套件和测试套件返回的结果。"

msgid ""
"If a ``logger`` is set, logs the message at the given integer `logging "
"level`_ (e.g. ``logging.DEBUG``, ``logging.INFO``, or ``logging.WARNING``). "
"Otherwise, the message is printed to the console, respecting the current "
"``verbosity``. For example, no message will be printed if the ``verbosity`` "
"is 0, ``INFO`` and above will be printed if the ``verbosity`` is at least 1, "
"and ``DEBUG`` will be printed if it is at least 2. The ``level`` defaults to "
"``logging.INFO``."
msgstr ""

msgid "Testing utilities"
msgstr "测试工具集"

msgid "``django.test.utils``"
msgstr "``django.test.utils``"

msgid ""
"To assist in the creation of your own test runner, Django provides a number "
"of utility methods in the ``django.test.utils`` module."
msgstr ""
"为了帮助创建自己的测试运行器，Django 在 ``django.test.utils`` 模块中提供了一"
"些实用的方法。"

msgid ""
"Performs global pre-test setup, such as installing instrumentation for the "
"template rendering system and setting up the dummy email outbox."
msgstr ""
"执行全局性的测试前设置，如为模板渲染系统安装仪器，设置虚拟的电子邮件发件箱。"

msgid ""
"If ``debug`` isn't ``None``, the :setting:`DEBUG` setting is updated to its "
"value."
msgstr "如果 ``debug`` 不是 ``None``，则 :setting:`DEBUG` 配置更新为其值。"

msgid ""
"Performs global post-test teardown, such as removing instrumentation from "
"the template system and restoring normal email services."
msgstr ""
"进行全局性的测试后拆解，如从模板系统中删除仪器设备，恢复正常的邮件服务。"

msgid "Creates the test databases."
msgstr "创建测试数据库。"

msgid ""
"Returns a data structure that provides enough detail to undo the changes "
"that have been made. This data will be provided to the :func:"
"`teardown_databases` function at the conclusion of testing."
msgstr ""
"返回一个数据结构，该结构提供了足够的细节来撤销已做的更改。这些数据将在测试结"
"束后提供给 :func:`teardown_databases` 函数。"

msgid ""
"The ``aliases`` argument determines which :setting:`DATABASES` aliases test "
"databases should be set up for. If it's not provided, it defaults to all of :"
"setting:`DATABASES` aliases."
msgstr ""

msgid ""
"The ``serialized_aliases`` argument determines what subset of ``aliases`` "
"test databases should have their state serialized to allow usage of the :ref:"
"`serialized_rollback <test-case-serialized-rollback>` feature. If it's not "
"provided, it defaults to ``aliases``."
msgstr ""

msgid ""
"The ``time_keeper`` kwarg was added, and all kwargs were made keyword-only."
msgstr ""
"增加了 ``time_keeper`` 关键字，并且所有的 kwargs 都变成了仅关键字参数。"

msgid "The ``serialized_aliases`` kwarg was added."
msgstr ""

msgid "Destroys the test databases, restoring pre-test conditions."
msgstr "销毁测试数据库，恢复测试前的条件。"

msgid ""
"``old_config`` is a data structure defining the changes in the database "
"configuration that need to be reversed. It's the return value of the :meth:"
"`setup_databases` method."
msgstr ""
"``old_config`` 是一个数据结构，定义了数据库配置中需要撤销的变化。它是 :meth:"
"`setup_databases` 方法的返回值。"

msgid "``django.db.connection.creation``"
msgstr "``django.db.connection.creation``"

msgid ""
"The creation module of the database backend also provides some utilities "
"that can be useful during testing."
msgstr "数据库后台的创建模块还提供了一些在测试过程中有用的实用程序。"

msgid "Creates a new test database and runs ``migrate`` against it."
msgstr "创建一个新的测试数据库并对其运行 ``migrate``。"

msgid "``verbosity`` has the same behavior as in ``run_tests()``."
msgstr "``verbosity`` 与 ``run_tests()`` 中的行为相同。"

msgid ""
"``autoclobber`` describes the behavior that will occur if a database with "
"the same name as the test database is discovered:"
msgstr "``autoclobber`` 描述了在发现与测试数据库同名的数据库时将发生的行为。"

msgid ""
"If ``autoclobber`` is ``False``, the user will be asked to approve "
"destroying the existing database. ``sys.exit`` is called if the user does "
"not approve."
msgstr ""
"如果 ``autoclobber`` 为 ``False``，将要求用户批准销毁现有数据库。如果用户不同"
"意，则调用 ``sys.exit``。"

msgid ""
"If autoclobber is ``True``, the database will be destroyed without "
"consulting the user."
msgstr "如果 autoclobber 为 ``True``，数据库将在不与用户协商的情况下被销毁。"

msgid ""
"``serialize`` determines if Django serializes the database into an in-memory "
"JSON string before running tests (used to restore the database state between "
"tests if you don't have transactions). You can set this to ``False`` to "
"speed up creation time if you don't have any test classes with :ref:"
"`serialized_rollback=True <test-case-serialized-rollback>`."
msgstr ""
"``serialize`` 决定 Django 是否在运行测试之前将数据库序列化为内存中的 JSON 字"
"符串（如果没有事务，用于在测试之间恢复数据库状态）。如果你没有使用 :ref:"
"`serialized_rollback=True <test-case-serialized-rollback>` 的测试类，你可以将"
"其设置为 ``False`` 以加快创建时间。"

msgid ""
"If you are using the default test runner, you can control this with the the :"
"setting:`SERIALIZE <TEST_SERIALIZE>` entry in the :setting:`TEST <DATABASE-"
"TEST>` dictionary."
msgstr ""
"如果你使用的是默认的测试运行器，你可以通过 :setting:`TEST <DATABASE-TEST> ` "
"字典中的 :setting:`SERIALIZE <TEST_SERIALIZE>` 条目来控制。"

msgid ""
"``keepdb`` determines if the test run should use an existing database, or "
"create a new one. If ``True``, the existing database will be used, or "
"created if not present. If ``False``, a new database will be created, "
"prompting the user to remove the existing one, if present."
msgstr ""
"``keepdb`` 决定测试运行是否应使用现有数据库，还是创建一个新的数据库。如果 "
"`True``，则使用现有的数据库，如果不存在，则创建新的数据库。如果 ``False``，则"
"创建一个新的数据库，并提示用户删除现有的数据库（如果存在）。"

msgid "Returns the name of the test database that it created."
msgstr "返回其创建的测试数据库的名称。"

msgid ""
"``create_test_db()`` has the side effect of modifying the value of :setting:"
"`NAME` in :setting:`DATABASES` to match the name of the test database."
msgstr ""
"``create_test_db()`` 的副作用是修改 :setting:`DATABASES` 中的 :setting:"
"`NAME` 的值，使其与测试数据库的名称相匹配。"

msgid ""
"Destroys the database whose name is the value of :setting:`NAME` in :setting:"
"`DATABASES`, and sets :setting:`NAME` to the value of ``old_database_name``."
msgstr ""
"销毁名称为 :setting:`DATABASES` 中 :setting:`NAME` 值的数据库，并将 :setting:"
"`NAME` 设置为 ``old_database_name`` 值。"

msgid ""
"The ``verbosity`` argument has the same behavior as for :class:`~django.test."
"runner.DiscoverRunner`."
msgstr ""
"``verbosity``  参数和测试类 :class:`~django.test.runner.DiscoverRunner` 的行"
"为一样。"

msgid ""
"If the ``keepdb`` argument is ``True``, then the connection to the database "
"will be closed, but the database will not be destroyed."
msgstr ""
"如果 ``keepdb`` 的参数为 ``True`` ，数据库连接会被关闭，但是数据库不会被销"
"毁。"

msgid "Integration with ``coverage.py``"
msgstr "集成 ``coverage.py``"

msgid ""
"Code coverage describes how much source code has been tested. It shows which "
"parts of your code are being exercised by tests and which are not. It's an "
"important part of testing applications, so it's strongly recommended to "
"check the coverage of your tests."
msgstr ""
"代码覆盖度表示有多少源代码被测试了。它表明了代码的哪些部分被测试用例覆盖，哪"
"些没有。这是测试应用很重要的部分，所以强烈推荐检查测试用例的覆盖度。"

msgid ""
"Django can be easily integrated with `coverage.py`_, a tool for measuring "
"code coverage of Python programs. First, `install coverage.py`_. Next, run "
"the following from your project folder containing ``manage.py``::"
msgstr ""
"Django很容易集成 `coverage.py` ，一个测试Python程序的代码覆盖度的工具。首"
"先， `安装 coverage.py`_ 。然后， 在包含 ``manage.py`` 的项目文件夹下运行。"

msgid ""
"This runs your tests and collects coverage data of the executed files in "
"your project. You can see a report of this data by typing following command::"
msgstr ""
"这样就会跑你的测试用例然后收集你的项目中被执行的文件的覆盖率数据。你可以通过"
"输入如下命令来输出这个结果的报告。"

msgid ""
"Note that some Django code was executed while running tests, but it is not "
"listed here because of the ``source`` flag passed to the previous command."
msgstr ""
"请注意一些Django代码会在运行期间被执行，但是因为在上一条命令中没有 "
"``source`` 选项所以在这里没有列出。"

msgid ""
"For more options like annotated HTML listings detailing missed lines, see "
"the `coverage.py`_ docs."
msgstr ""
"关于类似于输出详细内容的HTML列举的没有覆盖区域的选项，请查阅 `coverage.py`_ "
"的文档。"

msgid "Testing in Django"
msgstr "Django 中的测试"

msgid ""
"Automated testing is an extremely useful bug-killing tool for the modern web "
"developer. You can use a collection of tests -- a **test suite** -- to "
"solve, or avoid, a number of problems:"
msgstr ""

msgid ""
"When you're writing new code, you can use tests to validate your code works "
"as expected."
msgstr "当你编写新代码时，你可以利用测试确保代码按照期望的方式运行。"

msgid ""
"When you're refactoring or modifying old code, you can use tests to ensure "
"your changes haven't affected your application's behavior unexpectedly."
msgstr "当你重构或修改旧代码，你可以利用测试来确保你的修改不会使应用运行出错。"

msgid ""
"Testing a web application is a complex task, because a web application is "
"made of several layers of logic -- from HTTP-level request handling, to form "
"validation and processing, to template rendering. With Django's test-"
"execution framework and assorted utilities, you can simulate requests, "
"insert test data, inspect your application's output and generally verify "
"your code is doing what it should be doing."
msgstr ""

msgid ""
"The preferred way to write tests in Django is using the :mod:`unittest` "
"module built-in to the Python standard library. This is covered in detail in "
"the :doc:`overview` document."
msgstr ""
"在 Django 中编写测试的首选方式是使用 Python 标准库中内置的 :mod:`unittest` 模"
"块。这一点在 :doc:`overview` 文档中有详细介绍。"

msgid ""
"You can also use any *other* Python test framework; Django provides an API "
"and tools for that kind of integration. They are described in the :ref:"
"`other-testing-frameworks` section of :doc:`advanced`."
msgstr ""
"你也可以使用 *另一个* Python 测试框架；Django 提供了用于这种集成的 API 和工"
"具。这在 :doc:`advanced` 的 :ref:`other-testing-frameworks` 章节中有介绍。"

msgid "Writing and running tests"
msgstr "编写并运行测试"

msgid ""
"The :doc:`testing tutorial </intro/tutorial05>`, the :doc:`testing tools "
"reference </topics/testing/tools>`, and the :doc:`advanced testing topics </"
"topics/testing/advanced>`."
msgstr ""
":doc:`测试教程 </intro/tutorial05>`， :doc:`测试工具参考 </topics/testing/"
"tools>` 和 :doc:`进阶测试主题 </topics/testing/advanced>`。"

msgid ""
"This document is split into two primary sections. First, we explain how to "
"write tests with Django. Then, we explain how to run them."
msgstr ""
"本文档主要分为两部分。首先，我们介绍如何利用 Django 编写测试。接着，我们介绍"
"如何运行它们。"

msgid ""
"Django's unit tests use a Python standard library module: :mod:`unittest`. "
"This module defines tests using a class-based approach."
msgstr ""
"Django 的单元测试采用 Python 的标准模块： :mod:`unittest`。该模块以类的形式定"
"义测试。"

msgid ""
"Here is an example which subclasses from :class:`django.test.TestCase`, "
"which is a subclass of :class:`unittest.TestCase` that runs each test inside "
"a transaction to provide isolation::"
msgstr ""
"下面是一个例子，它是 :class:`django.test.TestCase` 的子类，同时父类也是 :"
"class:`unittest.TestCase` 的子类，在事务内部运行每个测试以提供隔离："

msgid ""
"When you :ref:`run your tests <running-tests>`, the default behavior of the "
"test utility is to find all the test cases (that is, subclasses of :class:"
"`unittest.TestCase`) in any file whose name begins with ``test``, "
"automatically build a test suite out of those test cases, and run that suite."
msgstr ""
"当你 :ref:`运行你的测试 <running-tests>` 时，测试工具的默认行为是在任何名字"
"以 ``test`` 开头的文件中找到所有的测试用例（也就是 :class:`unittest."
"TestCase` 的子类），从这些测试用例中自动构建一个测试套件，然后运行该套件。"

msgid "For more details about :mod:`unittest`, see the Python documentation."
msgstr "更多关于 :mod:`unittest` 的细节，参考 Python 文档。"

msgid "Where should the tests live?"
msgstr "测试代码应该放在哪？"

msgid ""
"The default :djadmin:`startapp` template creates a ``tests.py`` file in the "
"new application. This might be fine if you only have a few tests, but as "
"your test suite grows you'll likely want to restructure it into a tests "
"package so you can split your tests into different submodules such as "
"``test_models.py``, ``test_views.py``, ``test_forms.py``, etc. Feel free to "
"pick whatever organizational scheme you like."
msgstr ""
"默认的 :djadmin:`startapp` 会在新的应用程序中创建一个 ``tests.py`` 文件。如果"
"你只有几个测试，这可能是好的，但随着你的测试套件的增长，你可能会想把它重组为"
"一个测试包，这样你就可以把你的测试分成不同的子模块，如 ``test_models.py``、"
"``test_views.py``、``test_forms.py`` 等。你可以自由选择任何你喜欢的组织方案。"

msgid "See also :ref:`testing-reusable-applications`."
msgstr "另请参阅 :ref:`testing-reusable-applications`。"

msgid ""
"If your tests rely on database access such as creating or querying models, "
"be sure to create your test classes as subclasses of :class:`django.test."
"TestCase` rather than :class:`unittest.TestCase`."
msgstr ""
"如果你的测试依赖数据库连接，比如创建或查询模型，请确保继承 :class:`django."
"test.TestCase` 实现你的测试类，而不是 :class:`unittest.TestCase`。"

msgid ""
"Using :class:`unittest.TestCase` avoids the cost of running each test in a "
"transaction and flushing the database, but if your tests interact with the "
"database their behavior will vary based on the order that the test runner "
"executes them. This can lead to unit tests that pass when run in isolation "
"but fail when run in a suite."
msgstr ""
"使用 :class:`unittest.TestCase` 避免了在事务中运行每个测试并刷新数据库的成"
"本，但如果你的测试与数据库交互，它们的行为将根据测试运行器执行它们的顺序而变"
"化。这可能导致单元测试在单独运行时通过，但在套件中运行时失败。"

msgid "Running tests"
msgstr "运行测试"

msgid ""
"Once you've written tests, run them using the :djadmin:`test` command of "
"your project's ``manage.py`` utility::"
msgstr ""
"编写完测试后，使用项目的 ``manage.py`` 实用程序的 :djadmin:`test` 命令运行它"
"们："

msgid ""
"Test discovery is based on the unittest module's :py:ref:`built-in test "
"discovery <unittest-test-discovery>`.  By default, this will discover tests "
"in any file named \"test*.py\" under the current working directory."
msgstr ""
"测试发现是基于 unittest 模块的 :py:ref:`内建测试发现 <unittest-test-"
"discovery>`。默认情况下，这将发现当前工作目录下任何名为“test*.py”的文件中的测"
"试。"

msgid ""
"You can specify particular tests to run by supplying any number of \"test "
"labels\" to ``./manage.py test``. Each test label can be a full Python "
"dotted path to a package, module, ``TestCase`` subclass, or test method. For "
"instance::"
msgstr ""
"你可以通过向 ``./manage.py test`` 提供任意数量的“测试标签”来指定要运行的特定"
"测试。每个测试标签可以是指向包、模块、``TestCase`` 子类或测试方法的点分隔 "
"Python 路径。例如："

msgid ""
"You can also provide a path to a directory to discover tests below that "
"directory::"
msgstr "你还可以提供目录路径，以发现该目录下的测试："

msgid ""
"You can specify a custom filename pattern match using the ``-p`` (or ``--"
"pattern``) option, if your test files are named differently from the ``test*."
"py`` pattern::"
msgstr ""
"如果你的测试文件的命名与 ``test*.py`` 模式不同，你可以使用 ``-p`` （或 ``--"
"pattern``）选项指定一个自定义文件名模式匹配："

msgid ""
"If you press ``Ctrl-C`` while the tests are running, the test runner will "
"wait for the currently running test to complete and then exit gracefully. "
"During a graceful exit the test runner will output details of any test "
"failures, report on how many tests were run and how many errors and failures "
"were encountered, and destroy any test databases as usual. Thus pressing "
"``Ctrl-C`` can be very useful if you forget to pass the :option:`--failfast "
"<test --failfast>` option, notice that some tests are unexpectedly failing "
"and want to get details on the failures without waiting for the full test "
"run to complete."
msgstr ""
"如果你在测试运行时按 ``Ctrl-C``，测试运行器将等待当前运行的测试完成，然后优雅"
"地退出。在优雅退出过程中，测试运行器将输出任何测试失败的细节，报告运行了多少"
"次测试，遇到了多少次错误和失败，并像往常一样销毁任何测试数据库。因此，如果你"
"忘记了传入 :option:`--failfast <test --failfast>` 选项，注意到一些测试意外地"
"失败了，并且想在不等待整个测试运行完成的情况下获得失败的细节，那么按下 "
"``Ctrl-C`` 就会非常有用。"

msgid ""
"If you do not want to wait for the currently running test to finish, you can "
"press ``Ctrl-C`` a second time and the test run will halt immediately, but "
"not gracefully. No details of the tests run before the interruption will be "
"reported, and any test databases created by the run will not be destroyed."
msgstr ""
"如果你不想等待当前正在进行的测试结束，你可以按两次 ``Ctrl-C``，测试运行将立即"
"停止，但不会优雅地停止。不会报告中断前运行的测试细节，也不会销毁运行中创建的"
"任何测试数据库。"

msgid "Test with warnings enabled"
msgstr "在启用警告的情况下进行测试"

msgid ""
"It's a good idea to run your tests with Python warnings enabled: ``python -"
"Wa manage.py test``. The ``-Wa`` flag tells Python to display deprecation "
"warnings. Django, like many other Python libraries, uses these warnings to "
"flag when features are going away. It also might flag areas in your code "
"that aren't strictly wrong but could benefit from a better implementation."
msgstr ""
"启用 Python 警告来运行测试是个好主意：``python -Wa manage.py test``。``-Wa`` "
"标志告诉 Python 显示弃用警告。Django 和其他 Python 库一样，使用这些警告标志着"
"功能的消失。它也可以标记你的代码中严格来说没有错误的但可以从更好的实现中受益"
"的地方。"

msgid "The test database"
msgstr "测试数据库"

msgid ""
"Tests that require a database (namely, model tests) will not use your \"real"
"\" (production) database. Separate, blank databases are created for the "
"tests."
msgstr ""
"需要数据库的测试（即模型测试）将不会使用“实际”（生产）数据库。 将为测试创建单"
"独的空白数据库。"

msgid ""
"Regardless of whether the tests pass or fail, the test databases are "
"destroyed when all the tests have been executed."
msgstr "无论测试是通过还是失败，当所有测试执行完毕后，测试数据库都会被销毁。"

msgid ""
"You can prevent the test databases from being destroyed by using the :option:"
"`test --keepdb` option. This will preserve the test database between runs. "
"If the database does not exist, it will first be created. Any migrations "
"will also be applied in order to keep it up to date."
msgstr ""
"你可以通过使用 :option:`test --keepdb` 选项来防止测试数据库被破坏。 这将在两"
"次运行之间保留测试数据库。 如果数据库不存在，将首先创建它。 任何迁移都将被应"
"用，以使其保持最新状态。"

msgid ""
"As described in the previous section, if a test run is forcefully "
"interrupted, the test database may not be destroyed. On the next run, you'll "
"be asked whether you want to reuse or destroy the database. Use the :option:"
"`test --noinput` option to suppress that prompt and automatically destroy "
"the database. This can be useful when running tests on a continuous "
"integration server where tests may be interrupted by a timeout, for example."
msgstr ""
"如上一节所述，如果测试运行被强行中断，测试数据库可能不会被销毁。在下一次运行"
"时，你会被问到是要重新使用还是销毁数据库。使用 :option:`test --noinput` 选项"
"禁止显示该提示并自动销毁数据库。 例如，在持续集成服务器上运行测试时这很有用，"
"该测试可能会因超时而中断。"

msgid ""
"The default test database names are created by prepending ``test_`` to the "
"value of each :setting:`NAME` in :setting:`DATABASES`. When using SQLite, "
"the tests will use an in-memory database by default (i.e., the database will "
"be created in memory, bypassing the filesystem entirely!). The :setting:"
"`TEST <DATABASE-TEST>` dictionary in :setting:`DATABASES` offers a number of "
"settings to configure your test database. For example, if you want to use a "
"different database name, specify :setting:`NAME <TEST_NAME>` in the :setting:"
"`TEST <DATABASE-TEST>` dictionary for any given database in :setting:"
"`DATABASES`."
msgstr ""
"默认的测试数据库名称是通过在 :setting:`DATABASES` 中每个 :setting:`NAME` 的值"
"前加上 ``test_`` 来创建的。当使用 SQLite时，默认情况下测试将使用内存数据库"
"（即数据库将在内存中创建，完全绕开文件系统！）。:setting:`DATABASES` 中的 :"
"setting:`TEST <DATABASE-TEST>` 字典提供了许多设置来配置你的测试数据库。例如，"
"如果你想使用不同的数据库名称，给 :setting:`DATABASES` 中的每个数据库在 :"
"setting:`TEST <DATABASE-TEST>` 字典中指定 :setting:`NAME <TEST_NAME>`。"

msgid ""
"On PostgreSQL, :setting:`USER` will also need read access to the built-in "
"``postgres`` database."
msgstr ""
"在 PostgreSQL 上，:setting:`USER` 也需要对内置的 ``postgres`` 数据库进行读取"
"访问。"

msgid ""
"Aside from using a separate database, the test runner will otherwise use all "
"of the same database settings you have in your settings file: :setting:"
"`ENGINE <DATABASE-ENGINE>`, :setting:`USER`, :setting:`HOST`, etc. The test "
"database is created by the user specified by :setting:`USER`, so you'll need "
"to make sure that the given user account has sufficient privileges to create "
"a new database on the system."
msgstr ""
"除了使用单独的数据库外，测试运行器还将使用你在配置文件中的所有相同的数据库设"
"置： :setting:`ENGINE <DATABASE-ENGINE>`、:setting:`USER`、:setting:`HOST` "
"等。测试数据库是由 :setting:`USER` 指定的用户创建的，所以你需要确保给定的用户"
"账户有足够的权限在系统上创建一个新的数据库。"

msgid ""
"For fine-grained control over the character encoding of your test database, "
"use the :setting:`CHARSET <TEST_CHARSET>` TEST option. If you're using "
"MySQL, you can also use the :setting:`COLLATION <TEST_COLLATION>` option to "
"control the particular collation used by the test database. See the :doc:"
"`settings documentation </ref/settings>` for details of these and other "
"advanced settings."
msgstr ""
"为了对测试数据库的字符编码进行精细控制，请使用 :setting:`CHARSET "
"<TEST_CHARSET>` TEST 选项。如果你使用的是 MySQL，你也可以使用 :setting:"
"`COLLATION <TEST_COLLATION>` 选项来控制测试数据库使用的特定字符序。请参阅 :"
"doc:`配置文档 </ref/settings>` 了解这些和其他高级设置的细节。"

msgid ""
"If using an SQLite in-memory database with SQLite, `shared cache <https://"
"www.sqlite.org/sharedcache.html>`_ is enabled, so you can write tests with "
"ability to share the database between threads."
msgstr ""
"如果使用 SQLite 内存数据库，启用了 `共享缓存 <https://www.sqlite.org/"
"sharedcache.html>`_，你就可以编写线程之间共享数据库的测试。"

msgid "Finding data from your production database when running tests?"
msgstr "运行测试时从生产数据库中查找数据？"

msgid ""
"If your code attempts to access the database when its modules are compiled, "
"this will occur *before* the test database is set up, with potentially "
"unexpected results. For example, if you have a database query in module-"
"level code and a real database exists, production data could pollute your "
"tests. *It is a bad idea to have such import-time database queries in your "
"code* anyway - rewrite your code so that it doesn't do this."
msgstr ""
"如果你的代码在编译模块时试图访问数据库，这将在测试数据库建立 *之前* 发生，可"
"能会产生意想不到的结果。例如，如果你在模块级代码中进行数据库查询，并且存在真"
"实的数据库，则生产数据可能会污染你的测试。 无论如何，*在代码中都包含这样的导"
"入时数据库查询是一个坏主意*——重写代码，使其不会执行此操作。"

msgid ""
"This also applies to customized implementations of :meth:`~django.apps."
"AppConfig.ready()`."
msgstr "这也适用于 :meth:`~django.apps.AppConfig.ready()` 的自定义实现。"

msgid ""
"The :ref:`advanced multi-db testing topics <topics-testing-advanced-"
"multidb>`."
msgstr ":ref:`进阶多数据库测试主题 <topics-testing-advanced-multidb>`。"

msgid "Order in which tests are executed"
msgstr "执行测试的顺序"

msgid ""
"In order to guarantee that all ``TestCase`` code starts with a clean "
"database, the Django test runner reorders tests in the following way:"
msgstr ""
"为了保证所有的 ``TestCase`` 代码都从干净的数据库开始，Django 测试运行器以如下"
"方式重新排序测试："

msgid "All :class:`~django.test.TestCase` subclasses are run first."
msgstr "所有 :class:`~django.test.TestCase` 的子类首先运行。"

msgid ""
"Then, all other Django-based tests (test cases based on :class:`~django.test."
"SimpleTestCase`, including :class:`~django.test.TransactionTestCase`) are "
"run with no particular ordering guaranteed nor enforced among them."
msgstr ""
"然后，所有其他基于Django的测试（基于 :class:`~django.test.SimpleTestCase` 的"
"测试用例，包括 :class:`~django.test.TransactionTestCase`）都会被运行，它们之"
"间不保证也不强制执行特定的顺序。"

msgid ""
"Then any other :class:`unittest.TestCase` tests (including doctests) that "
"may alter the database without restoring it to its original state are run."
msgstr ""
"然后运行任何其他的 :class:`unittest.TestCase` 测试（包括 doctests），这些测试"
"可能会改变数据库而不将其恢复到原始状态。"

msgid ""
"The new ordering of tests may reveal unexpected dependencies on test case "
"ordering. This is the case with doctests that relied on state left in the "
"database by a given :class:`~django.test.TransactionTestCase` test, they "
"must be updated to be able to run independently."
msgstr ""
"新的测试顺序可能会意外的揭示出测试用例对顺序的依赖性。在 doctests 依赖于数据"
"库中给定的 :class:`~django.test.TransactionTestCase` 测试的情况下，必须更新它"
"们才能独立运行。"

msgid ""
"Failures detected when loading tests are ordered before all of the above for "
"quicker feedback. This includes things like test modules that couldn't be "
"found or that couldn't be loaded due to syntax errors."
msgstr ""

msgid ""
"You may randomize and/or reverse the execution order inside groups using "
"the :option:`test --shuffle` and :option:`--reverse <test --reverse>` "
"options. This can help with ensuring your tests are independent from each "
"other."
msgstr ""

msgid ""
"In older versions, failures detected when loading tests were not ordered "
"first."
msgstr ""

msgid "Rollback emulation"
msgstr "回滚模拟"

msgid ""
"Any initial data loaded in migrations will only be available in ``TestCase`` "
"tests and not in ``TransactionTestCase`` tests, and additionally only on "
"backends where transactions are supported (the most important exception "
"being MyISAM). This is also true for tests which rely on "
"``TransactionTestCase`` such as :class:`LiveServerTestCase` and :class:"
"`~django.contrib.staticfiles.testing.StaticLiveServerTestCase`."
msgstr ""
"任何在迁移中加载的初始数据将只能在 ``TestCase`` 测试中使用，而不能在 "
"``TransactionTestCase`` 测试中使用，此外，只有在支持事务的后端（最重要的例外"
"是 MyISAM）上才能使用。对于依赖 ``TransactionTestCase`` 的测试也是如此，比"
"如 :class:`LiveServerTestCase` 和 :class:`~django.contrib.staticfiles."
"testing.StaticLiveServerTestCase`。"

msgid ""
"Django can reload that data for you on a per-testcase basis by setting the "
"``serialized_rollback`` option to ``True`` in the body of the ``TestCase`` "
"or ``TransactionTestCase``, but note that this will slow down that test "
"suite by approximately 3x."
msgstr ""
"Django 可以通过在 ``TestCase`` 或 ``TransactionTestCase`` 中设置 "
"``serialized_rollback`` 选项为 ``True`` 来为你重新加载每个测试用例的数据，但"
"请注意，这将使测试套件的速度降低约 3 倍。"

msgid ""
"Third-party apps or those developing against MyISAM will need to set this; "
"in general, however, you should be developing your own projects against a "
"transactional database and be using ``TestCase`` for most tests, and thus "
"not need this setting."
msgstr ""
"第三方应用程序或那些针对 MyISAM 开发的应用程序将需要设置这个功能；但是，一般"
"来说，你应该针对事务性数据库开发你自己的项目，并在大多数测试中使用 "
"``TestCase``，因此不需要这个设置。"

msgid ""
"The initial serialization is usually very quick, but if you wish to exclude "
"some apps from this process (and speed up test runs slightly), you may add "
"those apps to :setting:`TEST_NON_SERIALIZED_APPS`."
msgstr ""
"初始序列化通常是非常快的，但如果你希望从这个过程中排除一些应用程序（并稍微加"
"快测试运行速度），你可以将这些应用程序添加到 :setting:"
"`TEST_NON_SERIALIZED_APPS`。"

msgid ""
"To prevent serialized data from being loaded twice, setting "
"``serialized_rollback=True`` disables the :data:`~django.db.models.signals."
"post_migrate` signal when flushing the test database."
msgstr ""
"为了防止序列化数据被加载两次，设置 ``serialized_rollback=True`` 在刷新测试数"
"据库时禁用 :data:`~django.db.models.signals.post_migrate` 信号。"

msgid "Other test conditions"
msgstr "其他测试条件"

msgid ""
"Regardless of the value of the :setting:`DEBUG` setting in your "
"configuration file, all Django tests run with :setting:`DEBUG`\\=False. This "
"is to ensure that the observed output of your code matches what will be seen "
"in a production setting."
msgstr ""
"无论配置文件中的 :setting:`DEBUG` 设置值是多少，所有的 Django 测试都以  :"
"setting:`DEBUG`\\=False 运行。这是为了确保你的代码观察到的输出与生产环境下的"
"输出一致。"

msgid ""
"Caches are not cleared after each test, and running \"manage.py test fooapp"
"\" can insert data from the tests into the cache of a live system if you run "
"your tests in production because, unlike databases, a separate \"test cache"
"\" is not used. This behavior :ticket:`may change <11505>` in the future."
msgstr ""
"每次测试后都不会清除缓存，如果在生产环境中运行测试，则运行 \"manage.py test "
"fooapp\" 可以将测试中的数据插入实时系统的缓存中，因为与数据库不同的是，没有使"
"用单独的“测试缓存”。这种行为在未来 :ticket:`可能改变 <11505>`。"

msgid "Understanding the test output"
msgstr "了解测试输出"

msgid ""
"When you run your tests, you'll see a number of messages as the test runner "
"prepares itself. You can control the level of detail of these messages with "
"the ``verbosity`` option on the command line::"
msgstr ""
"当你运行测试时，你会看到一些消息，因为测试运行器正在做准备。你可以通过命令行"
"上的 ``verbosity`` 选项来控制这些消息的详细程度："

msgid ""
"This tells you that the test runner is creating a test database, as "
"described in the previous section."
msgstr "这告诉你测试运行程序正在创建测试数据库，如上一节所述。"

msgid ""
"Once the test database has been created, Django will run your tests. If "
"everything goes well, you'll see something like this::"
msgstr ""
"创建测试数据库后，Django 将运行你的测试。 如果一切顺利，你会看到类似以下内容"
"的信息："

msgid ""
"If there are test failures, however, you'll see full details about which "
"tests failed::"
msgstr "但是，如果有测试失败，你会看到关于哪些测试失败的完整细节："

msgid ""
"A full explanation of this error output is beyond the scope of this "
"document, but it's pretty intuitive. You can consult the documentation of "
"Python's :mod:`unittest` library for details."
msgstr ""
"对这个错误输出的完整解释超出了本文的范围，但它非常直观。你可以参考 Python "
"的 :mod:`unittest` 库的文档以了解详细信息。"

msgid ""
"Note that the return code for the test-runner script is 1 for any number of "
"failed and erroneous tests. If all the tests pass, the return code is 0. "
"This feature is useful if you're using the test-runner script in a shell "
"script and need to test for success or failure at that level."
msgstr ""
"请注意，对于任何数量的失败和错误测试，test-runner 脚本的返回码均为 1。 如果所"
"有测试均通过，则返回码为 0。如果你在 shell 脚本中使用 test-runner 脚本，并且"
"需要在该级别上测试成功或失败，则此功能很有用。"

msgid "Speeding up the tests"
msgstr "加快测试"

msgid "Running tests in parallel"
msgstr "并行运行测试"

msgid ""
"As long as your tests are properly isolated, you can run them in parallel to "
"gain a speed up on multi-core hardware. See :option:`test --parallel`."
msgstr ""
"只要测试正确隔离，你就可以并行运行它们以加快多核硬件的运行速度。 参见 :"
"option:`test --parallel`."

msgid "Password hashing"
msgstr "密码哈希"

msgid ""
"The default password hasher is rather slow by design. If you're "
"authenticating many users in your tests, you may want to use a custom "
"settings file and set the :setting:`PASSWORD_HASHERS` setting to a faster "
"hashing algorithm::"
msgstr ""
"默认密码哈希器在设计上相当慢。 如果要在测试中对许多用户进行身份验证，则可能需"
"要使用自定义设置文件，并将 :setting:`PASSWORD_HASHERS` 设置为更快的哈希算法："

msgid ""
"Don't forget to also include in :setting:`PASSWORD_HASHERS` any hashing "
"algorithm used in fixtures, if any."
msgstr ""
"不要忘记在 :setting:`PASSWORD_HASHERS` 中包含在辅助工具中使用的任何哈希算法，"
"如果有的话。"

msgid "Preserving the test database"
msgstr "保留测试数据库"

msgid ""
"The :option:`test --keepdb` option preserves the test database between test "
"runs. It skips the create and destroy actions which can greatly decrease the "
"time to run tests."
msgstr ""
":option:`test --keepdb` 选项在两次测试运行之间保留测试数据库。 它跳过了创建和"
"销毁操作，这可以大大减少运行测试的时间。"

msgid "Testing tools"
msgstr "测试工具"

msgid ""
"Django provides a small set of tools that come in handy when writing tests."
msgstr "Django 提供了一小组在编写测试时会派上用场的工具。"

msgid "The test client"
msgstr "测试客户端"

msgid ""
"The test client is a Python class that acts as a dummy web browser, allowing "
"you to test your views and interact with your Django-powered application "
"programmatically."
msgstr ""

msgid "Some of the things you can do with the test client are:"
msgstr "你可以使用测试客户端执行以下操作："

msgid ""
"Simulate GET and POST requests on a URL and observe the response -- "
"everything from low-level HTTP (result headers and status codes) to page "
"content."
msgstr ""
"模拟 URL 上的 GET 和 POST 请求并观察响应——从低级 HTTP（结果头和状态码）到页面"
"内容，应有尽有。"

msgid ""
"See the chain of redirects (if any) and check the URL and status code at "
"each step."
msgstr "查看重定向链（如果有的话），并检查每个步骤的 URL 和状态码。"

msgid ""
"Test that a given request is rendered by a given Django template, with a "
"template context that contains certain values."
msgstr "测试给定的请求是否由给定的包含某些值以及模板上下文的 Django 模板渲染。"

msgid ""
"Note that the test client is not intended to be a replacement for Selenium_ "
"or other \"in-browser\" frameworks. Django's test client has a different "
"focus. In short:"
msgstr ""
"请注意，测试客户端并不是要取代 Selenium_ 或其他“浏览器内”框架。Django 的测试"
"客户端有不同的侧重点。简而言之："

msgid ""
"Use Django's test client to establish that the correct template is being "
"rendered and that the template is passed the correct context data."
msgstr ""
"使用 Django 的测试客户端来确定要渲染的模板正确，并且模板已传递了正确的上下文"
"数据。"

msgid ""
"Use in-browser frameworks like Selenium_ to test *rendered* HTML and the "
"*behavior* of web pages, namely JavaScript functionality. Django also "
"provides special support for those frameworks; see the section on :class:"
"`~django.test.LiveServerTestCase` for more details."
msgstr ""

msgid "A comprehensive test suite should use a combination of both test types."
msgstr "一个全面的测试套件应该使用这两种测试类型的组合。"

msgid "Overview and a quick example"
msgstr "概述和一个简单的例子"

msgid ""
"To use the test client, instantiate ``django.test.Client`` and retrieve web "
"pages::"
msgstr ""

msgid ""
"As this example suggests, you can instantiate ``Client`` from within a "
"session of the Python interactive interpreter."
msgstr "如本例所示，你可以从 Python 交互式解释器的会话中实例化 ``Client``。"

msgid "Note a few important things about how the test client works:"
msgstr "请注意测试客户端如何工作的一些重要事项："

msgid ""
"The test client does *not* require the web server to be running. In fact, it "
"will run just fine with no web server running at all! That's because it "
"avoids the overhead of HTTP and deals directly with the Django framework. "
"This helps make the unit tests run quickly."
msgstr ""

msgid ""
"When retrieving pages, remember to specify the *path* of the URL, not the "
"whole domain. For example, this is correct::"
msgstr "检索页面时，请记住指定 URL 的 *路径*，而不是整个域。例如，这是正确的："

msgid "This is incorrect::"
msgstr "这是错误的："

msgid ""
"The test client is not capable of retrieving web pages that are not powered "
"by your Django project. If you need to retrieve other web pages, use a "
"Python standard library module such as :mod:`urllib`."
msgstr ""

msgid ""
"To resolve URLs, the test client uses whatever URLconf is pointed-to by "
"your :setting:`ROOT_URLCONF` setting."
msgstr ""
"为了解析 URL，测试客户端使用你的 :setting:`ROOT_URLCONF` 配置指向的任何 "
"URLconf。"

msgid ""
"Although the above example would work in the Python interactive interpreter, "
"some of the test client's functionality, notably the template-related "
"functionality, is only available *while tests are running*."
msgstr ""
"虽然上面的例子可以在 Python 交互式解释器中工作，但是测试客户端的一些功能，尤"
"其是与模板相关的功能，只有在 *测试运行时* 才可以使用。"

msgid ""
"The reason for this is that Django's test runner performs a bit of black "
"magic in order to determine which template was loaded by a given view. This "
"black magic (essentially a patching of Django's template system in memory) "
"only happens during test running."
msgstr ""
"原因是 Django 的测试运行器为了确定哪个模板被给定的视图加载，执行了一点黑魔"
"法。这个黑魔法（本质上是内存中 Django 模板系统的补丁）只发生在测试运行期间。"

msgid ""
"By default, the test client will disable any CSRF checks performed by your "
"site."
msgstr "默认情况下，测试客户端将禁用站点执行的任何 CSRF 检查。"

msgid ""
"If, for some reason, you *want* the test client to perform CSRF checks, you "
"can create an instance of the test client that enforces CSRF checks. To do "
"this, pass in the ``enforce_csrf_checks`` argument when you construct your "
"client::"
msgstr ""
"如果出于某种原因，你 *想* 让测试客户端执行 CSRF 检查，则可以创建强制执行 "
"CSRF 检查的测试客户端实例。为此，请在构建客户端时传递 "
"``enforce_csrf_checks`` 参数："

msgid "Making requests"
msgstr "发出请求"

msgid "Use the ``django.test.Client`` class to make requests."
msgstr "使用 ``django.test.Client`` 类发出请求。"

msgid ""
"It requires no arguments at time of construction. However, you can use "
"keyword arguments to specify some default headers. For example, this will "
"send a ``User-Agent`` HTTP header in each request::"
msgstr ""
"它在构造时不需要任何参数。然而，你可以使用关键字参数来指定一些默认头信息。例"
"如，这将在每个请求中发送一个 ``User-Agent`` HTTP 头："

msgid ""
"The values from the ``extra`` keyword arguments passed to :meth:`~django."
"test.Client.get()`, :meth:`~django.test.Client.post()`, etc. have precedence "
"over the defaults passed to the class constructor."
msgstr ""
"传递给 :meth:`~django.test.Client.get()`、:meth:`~django.test.Client.post()` "
"等方法的 ``extra`` 关键字参数的值，优先于传递给类构造函数的默认值。"

msgid ""
"The ``enforce_csrf_checks`` argument can be used to test CSRF protection "
"(see above)."
msgstr "``enforce_csrf_checks`` 参数可用于测试 CSRF 保护（见上文）。"

msgid ""
"The ``json_encoder`` argument allows setting a custom JSON encoder for the "
"JSON serialization that's described in :meth:`post`."
msgstr ""
"``json_encoder`` 参数允许为 :meth:`post` 中描述的 JSON 序列化设置一个自定义 "
"JSON 编码器。"

msgid ""
"The ``raise_request_exception`` argument allows controlling whether or not "
"exceptions raised during the request should also be raised in the test. "
"Defaults to ``True``."
msgstr ""
"``raise_request_exception`` 参数允许控制是否在请求过程中引出的异常也应该在测"
"试中引出。默认值为 ``True``。"

msgid ""
"Once you have a ``Client`` instance, you can call any of the following "
"methods:"
msgstr "一旦有了 ``Client`` 实例，就可以调用以下任何一种方法："

msgid ""
"Makes a GET request on the provided ``path`` and returns a ``Response`` "
"object, which is documented below."
msgstr ""
"对提供的 ``path`` 上发出 GET 请求，并返回一个 ``Response`` 对象，如下所述。"

msgid ""
"The key-value pairs in the ``data`` dictionary are used to create a GET data "
"payload. For example::"
msgstr "``data`` 字典中的键值对用于创建 GET 数据有效载荷。例如："

msgid "...will result in the evaluation of a GET request equivalent to::"
msgstr "......将产生等效的 GET 请求："

msgid ""
"The ``extra`` keyword arguments parameter can be used to specify headers to "
"be sent in the request. For example::"
msgstr "``extra`` 关键词参数可以用来指定请求中要发送的头信息。例如："

msgid ""
"...will send the HTTP header ``HTTP_ACCEPT`` to the details view, which is a "
"good way to test code paths that use the :meth:`django.http.HttpRequest."
"accepts()` method."
msgstr ""
"......会将 HTTP 头 ``HTTP_ACCEPT`` 发送到 detail 视图，这是测试使用 :meth:"
"`django.http.HttpRequest.accepts()` 方法的代码路径的好方法。"

msgid "CGI specification"
msgstr "CGI 规范"

msgid ""
"The headers sent via ``**extra`` should follow CGI_ specification. For "
"example, emulating a different \"Host\" header as sent in the HTTP request "
"from the browser to the server should be passed as ``HTTP_HOST``."
msgstr ""
"通过 ``**extra`` 发送的头信息应遵循 CGI_ 规范。例如，在浏览器向服务器发送的 "
"HTTP 请求中，模拟不同的“Host”头，应以 ``HTTP_HOST`` 的形式发送。"

msgid ""
"If you already have the GET arguments in URL-encoded form, you can use that "
"encoding instead of using the data argument. For example, the previous GET "
"request could also be posed as::"
msgstr ""
"如果你已经有了 URL 编码形式的 GET 参数，你可以使用该编码代替使用数据参数。例"
"如，之前的 GET 请求也可以改成："

msgid ""
"If you provide a URL with both an encoded GET data and a data argument, the "
"data argument will take precedence."
msgstr "如果你提供的 URL 同时包含编码的 GET 数据和数据参数，数据参数将优先。"

msgid ""
"If you set ``follow`` to ``True`` the client will follow any redirects and a "
"``redirect_chain`` attribute will be set in the response object containing "
"tuples of the intermediate urls and status codes."
msgstr ""
"如果将 ``follow`` 设置为 ``True``，客户端将遵循所有重定向，并且将在响应对象中"
"设置 ``redirect_chain`` 属性，该属性是包含中间 URL 和状态码的元组。"

msgid ""
"If you had a URL ``/redirect_me/`` that redirected to ``/next/``, that "
"redirected to ``/final/``, this is what you'd see::"
msgstr ""
"如果你有一个 URL ``/redirect_me/``，重定向到 ``/next/``，再重定向到 ``/final/"
"``，这是你会看到的："

msgid ""
"If you set ``secure`` to ``True`` the client will emulate an HTTPS request."
msgstr "如果你把 ``secure`` 设置为 ``True``，则客户端将模拟 HTTPS 请求。"

msgid ""
"Makes a POST request on the provided ``path`` and returns a ``Response`` "
"object, which is documented below."
msgstr ""
"在提供的 ``path`` 上发出一个 POST 请求，并返回一个 ``Response`` 对象，如下所"
"述。"

msgid ""
"The key-value pairs in the ``data`` dictionary are used to submit POST data. "
"For example::"
msgstr "``data`` 字典中的键值对用于提交 POST 数据。例如："

msgid "...will result in the evaluation of a POST request to this URL::"
msgstr "......将产生对这个 URL 的 POST 请求："

msgid "...with this POST data::"
msgstr "......具有此 POST 数据："

msgid ""
"If you provide ``content_type`` as :mimetype:`application/json`, the "
"``data`` is serialized using :func:`json.dumps` if it's a dict, list, or "
"tuple. Serialization is performed with :class:`~django.core.serializers.json."
"DjangoJSONEncoder` by default, and can be overridden by providing a "
"``json_encoder`` argument to :class:`Client`. This serialization also "
"happens for :meth:`put`, :meth:`patch`, and :meth:`delete` requests."
msgstr ""
"如果你提供 :mimetype:`application/json` 为 ``content_type``，则如果 ``data`` "
"是一个字典、列表或元组时，使用 :func:`json.dumps` 进行序列化。序列化默认是通"
"过 :class:`~django.core.serializers.json.DjangoJSONEncoder`，可以通过为 :"
"class:`Client` 提供 ``json_encoder`` 参数覆盖。这个序列化也会发生在 :meth:"
"`put`、:meth:`patch` 和 :meth:`delete` 请求中。"

msgid ""
"If you provide any other ``content_type`` (e.g. :mimetype:`text/xml` for an "
"XML payload), the contents of ``data`` are sent as-is in the POST request, "
"using ``content_type`` in the HTTP ``Content-Type`` header."
msgstr ""
"如果你要提供任何其他的 ``content_type`` （例如 :mimetype:`text/xml` 用于 XML "
"有效载荷），使用HTTP ``Content-Type`` 头中的 ``content_type``，``data`` 的内"
"容在 POST 请求中按原样发送。"

msgid ""
"If you don't provide a value for ``content_type``, the values in ``data`` "
"will be transmitted with a content type of :mimetype:`multipart/form-data`. "
"In this case, the key-value pairs in ``data`` will be encoded as a multipart "
"message and used to create the POST data payload."
msgstr ""
"如果你没有为 ``content_type`` 提供一个值，``data`` 中的值将以 :mimetype:"
"`multipart/form-data` 的内容类型进行传输。在这种情况下，``data`` 中的键值对将"
"被编码为多部分消息，并用于创建 POST 数据有效载荷。"

msgid ""
"To submit multiple values for a given key -- for example, to specify the "
"selections for a ``<select multiple>`` -- provide the values as a list or "
"tuple for the required key. For example, this value of ``data`` would submit "
"three selected values for the field named ``choices``::"
msgstr ""
"要为一个给定的键提交多个值——例如，要指定 ``<select multiple>`` 的选择——为所需"
"键提供一个列表或元组的值。例如，这个 ``data`` 的值将为名为 ``choices`` 的字段"
"提交三个选择值："

msgid ""
"Submitting files is a special case. To POST a file, you need only provide "
"the file field name as a key, and a file handle to the file you wish to "
"upload as a value. For example::"
msgstr ""
"提交文件是一种特殊情况。要 POST 一个文件，你只需要提供文件字段名作为键，以及"
"你想上传的文件的文件句柄作为值。例如："

msgid ""
"(The name ``attachment`` here is not relevant; use whatever name your file-"
"processing code expects.)"
msgstr ""
"（这里的 ``attachment`` 名称无关紧要；可以使用你的文件处理代码期望的任何名"
"称。）"

msgid ""
"You may also provide any file-like object (e.g., :class:`~io.StringIO` or :"
"class:`~io.BytesIO`) as a file handle. If you're uploading to an :class:"
"`~django.db.models.ImageField`, the object needs a ``name`` attribute that "
"passes the :data:`~django.core.validators.validate_image_file_extension` "
"validator. For example::"
msgstr ""
"你也可以提供任何类似于文件的对象（例如 :class:`~io.StringIO` 或 :class:`~io."
"BytesIO`）作为文件句柄。如果你要上传到 :class:`~django.db.models."
"ImageField`，这个对象需要一个可以通过 :data:`~django.core.validators."
"validate_image_file_extension` 验证器的 ``name`` 属性。例如："

msgid ""
"Note that if you wish to use the same file handle for multiple ``post()`` "
"calls then you will need to manually reset the file pointer between posts. "
"The easiest way to do this is to manually close the file after it has been "
"provided to ``post()``, as demonstrated above."
msgstr ""
"请注意，如果你想在多次调用 ``post()`` 时使用同一个文件句柄，那么你需要在两次"
"调用之间手动重置文件指针。最简单的方法是在向 ``post()`` 提供文件后手动关闭文"
"件，如上所示。"

msgid ""
"You should also ensure that the file is opened in a way that allows the data "
"to be read. If your file contains binary data such as an image, this means "
"you will need to open the file in ``rb`` (read binary) mode."
msgstr ""
"你还应确保文件的打开方式允许数据被读取。如果你的文件包含二进制数据，如图像，"
"这意味着你需要以 ``rb`` （读取二进制）模式打开文件。"

msgid "The ``extra`` argument acts the same as for :meth:`Client.get`."
msgstr "``extra`` 参数的作用与 :meth:`Client.get` 相同。"

msgid ""
"If the URL you request with a POST contains encoded parameters, these "
"parameters will be made available in the request.GET data. For example, if "
"you were to make the request::"
msgstr ""
"如果你用 POST 请求的 URL 包含编码参数，这些参数将在 request.GET 数据中提供。"
"例如，如果你要请求："

msgid ""
"... the view handling this request could interrogate request.POST to "
"retrieve the username and password, and could interrogate request.GET to "
"determine if the user was a visitor."
msgstr ""
"......处理这个请求的视图可以询问 request.POST 来检索用户名和密码，也可以询问 "
"request.GET 来确定该用户是否是访客。"

msgid ""
"Makes a HEAD request on the provided ``path`` and returns a ``Response`` "
"object. This method works just like :meth:`Client.get`, including the "
"``follow``, ``secure`` and ``extra`` arguments, except it does not return a "
"message body."
msgstr ""
"在提供的 ``path`` 上发出一个 HEAD 请求，并返回一个 ``Response`` 对象。这个方"
"法的工作原理和 :meth:`Client.get`  一样，包括 ``follow``、``secure`` 和 "
"``extra`` 参数，只是它不返回消息主体。"

msgid ""
"Makes an OPTIONS request on the provided ``path`` and returns a ``Response`` "
"object. Useful for testing RESTful interfaces."
msgstr ""
"在提供的 ``path`` 上发出一个 OPTIONS 请求并返回一个 ``Response`` 对象。用于测"
"试 RESTful 接口。"

msgid ""
"When ``data`` is provided, it is used as the request body, and a ``Content-"
"Type`` header is set to ``content_type``."
msgstr ""
"当提供 ``data`` 时，它将被用作请求主体并且 ``Content-Type`` 头被设置为 "
"``content_type``。"

msgid ""
"The ``follow``, ``secure`` and ``extra`` arguments act the same as for :meth:"
"`Client.get`."
msgstr ""
"``follow``、 ``secure`` 和 ``extra`` 参数的作用与 :meth:`Client.get` 相同。"

msgid ""
"Makes a PUT request on the provided ``path`` and returns a ``Response`` "
"object. Useful for testing RESTful interfaces."
msgstr ""
"在提供的 ``path`` 上发出一个 PUT 请求，并返回一个 ``Response`` 对象。用于测"
"试 RESTful 接口。"

msgid ""
"Makes a PATCH request on the provided ``path`` and returns a ``Response`` "
"object. Useful for testing RESTful interfaces."
msgstr ""
"在提供的 ``path`` 上发出一个 PATCH 请求，并返回一个 ``Response`` 对象。用于测"
"试 RESTful 接口。"

msgid ""
"Makes a DELETE request on the provided ``path`` and returns a ``Response`` "
"object. Useful for testing RESTful interfaces."
msgstr ""
"在提供的 ``path`` 上发出一个 DELETE 请求，并返回一个 ``Response`` 对象。用于"
"测试 RESTful 接口。"

msgid ""
"Makes a TRACE request on the provided ``path`` and returns a ``Response`` "
"object. Useful for simulating diagnostic probes."
msgstr ""
"在提供的 ``path`` 上发出一个 TRACE 请求，并返回一个 ``Response`` 对象。用于模"
"拟诊断探针。"

msgid ""
"Unlike the other request methods, ``data`` is not provided as a keyword "
"parameter in order to comply with :rfc:`7231#section-4.3.8`, which mandates "
"that TRACE requests must not have a body."
msgstr ""
"与其他请求方法不同，为了符合 :rfc:`7231#section-4.3.8` 的要求，不提供 "
"``data`` 作为关键字参数，该 RFC 要求跟踪请求不能有主体。"

msgid ""
"The ``follow``, ``secure``, and ``extra`` arguments act the same as for :"
"meth:`Client.get`."
msgstr ""
"``follow``、 ``secure`` 和 ``extra`` 参数的作用与 :meth:`Client.get` 相同。"

msgid ""
"If your site uses Django's :doc:`authentication system</topics/auth/index>` "
"and you deal with logging in users, you can use the test client's "
"``login()`` method to simulate the effect of a user logging into the site."
msgstr ""
"如果你的网站使用了 Django 的 :doc:`认证系统</topics/auth/index>`，并且你需要"
"处理登录用户的问题，你可以使用测试客户端的 ``login()`` 方法来模拟用户登录网站"
"的效果。"

msgid ""
"After you call this method, the test client will have all the cookies and "
"session data required to pass any login-based tests that may form part of a "
"view."
msgstr ""
"调用此方法后，测试客户端将拥有通过任何可能构成视图一部分的基于登录的测试所需"
"的所有 cookie 和会话数据。"

msgid ""
"The format of the ``credentials`` argument depends on which :ref:"
"`authentication backend <authentication-backends>` you're using (which is "
"configured by your :setting:`AUTHENTICATION_BACKENDS` setting). If you're "
"using the standard authentication backend provided by Django "
"(``ModelBackend``), ``credentials`` should be the user's username and "
"password, provided as keyword arguments::"
msgstr ""
"``credentials`` 参数的格式取决于你使用的 :ref:`认证后端 <authentication-"
"backends>` （这是由你的 :setting:`AUTHENTICATION_BACKENDS` 配置）。如果你使用"
"的是 Django 提供的标准认证后端（``ModelBackend``），``credentials`` 应该是用"
"户的用户名和密码，并作为关键字参数提供："

msgid ""
"If you're using a different authentication backend, this method may require "
"different credentials. It requires whichever credentials are required by "
"your backend's ``authenticate()`` method."
msgstr ""
"如果你使用的是不同的认证后端，这个方法可能需要不同的凭证。它需要你的后端 "
"``authenticate()`` 方法所需要的任何凭证。"

msgid ""
"``login()`` returns ``True`` if it the credentials were accepted and login "
"was successful."
msgstr "如果凭证被接受且登录成功，则 ``login()`` 返回 ``True``。"

msgid ""
"Finally, you'll need to remember to create user accounts before you can use "
"this method. As we explained above, the test runner is executed using a test "
"database, which contains no users by default. As a result, user accounts "
"that are valid on your production site will not work under test conditions. "
"You'll need to create users as part of the test suite -- either manually "
"(using the Django model API) or with a test fixture. Remember that if you "
"want your test user to have a password, you can't set the user's password by "
"setting the password attribute directly -- you must use the :meth:`~django."
"contrib.auth.models.User.set_password()` function to store a correctly "
"hashed password. Alternatively, you can use the :meth:`~django.contrib.auth."
"models.UserManager.create_user` helper method to create a new user with a "
"correctly hashed password."
msgstr ""
"最后，在使用这个方法之前，你需要记得创建用户账户。正如我们上面所解释的，测试"
"运行器是使用测试数据库执行的，默认情况下，数据库中不包含用户。因此，在生产站"
"点上有效的用户账户在测试条件下将无法工作。你需要创建用户作为测试套件的一部"
"分--无论是手动创建（使用 Django 模型 API）还是使用测试夹具。记住，如果你想让"
"你的测试用户有一个密码，你不能直接通过设置密码属性来设置用户的密码——你必须使"
"用 :meth:`~django.contrib.auth.models.User.set_password()` 函数来存储一个正确"
"的哈希密码。或者，你可以使用 :meth:`~django.contrib.auth.models.UserManager."
"create_user` 辅助方法来创建一个具有正确哈希密码的新用户。"

msgid ""
"If your site uses Django's :doc:`authentication system</topics/auth/index>`, "
"you can use the ``force_login()`` method to simulate the effect of a user "
"logging into the site. Use this method instead of :meth:`login` when a test "
"requires a user be logged in and the details of how a user logged in aren't "
"important."
msgstr ""
"如果你的网站使用了 Django 的 :doc:`认证系统 </topics/auth/index>`，你可以使"
"用 ``force_login()`` 方法来模拟用户登录网站的效果。当测试需要用户登录，而用户"
"如何登录的细节并不重要时，可以使用这个方法代替 :meth:`login`。"

msgid ""
"Unlike ``login()``, this method skips the authentication and verification "
"steps: inactive users (:attr:`is_active=False <django.contrib.auth.models."
"User.is_active>`) are permitted to login and the user's credentials don't "
"need to be provided."
msgstr ""
"与 ``login()`` 不同的是，这个方法跳过了认证和验证步骤：不活跃的用户（:attr:"
"`is_active=False <django.contrib.auth.models.User.is_active>`）被允许登录，并"
"且不需要提供用户凭证。"

msgid ""
"The user will have its ``backend`` attribute set to the value of the "
"``backend`` argument (which should be a dotted Python path string), or to "
"``settings.AUTHENTICATION_BACKENDS[0]`` if a value isn't provided. The :func:"
"`~django.contrib.auth.authenticate` function called by :meth:`login` "
"normally annotates the user like this."
msgstr ""
"用户的 ``backend`` 属性将被设置为 ``backend`` 参数的值（应该是一个点分隔 "
"Python 路径字符串），如果没有提供值，则设置为 ``settings."
"AUTHENTICATION_BACKENDS[0]``。:meth:`login` 调用的 :func:`~django.contrib."
"auth.authenticate` 函数通常会对用户进行注释。"

msgid ""
"This method is faster than ``login()`` since the expensive password hashing "
"algorithms are bypassed. Also, you can speed up ``login()`` by :ref:`using a "
"weaker hasher while testing <speeding-up-tests-auth-hashers>`."
msgstr ""
"这个方法比 ``login()`` 快，因为它绕过了昂贵的密码散列算法。另外，你也可以通"
"过 :ref:`在测试时使用较弱的哈希算法 <speeding-up-tests-auth-hashers>` 来加快 "
"``login()`` 速度。"

msgid ""
"If your site uses Django's :doc:`authentication system</topics/auth/index>`, "
"the ``logout()`` method can be used to simulate the effect of a user logging "
"out of your site."
msgstr ""
"如果你的网站使用了 Django 的 :doc:`认证系统 </topics/auth/index>`，"
"``logout()`` 方法可以用来模拟用户注销网站的效果。"

msgid ""
"After you call this method, the test client will have all the cookies and "
"session data cleared to defaults. Subsequent requests will appear to come "
"from an :class:`~django.contrib.auth.models.AnonymousUser`."
msgstr ""
"调用此方法后，测试客户端的所有 cookie 和会话数据都会被清除为默认值。随后的请"
"求将看起来来自一个 :class:`~django.contrib.auth.models.AnonymousUser`。"

msgid "Testing responses"
msgstr "测试响应"

msgid ""
"The ``get()`` and ``post()`` methods both return a ``Response`` object. This "
"``Response`` object is *not* the same as the ``HttpResponse`` object "
"returned by Django views; the test response object has some additional data "
"useful for test code to verify."
msgstr ""
"``get()`` 和 ``post()`` 方法都会返回一个 ``Response`` 对象，这个 "
"``Response`` 对象与 Django 视图返回的 ``HttpResponse`` 对象是 *不* 一样的；测"
"试响应对象有一些额外的数据，对测试代码验证很有用。"

msgid "Specifically, a ``Response`` object has the following attributes:"
msgstr "具体来说，``Response`` 对象具有以下属性："

msgid ""
"The test client that was used to make the request that resulted in the "
"response."
msgstr "用于发出请求并得到响应的测试客户端。"

msgid ""
"The body of the response, as a bytestring. This is the final page content as "
"rendered by the view, or any error message."
msgstr ""
"以字节字符串形式的响应主体。 这是视图或任何错误消息所呈现的最终页面内容。"

msgid ""
"The template ``Context`` instance that was used to render the template that "
"produced the response content."
msgstr "模板 ``Context`` 实例，用于渲染产生响应内容的模板。"

msgid ""
"If the rendered page used multiple templates, then ``context`` will be a "
"list of ``Context`` objects, in the order in which they were rendered."
msgstr ""
"如果渲染的页面使用了多个模板，那么 ``context`` 将是一个按渲染顺序排列的 "
"``Context`` 对象列表。"

msgid ""
"Regardless of the number of templates used during rendering, you can "
"retrieve context values using the ``[]`` operator. For example, the context "
"variable ``name`` could be retrieved using::"
msgstr ""
"无论在渲染过程中使用了多少模板，你都可以使用 ``[]`` 操作符来检索上下文值。例"
"如，上下文变量 ``name`` 可以使用："

msgid "Not using Django templates?"
msgstr "没有使用 Django 模板？"

msgid ""
"This attribute is only populated when using the :class:`~django.template."
"backends.django.DjangoTemplates` backend. If you're using another template "
"engine, :attr:`~django.template.response.SimpleTemplateResponse."
"context_data` may be a suitable alternative on responses with that attribute."
msgstr ""
"这个属性只有在使用 :class:`~django.template.backends.django.DjangoTemplates` "
"后端时才会被填充。如果你正在使用其他模板引擎，在带有该属性的响应上，:attr:"
"`~django.template.response.SimpleTemplateResponse.context_data` 可能是一个合"
"适的选择。"

msgid ""
"A tuple of three values that provides information about the unhandled "
"exception, if any, that occurred during the view."
msgstr ""
"一个由三个值组成的元组，它提供了关于在视图期间发生的未处理异常（如果有）的信"
"息。"

msgid ""
"The values are (type, value, traceback), the same as returned by Python's :"
"func:`sys.exc_info`. Their meanings are:"
msgstr ""
"值是（type，value，traceback），与 Python 的 :func:`sys.exc_info` 返回的值相"
"同。它们的含义是："

msgid "*type*: The type of the exception."
msgstr "*type*：异常的类型。"

msgid "*value*: The exception instance."
msgstr "*value*：异常的实例。"

msgid ""
"*traceback*: A traceback object which encapsulates the call stack at the "
"point where the exception originally occurred."
msgstr "*traceback*：一个追溯对象，在最初发生异常的地方封装了调用堆栈。"

msgid "If no exception occurred, then ``exc_info`` will be ``None``."
msgstr "如果没有发生异常，那么 ``exc_info`` 将是 ``None``。"

msgid ""
"The body of the response, parsed as JSON. Extra keyword arguments are passed "
"to :func:`json.loads`. For example::"
msgstr ""
"解析为 JSON 的响应主体。额外的关键字参数传递给 :func:`json.loads`。例如："

msgid ""
"If the ``Content-Type`` header is not ``\"application/json\"``, then a :exc:"
"`ValueError` will be raised when trying to parse the response."
msgstr ""
"如果 ``Content-Type`` 头不是 ``\"application/json\"``，那么在试图解析响应时将"
"会出现一个 :exc:`ValueError`。"

msgid "The request data that stimulated the response."
msgstr "激发响应的请求数据。"

msgid ""
"The ``WSGIRequest`` instance generated by the test handler that generated "
"the response."
msgstr "由生成响应的测试处理程序生成的 ``WSGIRequest`` 实例。"

msgid ""
"The HTTP status of the response, as an integer. For a full list of defined "
"codes, see the `IANA status code registry`_."
msgstr ""
"整数形式的响应 HTTP 状态。关于定义代码的完整列表，查看 `IANA status code "
"registry`_."

msgid ""
"A list of ``Template`` instances used to render the final content, in the "
"order they were rendered. For each template in the list, use ``template."
"name`` to get the template's file name, if the template was loaded from a "
"file. (The name is a string such as ``'admin/index.html'``.)"
msgstr ""
"用于渲染最终内容的 ``Template`` 实例列表，按渲染顺序排列。对于列表中的每个模"
"板，如果模板是从文件中加载的，则使用 ``template.name`` 获得模板的文件名。（名"
"字是一个字符串，如 ``'admin/index.html'``。）"

msgid ""
"This attribute is only populated when using the :class:`~django.template."
"backends.django.DjangoTemplates` backend. If you're using another template "
"engine, :attr:`~django.template.response.SimpleTemplateResponse."
"template_name` may be a suitable alternative if you only need the name of "
"the template used for rendering."
msgstr ""
"这个属性只有在使用 :class:`~django.template.backends.django.DjangoTemplates` "
"后端时才会被填充。如果你使用的是其他模板引擎，并且你只需要渲染所用模板的名"
"称，那么 :attr:`~django.template.response.SimpleTemplateResponse."
"template_name` 可能是一个合适的选择。"

msgid ""
"An instance of :class:`~django.urls.ResolverMatch` for the response. You can "
"use the :attr:`~django.urls.ResolverMatch.func` attribute, for example, to "
"verify the view that served the response::"
msgstr ""
"响应的 :class:`~django.urls.ResolverMatch` 的实例。你可以使用 :attr:`~django."
"urls.ResolverMatch.func` 属性，例如，验证服务于响应的视图："

msgid ""
"If the given URL is not found, accessing this attribute will raise a :exc:"
"`~django.urls.Resolver404` exception."
msgstr ""
"如果找不到给定的 URL，访问这个属性会引发一个 :exc:`~django.urls.Resolver404` "
"异常。"

msgid ""
"As with a normal response, you can also access the headers through :attr:`."
"HttpResponse.headers`. For example, you could determine the content type of "
"a response using ``response.headers['Content-Type']``."
msgstr ""
"和普通的响应一样，你也可以通过 :attr:`.HttpResponse.headers` 访问头信息。例"
"如，你可以使用 ``response.headers['Content-Type']`` 来确定一个响应的内容类"
"型。"

msgid "Exceptions"
msgstr "例外"

msgid ""
"If you point the test client at a view that raises an exception and ``Client."
"raise_request_exception`` is ``True``, that exception will be visible in the "
"test case. You can then use a standard ``try ... except`` block or :meth:"
"`~unittest.TestCase.assertRaises` to test for exceptions."
msgstr ""
"如果你把测试客户端指向一个会引发异常的视图，并且 ``Client."
"raise_request_exception`` 是 ``True``，那么这个异常将在测试用例中可见。然后你"
"可以使用标准的 ``try ... except`` 块或 :meth:`~unittest.TestCase."
"assertRaises` 来测试异常。"

msgid ""
"The only exceptions that are not visible to the test client are :class:"
"`~django.http.Http404`, :class:`~django.core.exceptions.PermissionDenied`, :"
"exc:`SystemExit`, and :class:`~django.core.exceptions.SuspiciousOperation`. "
"Django catches these exceptions internally and converts them into the "
"appropriate HTTP response codes. In these cases, you can check ``response."
"status_code`` in your test."
msgstr ""
"测试客户端看不到的异常只有 :class:`~django.http.Http404`、:class:`~django."
"core.exceptions.PermissionDenied`、:exc:`SystemExit` 和 :class:`~django.core."
"exceptions.SuspiciousOperation`。Django 在内部捕获这些异常，并将其转换为相应"
"的 HTTP 响应代码。在这些情况下，你可以在测试中检查 ``response.status_code``。"

msgid ""
"If ``Client.raise_request_exception`` is ``False``, the test client will "
"return a 500 response as would be returned to a browser. The response has "
"the attribute :attr:`~Response.exc_info` to provide information about the "
"unhandled exception."
msgstr ""
"如果 ``Client.raise_request_exception`` 为 ``False``，测试客户端将返回一个 "
"500 的响应，就像返回给浏览器一样。响应有属性 :attr:`~Response.exc_info` 来提"
"供关于未处理的异常的信息。"

msgid "Persistent state"
msgstr "持久状态"

msgid ""
"The test client is stateful. If a response returns a cookie, then that "
"cookie will be stored in the test client and sent with all subsequent "
"``get()`` and ``post()`` requests."
msgstr ""
"测试客户端是有状态的。如果一个响应返回一个 cookie，那么这个 cookie 将被存储在"
"测试客户端，并与所有后续的 ``get()`` 和 ``post()`` 请求一起发送。"

msgid ""
"Expiration policies for these cookies are not followed. If you want a cookie "
"to expire, either delete it manually or create a new ``Client`` instance "
"(which will effectively delete all cookies)."
msgstr ""
"不遵循这些 cookie 的过期策略。如果你希望 cookie 过期，请手动删除它或创建一个"
"新的 ``Client`` 实例（这将有效地删除所有 cookie）。"

msgid ""
"A test client has two attributes that store persistent state information. "
"You can access these properties as part of a test condition."
msgstr ""
"测试客户端有两个属性，存储持久化的状态信息。你可以作为测试条件的一部分来访问"
"这些属性。"

msgid ""
"A Python :class:`~http.cookies.SimpleCookie` object, containing the current "
"values of all the client cookies. See the documentation of the :mod:`http."
"cookies` module for more."
msgstr ""
"一个 Python :class:`~http.cookies.SimpleCookie` 对象，包含所有客户端 cookie "
"的当前值。更多信息请参见 :mod:`http.cookies` 模块的文档。"

msgid ""
"A dictionary-like object containing session information. See the :doc:"
"`session documentation</topics/http/sessions>` for full details."
msgstr ""
"一个类似字典的对象，包含会话信息。详细内容请参见 :doc:`会话文档 </topics/"
"http/sessions>`。"

msgid ""
"To modify the session and then save it, it must be stored in a variable "
"first (because a new ``SessionStore`` is created every time this property is "
"accessed)::"
msgstr ""
"要修改会话然后保存，必须先将其存储在一个变量中（因为每次访问该属性时都会创建"
"一个新的 ``SessionStore``）："

msgid "Setting the language"
msgstr "设置语言"

msgid ""
"When testing applications that support internationalization and "
"localization, you might want to set the language for a test client request. "
"The method for doing so depends on whether or not the :class:`~django."
"middleware.locale.LocaleMiddleware` is enabled."
msgstr ""
"在测试支持国际化和本地化的应用程序时，你可能想为测试客户端请求设置语言。这样"
"做的方法取决于 :class:`~django.middleware.locale.LocaleMiddleware` 是否启用。"

msgid ""
"If the middleware is enabled, the language can be set by creating a cookie "
"with a name of :setting:`LANGUAGE_COOKIE_NAME` and a value of the language "
"code::"
msgstr ""
"如果启用了中间件，可以通过创建一个名为 :setting:`LANGUAGE_COOKIE_NAME` 的 "
"cookie 来设置语言，其值为语言代码：。"

msgid "or by including the ``Accept-Language`` HTTP header in the request::"
msgstr "或在请求中加入 ``Accept-Language`` HTTP 头："

msgid "More details are in :ref:`how-django-discovers-language-preference`."
msgstr "更多细节请参考 :ref:`how-django-discovers-language-preference`。"

msgid ""
"If the middleware isn't enabled, the active language may be set using :func:"
"`.translation.override`::"
msgstr ""
"如果中间件没有启用，可以使用 :func:`.translation.override` 设置活动语言："

msgid "More details are in :ref:`explicitly-setting-the-active-language`."
msgstr "更多细节见 :ref:`explicitly-setting-the-active-language`。"

msgid "The following is a unit test using the test client::"
msgstr "以下是使用测试客户端进行的单元测试："

msgid ":class:`django.test.RequestFactory`"
msgstr ":class:`django.test.RequestFactory`"

msgid "Provided test case classes"
msgstr "提供的测试用例类"

msgid ""
"Normal Python unit test classes extend a base class of :class:`unittest."
"TestCase`. Django provides a few extensions of this base class:"
msgstr ""
"一般的 Python 单元测试类都会扩展一个基类 :class:`unittest.TestCase`。Django "
"提供了这个基类的一些扩展。"

msgid "Hierarchy of Django unit testing classes"
msgstr "Django 单元测试类的层次结构"

msgid ""
"You can convert a normal :class:`unittest.TestCase` to any of the "
"subclasses: change the base class of your test from ``unittest.TestCase`` to "
"the subclass. All of the standard Python unit test functionality will be "
"available, and it will be augmented with some useful additions as described "
"in each section below."
msgstr ""
"你可以将一个普通的 :class:`unittest.TestCase` 转换为任何一个子类：将你的测试"
"基类从 ``unittest.TestCase`` 改为子类。所有标准的 Python 单元测试功能都将是可"
"用的，并且它将被一些有用的附加功能所增强，如下面每节所述。"

msgid "``SimpleTestCase``"
msgstr "``SimpleTestCase``"

msgid "A subclass of :class:`unittest.TestCase` that adds this functionality:"
msgstr ":class:`unittest.TestCase` 的一个子类，增加了以下功能："

msgid "Some useful assertions like:"
msgstr "一些有用的断言，例如："

msgid ""
"Checking that a callable :meth:`raises a certain exception <SimpleTestCase."
"assertRaisesMessage>`."
msgstr ""
"检查一个可调用对象 :meth:`会引发某个异常 <SimpleTestCase."
"assertRaisesMessage>`。"

msgid ""
"Checking that a callable :meth:`triggers a certain warning <SimpleTestCase."
"assertWarnsMessage>`."
msgstr ""
"检查一个可调用对象 :meth:`会触发某个警告 <SimpleTestCase."
"assertWarnsMessage>`。"

msgid ""
"Testing form field :meth:`rendering and error treatment <SimpleTestCase."
"assertFieldOutput>`."
msgstr ""
"测试表单字段 :meth:`渲染和错误处理 <SimpleTestCase.assertFieldOutput>`。"

msgid ""
"Testing :meth:`HTML responses for the presence/lack of a given fragment "
"<SimpleTestCase.assertContains>`."
msgstr ""
"测试 :meth:`HTML 响应是否存在／缺乏给定的片段 <SimpleTestCase."
"assertContains>`。"

msgid ""
"Verifying that a template :meth:`has/hasn't been used to generate a given "
"response content <SimpleTestCase.assertTemplateUsed>`."
msgstr ""
"验证模板 :meth:`是否被用于生成给定的响应内容 <SimpleTestCase."
"assertTemplateUsed>`。"

msgid ""
"Verifying that two :meth:`URLs <SimpleTestCase.assertURLEqual>` are equal."
msgstr "验证两个 :meth:`URL <SimpleTestCase.assertURLEqual>` 是否相等。"

msgid ""
"Verifying an HTTP :meth:`redirect <SimpleTestCase.assertRedirects>` is "
"performed by the app."
msgstr ""

msgid ""
"Robustly testing two :meth:`HTML fragments <SimpleTestCase.assertHTMLEqual>` "
"for equality/inequality or :meth:`containment <SimpleTestCase.assertInHTML>`."
msgstr ""
"严格测试两个 :meth:`HTML 片段 <SimpleTestCase.assertHTMLEqual>` 是否相等或 :"
"meth:`包含 <SimpleTestCase.assertInHTML>`。"

msgid ""
"Robustly testing two :meth:`XML fragments <SimpleTestCase.assertXMLEqual>` "
"for equality/inequality."
msgstr ""
"严格测试两个 :meth:`XML 片段 <SimpleTestCase.assertXMLEqual>` 是否相等。"

msgid ""
"Robustly testing two :meth:`JSON fragments <SimpleTestCase.assertJSONEqual>` "
"for equality."
msgstr "严格测试两个 :meth:`JSON 片段 <SimpleTestCase.assertJSONEqual>` 相等。"

msgid ""
"The ability to run tests with :ref:`modified settings <overriding-settings>`."
msgstr "能够用 :ref:`修改后的配置 <overriding-settings>` 运行测试。"

msgid "Using the :attr:`~SimpleTestCase.client` :class:`~django.test.Client`."
msgstr "使用 :attr:`~SimpleTestCase.client` :class:`~django.test.Client`。"

msgid ""
"If your tests make any database queries, use subclasses :class:`~django.test."
"TransactionTestCase` or :class:`~django.test.TestCase`."
msgstr ""
"如果你的测试进行任何数据库查询，请使用子类 :class:`~django.test."
"TransactionTestCase` 或 :class:`~django.test.TestCase`。"

msgid ""
":class:`~SimpleTestCase` disallows database queries by default. This helps "
"to avoid executing write queries which will affect other tests since each "
"``SimpleTestCase`` test isn't run in a transaction. If you aren't concerned "
"about this problem, you can disable this behavior by setting the "
"``databases`` class attribute to ``'__all__'`` on your test class."
msgstr ""
":class:`~SimpleTestCase` 默认不允许数据库查询。这有助于避免执行写查询而影响其"
"他测试，因为每个 ``SimpleTestCase`` 测试不是在事务中运行的。如果你不关心这个"
"问题，你可以通过在你的测试类上设置 ``databases`` 类属性为 ``'__all__'`` 来禁"
"止这个行为。"

msgid ""
"``SimpleTestCase`` and its subclasses (e.g. ``TestCase``, ...) rely on "
"``setUpClass()`` and ``tearDownClass()`` to perform some class-wide "
"initialization (e.g. overriding settings). If you need to override those "
"methods, don't forget to call the ``super`` implementation::"
msgstr ""
"``SimpleTestCase`` 和它的子类（如 ``TestCase``）依靠 ``setUpClass()`` 和 "
"``tearDownClass()`` 来执行一些全类范围的初始化（如覆盖配置）。如果你需要覆盖"
"这些方法，别忘了调用 ``super`` 实现："

msgid ""
"Be sure to account for Python's behavior if an exception is raised during "
"``setUpClass()``. If that happens, neither the tests in the class nor "
"``tearDownClass()`` are run. In the case of :class:`django.test.TestCase`, "
"this will leak the transaction created in ``super()``  which results in "
"various symptoms including a segmentation fault on some platforms (reported "
"on macOS). If you want to intentionally raise an exception such as :exc:"
"`unittest.SkipTest` in ``setUpClass()``, be sure to do it before calling "
"``super()`` to avoid this."
msgstr ""
"如果在 ``setUpClass()`` 过程中出现异常，一定要考虑到 Python 的行为。如果发生"
"这种情况，类中的测试和 ``tearDownClass()`` 都不会被运行。在 :class:`django."
"test.TestCase` 的情况下，这将会泄露在 ``super()`` 中创建的事务，从而导致各种"
"症状，包括在某些平台上的分段故障（在 macOS 上报告）。如果你想在 "
"``setUpClass()`` 中故意引发一个异常，如 :exc:`unittest.SkipTest`，一定要在调"
"用 ``super()`` 之前进行，以避免这种情况。"

msgid "``TransactionTestCase``"
msgstr "``TransactionTestCase``"

msgid ""
"``TransactionTestCase`` inherits from :class:`~django.test.SimpleTestCase` "
"to add some database-specific features:"
msgstr ""
"``TransactionTestCase`` 继承自 :class:`~django.test.SimpleTestCase` 以增加一"
"些数据库特有的功能："

msgid ""
"Resetting the database to a known state at the beginning of each test to "
"ease testing and using the ORM."
msgstr "在每次测试开始时将数据库重新设置为已知状态，以方便测试和使用 ORM。"

msgid "Database :attr:`~TransactionTestCase.fixtures`."
msgstr "数据库 :attr:`~TransactionTestCase.fixtures`."

msgid ""
"Test :ref:`skipping based on database backend features <skipping-tests>`."
msgstr "测试 :ref:`基于数据库后端功能的跳过 <skipping-tests>`."

msgid ""
"The remaining specialized :meth:`assert* <TransactionTestCase."
"assertQuerysetEqual>` methods."
msgstr ""
"其他专门的 :meth:`assert* <TransactionTestCase.assertQuerysetEqual>` 方法。"

msgid ""
"Django's :class:`TestCase` class is a more commonly used subclass of "
"``TransactionTestCase`` that makes use of database transaction facilities to "
"speed up the process of resetting the database to a known state at the "
"beginning of each test. A consequence of this, however, is that some "
"database behaviors cannot be tested within a Django ``TestCase`` class. For "
"instance, you cannot test that a block of code is executing within a "
"transaction, as is required when using :meth:`~django.db.models.query."
"QuerySet.select_for_update()`. In those cases, you should use "
"``TransactionTestCase``."
msgstr ""
"Django 的 :class:`TestCase` 类是 ``TransactionTestCase`` 的一个比较常用的子"
"类，它利用数据库事务设施来加快在每次测试开始时将数据库重置到已知状态的过程。"
"然而，这样做的一个后果是，有些数据库行为不能在 Django ``TestCase`` 类中进行测"
"试。例如，你不能像使用 :meth:`~django.db.models.querySet."
"select_for_update()` 时那样，测试一个代码块是否在一个事务中执行。在这些情况"
"下，你应该使用 ``TransactionTestCase``。"

msgid ""
"``TransactionTestCase`` and ``TestCase`` are identical except for the manner "
"in which the database is reset to a known state and the ability for test "
"code to test the effects of commit and rollback:"
msgstr ""
"``TransactionTestCase`` 和 ``TestCase`` 除了将数据库重设为已知状态的方式和测"
"试与测试提交和回滚效果的相关代码外，其他都是相同的。"

msgid ""
"A ``TransactionTestCase`` resets the database after the test runs by "
"truncating all tables. A ``TransactionTestCase`` may call commit and "
"rollback and observe the effects of these calls on the database."
msgstr ""
"``TransactionTestCase`` 在测试运行后，通过清空所有表来重置数据库。"
"``TransactionTestCase`` 可以调用提交和回滚，并观察这些调用对数据库的影响。"

msgid ""
"A ``TestCase``, on the other hand, does not truncate tables after a test. "
"Instead, it encloses the test code in a database transaction that is rolled "
"back at the end of the test. This guarantees that the rollback at the end of "
"the test restores the database to its initial state."
msgstr ""
"另一方面，``TestCase`` 在测试后不清空表。相反，它将测试代码包含在数据库事务"
"中，在测试结束后回滚。这保证了测试结束时的回滚能将数据库恢复到初始状态。"

msgid ""
"``TestCase`` running on a database that does not support rollback (e.g. "
"MySQL with the MyISAM storage engine), and all instances of "
"``TransactionTestCase``, will roll back at the end of the test by deleting "
"all data from the test database."
msgstr ""
"在不支持回滚的数据库上运行的 ``TestCase`` （例如 MyISAM 存储引擎的 MySQL ），"
"则 ``TransactionTestCase`` 的所有实例，将在测试结束时回滚，删除测试数据库中的"
"所有数据。"

msgid ""
"Apps :ref:`will not see their data reloaded <test-case-serialized-"
"rollback>`; if you need this functionality (for example, third-party apps "
"should enable this) you can set ``serialized_rollback = True`` inside the "
"``TestCase`` body."
msgstr ""
"应用 :ref:`不会看到他们的数据被重新加载 <test-case-serialized-rollback>`；如"
"果你需要这个功能（例如，第三方应用应该启用这个功能），你可以在 ``TestCase`` "
"中设置 ``serialized_rollback = True``。"

msgid "``TestCase``"
msgstr "``TestCase``"

msgid ""
"This is the most common class to use for writing tests in Django. It "
"inherits from :class:`TransactionTestCase` (and by extension :class:"
"`SimpleTestCase`). If your Django application doesn't use a database, use :"
"class:`SimpleTestCase`."
msgstr ""
"这是 Django 中最常用的编写测试的类。它继承自 :class:`TransactionTestCase` "
"（以及扩展自 :class:`SimpleTestCase`）。如果你的 Django 应用程序不使用数据"
"库，就使用 :class:`SimpleTestCase`。"

msgid "The class:"
msgstr "此类："

msgid ""
"Wraps the tests within two nested :func:`~django.db.transaction.atomic` "
"blocks: one for the whole class and one for each test. Therefore, if you "
"want to test some specific database transaction behavior, use :class:"
"`TransactionTestCase`."
msgstr ""
"在两个嵌套的 :func:`~django.db.transaction.atomic` 块中封装测试：一个用于整个"
"类，一个用于每个测试。因此，如果你想测试一些特定的数据库事务行为，可以使用 :"
"class:`TransactionTestCase`。"

msgid "Checks deferrable database constraints at the end of each test."
msgstr "在每次测试结束时检查可延迟的数据库约束。"

msgid "It also provides an additional method:"
msgstr "它还提供了另一种方法："

msgid ""
"The class-level ``atomic`` block described above allows the creation of "
"initial data at the class level, once for the whole ``TestCase``. This "
"technique allows for faster tests as compared to using ``setUp()``."
msgstr ""
"上文所述的类级 ``atomic`` 块允许在类级创建初始数据，整个 ``TestCase`` 只需一"
"次。与使用 ``setUp()`` 相比，这种技术允许更快的测试。"

msgid ""
"Note that if the tests are run on a database with no transaction support "
"(for instance, MySQL with the MyISAM engine), ``setUpTestData()`` will be "
"called before each test, negating the speed benefits."
msgstr ""
"请注意，如果测试是在没有事务支持的数据库上运行（例如，MyISAM 引擎的 MySQL），"
"``setUpTestData()`` 将在每次测试前被调用，从而降低了速度优势。"

msgid ""
"Objects assigned to class attributes in ``setUpTestData()`` must support "
"creating deep copies with :py:func:`copy.deepcopy` in order to isolate them "
"from alterations performed by each test methods. In previous versions of "
"Django these objects were reused and changes made to them were persisted "
"between test methods."
msgstr ""
"在 ``setUpTestData()`` 中分配给类属性的对象必须支持用 :py:func:`copy."
"deepcopy` 来创建深度拷贝，以便将它们与每个测试方法所做的改变隔离。在以前的 "
"Django 版本中，这些对象被重复使用，对它们所做的改变在测试方法之间持续存在。"

msgid ""
"Returns a context manager that captures :func:`transaction.on_commit() "
"<django.db.transaction.on_commit>` callbacks for the given database "
"connection. It returns a list that contains, on exit of the context, the "
"captured callback functions. From this list you can make assertions on the "
"callbacks or call them to invoke their side effects, emulating a commit."
msgstr ""
"返回一个为给定的数据库连接捕获 :func:`transaction.on_commit() <django.db."
"transaction.on_commit>` 回调的上下文管理器。它返回一个列表，其中包含在退出上"
"下文时，捕获的回调函数。从这个列表中，你可以对回调进行断言，或者调用它们来获"
"得其副作用，模拟一个提交。"

msgid ""
"``using`` is the alias of the database connection to capture callbacks for."
msgstr "``using`` 是数据库连接的别名，用于捕获回调。"

msgid ""
"If ``execute`` is ``True``, all the callbacks will be called as the context "
"manager exits, if no exception occurred. This emulates a commit after the "
"wrapped block of code."
msgstr ""
"如果 ``execute`` 是 ``True``，并且如果没有发生异常，所有的回调将在上下文管理"
"器退出时被调用。这模拟了在包裹的代码块之后的提交。"

msgid ""
"In older versions, new callbacks added while executing :func:`.transaction."
"on_commit` callbacks were not captured."
msgstr ""

msgid "``LiveServerTestCase``"
msgstr "``LiveServerTestCase``"

msgid ""
"``LiveServerTestCase`` does basically the same as :class:`~django.test."
"TransactionTestCase` with one extra feature: it launches a live Django "
"server in the background on setup, and shuts it down on teardown. This "
"allows the use of automated test clients other than the :ref:`Django dummy "
"client <test-client>` such as, for example, the Selenium_ client, to execute "
"a series of functional tests inside a browser and simulate a real user's "
"actions."
msgstr ""
"``LiveServerTestCase`` 和 :class:`~django.test.TransactionTestCase` 的功能基"
"本相同，但多了一个功能：它在设置时在后台启动一个实时的 Django 服务器，并在关"
"闭时将其关闭。这就允许使用 :ref:`Django 虚拟客户端 <test-client>` 以外的自动"
"化测试客户端，例如，Selenium_ 客户端，在浏览器内执行一系列功能测试，并模拟真"
"实用户的操作。"

msgid ""
"The live server listens on ``localhost`` and binds to port 0 which uses a "
"free port assigned by the operating system. The server's URL can be accessed "
"with ``self.live_server_url`` during the tests."
msgstr ""
"实时服务器在 ``localhost`` 上监听，并绑定到 0 号端口，0 号端口使用操作系统分"
"配的一个空闲端口。在测试过程中可以用 ``self.live_server_url`` 访问服务器的 "
"URL。"

msgid ""
"To demonstrate how to use ``LiveServerTestCase``, let's write a Selenium "
"test. First of all, you need to install the `selenium package`_ into your "
"Python path:"
msgstr ""
"为了演示如何使用 ``LiveServerTestCase``，让我们写一个 Selenium 测试。首先，你"
"需要将 `selenium package`_ 安装到你的 Python 路径中。"

msgid ""
"Then, add a ``LiveServerTestCase``-based test to your app's tests module "
"(for example: ``myapp/tests.py``). For this example, we'll assume you're "
"using the :mod:`~django.contrib.staticfiles` app and want to have static "
"files served during the execution of your tests similar to what we get at "
"development time with ``DEBUG=True``, i.e. without having to collect them "
"using :djadmin:`collectstatic`. We'll use the  :class:`~django.contrib."
"staticfiles.testing.StaticLiveServerTestCase` subclass which provides that "
"functionality. Replace it with ``django.test.LiveServerTestCase`` if you "
"don't need that."
msgstr ""
"然后，在你的应用程序的测试模块中添加一个基于 ``LiveServerTestCase`` 的测试"
"（例如：``myapp/tests.py``）。在这个例子中，我们将假设你正在使用 :mod:"
"`~django.contrib.staticfiles` 应用，并且希望在执行测试时提供类似于我们在开发"
"时使用 ``DEBUG=True`` 得到的静态文件，即不必使用 :djadmin:`collectstatic` 收"
"集它们。我们将使用 :class:`~django.contrib.staticfiles.testing."
"StaticLiveServerTestCase` 子类，它提供了这个功能。如果不需要的话，可以用 "
"``django.test.LiveServerTestCase`` 代替。"

msgid "The code for this test may look as follows::"
msgstr "这个测试的代码可能如下："

msgid "Finally, you may run the test as follows:"
msgstr "最后，你可以按以下方式进行测试："

msgid ""
"This example will automatically open Firefox then go to the login page, "
"enter the credentials and press the \"Log in\" button. Selenium offers other "
"drivers in case you do not have Firefox installed or wish to use another "
"browser. The example above is just a tiny fraction of what the Selenium "
"client can do; check out the `full reference`_ for more details."
msgstr ""
"这个例子会自动打开 Firefox，然后进入登录页面，输入凭证并按“登录”按钮。"
"Selenium 提供了其他驱动程序，以防你没有安装 Firefox 或希望使用其他浏览器。上"
"面的例子只是 Selenium 客户端能做的一小部分，更多细节请查看 `full "
"reference`_。"

msgid ""
"When using an in-memory SQLite database to run the tests, the same database "
"connection will be shared by two threads in parallel: the thread in which "
"the live server is run and the thread in which the test case is run. It's "
"important to prevent simultaneous database queries via this shared "
"connection by the two threads, as that may sometimes randomly cause the "
"tests to fail. So you need to ensure that the two threads don't access the "
"database at the same time. In particular, this means that in some cases (for "
"example, just after clicking a link or submitting a form), you might need to "
"check that a response is received by Selenium and that the next page is "
"loaded before proceeding with further test execution. Do this, for example, "
"by making Selenium wait until the ``<body>`` HTML tag is found in the "
"response (requires Selenium > 2.13)::"
msgstr ""
"当使用内存 SQLite 数据库运行测试时，同一个数据库连接将由两个线程并行共享：运"
"行实时服务器的线程和运行测试用例的线程。要防止两个线程通过这个共享连接同时进"
"行数据库查询，因为这有时可能会随机导致测试失败。所以你需要确保两个线程不会同"
"时访问数据库。特别是，这意味着在某些情况下（例如，刚刚点击一个链接或提交一个"
"表单之后），你可能需要检查 Selenium 是否收到了响应，并且在继续执行进一步的测"
"试之前，检查下一个页面是否被加载。例如，让 Selenium 等待直到在响应中找到 "
"``<body>`` HTML 标签（需要 Selenium > 2.13）："

msgid ""
"The tricky thing here is that there's really no such thing as a \"page load,"
"\" especially in modern web apps that generate HTML dynamically after the "
"server generates the initial document. So, checking for the presence of "
"``<body>`` in the response might not necessarily be appropriate for all use "
"cases. Please refer to the `Selenium FAQ`_ and `Selenium documentation`_ for "
"more information."
msgstr ""

msgid "Test cases features"
msgstr "测试用例特性"

msgid "Default test client"
msgstr "默认测试客户端"

msgid ""
"Every test case in a ``django.test.*TestCase`` instance has access to an "
"instance of a Django test client. This client can be accessed as ``self."
"client``. This client is recreated for each test, so you don't have to worry "
"about state (such as cookies) carrying over from one test to another."
msgstr ""
"``django.test.*TestCase`` 实例中的每个测试用例都可以访问一个 Django 测试客户"
"端的实例。这个客户端可以用 ``self.client`` 来访问。这个客户端在每个测试中都会"
"被重新创建，所以你不必担心状态（比如 cookie）会从一个测试转移到另一个测试中。"

msgid "This means, instead of instantiating a ``Client`` in each test::"
msgstr "这意味着，不必每个测试中实例化一个 ``Client``："

msgid "...you can refer to ``self.client``, like so::"
msgstr "......你可以引用 ``self.client``，像这样："

msgid "Customizing the test client"
msgstr "自定义测试客户端"

msgid ""
"If you want to use a different ``Client`` class (for example, a subclass "
"with customized behavior), use the :attr:`~SimpleTestCase.client_class` "
"class attribute::"
msgstr ""
"如果你想使用不同的 ``Client`` 类（例如，一个具有自定义行为的子类），使用 :"
"attr:`~SimpleTestCase.client_class` 类属性："

msgid "Fixture loading"
msgstr "辅助工具加载"

msgid ""
"A test case for a database-backed website isn't much use if there isn't any "
"data in the database. Tests are more readable and it's more maintainable to "
"create objects using the ORM, for example in :meth:`TestCase.setUpTestData`, "
"however, you can also use fixtures."
msgstr ""
"如果数据库中没有任何数据，那么数据库支持的网站的测试用例就没什么用了。测试使"
"用ORM创建对象更易读，也更易维护，例如在 :meth:`TestCase.setUpTestData` 中。但"
"是，你也可以使用辅助工具。"

msgid ""
"A fixture is a collection of data that Django knows how to import into a "
"database. For example, if your site has user accounts, you might set up a "
"fixture of fake user accounts in order to populate your database during "
"tests."
msgstr ""
"辅助工具是 Django 知道如何导入数据库的数据集合。例如，如果你的网站有用户账"
"户，你可能会设置一个假用户账户的辅助工具，以便在测试时填充你的数据库。"

msgid ""
"The most straightforward way of creating a fixture is to use the :djadmin:"
"`manage.py dumpdata <dumpdata>` command. This assumes you already have some "
"data in your database. See the :djadmin:`dumpdata documentation<dumpdata>` "
"for more details."
msgstr ""
"创建辅助工具的最直接方法是使用 :djadmin:`manage.py dumpdata <dumpdata>` 命"
"令。这假定你已经在你的数据库中拥有一些数据。参见 :djadmin:`dumpdata 文档"
"<dumpdata>` 了解更多细节。"

msgid ""
"Once you've created a fixture and placed it in a ``fixtures`` directory in "
"one of your :setting:`INSTALLED_APPS`, you can use it in your unit tests by "
"specifying a ``fixtures`` class attribute on your :class:`django.test."
"TestCase` subclass::"
msgstr ""
"一旦你创建了一个辅助工具，并把它放在你的 :setting:`INSTALLED_APPS` 中的 "
"``fixtures`` 目录下，你就可以通过在你的 :class:`django.test.TestCase` 子类上"
"指定一个 ``fixtures`` 类属性来在你的单元测试中使用它。"

msgid "Here's specifically what will happen:"
msgstr "具体来说，将发生以下情况："

msgid ""
"At the start of each test, before ``setUp()`` is run, Django will flush the "
"database, returning the database to the state it was in directly after :"
"djadmin:`migrate` was called."
msgstr ""
"在每次测试开始时，在 ``setUp()`` 运行之前，Django 会对数据库进行刷新，将数据"
"库直接返回到 :djadmin:`migrate` 被调用后的状态。"

msgid ""
"Then, all the named fixtures are installed. In this example, Django will "
"install any JSON fixture named ``mammals``, followed by any fixture named "
"``birds``. See the :djadmin:`loaddata` documentation for more details on "
"defining and installing fixtures."
msgstr ""
"然后，所有命名的辅助工具都会被安装。在这个例子中，Django 将安装任何名为 "
"``mammals`` 的 JSON 辅助工具，然后是任何名为 ``birds`` 的辅助工具。请参阅 :"
"djadmin:`loaddata` 文档，了解更多关于定义和安装辅助工具的细节。"

msgid ""
"For performance reasons, :class:`TestCase` loads fixtures once for the "
"entire test class, before :meth:`~TestCase.setUpTestData`, instead of before "
"each test, and it uses transactions to clean the database before each test. "
"In any case, you can be certain that the outcome of a test will not be "
"affected by another test or by the order of test execution."
msgstr ""
"出于性能方面的考虑， :class:`TestCase` 在 :meth:`~TestCase.setUpTestData` 之"
"前为整个测试类加载一次辅助工具，而不是在每次测试之前加载，并且它在每次测试之"
"前使用事务来清理数据库。在任何情况下，你都可以确定一个测试的结果不会受到另一"
"个测试或测试执行顺序的影响。"

msgid ""
"By default, fixtures are only loaded into the ``default`` database. If you "
"are using multiple databases and set :attr:`TransactionTestCase.databases`, "
"fixtures will be loaded into all specified databases."
msgstr ""
"默认情况下，辅助工具只被加载到 ``default`` 数据库中。如果你使用多个数据库并且"
"设置了 :attr:`TransactionTestCase.databases`，辅助工具将被加载到所有指定的数"
"据库中。"

msgid "URLconf configuration"
msgstr "URLconf 配置"

msgid ""
"If your application provides views, you may want to include tests that use "
"the test client to exercise those views. However, an end user is free to "
"deploy the views in your application at any URL of their choosing. This "
"means that your tests can't rely upon the fact that your views will be "
"available at a particular URL. Decorate your test class or test method with "
"``@override_settings(ROOT_URLCONF=...)`` for URLconf configuration."
msgstr ""
"如果你的应用程序提供了视图，你可能希望包含使用测试客户端来行使这些视图的测"
"试。然而，最终用户可以自由地在他们选择的任何 URL 上部署应用程序中的视图。这意"
"味着你的测试不能依赖于你的视图将在特定的 URL 上可用这一事实。用 "
"``@override_settings(ROOT_URLCONF=...)`` 来装饰你的测试类或测试方法的 "
"URLconf 配置。"

msgid "Multi-database support"
msgstr "多数据库支持"

msgid ""
"Django sets up a test database corresponding to every database that is "
"defined in the :setting:`DATABASES` definition in your settings and referred "
"to by at least one test through ``databases``."
msgstr ""
"Django 设置了一个测试数据库，对应于你设置中的 :setting:`DATABASES` 定义的并且"
"至少有一个测试引用了 ``databases`` 的每个数据库。"

msgid ""
"However, a big part of the time taken to run a Django ``TestCase`` is "
"consumed by the call to ``flush`` that ensures that you have a clean "
"database at the start of each test run. If you have multiple databases, "
"multiple flushes are required (one for each database), which can be a time "
"consuming activity -- especially if your tests don't need to test multi-"
"database activity."
msgstr ""
"然而，运行一个 Django ``TestCase`` 所花费的时间很大一部分是被调用 ``flush`` "
"所消耗的，它确保了你在每次测试运行开始时有一个干净的数据库。如果你有多个数据"
"库，就需要多次刷新（每个数据库一个），这可能是一个耗时的活动——特别是当你的测"
"试不需要测试多数据库活动时。"

msgid ""
"As an optimization, Django only flushes the ``default`` database at the "
"start of each test run. If your setup contains multiple databases, and you "
"have a test that requires every database to be clean, you can use the "
"``databases`` attribute on the test suite to request extra databases to be "
"flushed."
msgstr ""
"作为一种优化，Django 只在每次测试运行开始时刷新 ``default`` 数据库。如果你的"
"设置包含多个数据库，并且你的测试要求每个数据库都是干净的，你可以使用测试套件"
"上的 ``databases`` 属性来请求额外的数据库被刷新。"

msgid ""
"This test case will flush the ``default`` and ``other`` test databases "
"before running ``test_index_page_view``. You can also use ``'__all__'`` to "
"specify that all of the test databases must be flushed."
msgstr ""
"这个测试用例将在运行 ``test_index_page_view`` 之前刷新 ``default`` 和 "
"``other`` 测试数据库。你也可以使用 ``'__all__'`` 来指定所有的测试数据库必须被"
"刷新。"

msgid ""
"The ``databases`` flag also controls which databases the :attr:"
"`TransactionTestCase.fixtures` are loaded into. By default, fixtures are "
"only loaded into the ``default`` database."
msgstr ""
"``databases`` 标志也控制 :attr:`TransactionTestCase.fixtures` 被加载到哪些数"
"据库。默认情况下，辅助工具只被加载到 ``default`` 数据库中。"

msgid ""
"Queries against databases not in ``databases`` will give assertion errors to "
"prevent state leaking between tests."
msgstr ""
"对不在 ``databases`` 中的数据库的查询将给出断言错误，以防止测试之间的状态泄"
"露。"

msgid ""
"By default, only the ``default`` database will be wrapped in a transaction "
"during a ``TestCase``'s execution and attempts to query other databases will "
"result in assertion errors to prevent state leaking between tests."
msgstr ""
"默认情况下，在 ``TestCase`` 期间，仅将 ``default`` 数据库包装在事务中，并且尝"
"试查询其他数据库将导致断言错误，以防止测试之间的状态泄漏。"

msgid ""
"Use the ``databases`` class attribute on the test class to request "
"transaction wrapping against non-``default`` databases."
msgstr ""
"在测试类上使用 ``databases`` 类属性来请求对非 ``default`` 数据库进行事务包"
"装。"

msgid ""
"This test will only allow queries against the ``other`` database. Just like "
"for :attr:`SimpleTestCase.databases` and :attr:`TransactionTestCase."
"databases`, the ``'__all__'`` constant can be used to specify that the test "
"should allow queries to all databases."
msgstr ""
"这个测试只允许对 ``other`` 数据库进行查询。就像 :attr:`SimpleTestCase."
"databases` 和 :attr:`TransactionTestCase.databases` 一样，``'__all__'`` 常量"
"可以用来指定测试应该允许对所有数据库进行查询。"

msgid "Overriding settings"
msgstr "覆盖配置"

msgid ""
"Use the functions below to temporarily alter the value of settings in tests. "
"Don't manipulate ``django.conf.settings`` directly as Django won't restore "
"the original values after such manipulations."
msgstr ""
"使用下面的函数可以临时改变测试中的设置值。不要直接操作 ``django.conf."
"settings``，因为 Django 不会在这种操作后恢复原始值。"

msgid ""
"For testing purposes it's often useful to change a setting temporarily and "
"revert to the original value after running the testing code. For this use "
"case Django provides a standard Python context manager (see :pep:`343`) "
"called :meth:`~django.test.SimpleTestCase.settings`, which can be used like "
"this::"
msgstr ""
"为了测试的目的，经常需要临时改变一个设置，并在运行测试代码后恢复到原始值。对"
"于这个用例，Django 提供了一个标准的 Python 上下文管理器（见 :pep:`343`），叫"
"做 :meth:`~django.test.SimpleTestCase.settings`，可以这样使用："

msgid ""
"This example will override the :setting:`LOGIN_URL` setting for the code in "
"the ``with`` block and reset its value to the previous state afterward."
msgstr ""

msgid ""
"It can prove unwieldy to redefine settings that contain a list of values. In "
"practice, adding or removing values is often sufficient. Django provides "
"the :meth:`~django.test.SimpleTestCase.modify_settings` context manager for "
"easier settings changes::"
msgstr ""
"重新定义包含一系列值的设置可能会很麻烦。在实践中，添加或删除值通常是足够的。"
"Django 提供了 :meth:`~django.test.SimpleTestCase.modify_settings` 上下文管理"
"器，以方便更改设置："

msgid ""
"For each action, you can supply either a list of values or a string. When "
"the value already exists in the list, ``append`` and ``prepend`` have no "
"effect; neither does ``remove`` when the value doesn't exist."
msgstr ""
"对于每个操作，你可以提供一个值的列表或一个字符串。当值已经存在于列表中时，"
"``append`` 和 ``prepend`` 没有效果；当值不存在时，``remove`` 也没有效果。"

msgid ""
"In case you want to override a setting for a test method, Django provides "
"the :func:`~django.test.override_settings` decorator (see :pep:`318`). It's "
"used like this::"
msgstr ""
"如果你想覆盖一个测试方法的设置，Django 提供了 :func:`~django.test."
"override_settings` 装饰器（见 :pep:`318`）。它的用法是这样的："

msgid ""
"The decorator can also be applied to :class:`~django.test.TestCase` classes::"
msgstr "装饰器也可以应用于 :class:`~django.test.TestCase` 类："

msgid ""
"Likewise, Django provides the :func:`~django.test.modify_settings` "
"decorator::"
msgstr "同样，Django 也提供了 :func:`~django.test.modify_settings` 装饰器："

msgid "The decorator can also be applied to test case classes::"
msgstr "此装饰器也可以应用于测试用例类："

msgid ""
"When given a class, these decorators modify the class directly and return "
"it; they don't create and return a modified copy of it. So if you try to "
"tweak the above examples to assign the return value to a different name than "
"``LoginTestCase`` or ``MiddlewareTestCase``, you may be surprised to find "
"that the original test case classes are still equally affected by the "
"decorator. For a given class, :func:`~django.test.modify_settings` is always "
"applied after :func:`~django.test.override_settings`."
msgstr ""
"当给定一个类时，这些装饰器直接修改该类并返回它，它们不会创建并返回一个修改后"
"的副本。因此，如果你试图调整上面的例子，将返回值分配给一个不同于 "
"``LoginTestCase`` 或 ``MiddlewareTestCase`` 的名称，你可能会惊讶地发现，原来"
"的测试用例类仍然同样受到装饰器的影响。对于一个给定的类，:func:`~django.test."
"modify_settings` 总是应用在 :func:`~django.test.override_settings` 之后。"

msgid ""
"The settings file contains some settings that are only consulted during "
"initialization of Django internals. If you change them with "
"``override_settings``, the setting is changed if you access it via the "
"``django.conf.settings`` module, however, Django's internals access it "
"differently. Effectively, using :func:`~django.test.override_settings` or :"
"func:`~django.test.modify_settings` with these settings is probably not "
"going to do what you expect it to do."
msgstr ""
"配置文件中包含了一些设置，这些设置只有在 Django 内部初始化时才会被使用。如果"
"你用 ``override_settings`` 改变它们，当你通过``django.conf.settings`` 模块访"
"问会得到被改变的配置。但是，Django 的内部程序访问它的方式是不同的。实际上，使"
"用 :func:`~django.test.override_settings` 或者 :func:`~django.test."
"modify_settings` 来使用这些设置，很可能达不到你预期的效果。"

msgid ""
"We do not recommend altering the :setting:`DATABASES` setting. Altering the :"
"setting:`CACHES` setting is possible, but a bit tricky if you are using "
"internals that make using of caching, like :mod:`django.contrib.sessions`. "
"For example, you will have to reinitialize the session backend in a test "
"that uses cached sessions and overrides :setting:`CACHES`."
msgstr ""
"我们不建议改变 :setting:`DATABASES` 的设置。改变 :setting:`CACHES` 的设置是可"
"能的，但如果你使用的是内部缓存，比如 :mod:`django.contrib.session`，就有点棘"
"手。例如，你必须在使用缓存会话并覆盖 :setting:`CACHES` 的测试中重新初始化会话"
"后端。"

msgid ""
"Finally, avoid aliasing your settings as module-level constants as "
"``override_settings()`` won't work on such values since they are only "
"evaluated the first time the module is imported."
msgstr ""
"最后，避免将你的配置别名为模块级常量，因为 ``override_settings()`` 不会对这些"
"值起作用，它们只在第一次导入模块时才被评估。"

msgid ""
"You can also simulate the absence of a setting by deleting it after settings "
"have been overridden, like this::"
msgstr "你也可以在配置被覆盖后，通过删除配置来模拟没有配置，比如这样："

msgid ""
"When overriding settings, make sure to handle the cases in which your app's "
"code uses a cache or similar feature that retains state even if the setting "
"is changed. Django provides the :data:`django.test.signals.setting_changed` "
"signal that lets you register callbacks to clean up and otherwise reset "
"state when settings are changed."
msgstr ""
"覆盖配置时，请确保处理你的应用代码使用即使保留配置更改也能保持状态的缓存或类"
"似功能的情况。Django 提供了 :data:`django.test.signals.setting_changed` 信"
"号，让你在设置被改变时，可以注册回调来清理和重置状态。"

msgid "Django itself uses this signal to reset various data:"
msgstr "Django 自己也使用这个信号来重置各种数据。"

msgid "Overridden settings"
msgstr "覆盖配置"

msgid "Data reset"
msgstr "数据重置"

msgid "USE_TZ, TIME_ZONE"
msgstr "USE_TZ，TIME_ZONE"

msgid "Databases timezone"
msgstr "数据库时区"

msgid "TEMPLATES"
msgstr "TEMPLATES"

msgid "Template engines"
msgstr "模板引擎"

msgid "SERIALIZATION_MODULES"
msgstr "SERIALIZATION_MODULES"

msgid "Serializers cache"
msgstr "序列化器缓存"

msgid "LOCALE_PATHS, LANGUAGE_CODE"
msgstr "LOCALE_PATHS，LANGUAGE_CODE"

msgid "Default translation and loaded translations"
msgstr "默认翻译和加载的翻译"

msgid "MEDIA_ROOT, DEFAULT_FILE_STORAGE"
msgstr "MEDIA_ROOT，DEFAULT_FILE_STORAGE"

msgid "Default file storage"
msgstr "默认文件存储"

msgid "Emptying the test outbox"
msgstr "清空测试发件箱"

msgid ""
"If you use any of Django's custom ``TestCase`` classes, the test runner will "
"clear the contents of the test email outbox at the start of each test case."
msgstr ""
"如果你使用任何 Django 的自定义 ``TestCase`` 类，测试运行器将在每个测试用例开"
"始时清除测试邮件发件箱的内容。"

msgid ""
"For more detail on email services during tests, see `Email services`_ below."
msgstr "关于测试期间电子邮件服务的更多细节，请参见下面的 `Email services`_。"

msgid "Assertions"
msgstr "断言"

msgid ""
"As Python's normal :class:`unittest.TestCase` class implements assertion "
"methods such as :meth:`~unittest.TestCase.assertTrue` and :meth:`~unittest."
"TestCase.assertEqual`, Django's custom :class:`TestCase` class provides a "
"number of custom assertion methods that are useful for testing web "
"applications:"
msgstr ""

msgid ""
"The failure messages given by most of these assertion methods can be "
"customized with the ``msg_prefix`` argument. This string will be prefixed to "
"any failure message generated by the assertion. This allows you to provide "
"additional details that may help you to identify the location and cause of a "
"failure in your test suite."
msgstr ""
"大多数这些断言方法给出的失败信息可以用 ``msg_prefix`` 参数自定义。这个字符串"
"将被加在断言产生的任何失败信息的前面。这允许你提供额外的细节，以帮助你确定测"
"试套件中失败的位置和原因。"

msgid ""
"Asserts that execution of ``callable`` raises ``expected_exception`` and "
"that ``expected_message`` is found in the exception's message. Any other "
"outcome is reported as a failure. It's a simpler version of :meth:`unittest."
"TestCase.assertRaisesRegex` with the difference that ``expected_message`` "
"isn't treated as a regular expression."
msgstr ""
"断言执行 ``callable`` 引起 ``expected_exception``，并且在异常信息中发现 "
"``expected_message``。任何其他结果都会被报告为失败。它是 :meth:`unittest."
"TestCase.assertRaisesRegex` 的简单版本，不同的是 ``expected_message`` 不作为"
"正则表达式处理。"

msgid ""
"If only the ``expected_exception`` and ``expected_message`` parameters are "
"given, returns a context manager so that the code being tested can be "
"written inline rather than as a function::"
msgstr ""
"如果只给了 ``expected_exception`` 和 ``expected_message`` 参数，则返回一个上"
"下文管理器，以便被测试的代码可以内联而不是作为一个函数来写："

msgid ""
"Analogous to :meth:`SimpleTestCase.assertRaisesMessage` but for :meth:"
"`~unittest.TestCase.assertWarnsRegex` instead of :meth:`~unittest.TestCase."
"assertRaisesRegex`."
msgstr ""
"类似于 :meth:`SimpleTestCase.assertRaisesMessage`，但是 :meth:`~unittest."
"TestCase.assertWarnsRegex` 代替 :meth:`~unittest.TestCase."
"assertRaisesRegex`。"

msgid "Asserts that a form field behaves correctly with various inputs."
msgstr "断言表单字段在不同的输入情况下表现正确。"

msgid "the class of the field to be tested."
msgstr "待测试字段的类。"

msgid "a dictionary mapping valid inputs to their expected cleaned values."
msgstr "一个字典，将有效输入映射到它们的预期干净值。"

msgid ""
"a dictionary mapping invalid inputs to one or more raised error messages."
msgstr "一个字典，将无效输入映射到一个或多个引发的错误信息"

msgid "the args passed to instantiate the field."
msgstr "传递给实例化字段的 args。"

msgid "the kwargs passed to instantiate the field."
msgstr "传递给实例化字段的 kwargs。"

msgid "the expected clean output for inputs in ``empty_values``."
msgstr "``empty_values`` 中输入的预期干净输出。"

msgid ""
"For example, the following code tests that an ``EmailField`` accepts ``a@a."
"com`` as a valid email address, but rejects ``aaa`` with a reasonable error "
"message::"
msgstr ""
"例如，以下代码测试 ``EmailField`` 接受 ``a@a.com`` 作为有效的电子邮件地址，但"
"拒绝 ``aaa``，并给出合理的错误信息："

msgid ""
"Asserts that a field on a form raises the provided list of errors when "
"rendered on the form."
msgstr "断言表单中的某个字段在表单中呈现时，会引发所提供的错误列表。"

msgid ""
"``response`` must be a response instance returned by the :class:`test client "
"<django.test.Response>`."
msgstr ""

msgid ""
"``form`` is the name the ``Form`` instance was given in the template context "
"of the response."
msgstr ""

msgid ""
"``field`` is the name of the field on the form to check. If ``field`` has a "
"value of ``None``, non-field errors (errors you can access via :meth:`form."
"non_field_errors() <django.forms.Form.non_field_errors>`) will be checked."
msgstr ""
"``field`` 是表单中要检查的字段名。如果 ``field`` 的值为 ``None``，则会检查非"
"字段错误（可以通过 :meth:`form.non_field_errors() <django.forms.Form."
"non_field_errors>`）。"

msgid ""
"``errors`` is an error string, or a list of error strings, that are expected "
"as a result of form validation."
msgstr "``errors`` 是一个错误字符串，或一个错误字符串列表，是表单验证的结果。"

msgid ""
"Asserts that the ``formset`` raises the provided list of errors when "
"rendered."
msgstr "断言 ``formset`` 在渲染时，会引发所提供的错误列表。"

msgid ""
"``formset`` is the name the ``Formset`` instance was given in the template "
"context of the response."
msgstr ""

msgid ""
"``form_index`` is the number of the form within the ``Formset``.  If "
"``form_index`` has a value of ``None``, non-form errors (errors you can "
"access via ``formset.non_form_errors()``) will be checked."
msgstr ""
"``form_index`` 是 ``Formset`` 中表单的编号。 如果 ``form_index`` 的值为 "
"``None``，则将检查非表单错误（可以通过 ``formset.non_form_errors()`` 访问的错"
"误）。"

msgid ""
"Asserts that a :class:`response <django.http.HttpResponse>` produced the "
"given :attr:`~django.http.HttpResponse.status_code` and that ``text`` "
"appears in its :attr:`~django.http.HttpResponse.content`. If ``count`` is "
"provided, ``text`` must occur exactly ``count`` times in the response."
msgstr ""

msgid ""
"Set ``html`` to ``True`` to handle ``text`` as HTML. The comparison with the "
"response content will be based on HTML semantics instead of character-by-"
"character equality. Whitespace is ignored in most cases, attribute ordering "
"is not significant. See :meth:`~SimpleTestCase.assertHTMLEqual` for more "
"details."
msgstr ""
"将 ``html`` 设置为 ``True``，将 ``text`` 作为 HTML 处理。与响应内容的比较将基"
"于 HTML 语义，而不是逐个字符的平等。在大多数情况下，空格会被忽略，属性排序并"
"不重要。详见 :meth:`~SimpleTestCase.assertHTMLEqual`。"

msgid ""
"Asserts that a :class:`response <django.http.HttpResponse>` produced the "
"given :attr:`~django.http.HttpResponse.status_code` and that ``text`` does "
"*not* appear in its :attr:`~django.http.HttpResponse.content`."
msgstr ""

msgid ""
"Asserts that the template with the given name was used in rendering the "
"response."
msgstr "断言给定名称的模板被用于渲染响应。"

msgid "``template_name`` should be a string such as ``'admin/index.html'``."
msgstr "``template_name``应当是一个字符串，如``'admin/index.html'``。"

msgid ""
"The ``count`` argument is an integer indicating the number of times the "
"template should be rendered. Default is ``None``, meaning that the template "
"should be rendered one or more times."
msgstr ""

msgid "You can use this as a context manager, like this::"
msgstr "你可以把它作为一个上下文管理器，比如："

msgid ""
"Asserts that the template with the given name was *not* used in rendering "
"the response."
msgstr "断言给定名称的模板在渲染响应时 *没有* 被使用。"

msgid ""
"You can use this as a context manager in the same way as :meth:"
"`~SimpleTestCase.assertTemplateUsed`."
msgstr ""
"你可以用 :meth:`~SimpleTestCase.assertTemplateUsed` 一样的方式将其作为上下文"
"管理器。"

msgid ""
"Asserts that two URLs are the same, ignoring the order of query string "
"parameters except for parameters with the same name. For example, ``/path/?"
"x=1&y=2`` is equal to ``/path/?y=2&x=1``, but ``/path/?a=1&a=2`` isn't equal "
"to ``/path/?a=2&a=1``."
msgstr ""
"断言两个 URL 是相同的，忽略查询字符串参数的顺序，但同名参数除外。例如，``/"
"path/?x=1&y=2`` 等于 ``/path/?y=2&x=1``，但 ``/path/?a=1&a=2`` 不等于 ``/"
"path/?a=2&a=1``。"

msgid ""
"Asserts that the :class:`response <django.http.HttpResponse>` returned a :"
"attr:`~django.http.HttpResponse.status_code` redirect status, redirected to "
"``expected_url`` (including any ``GET`` data), and that the final page was "
"received with ``target_status_code``."
msgstr ""

msgid ""
"If your request used the ``follow`` argument, the ``expected_url`` and "
"``target_status_code`` will be the url and status code for the final point "
"of the redirect chain."
msgstr ""
"如果你的请求使用了 ``follow`` 参数，``expected_url`` 和 "
"``target_status_code`` 将是重定向链最后一点的网址和状态码。"

msgid ""
"If ``fetch_redirect_response`` is ``False``, the final page won't be loaded. "
"Since the test client can't fetch external URLs, this is particularly useful "
"if ``expected_url`` isn't part of your Django app."
msgstr ""
"如果 ``fetch_redirect_response`` 为 ``False``，则最终页面不会被加载。由于测试"
"客户端不能获取外部 URL，所以如果 ``expected_url`` 不是 Django 应用的一部分，"
"这一点就特别有用。"

msgid ""
"Scheme is handled correctly when making comparisons between two URLs. If "
"there isn't any scheme specified in the location where we are redirected to, "
"the original request's scheme is used. If present, the scheme in "
"``expected_url`` is the one used to make the comparisons to."
msgstr ""
"在两个 URL 之间进行比较时，可以正确处理协议。如果在我们被重定向到的位置没有指"
"定任何协议，则使用原始请求的协议。如果存在，``expected_url`` 中的协议就是用来"
"进行比较的。"

msgid ""
"Asserts that the strings ``html1`` and ``html2`` are equal. The comparison "
"is based on HTML semantics. The comparison takes following things into "
"account:"
msgstr ""
"断言字符串 ``html1`` 和 ``html2`` 相等。比较是基于 HTML 语义的。比较时考虑到"
"以下因素："

msgid "Whitespace before and after HTML tags is ignored."
msgstr "HTML 标签前后的空白会被忽略。"

msgid "All types of whitespace are considered equivalent."
msgstr "所有类型的空白都被认为是等价的。"

msgid ""
"All open tags are closed implicitly, e.g. when a surrounding tag is closed "
"or the HTML document ends."
msgstr "所有打开的标签都是隐式关闭的，例如当周围的标签关闭或 HTML 文档结束时。"

msgid "Empty tags are equivalent to their self-closing version."
msgstr "空标签相当于其自动闭合版。"

msgid "The ordering of attributes of an HTML element is not significant."
msgstr "HTML 元素的属性排序并不重要。"

msgid ""
"Boolean attributes (like ``checked``) without an argument are equal to "
"attributes that equal in name and value (see the examples)."
msgstr ""

msgid ""
"Text, character references, and entity references that refer to the same "
"character are equivalent."
msgstr "引用同一字符的文本、字符引用和实体引用是等价的。"

msgid ""
"The following examples are valid tests and don't raise any "
"``AssertionError``::"
msgstr "下面的例子是有效的测试，并且没有引起任何 ``AssertionError``:"

msgid ""
"``html1`` and ``html2`` must contain HTML. An ``AssertionError`` will be "
"raised if one of them cannot be parsed."
msgstr ""
"``html1`` 和 ``html2`` 必须包含 HTML。如果其中一个不能被解析，将产生一个 "
"``AssertionError``。"

msgid "Output in case of error can be customized with the ``msg`` argument."
msgstr "错误时的输出可以用 ``msg`` 参数自定义。"

msgid ""
"In older versions, any attribute (not only boolean attributes) without a "
"value was considered equal to an attribute with the same name and value."
msgstr ""

msgid ""
"Asserts that the strings ``html1`` and ``html2`` are *not* equal. The "
"comparison is based on HTML semantics. See :meth:`~SimpleTestCase."
"assertHTMLEqual` for details."
msgstr ""
"断言字符串 ``html1`` 和 ``html2`` *不* 相等。比较是基于 HTML 语义的。详见 :"
"meth:`~SimpleTestCase.assertHTMLEqual`。"

msgid ""
"Asserts that the strings ``xml1`` and ``xml2`` are equal. The comparison is "
"based on XML semantics. Similarly to :meth:`~SimpleTestCase."
"assertHTMLEqual`, the comparison is made on parsed content, hence only "
"semantic differences are considered, not syntax differences. When invalid "
"XML is passed in any parameter, an ``AssertionError`` is always raised, even "
"if both strings are identical."
msgstr ""
"断言字符串 ``xml1`` 和 ``xml2`` 相等。比较是基于 XML 语义的。与 :meth:"
"`~SimpleTestCase.assertHTMLEqual` 类似，比较是在解析内容上进行的，因此只考虑"
"语义差异，而不是语法差异。当任何参数中传递了无效的 XML 时，即使两个字符串相"
"同，也总是会引发一个 ``AssertionError``。"

msgid ""
"XML declaration, document type, processing instructions, and comments are "
"ignored. Only the root element and its children are compared."
msgstr ""
"忽略 XML 声明、文档类型、处理指令和注释。只有根元素和它的子元素被比较。"

msgid ""
"Asserts that the strings ``xml1`` and ``xml2`` are *not* equal. The "
"comparison is based on XML semantics. See :meth:`~SimpleTestCase."
"assertXMLEqual` for details."
msgstr ""
"断言字符串 ``xml1`` 和 ``xml2`` *不* 相等。比较是基于 XML 语义的，参见 :meth:"
"`~SimpleTestCase.assertXMLEqual`。"

msgid ""
"Asserts that the HTML fragment ``needle`` is contained in the ``haystack`` "
"one."
msgstr "断言 HTML 片段 ``needle`` 包含在 ``haystack`` 中。"

msgid ""
"If the ``count`` integer argument is specified, then additionally the number "
"of ``needle`` occurrences will be strictly verified."
msgstr "如果指定了 ``count`` 整数参数，则将严格核查 ``needle`` 的出现次数。"

msgid ""
"Whitespace in most cases is ignored, and attribute ordering is not "
"significant. See :meth:`~SimpleTestCase.assertHTMLEqual` for more details."
msgstr ""
"在大多数情况下，空白是被忽略的，属性排序并不重要。参见 :meth:"
"`~SimpleTestCase.assertHTMLEqual` 以了解更多细节。"

msgid ""
"Asserts that the JSON fragments ``raw`` and ``expected_data`` are equal. "
"Usual JSON non-significant whitespace rules apply as the heavyweight is "
"delegated to the :mod:`json` library."
msgstr ""
"断言 JSON 片段 ``raw`` 和 ``expected_data`` 相等。通常的 JSON 非显性空格规则"
"适用，因为重量级是委托给 :mod:`json` 库的。"

msgid ""
"Asserts that the JSON fragments ``raw`` and ``expected_data`` are *not* "
"equal. See :meth:`~SimpleTestCase.assertJSONEqual` for further details."
msgstr ""
"断言 JSON 片段 ``raw`` 和 ``expected_data`` *不* 相等。详见 :meth:"
"`~SimpleTestCase.assertJSONEqual`。"

msgid ""
"Asserts that a queryset ``qs`` matches a particular iterable of values "
"``values``."
msgstr "断言一个查询集 ``qs`` 与一个特定的可迭代对象 ``values`` 的值匹配。"

msgid ""
"If ``transform`` is provided, ``values`` is compared to a list produced by "
"applying ``transform`` to each member of ``qs``."
msgstr ""
"如果提供了 ``transform``，``values`` 将与应用 ``transform`` 于 ``qs`` 而产生"
"的列表中每个成员进行比较。"

msgid ""
"By default, the comparison is also ordering dependent. If ``qs`` doesn't "
"provide an implicit ordering, you can set the ``ordered`` parameter to "
"``False``, which turns the comparison into a ``collections.Counter`` "
"comparison. If the order is undefined (if the given ``qs`` isn't ordered and "
"the comparison is against more than one ordered value), a ``ValueError`` is "
"raised."
msgstr ""
"默认情况下，比较也是依赖于顺序的。如果 ``qs`` 不提供隐式排序，你可以将 "
"``ordered`` 参数设置为 ``False``，这将使比较变成 ``collections.Counter`` 比"
"较。如果顺序是未定义的（如果给定的 ``qs`` 不是有序的，并且比较的对象是一个以"
"上的有序值），会产生一个 ``ValueError``。"

msgid "The default value of ``transform`` argument was changed to ``None``."
msgstr "``transform`` 参数的默认值改为 ``None``。"

msgid "Support for direct comparison between querysets was added."
msgstr "增加了对查询集之间直接比较的支持。"

msgid ""
"If ``transform`` is not provided and ``values`` is a list of strings, it's "
"compared to a list produced by applying ``repr()`` to each member of ``qs``. "
"This behavior is deprecated and will be removed in Django 4.1. If you need "
"it, explicitly set ``transform`` to ``repr``."
msgstr ""
"如果没有提供 ``transform``，并且 ``values`` 是一个字符串列表，它将被比作一个"
"对 ``qs`` 的每个成员应用 ``repr()`` 产生的列表。这一行为已被废弃，并将在 "
"Django 4.1 中被移除。如果你需要它，可以明确地将 ``transform`` 设置为 "
"``repr``。"

msgid ""
"Asserts that when ``func`` is called with ``*args`` and ``**kwargs`` that "
"``num`` database queries are executed."
msgstr ""
"断言当 ``func`` 与 ``*args`` 和 ``**kwargs`` 一起调用时，会执行 ``num`` 次数"
"据库查询。"

msgid ""
"If a ``\"using\"`` key is present in ``kwargs`` it is used as the database "
"alias for which to check the number of queries::"
msgstr ""
"如果 ``kwargs`` 中存在 ``\"using\"`` 键，则使用该键作为数据库别名，以检查查询"
"次数："

msgid ""
"If you wish to call a function with a ``using`` parameter you can do it by "
"wrapping the call with a ``lambda`` to add an extra parameter::"
msgstr ""
"如果你想调用一个带有 ``using`` 参数的函数，你可以通过用 ``lambda`` 包装调用来"
"增加一个额外的参数："

msgid "You can also use this as a context manager::"
msgstr "你也可以用它作为上下文管理器::"

msgid "Tagging tests"
msgstr "标记测试"

msgid ""
"You can tag your tests so you can easily run a particular subset. For "
"example, you might label fast or slow tests::"
msgstr ""
"你可以给你的测试打上标签，这样你就可以轻松地运行一个特定的子集。例如，你可以"
"标记快速或慢速测试："

msgid "You can also tag a test case::"
msgstr "你也可以标记一个测试用例："

msgid ""
"Subclasses inherit tags from superclasses, and methods inherit tags from "
"their class. Given::"
msgstr "子类从超类继承标签，方法从其类继承标签。如："

msgid ""
"``SampleTestCaseChild.test`` will be labeled with ``'slow'``, ``'core'``, "
"``'bar'``, and ``'foo'``."
msgstr ""
"``SampleTestCaseChild.test`` 将用 ``'slow'``、``'core'``、``'bar'`` 和 "
"``'foo'`` 来标注。"

msgid ""
"Then you can choose which tests to run. For example, to run only fast tests:"
msgstr "然后你可以选择要运行的测试。例如，只运行快速测试："

msgid "Or to run fast tests and the core one (even though it's slow):"
msgstr "或者运行快速测试和核心测试（即使它很慢）："

msgid ""
"You can also exclude tests by tag. To run core tests if they are not slow:"
msgstr "你也可以通过标签来排除测试。如果要运行不慢的核心测试："

msgid ""
":option:`test --exclude-tag` has precedence over :option:`test --tag`, so if "
"a test has two tags and you select one of them and exclude the other, the "
"test won't be run."
msgstr ""
":option:`test --exclud-tag` 优先于 :option:`test --tag`，所以如果一个测试有两"
"个标签，你选择了其中一个而排除了另一个，测试就不会被运行。"

msgid "Testing asynchronous code"
msgstr "测试异步代码"

msgid ""
"If you merely want to test the output of your asynchronous views, the "
"standard test client will run them inside their own asynchronous loop "
"without any extra work needed on your part."
msgstr ""
"如果你只是想测试异步视图的输出，标准测试客户端将在自己的异步循环中运行它们，"
"而不需要你做任何额外的工作。"

msgid ""
"However, if you want to write fully-asynchronous tests for a Django project, "
"you will need to take several things into account."
msgstr "但是，如果你想为 Django 项目编写完全异步的测试，你需要考虑到几个问题。"

msgid ""
"Firstly, your tests must be ``async def`` methods on the test class (in "
"order to give them an asynchronous context). Django will automatically "
"detect any ``async def`` tests and wrap them so they run in their own event "
"loop."
msgstr ""
"首先，你的测试必须是测试类上的 ``async def`` 方法（为了给它们一个异步的上下"
"文）。Django 会自动检测到任何 ``async def`` 的测试，并将它们封装在自己的事件"
"循环中运行。"

msgid ""
"If you are testing from an asynchronous function, you must also use the "
"asynchronous test client. This is available as ``django.test.AsyncClient``, "
"or as ``self.async_client`` on any test."
msgstr ""
"如果你从一个异步函数进行测试，你也必须使用异步测试客户端。这在任何测试中都可"
"以作为 ``django.test.AsyncClient`` 或 ``self.async_client`` 使用。"

msgid ""
"``AsyncClient`` has the same methods and signatures as the synchronous "
"(normal) test client, with two exceptions:"
msgstr ""
"``AsyncClient`` 具有与同步（普通）测试客户端相同的方法和签名，但有两个例外："

msgid "The ``follow`` parameter is not supported."
msgstr "不支持 ``follow`` 参数。"

msgid ""
"Headers passed as ``extra`` keyword arguments should not have the ``HTTP_`` "
"prefix required by the synchronous client (see :meth:`Client.get`). For "
"example, here is how to set an HTTP ``Accept`` header::"
msgstr ""
"作为 ``extra`` 关键字参数传递的头信息不应该有同步客户端所要求的 ``HTTP_`` 前"
"缀（参见 :meth:`Client.get`）。例如，下面是如何设置 HTTP ``Accept`` 头："

msgid "Using ``AsyncClient`` any method that makes a request must be awaited::"
msgstr "使用 ``AsyncClient`` 任何提出请求的方法都必须被等待："

msgid ""
"The asynchronous client can also call synchronous views; it runs through "
"Django's :doc:`asynchronous request path </topics/async>`, which supports "
"both. Any view called through the ``AsyncClient`` will get an "
"``ASGIRequest`` object for its ``request`` rather than the ``WSGIRequest`` "
"that the normal client creates."
msgstr ""
"异步客户端也可以调用同步视图；它通过 Django 的 :doc:`异步请求路径 </topics/"
"async>` 运行，它支持这两种方式。任何通过 ``AsyncClient`` 调用的视图都会得到一"
"个 ``ASGIRequest`` 对象作为它的 ``request``，而不是普通客户端创建的 "
"``WSGIRequest``。"

msgid ""
"If you are using test decorators, they must be async-compatible to ensure "
"they work correctly. Django's built-in decorators will behave correctly, but "
"third-party ones may appear to not execute (they will \"wrap\" the wrong "
"part of the execution flow and not your test)."
msgstr ""
"如果你使用的是测试装饰器，它们必须是异步兼容的，以确保它们正确工作。Django 内"
"置的装饰器会正常工作，但第三方的装饰器可能会出现无法执行的情况（它们会“包"
"装”执行流程中错误的部分，而不是你的测试）。"

msgid ""
"If you need to use these decorators, then you should decorate your test "
"methods with :func:`~asgiref.sync.async_to_sync` *inside* of them instead::"
msgstr ""
"如果你需要使用这些装饰器，那么你应该用 :func:`~asgiref.sync.async_to_sync` 来"
"装饰你的测试方法:"

msgid "Email services"
msgstr "邮件服务"

msgid ""
"If any of your Django views send email using :doc:`Django's email "
"functionality </topics/email>`, you probably don't want to send email each "
"time you run a test using that view. For this reason, Django's test runner "
"automatically redirects all Django-sent email to a dummy outbox. This lets "
"you test every aspect of sending email -- from the number of messages sent "
"to the contents of each message -- without actually sending the messages."
msgstr ""
"如果你的任何 Django 视图使用 :doc:`Django 的邮件功能 </topics/email>` 发送电"
"子邮件，你可能不想每次使用该视图运行测试时都发送电子邮件。出于这个原因，"
"Django 的测试运行器会自动将所有 Django 发送的邮件重定向到一个虚拟的发件箱。这"
"让你可以测试发送邮件的每一个方面——从发送邮件的数量到每封邮件的内容——而不用实"
"际发送邮件。"

msgid ""
"The test runner accomplishes this by transparently replacing the normal "
"email backend with a testing backend. (Don't worry -- this has no effect on "
"any other email senders outside of Django, such as your machine's mail "
"server, if you're running one.)"
msgstr ""
"测试运行器通过透明的将正常的邮件后端替换为测试后端来实现。（别担心——这对 "
"Django 之外的其他邮件发送器没有影响，比如你机器的邮件服务器，如果你正在运行一"
"个的话。）"

msgid ""
"During test running, each outgoing email is saved in ``django.core.mail."
"outbox``. This is a list of all :class:`~django.core.mail.EmailMessage` "
"instances that have been sent.  The ``outbox`` attribute is a special "
"attribute that is created *only* when the ``locmem`` email backend is used. "
"It doesn't normally exist as part of the :mod:`django.core.mail` module and "
"you can't import it directly. The code below shows how to access this "
"attribute correctly."
msgstr ""
"在测试运行过程中，每一封发出的邮件都会保存在 ``django.core.mail.outbox`` 中。"
"这是所有已经发送的 :class:`~django.core.mail.EmailMessage` 实例的列表。 "
"``outbox`` 属性是一个特殊的属性，只有在使用 ``locmem`` 邮件后端时才会创建。它"
"通常不作为 :mod:`django.core.mail` 模块的一部分存在，你也不能直接导入它。下面"
"的代码展示了如何正确访问这个属性。"

msgid ""
"Here's an example test that examines ``django.core.mail.outbox`` for length "
"and contents::"
msgstr "下面是一个检查 ``django.core.mail.outbox`` 长度和内容的测试示例："

msgid ""
"As noted :ref:`previously <emptying-test-outbox>`, the test outbox is "
"emptied at the start of every test in a Django ``*TestCase``. To empty the "
"outbox manually, assign the empty list to ``mail.outbox``::"
msgstr ""
"正如 :ref:`之前 <emptying-test-outbox>`，在 Django ``*TestCase`` 中的每个测试"
"开始时，测试发件箱都会被清空。要手动清空发件箱，将空列表分配给 ``mail."
"outbox``："

msgid "Management Commands"
msgstr "管理命令"

msgid ""
"Management commands can be tested with the :func:`~django.core.management."
"call_command` function. The output can be redirected into a ``StringIO`` "
"instance::"
msgstr ""
"管理命令可以用 :func:`~django.core.management.call_command` 函数来测试。输出"
"可以重定向到 ``StringIO`` 实例中："

msgid "Skipping tests"
msgstr "忽略测试"

msgid ""
"The unittest library provides the :func:`@skipIf <unittest.skipIf>` and :"
"func:`@skipUnless <unittest.skipUnless>` decorators to allow you to skip "
"tests if you know ahead of time that those tests are going to fail under "
"certain conditions."
msgstr ""
"unittest 库提供了 :func:`@skipIf <unittest.skipIf>` 和 :func:`@skipUnless "
"<unittest.skipUnless>` 装饰器，允许你跳过测试，如果你事先知道这些测试在某些条"
"件下会失败。"

msgid ""
"For example, if your test requires a particular optional library in order to "
"succeed, you could decorate the test case with :func:`@skipIf <unittest."
"skipIf>`. Then, the test runner will report that the test wasn't executed "
"and why, instead of failing the test or omitting the test altogether."
msgstr ""
"例如，如果你的测试需要一个特定的可选库才能成功，你可以用 :func:`@skipIf "
"<unittest.skipIf>` 来装饰测试用例。然后，测试运行器将报告测试没有被执行以及原"
"因，而不是测试失败或完全省略测试。"

msgid ""
"To supplement these test skipping behaviors, Django provides two additional "
"skip decorators. Instead of testing a generic boolean, these decorators "
"check the capabilities of the database, and skip the test if the database "
"doesn't support a specific named feature."
msgstr ""
"为了补充这些测试跳过行为，Django 提供了两个额外的跳过装饰器。这些装饰器不是测"
"试一个通用的布尔值，而是检查数据库的能力，如果数据库不支持一个特定的命名特"
"性，则跳过测试。"

msgid ""
"The decorators use a string identifier to describe database features. This "
"string corresponds to attributes of the database connection features class. "
"See :source:`django.db.backends.base.features.BaseDatabaseFeatures class "
"<django/db/backends/base/features.py>` for a full list of database features "
"that can be used as a basis for skipping tests."
msgstr ""
"装饰器使用一个字符串标识符来描述数据库特征。这个字符串对应于数据库连接特征类"
"的属性。参见 :source:`django.db.backends.base.features.BaseDatabaseFeatures "
"类 <django/db/backends/base/features.py>` 以获得可作为跳过测试基础的数据库特"
"征的完整列表。"

msgid ""
"Skip the decorated test or ``TestCase`` if all of the named database "
"features are supported."
msgstr "如果支持某个命名的数据库功能，则跳过装饰测试或 ``TestCase``。"

msgid ""
"For example, the following test will not be executed if the database "
"supports transactions (e.g., it would *not* run under PostgreSQL, but it "
"would under MySQL with MyISAM tables)::"
msgstr ""
"例如，如果数据库支持事务，下面的测试将不会被执行（例如，在PostgreSQL 下，它"
"将 *不* 会运行，但在 MySQL 的 MyISAM 表下却可以）："

msgid ""
"Skip the decorated test or ``TestCase`` if any of the named database "
"features are *not* supported."
msgstr "如果 *不* 支持某个命名的数据库功能，则跳过装饰测试或 ``TestCase``。"

msgid ""
"For example, the following test will only be executed if the database "
"supports transactions (e.g., it would run under PostgreSQL, but *not* under "
"MySQL with MyISAM tables)::"
msgstr ""
"例如，接下来的测试仅在支持事务的数据库下执行(如：可以是PostgreSQL，但不可以是"
"使用MyISAM数据库引擎的MySQL)::"
