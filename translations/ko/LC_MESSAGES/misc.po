# SOME DESCRIPTIVE TITLE.
# Copyright (C) Django Software Foundation and contributors
# This file is distributed under the same license as the Django package.
#
# Translators:
# decyma <soos3121@gmail.com>, 2022
# DoJun Lee <leedoe0709@ssu.ac.kr>, 2017
# Gyeongjun Paik <paikend@gmail.com>, 2021
# Hwang, Geon Gu <under_09@naver.com>, 2017
# Hyungsuk Yoon <youhanmir@gmail.com>, 2016
# Jaeyoung Heo <jay.jaeyoung@gmail.com>, 2017
# Jay Oh <theanswer.jay@gmail.com>, 2020
# Minseok Choi <cms9597@gmail.com>, 2016
# Yong Choi <sk8er.choi@gmail.com>, 2019-2020
msgid ""
msgstr ""
"Project-Id-Version: django-docs\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-07-27 03:41-0500\n"
"PO-Revision-Date: 2022-04-02 20:00+0000\n"
"Last-Translator: decyma <soos3121@gmail.com>\n"
"Language-Team: Korean (http://www.transifex.com/django/django-docs/language/"
"ko/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ko\n"
"Plural-Forms: nplurals=1; plural=0;\n"

msgid "API stability"
msgstr "API 안정성"

msgid ""
"Django is committed to API stability and forwards-compatibility. In a "
"nutshell, this means that code you develop against a version of Django will "
"continue to work with future releases. You may need to make minor changes "
"when upgrading the version of Django your project uses: see the \"Backwards "
"incompatible changes\" section of the :doc:`release note </releases/index>` "
"for the version or versions to which you are upgrading."
msgstr ""
"Django는 API의 안정성과 다음버젼의 호환성을 보장하고 있습니다. 요컨대, 새로 "
"업데이트되는 Django 버전에서도 기존에 작성한 코드는 문제 없이 돌아갈 것이라"
"는 뜻입니다. 하지만 업데이트후 프로젝트 별 소소한 변경 작업들은 해줘야 할 수 "
"있습니다. 이에 대해서는 \"이전 버전과 호환되지 않는 변경사항\" 섹션에서 :doc:"
"`릴리스 노트 </releases/index>` 기존 버전 혹은 업그레이드 대상 버전의 문서를 "
"참조하시기 바랍니다."

msgid ""
"At the same time as making API stability a very high priority, Django is "
"also committed to continual improvement, along with aiming for \"one way to "
"do it\" (eventually) in the APIs we provide. This means that when we "
"discover clearly superior ways to do things, we will deprecate and "
"eventually remove the old ways. Our aim is to provide a modern, dependable "
"web framework of the highest quality that encourages best practices in all "
"projects that use it. By using incremental improvements, we try to avoid "
"both stagnation and large breaking upgrades."
msgstr ""
"API 안정성을 매우 높은 우선순위로 만드는 동시에 Django는 우리가 제공하는 API"
"에서 (결과적으로) \"한 가지 방법\"을 목표로 하는 것과 함께 지속적인 개선에도 "
"전념하고 있습니다. 이것은 우리가 일을 하는 데 있어 분명히 더 나은 방법을 발견"
"할 때 이전 방법을 더 이상 사용하지 않고 결국 제거할 것임을 의미합니다. 우리"
"의 목표는 그것을 사용하는 모든 프로젝트에서 모범 사례를 장려하는 최고 품질의 "
"현대적이고 신뢰할 수 있는 웹 프레임워크를 제공하는 것입니다. 점진적 개선을 이"
"용해 정체 및 대규모 중단 업그레이드를 모두 방지하려고 합니다."

msgid "What \"stable\" means"
msgstr "\"안정적인 것\"의 의미"

msgid "In this context, stable means:"
msgstr "이 문맥에서, 안정적인 것은 다음을 의미합니다."

msgid ""
"All the public APIs (everything in this documentation) will not be moved or "
"renamed without providing backwards-compatible aliases."
msgstr ""
"공개된 모든 API(이 문서에 있든 모든것)들이 이전 버전과 호환되는 별명을 제공하"
"지 않고 이동되거나 이름이 바뀌지 않을 것 입니다."

msgid ""
"If new features are added to these APIs -- which is quite possible -- they "
"will not break or change the meaning of existing methods. In other words, "
"\"stable\" does not (necessarily) mean \"complete.\""
msgstr ""
"이 API들에 새로운 기능이 추가된다면, 이 기능들은 이미 존재하는 메소드들의 의"
"미를 바꾸거나 중단시키지 않을 것 입니다. 다시 말하면 \"안정적인 것\"의 의미"
"는 (어쩔 수 없이) \"완벽한 것\"이 아닙니다."

msgid ""
"If, for some reason, an API declared stable must be removed or replaced, it "
"will be declared deprecated but will remain in the API for at least two "
"feature releases. Warnings will be issued when the deprecated method is "
"called."
msgstr ""
"만약 어떤 이유로 안정적인 것에 선언된 API가 삭제되야 하거나 대체되야 한다면, "
"이것은 사용 금지로 선언될 것 입니다 그러나 이것은 앞으로 두번의 릴리스에서 "
"API에 포함될 것 입니다. 사용이 금지된 메소드가 호출될 때 경고들이 발생될 것 "
"입니다."

msgid ""
"See :ref:`official-releases` for more details on how Django's version "
"numbering scheme works, and how features will be deprecated."
msgstr ""
":ref:`official-releases`\\에 Django 버전 번호를 붙이는 기준과, 어떻게 기능들"
"이 비활성화 되는지에 대한 자세한 설명이 있습니다."

msgid ""
"We'll only break backwards compatibility of these APIs without a deprecation "
"process if a bug or security hole makes it completely unavoidable."
msgstr ""
"저희는 버그나 보안상 문제가 발생하지 않는 이상 이전 버전 호환성을 지킵니다."

msgid "Stable APIs"
msgstr "안정적인 API들"

msgid ""
"In general, everything covered in the documentation -- with the exception of "
"anything in the :doc:`internals area </internals/index>` is considered "
"stable."
msgstr ""
"일반적으로 모든 것을 문서에서 다루되 :doc:`내부 영역 </internals/index>`\\에 "
"있는 것은 안정적이라고 간주합니다."

msgid "Exceptions"
msgstr "예외"

msgid ""
"There are a few exceptions to this stability and backwards-compatibility "
"promise."
msgstr "이러한 안정성과 하위 호환성 보장에 대한 몇 가지 예외가 있습니다."

msgid "Security fixes"
msgstr "보안 픽스"

msgid ""
"If we become aware of a security problem -- hopefully by someone following "
"our :ref:`security reporting policy <reporting-security-issues>` -- we'll do "
"everything necessary to fix it. This might mean breaking backwards "
"compatibility; security trumps the compatibility guarantee."
msgstr ""
"우리가 :ref:`보안 보고 정책 <reporting-security-issues>`\\에 따라 보안 문제"
"를 인지하게 되면, 그것을 해결하기 위해 무엇이든 할 것입니다. 이것은 하위 호환"
"성을 깰 수도 있다는 말입니다. 보안이 호환성 보장보다 우선이기 때문입니다."

msgid "APIs marked as internal"
msgstr "API들은 내부것으로 표시됩니다."

msgid "Certain APIs are explicitly marked as \"internal\" in a couple of ways:"
msgstr "어떤 API들은 다양한 방법으로 \"internal\"로 표시됩니다."

msgid ""
"Some documentation refers to internals and mentions them as such. If the "
"documentation says that something is internal, we reserve the right to "
"change it."
msgstr ""
"몇몇 문서에서 internal이라고 언급한 경우. 문서에 어떤 것이 internal이라고 되"
"어 있을 경우, 우리는 그것을 변경할 권한이 있습니다."

msgid ""
"Functions, methods, and other objects prefixed by a leading underscore "
"(``_``). This is the standard Python way of indicating that something is "
"private; if any method starts with a single ``_``, it's an internal API."
msgstr ""
"밑줄(``_``)로 시작하는 함수, 메서드, 그외 객체. 이것은 Python에서 어떤 것이 "
"비공개(private)임을 표시하는 표준 방식입니다. ``_``\\로 시작하는 메서드는 내"
"부 API입니다."

msgid "Design philosophies"
msgstr "설계 철학"

msgid ""
"This document explains some of the fundamental philosophies Django's "
"developers have used in creating the framework. Its goal is to explain the "
"past and guide the future."
msgstr ""
"이 문서는 Django의 개발자들이 프레임워크를 창조하는 데 사용한 기초 철학을 설"
"명합니다. 이 문서의 목적은 과거를 설명하고 미래를 안내하는 것입니다."

msgid "Overall"
msgstr "일반"

msgid "Loose coupling"
msgstr "느슨한 결합"

msgid ""
"A fundamental goal of Django's stack is `loose coupling and tight "
"cohesion`_. The various layers of the framework shouldn't \"know\" about "
"each other unless absolutely necessary."
msgstr ""
"Django 스택의 근본적인 목표는 `느슨한 결합, 탄탄한 응집`_\\입니다. 프레임워크"
"의 각 계층은 정말로 필요하기 전에는 서로 \"알지 못해야\" 합니다."

msgid ""
"For example, the template system knows nothing about web requests, the "
"database layer knows nothing about data display and the view system doesn't "
"care which template system a programmer uses."
msgstr ""
"예를 들어, 템플릿 시스템은 웹 요청에 대해 아무 것도 모르고, DB 계층은 데이터 "
"표시에 대해 아무 것도 모르고, View 시스템은 프로그래머가 사용하는 템플릿 시스"
"템을 사용하는지와 무관합니다."

msgid ""
"Although Django comes with a full stack for convenience, the pieces of the "
"stack are independent of another wherever possible."
msgstr ""
"Django는 편의성을 위해 풀 스택으로 제공되지만, 스택의 각 부분은 가능한 한 독"
"립성을 띱니다."

msgid "Less code"
msgstr "적은 코드"

msgid ""
"Django apps should use as little code as possible; they should lack "
"boilerplate. Django should take full advantage of Python's dynamic "
"capabilities, such as introspection."
msgstr ""
"Django는 가능한 한 최소한의 코드를 사용하며, 틀에 박힌 코드를 배제합니다. "
"Django는 인트로스펙션과 같은 Python의 동적인 기능을 최대한 활용합니다."

msgid "Quick development"
msgstr "신속한 개발"

msgid ""
"The point of a web framework in the 21st century is to make the tedious "
"aspects of web development fast. Django should allow for incredibly quick "
"web development."
msgstr ""
"21세기 웹 프레임워크의 핵심은 웹 개발의 지루한 부분을 빠르게 만드는 것입니"
"다. Django는 놀랄만큼 빠른 웹 개발을 가능하게 합니다."

msgid "Don't repeat yourself (DRY)"
msgstr "반복하지 말 것(DRY)"

msgid ""
"Every distinct concept and/or piece of data should live in one, and only "
"one, place. Redundancy is bad. Normalization is good."
msgstr ""
"고유한 개념 및 데이터는 단 한 번, 단 한 곳에 존재하는 것으로 족합니다. 중복성"
"은 나쁜 것이고, 정규화는 좋은 것입니다."

msgid ""
"The framework, within reason, should deduce as much as possible from as "
"little as possible."
msgstr ""
"그러한 이유로, 본 프레임워크는 최소한의 것들을 가지고 최대한의 것을 만들어내"
"도록 합니다."

msgid "The `discussion of DRY on the Portland Pattern Repository`__"
msgstr "`Portland Pattern Repository의 DRY에 관한 논의`__"

msgid "Explicit is better than implicit"
msgstr "명시적인 것이 묵시적인 것보다 낫다"

msgid ""
"This is a core Python principle listed in :pep:`20`, and it means Django "
"shouldn't do too much \"magic.\" Magic shouldn't happen unless there's a "
"really good reason for it. Magic is worth using only if it creates a huge "
"convenience unattainable in other ways, and it isn't implemented in a way "
"that confuses developers who are trying to learn how to use the feature."
msgstr ""
"이것은 :pep:`20`\\에 기술된 Python 핵심 원칙이며, Django가 \"마법\"을 많이 부"
"리지 말아야 한다는 것입니다. 정당한 이유 없이 마법이 일어나서는 안 됩니다. 마"
"법은 매우 큰 편익이 있을 때만 허용되며, 기능의 사용법을 배우고자 하는 개발자"
"에게 혼란을 일으키는 방식으로 구현되어서는 안 됩니다."

msgid "Consistency"
msgstr "일관성"

msgid ""
"The framework should be consistent at all levels. Consistency applies to "
"everything from low-level (the Python coding style used) to high-level (the "
"\"experience\" of using Django)."
msgstr ""
"본 프레임워크는 모든 수준에서 일관적이어야 합니다. 일관성은 저수준(Python 코"
"딩 스타일)에서 고수준(Django 사용 \"경험\")이 이르기까지 적용됩니다."

msgid "Models"
msgstr "모델"

msgid ""
"Fields shouldn't assume certain behaviors based solely on the name of the "
"field. This requires too much knowledge of the system and is prone to "
"errors. Instead, behaviors should be based on keyword arguments and, in some "
"cases, on the type of the field."
msgstr ""
"어떤 필드가 그 이름에 전적으로 의존하여 특정한 성질을 가질 것으로 가정해서는 "
"안 됩니다. 이는 시스템에 대한 지식을 너무 많이 필요로 하며 오류를 양산합니"
"다. 필드의 성질은 키워드 인자에 근거해야 하며, 경우에 따라서는 필드의 유형에 "
"근거해야 합니다."

msgid "Include all relevant domain logic"
msgstr "모든 관련 도메인 로직을 포함하라"

msgid ""
"Models should encapsulate every aspect of an \"object,\" following Martin "
"Fowler's `Active Record`_ design pattern."
msgstr ""
"모델은 마틴 파울러의 `활성 레코드(Active Record)` 디자인 패턴을 따라 \"객체"
"\"의 모든 관점(aspect)을 캡슐화해야 합니다."

msgid ""
"This is why both the data represented by a model and information about it "
"(its human-readable name, options like default ordering, etc.) are defined "
"in the model class; all the information needed to understand a given model "
"should be stored *in* the model."
msgstr ""
"데이터를 모델로 표현하고 그에 대한 정보(사람이 읽을 수 있는 이름, 기본 순서 "
"같은 선택 사항 등)를 모델 클래스에 정의하는 이유는 그 때문입니다. 모델을 이해"
"하는 데 요구되는 모든 정보가 모델 *내*\\에 있어야 합니다."

msgid "Database API"
msgstr "데이터베이스 API"

msgid "The core goals of the database API are:"
msgstr "데이터베이스 API의 핵심 목표는 다음과 같습니다."

msgid "SQL efficiency"
msgstr "SQL 효율성"

msgid ""
"It should execute SQL statements as few times as possible, and it should "
"optimize statements internally."
msgstr ""
"SQL 문을 가능한 한 적은 횟수로 실행해야 하며 내부적으로 최적화해야 합니다."

msgid ""
"This is why developers need to call ``save()`` explicitly, rather than the "
"framework saving things behind the scenes silently."
msgstr ""
"저장을 프레임워크에서 조용히 처리해주는 대신, 개발자가 ``save()``\\를 명시적"
"으로 호출하도록 한 이유입니다."

msgid ""
"This is also why the ``select_related()`` ``QuerySet`` method exists. It's "
"an optional performance booster for the common case of selecting \"every "
"related object.\""
msgstr ""
"``select_related()`` ``QuerySet`` 메서드가 존재하는 것도 이 때문입니다. 이것"
"은 \"관련된 모든 객체\"를 선택하는 공통적인 경우에 성능을 향상시키는 선택사항"
"입니다."

msgid "Terse, powerful syntax"
msgstr "간결하고 강력한 구문"

msgid ""
"The database API should allow rich, expressive statements in as little "
"syntax as possible. It should not rely on importing other modules or helper "
"objects."
msgstr ""
"데이터베이스 API는 가능한 한 적은 구문을 가지고 풍부하고 표현력이 뛰어난 문장"
"을 생성할 수 있어야 합니다. 다른 모듈이나 도움 객체를 임포트하는 것에 의존해"
"서는 안 됩니다."

msgid ""
"Joins should be performed automatically, behind the scenes, when necessary."
msgstr ""
"조인(join)이 요구될 때에는 겉으로 드러나지 않게 자동으로 수행되어야 합니다."

msgid ""
"Every object should be able to access every related object, systemwide. This "
"access should work both ways."
msgstr ""
"모든 객체는 시스템의 모든 관련 객체에 접근할 수 있어야 합니다. 이러한 접근은 "
"양방향이어야 합니다."

msgid "Option to drop into raw SQL easily, when needed"
msgstr "필요할 경우 SQL 문을 직접 작성하기 쉬워야 함"

msgid ""
"The database API should realize it's a shortcut but not necessarily an end-"
"all-be-all. The framework should make it easy to write custom SQL -- entire "
"statements, or just custom ``WHERE`` clauses as custom parameters to API "
"calls."
msgstr ""
"데이터베이스 API는 개발의 편의를 위한 것이며, 반드시 사용해야 하는 것은 아닙"
"니다. 프레임워크는 맞춤 SQL(전체 문장 또는 API 호출 시 맞춤 파라미터로서의 맞"
"춤 ``WHERE`` 절)도 쉽게 작성할 수 있어야 합니다."

msgid "URL design"
msgstr "URL 설계"

msgid ""
"URLs in a Django app should not be coupled to the underlying Python code. "
"Tying URLs to Python function names is a Bad And Ugly Thing."
msgstr ""
"Django 앱의 URL은 하부 Python 코드와 결합되어서는 안 됩니다. Python 함수 이름"
"과 URL을 엮는 것은 좋지 않습니다."

msgid ""
"Along these lines, the Django URL system should allow URLs for the same app "
"to be different in different contexts. For example, one site may put stories "
"at ``/stories/``, while another may use ``/news/``."
msgstr ""
"Django URL 시스템은 같은 앱을 다른 맥락에서 사용할 수 있도록 합니다. 예를 들"
"어, 한 사이트에서는 ``/stories/``\\ 에, 또 다른 사이트에서는 ``/news/``\\ 에 "
"넣을 수 있습니다."

msgid "Infinite flexibility"
msgstr "무한한 유연성"

msgid ""
"URLs should be as flexible as possible. Any conceivable URL design should be "
"allowed."
msgstr ""
"URL은 가능한 한 유연해야 합니다. 생각할 수 있는 모든 URL 설계가 가능합니다."

msgid "Encourage best practices"
msgstr "모범 사례를 장려"

msgid ""
"The framework should make it just as easy (or even easier) for a developer "
"to design pretty URLs than ugly ones."
msgstr ""
"본 프레임워크는 개발자로 하여금 지저분한 URL보다는 예쁜 URL을 더 쉽게 설계할 "
"수 있도록 해야 합니다."

msgid "File extensions in web-page URLs should be avoided."
msgstr "웹 페이지 URL에 파일 확장자를 넣는 것은 지양해야 합니다."

msgid "Vignette-style commas in URLs deserve severe punishment."
msgstr "URL에 Vignette 스타일의 콤마는 큰 벌을 받아 마땅합니다."

msgid "Definitive URLs"
msgstr "명확한 URL"

msgid ""
"Technically, ``foo.com/bar`` and ``foo.com/bar/`` are two different URLs, "
"and search-engine robots (and some web traffic-analyzing tools) would treat "
"them as separate pages. Django should make an effort to \"normalize\" URLs "
"so that search-engine robots don't get confused."
msgstr ""
"기술적으로 ``foo.com/bar``와 ``foo.com/bar/``는 서로 다른 두 개의 URL이며 검"
"색 엔진 로봇(또는 일부 웹 트래픽 분석 도구)은 이를 별도의 페이지로 취급합니"
"다. Django는 URL을 ``정규화``하여 검색 엔진 로봇이 혼동하지 않게 해야 합니다."

msgid "This is the reasoning behind the :setting:`APPEND_SLASH` setting."
msgstr "이것이 바로 :setting:`APPEND_SLASH` 설정이 있는 이유입니다."

msgid "Template system"
msgstr "템플릿 시스템"

msgid "Separate logic from presentation"
msgstr "표현과 로직을 분리"

msgid ""
"We see a template system as a tool that controls presentation and "
"presentation-related logic -- and that's it. The template system shouldn't "
"support functionality that goes beyond this basic goal."
msgstr ""
"우리는 템플릿 시스템이 표현을 제어하는 도구이자 표현에 관련된 로직일 뿐이라"
"고 봅니다. 템플릿 시스템은 이러한 기본 목표를 넘어서는 기능을 지원하지 말아"
"야 합니다."

msgid "Discourage redundancy"
msgstr "중복을 배제"

msgid ""
"The majority of dynamic websites use some sort of common sitewide design -- "
"a common header, footer, navigation bar, etc. The Django template system "
"should make it easy to store those elements in a single place, eliminating "
"duplicate code."
msgstr ""
"대다수의 동적 웹사이트는 공통 헤더, 푸터, 네이게이션 바 같은 사이트 공통 디자"
"인을 갖습니다. Django 템플릿 시스템은 이러한 요소를 한 곳에 저장하기 쉽게 하"
"여 중복 코드를 없애야 합니다."

msgid ""
"This is the philosophy behind :ref:`template inheritance <template-"
"inheritance>`."
msgstr ""
"이것이 :ref:`템플릿 상속 <template-inheritance>`\\의 기초가 되는 철학입니다."

msgid "Be decoupled from HTML"
msgstr "HTML과의 분리"

msgid ""
"The template system shouldn't be designed so that it only outputs HTML. It "
"should be equally good at generating other text-based formats, or just plain "
"text."
msgstr ""
"템플릿 시스템은 HTML만을 출력하도록 설계하지 말아야 합니다. 텍스트 기반 포맷 "
"또는 일반 텍스트도 마찬가지로 잘 생성할 수 있어야 합니다."

msgid "XML should not be used for template languages"
msgstr "XML을 템플릿 언어로 사용하지 말 것"

msgid ""
"Using an XML engine to parse templates introduces a whole new world of human "
"error in editing templates -- and incurs an unacceptable level of overhead "
"in template processing."
msgstr ""
"템플릿 해석을 위해 XML 엔진을 사용하게 되면 템플릿 편집에 있어서 실수가 발생"
"할 가능성이 매우 커질 뿐 아니라, 템플릿 처리에 너무 큰 과부하가 걸립니다."

msgid "Assume designer competence"
msgstr "디자이너가 코딩 능력이 있는 것으로 가정"

msgid ""
"The template system shouldn't be designed so that templates necessarily are "
"displayed nicely in WYSIWYG editors such as Dreamweaver. That is too severe "
"of a limitation and wouldn't allow the syntax to be as nice as it is. Django "
"expects template authors are comfortable editing HTML directly."
msgstr ""
"템플릿 시스템은 템플릿이 반드시 드림위버(Dreamweaver) 같은 위지윅(WYSIWYG) 편"
"집기에서 제대로 보이도록 설계하지는 않습니다. 그렇게 하려면 너무 제약이 많아"
"지며 지금과 같이 훌륭한 구문을 유지하기 힘들기 때문입니다. Django는 템플릿 작"
"성자가 HTML을 직접 편집하는 것을 어려워 하지 않을 것을 전제로 합니다."

msgid "Treat whitespace obviously"
msgstr "공백에 특별한 의미를 부여하지 말 것"

msgid ""
"The template system shouldn't do magic things with whitespace. If a template "
"includes whitespace, the system should treat the whitespace as it treats "
"text -- just display it. Any whitespace that's not in a template tag should "
"be displayed."
msgstr ""
"템플릿 시스템은 공백을 가지고 특수한 동작을 일으켜서는 안 됩니다. 템플릿에 공"
"백이 포함되어 있으면 그것을 그저 텍스트의 공백으로서 표출(display)해야 합니"
"다. 템플릿 태그 내에 있지 않은 모든 공백은 표출해야 합니다."

msgid "Don't invent a programming language"
msgstr "프로그래밍 언어를 발명하지 말 것"

msgid ""
"The goal is not to invent a programming language. The goal is to offer just "
"enough programming-esque functionality, such as branching and looping, that "
"is essential for making presentation-related decisions. The :ref:`Django "
"Template Language (DTL) <template-language-intro>` aims to avoid advanced "
"logic."
msgstr ""
"프로그래밍 언어의 발명을 목적으로 하는 것이 아닙니다. 분기와 반복 같이 표현 "
"계층에 꼭 필요한 프로그래밍 기능을 제공하는 것이 목표입니다. :ref:`Django 템"
"플릿 언어(DTL) <template-language-intro>`\\는 고급 로직을 제공하지 않습니다."

msgid ""
"The Django template system recognizes that templates are most often written "
"by *designers*, not *programmers*, and therefore should not assume Python "
"knowledge."
msgstr ""
"Django 템플릿 시스템은 템플릿이 *프로그래머*\\가 아닌 *디자이너*\\에 의해 작"
"성되는 것을 전제로 하므로, 그들이 Python 지식을 갖고 있을 것으로 간주해서는 "
"안 됩니다."

msgid "Safety and security"
msgstr "안전과 보안"

msgid ""
"The template system, out of the box, should forbid the inclusion of "
"malicious code -- such as commands that delete database records."
msgstr ""
"템플릿 시스템은 데이터베이스의 레코드를 삭제하는 명령과 같은 악의적 코드를 포"
"함할 수 없게 되어 있어야 합니다."

msgid ""
"This is another reason the template system doesn't allow arbitrary Python "
"code."
msgstr ""
"이것은 템플릿 시스템이 임의의 Python 코드를 실행할 수 없는 또 다른 이유이기"
"도 합니다."

msgid "Extensibility"
msgstr "확장성"

msgid ""
"The template system should recognize that advanced template authors may want "
"to extend its technology."
msgstr ""
"높은 수준의 기술을 가진 템플릿 작성자는 템플릿 시스템을 확장할 수 있습니다."

msgid "This is the philosophy behind custom template tags and filters."
msgstr "맞춤 템플릿 태그와 필터는 이러한 철학을 바탕으로 합니다."

msgid "Views"
msgstr "뷰"

msgid "Simplicity"
msgstr "단순성"

msgid ""
"Writing a view should be as simple as writing a Python function. Developers "
"shouldn't have to instantiate a class when a function will do."
msgstr ""
"뷰를 작성하는 것은 Python 함수를 작성하는 것만큼 단순해야 합니다. 개발자는 함"
"수로 처리할 수 있는 일을 하기 위해 클래스의 인스턴스를 굳이 생성하지 않아도 "
"됩니다."

msgid "Use request objects"
msgstr "요청 객체의 사용"

msgid ""
"Views should have access to a request object -- an object that stores "
"metadata about the current request. The object should be passed directly to "
"a view function, rather than the view function having to access the request "
"data from a global variable. This makes it light, clean and easy to test "
"views by passing in \"fake\" request objects."
msgstr ""
"뷰는 요청 객체(현재 요청에 대한 메타데이터를 갖는 객체)에 접근할 수 있어야 합"
"니다. 뷰 함수가 글로벌 변수의 요청 데이터에 접근하도록 하지 말고, 요청 객체"
"를 뷰 함수에 직접 전달합니다. \"가짜\" 요청 객체를 전달함으로써 가볍고 깔끔하"
"며 쉬운 테스트 뷰를 만들 수 있습니다."

msgid ""
"A view shouldn't care about which template system the developer uses -- or "
"even whether a template system is used at all."
msgstr ""
"뷰는 개발자가 어느 템플릿 시스템을 사용하는지, 혹은 템플릿 시스템을 사용하는"
"지에 무관해야 합니다."

msgid "Differentiate between GET and POST"
msgstr "GET과 POST를 구분"

msgid ""
"GET and POST are distinct; developers should explicitly use one or the "
"other. The framework should make it easy to distinguish between GET and POST "
"data."
msgstr ""
"GET과 POST는 고유한 것이므로, 개발자는 명시적으로 둘 중 하나를 사용해야 합니"
"다. 본 프레임워크는 GET과 POST 데이터를 쉽게 구분할 수 있도록 해야 합니다."

msgid "Cache Framework"
msgstr "캐시 프레임워크"

msgid "The core goals of Django's :doc:`cache framework </topics/cache>` are:"
msgstr ""
"Django :doc:`캐시 프레임워크 </topics/cache>`\\의 핵심 목표는 다음과 같습니"
"다."

msgid ""
"A cache should be as fast as possible.  Hence, all framework code "
"surrounding the cache backend should be kept to the absolute minimum, "
"especially for ``get()`` operations."
msgstr ""
"캐시는 가능한 한 빨라야 합니다. 캐시 백엔드와 관련된 모든 프레임워크 코드, 특"
"히 ``get()`` 연산은 군더더기 없이 최소한을 남겨야 합니다."

msgid ""
"The cache API should provide a consistent interface across the different "
"cache backends."
msgstr ""
"캐시 API는 여러 캐시 백엔드에 대해 일관적 인터페이스를 제공해야 합니다."

msgid ""
"The cache API should be extensible at the application level based on the "
"developer's needs (for example, see :ref:`cache_key_transformation`)."
msgstr ""
"캐시 API는 개발자의 요구에 따라 애플리케이션 수준에서 확장 가능해야 합니다(:"
"ref:`cache_key_transformation` 참조)."

msgid "Third-party distributions of Django"
msgstr "Django의 서드 파티 분배"

msgid ""
"Many third-party distributors are now providing versions of Django "
"integrated with their package-management systems. These can make "
"installation and upgrading much easier for users of Django since the "
"integration includes the ability to automatically install dependencies (like "
"database adapters) that Django requires."
msgstr ""
"많은 서드 파티 배포자가 Django를 각자의 패키지 관리 시스템에서 제공하고 있습"
"니다. 이는 Django가 의존하는 패키지(예: 데이터베이스 어댑터)를 자동으로 설치"
"해줌으로써 사용자가 Django를 쉽게 설치 및 업그레이드할 수 있게 해줄 수 있습니"
"다."

msgid ""
"Typically, these packages are based on the latest stable release of Django, "
"so if you want to use the development version of Django you'll need to "
"follow the instructions for :ref:`installing the development version "
"<installing-development-version>` from our Git repository."
msgstr ""
"이러한 패키지는 Django의 최종 릴리스에 기초를 두는 것이 일반적이므로, 만약 "
"Django의 개발 버전을 사용하고 싶으면 우리의 Git 저장소에 있는 :ref:`개발 버"
"전 설치 <installing-development-version>` 지침을 따라야 합니다."

msgid ""
"If you're using Linux or a Unix installation, such as OpenSolaris, check "
"with your distributor to see if they already package Django. If you're using "
"a Linux distro and don't know how to find out if a package is available, "
"then now is a good time to learn.  The Django Wiki contains a list of `Third "
"Party Distributions`_ to help you out."
msgstr ""
"Linux 또는 Unix(예: OpenSolaris) 사용자는 Django 패키지가 이미 있는지 확인하"
"세요. Linux 배포판을 사용하지만 패키지를 찾는 방법을 모른다면, 지금이 배울 기"
"회입니다. Django 위키의 `Third Party Distributions`_\\가 도움이 될 것입니다."

msgid "For distributors"
msgstr "배포자에게"

msgid ""
"If you'd like to package Django for distribution, we'd be happy to help out! "
"Please join the |django-developers| mailing list and introduce yourself."
msgstr ""
"Django를 패키징하여 배포하고자 한다면 저희가 기꺼이 돕겠습니다! |django-"
"developers| 메일링 리스트에 가입해서 자기 소개를 해주세요."

msgid ""
"We also encourage all distributors to subscribe to the |django-announce| "
"mailing list, which is a (very) low-traffic list for announcing new releases "
"of Django and important bugfixes."
msgstr ""
"모든 배포자는 |django-announce| 메일링 리스트를 구독하기 바랍니다. Django 및 "
"중요 버그 픽스의 릴리스가 아주 가끔씩 올라옵니다."

msgid "Meta-documentation and miscellany"
msgstr "메타 문서 및 기타"

msgid ""
"Documentation that we can't find a more organized place for. Like that "
"drawer in your kitchen with the scissors, batteries, duct tape, and other "
"junk."
msgstr ""
"적당한 분류를 찾을 수 없는 문서들이 여기 있습니다. 잡동사니를 넣어두는 서랍 "
"같은 곳입니다."
