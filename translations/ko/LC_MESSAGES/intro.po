# SOME DESCRIPTIVE TITLE.
# Copyright (C) Django Software Foundation and contributors
# This file is distributed under the same license as the Django package.
#
# Translators:
# Junbum Lee, 2016
# 김신원, 2023
# bukim0329, 2021
# Churow Park <churow@naver.com>, 2019
# Claude Paroz <claude@2xlibre.net>, 2020
# decyma <soos3121@gmail.com>, 2022
# BakSulgi <dhwjdgh9@naver.com>, 2017
# DONGHO JEONG <nearermg@gmail.com>, 2020
# Eunmin Kim <telepopsound@gmail.com>, 2019
# FIRST AUTHOR <EMAIL@ADDRESS>, 2016
# Geonho Kim / Leo Kim <gh.leokim@gmail.com>, 2019
# Jay Oh <theanswer.jay@gmail.com>, 2020
# Jeho Sung <scheho@gmail.com>, 2016
# Le Tartuffe <magno79@gmail.com>, 2016
# Jisung Kim <kimjs3115@gmail.com>, 2018
# Jongyeal Kang <orthoped.kjy@gmail.com>, 2018
# JunoJunho <wnsgh611@gmail.com>, 2015
# Nirvana <kimqqyun@gmail.com>, 2016
# Laehyoung Kim <rerongs@gmail.com>, 2017
# 이지현 <wlgus5781@gmail.com>, 2017
# LEE, SOOJUNG <ruby04.s.lee@gmail.com>, 2023
# Mariusz Felisiak <felisiak.mariusz@gmail.com>, 2022
# Nirvana <kimqqyun@gmail.com>, 2016
# 이동현, 2022
# Park Seong Heum <bb0162@live.co.kr>, 2018
# Pelly Ryu <hermement@gmail.com>, 2016
# Seacbyul Lee <femizkim@gmail.com>, 2017
# Seho Noh <iam@sehonoh.kr>, 2017
# decyma <soos3121@gmail.com>, 2022
# Woo-Jing, Seok <woojing.seok@gmail.com>, 2016-2017
# seungho, kim <raccoonyy@gmail.com>, 2016,2022
# Seungik Sung, 2023
# Subin Choi <os1742@gmail.com>, 2016
# 이우현 <krta22@gmail.com>, 2022
# 이한샘 <wooruang@gmail.com>, 2019
# Yeonsu Bak <yeonsubak@gmail.com>, 2015
# Yong Choi <sk8er.choi@gmail.com>, 2015,2019-2020,2023
msgid ""
msgstr ""
"Project-Id-Version: django-docs\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-11-30 05:02-0600\n"
"PO-Revision-Date: 2013-04-02 20:00+0000\n"
"Last-Translator: Seungik Sung, 2023\n"
"Language-Team: Korean (http://app.transifex.com/django/django-docs/language/"
"ko/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ko\n"
"Plural-Forms: nplurals=1; plural=0;\n"

msgid "Writing your first patch for Django"
msgstr "첫 Django 패치 작성하기"

msgid "Introduction"
msgstr "개요"

msgid ""
"Interested in giving back to the community a little? Maybe you've found a "
"bug in Django that you'd like to see fixed, or maybe there's a small feature "
"you want added."
msgstr ""
"커뮤니티에 보답하고 싶은가요? 고치고 싶은 버그가 있거나, 추가하고 싶은 기능"
"이 있을지도 모릅니다."

msgid ""
"Contributing back to Django itself is the best way to see your own concerns "
"addressed. This may seem daunting at first, but it's a well-traveled path "
"with documentation, tooling, and a community to support you. We'll walk you "
"through the entire process, so you can learn by example."
msgstr ""
"Django에 기여하는 것이야말로 여러분의 문제를 해결하는 최선의 방법입니다. 처음"
"에는 부담스러울 수도 있지만 문서, 도구 및 커뮤니티를 이용하면 쉽게 이용할 수 "
"있습니다. 모든 과정을 안내해 드릴 것이므로,예제를 통해 배울 수 있습니다."

msgid "Who's this tutorial for?"
msgstr "이 튜토리얼은 누구를 위한 것인가요?"

msgid ""
"If you are looking for a reference on the details of making code "
"contributions, see the :doc:`/internals/contributing/writing-code/index` "
"documentation."
msgstr ""
"코드 기여에 대한 세부 참조를 보려면 :doc:'/internals/committing/writing-code/"
"index' 문서를 참조하십시오."

msgid ""
"For this tutorial, we expect that you have at least a basic understanding of "
"how Django works. This means you should be comfortable going through the "
"existing tutorials on :doc:`writing your first Django app</intro/"
"tutorial01>`. In addition, you should have a good understanding of Python "
"itself. But if you don't, `Dive Into Python`__ is a fantastic (and free) "
"online book for beginning Python programmers."
msgstr ""
"이 튜토리얼을 진행하기 위해서는, Django에 대한 기본적인 이해가 필요합니다. :"
"doc:`첫번째 Django 앱 작성해보기</intro/tutorial01>` 를 무난하게 따라할 정도"
"면 됩니다. 또한, Python에 대한 적당한 이해도 필요합니다만, 그렇지 않다면 초"
"보 Python 프로그래머를 위한 훌륭한 (무료 ) 온라인 도서 `Dive Into Python`__ "
"을 권장합니다."

msgid ""
"Those of you who are unfamiliar with version control systems and Trac will "
"find that this tutorial and its links include just enough information to get "
"started. However, you'll probably want to read some more about these "
"different tools if you plan on contributing to Django regularly."
msgstr ""
"버전 관리 시스템과 Trac에 대해 잘 모르는 분은 이 튜토리얼과 튜토리얼에 포함"
"된 링크를 통해 충분한 정보를 찾을 수 있을 것입니다. 하지만, 장고에 계속 공헌"
"하고자 한다면 이러한 다른 도구들에 대하여 더 읽어두는 것도 좋을 것입니다."

msgid ""
"For the most part though, this tutorial tries to explain as much as "
"possible, so that it can be of use to the widest audience."
msgstr ""
"하지만 대부분의 경우, 이 튜토리얼은 폭넓은 독자에게 사용이 될 수 있도록 최대"
"한 설명하려고 합니다."

msgid "Where to get help:"
msgstr "도움을 받을 수 있는 방법"

msgid ""
"If you're having trouble going through this tutorial, please post a message "
"on the `Django Forum`_, |django-developers|, or drop by `#django-dev on irc."
"libera.chat`__ to chat with other Django users who might be able to help."
msgstr ""
"이 튜토리얼을 진행하다가 어려움이 있다면 `Django Forum`_의 |django "
"developers|에 메시지를 보내거나, irc.libera.chat___에 있는 '#django-dev on "
"irc.libera-chat____를 통해 도움을 줄 수 있는 다른 장고 사용자와 이야기하기하"
"십시오."

msgid "What does this tutorial cover?"
msgstr "이 튜토리얼이 다루는 내용은 무엇입니까?"

msgid ""
"We'll be walking you through contributing a patch to Django for the first "
"time. By the end of this tutorial, you should have a basic understanding of "
"both the tools and the processes involved. Specifically, we'll be covering "
"the following:"
msgstr ""
"여기서는 여러분이 장고에 대한 패치를 처음 제출하는 과정을 다룹니다. 이 튜토리"
"얼을 마치면, 여러분은 기본적인 관련 도구와 프로세스를 모두 이해하게 될 것입니"
"다. 좀더 구체적으로는 다음 내용을 다룹니다."

msgid "Installing Git."
msgstr "GIT 설치"

msgid "Downloading a copy of Django's development version."
msgstr "Django의 개발 버전 사본 다운로드"

msgid "Running Django's test suite."
msgstr "Django의 테스트 스위트를 실행."

msgid "Writing a test for your patch."
msgstr "패치에 대한 테스트를 작성."

msgid "Writing the code for your patch."
msgstr "패치 코드를 작성."

msgid "Testing your patch."
msgstr "패치를 테스트."

msgid "Submitting a pull request."
msgstr "pull request 보내기."

msgid "Where to look for more information."
msgstr "더 많은 정보를 찾을 수 있는 곳."

msgid ""
"Once you're done with the tutorial, you can look through the rest of :doc:"
"`Django's documentation on contributing</internals/contributing/index>`. It "
"contains lots of great information and is a must read for anyone who'd like "
"to become a regular contributor to Django. If you've got questions, it's "
"probably got the answers."
msgstr ""
"한번 튜토리얼을 마쳤다면, :doc:`Django 문서의 기여하기</internals/"
"contributing/index>`\\를 통해 나머지를 볼 수 있습니다. 다양한 정보들이 있으"
"며, 특히 Django 의 정규 기여자가 되고 싶다면 반드시 봐야 합니다. 궁금하신 점"
"이 있다면 답을 얻으실 수 있을 것입니다."

msgid "Python 3 required!"
msgstr "파이썬 3.x 버전이 필요합니다."

msgid ""
"The current version of Django doesn't support Python 2.7. Get Python 3 at "
"`Python's download page <https://www.python.org/downloads/>`_ or with your "
"operating system's package manager."
msgstr ""
"Django 현재의 버전은 파이썬 2.7 을 지원하지 않습니다. `파이썬 다운로드 페이"
"지 <https://www.python.org/downloads/>`_ 또는 자신의 운영체제의 패키지 관리자"
"로부터 파이썬 3을 받을 수 있습니다."

msgid "For Windows users"
msgstr "윈도우 운영체제를 사용하는 경우"

msgid ""
"See :ref:`install_python_windows` on Windows docs for additional guidance."
msgstr " :ref:`install_python_windows` 를 통해 가이드라인을 참조하세요."

msgid "Code of Conduct"
msgstr "행동 지침"

msgid ""
"As a contributor, you can help us keep the Django community open and "
"inclusive. Please read and follow our `Code of Conduct <https://www."
"djangoproject.com/conduct/>`_."
msgstr ""
"당신은 기여자로서, 개방적이고 포괄적인 Django 커뮤니티를 유지하도록 도움을 "
"줄 수 있습니다. `행동 강령 <https://www.djangoproject.com/conduct/>`_ 을 읽"
"고 숙지해주세요."

msgid "Installing Git"
msgstr "GIT 설치"

msgid ""
"For this tutorial, you'll need Git installed to download the current "
"development version of Django and to generate patch files for the changes "
"you make."
msgstr ""
"이 튜토리얼에서와 같이, 현재 개발 버전의 Django를 다운로드하고 수정하여 패치 "
"파일을 생성하기 위해서는 Git을 설치해야 합니다."

msgid ""
"To check whether or not you have Git installed, enter ``git`` into the "
"command line. If you get messages saying that this command could not be "
"found, you'll have to download and install it, see `Git's download page`__."
msgstr ""
"Git 이 설치되었는지 확인해보기 위해, 커맨드라인에서 ``git`` 라고 입력해보세"
"요. 만약 그런 명령을 찾을 수 없다는 메세지가 나오면 Git 이 설치되지 않았다는 "
"의미입니다. `Git's download page`__ 를 참조하세요."

msgid ""
"If you're not that familiar with Git, you can always find out more about its "
"commands (once it's installed) by typing ``git help`` into the command line."
msgstr ""
"Git을 사용하는 것이 익숙하지 않다면, (우선 설치가 완료되면) 커맨드라인 상에"
"서 ``git help``\\를 입력함으로써 명령어에 대한 자세한 정보를 확인할 수 있습니"
"다."

msgid "Getting a copy of Django's development version"
msgstr "Django 개발 버전의 사본을 얻기"

msgid ""
"The first step to contributing to Django is to get a copy of the source "
"code. First, `fork Django on GitHub <https://github.com/django/django/"
"fork>`__. Then, from the command line, use the ``cd`` command to navigate to "
"the directory where you'll want your local copy of Django to live."
msgstr ""
"Django에 기여하기 위한 첫걸음은 소스 코드를 내려받는 것입니다. 먼저, `깃허브"
"에서 Django를 포크 <https://github.com/django/django/fork>`__\\ 하세요. 그 다"
"음에, 명령행에서 ``cd`` 명령을 통해 Django 소스를 내려받을 디렉토리로 이동하"
"세요."

msgid "Download the Django source code repository using the following command:"
msgstr "다음 명령을 통해 Django 소스코드 저장소를 다운로드하십시오."

msgid "Low bandwidth connection?"
msgstr "인터넷이 느린가요 (대역폭이 낮나요) ?"

msgid ""
"You can add the ``--depth 1`` argument to ``git clone`` to skip downloading "
"all of Django's commit history, which reduces data transfer from  ~250 MB to "
"~70 MB."
msgstr ""
"``git clone`` 명령어 뒤에 ``--depth 1`` 인자를 추가하면 Django의 이전 수정 이"
"력을 무시하고 최신 수정 이력만 남은 소스코드를 다운로드 받을 수 있습니다. 이"
"로써 다운로드 받아야할 데이터 용량이 250MB 정도에서 70MB 정도로 줄어들게 된답"
"니다."

msgid ""
"Now that you have a local copy of Django, you can install it just like you "
"would install any package using ``pip``. The most convenient way to do so is "
"by using a *virtual environment*, which is a feature built into Python that "
"allows you to keep a separate directory of installed packages for each of "
"your projects so that they don't interfere with each other."
msgstr ""
"Django의 로컬 사본을 갖게 되었으므로, 여느 패키지와 마찬가지로 ``pip``\\ 를 "
"사용해 설치할 수 있습니다. 가장 편리한 방법은 Python에 내장된 *가상 환경* 기"
"능을 사용하는 것으로, 각 프로젝트를 위해 설치한 패키지들을 별도의 디렉토리에 "
"둠으로써 서로 간섭이 일어나지 않도록 할 수 있습니다."

msgid ""
"It's a good idea to keep all your virtual environments in one place, for "
"example in ``.virtualenvs/`` in your home directory."
msgstr ""
"모든 가상 환경을 홈 디렉토리의 ``.virtualenvs/`` 같은 곳에 모아두는 것이 좋습"
"니다."

msgid "Create a new virtual environment by running:"
msgstr "다음 명령을 실행해 새로운 가상 환경을 생성합니다."

msgid "The path is where the new environment will be saved on your computer."
msgstr "경로는 당신의 컴퓨터에서 새로운 환경이 저장될 위치를 의미합니다."

msgid ""
"The final step in setting up your virtual environment is to activate it:"
msgstr "가상 환경을 활성화함으로써 구성을 마무리합니다."

msgid ""
"If the ``source`` command is not available, you can try using a dot instead:"
msgstr ""
"만약 ``source`` 명령을 사용할 수 없다면, 대신 마침표(.)를 사용해 보십시오."

msgid ""
"You have to activate the virtual environment whenever you open a new "
"terminal window."
msgstr "새로운 터미널 창을 열 때마다 가상 환경을 활성화해야 합니다. "

msgid "To activate your virtual environment on Windows, run:"
msgstr "Windows에서 가상 환경을 활성화하려면 다음 명령을 사용합니다."

msgid ""
"The name of the currently activated virtual environment is displayed on the "
"command line to help you keep track of which one you are using. Anything you "
"install through ``pip`` while this name is displayed will be installed in "
"that virtual environment, isolated from other environments and system-wide "
"packages."
msgstr ""
"현재 활성화된 가상 환경의 이름이 명령행에 표시되므로 현재 사용하는 것이 무엇"
"인지 알 수 있습니다. 이러한 이름이 표시되는 동안 ``pip``\\ 로 설치한 것은 해"
"당 가상 환경 내에 설치되어, 다른 환경 및 시스템 패키지와 격리됩니다."

msgid "Go ahead and install the previously cloned copy of Django:"
msgstr "앞서 복제한 Django 사본을 설치합니다."

msgid ""
"The installed version of Django is now pointing at your local copy by "
"installing in editable mode. You will immediately see any changes you make "
"to it, which is of great help when writing your first patch."
msgstr ""
"현재 설치된 Django는 로컬 사본을 가리킵니다. 이에 대한 모든 변경을 즉시 확인"
"할 수 있으며, 이러한 구조는 첫 번째 패치를 작성할 때 큰 도움이 될 것입니다."

msgid "Creating projects with a local copy of Django"
msgstr "로컬 디스크에 있는 Django 복사본으로부터 프로젝트 생성하기"

msgid ""
"It may be helpful to test your local changes with a Django project. First "
"you have to create a new virtual environment, :ref:`install the previously "
"cloned local copy of Django in editable mode <intro-contributing-install-"
"local-copy>`, and create a new Django project outside of your local copy of "
"Django. You will immediately see any changes you make to Django in your new "
"project, which is of great help when writing your first patch, especially if "
"testing any changes to the UI."
msgstr ""

msgid ""
"You can follow the :doc:`tutorial</intro/tutorial01>` for help in creating a "
"Django project."
msgstr ""

msgid "Running Django's test suite for the first time"
msgstr "Django의 테스트 스위트를 처음으로 실행하기"

msgid ""
"When contributing to Django it's very important that your code changes don't "
"introduce bugs into other areas of Django. One way to check that Django "
"still works after you make your changes is by running Django's test suite. "
"If all the tests still pass, then you can be reasonably sure that your "
"changes work and haven't broken other parts of Django. If you've never run "
"Django's test suite before, it's a good idea to run it once beforehand to "
"get familiar with its output."
msgstr ""
"Django에 기여할 때 당신의 코드 변경이 Django의 다른 영역에 버그가 발생하지 않"
"도록 하는 것이 매우 중요합니다. 변경한 후에도 Django가 여전히 작동하는지 확인"
"하는 한 가지 방법은 Django의 test suite를 실행하는 것입니다. 모든 테스트가 여"
"전히 통과한다면, Django의 다른 부분이 망가지지 않았다고 확신할 수 있습니다. "
"아직 한 번도 Django의 test suite를 실행해 본 적이 없다면 출력물에 익숙해지기 "
"위해 미리 한 번 실행해보는 것이 좋습니다."

msgid ""
"Before running the test suite, enter the Django ``tests/`` directory using "
"the ``cd tests`` command, and install test dependencies by running:"
msgstr ""
"test suite를 실행하기 전, ``cd tests`` 명령어를 사용하여 Django의 ``tests/`` "
"디렉토리에 들어갑니다. 그리고 다음을 실행하여 테스트 종속성을 설치하세요:"

msgid ""
"If you encounter an error during the installation, your system might be "
"missing a dependency for one or more of the Python packages. Consult the "
"failing package's documentation or search the web with the error message "
"that you encounter."
msgstr ""
"설치 중 오류가 발생했다면, 시스템이 하나 이상의 Python 패키지에 대한 의존성"
"을 해결하지 못한 것일 수 있습니다. 설치에 실패한 패키지의 문서를 참조하거나 "
"오류 메시지를 웹에서 검색하십시오."

msgid ""
"Now we are ready to run the test suite. If you're using GNU/Linux, macOS, or "
"some other flavor of Unix, run:"
msgstr ""
"이제 테스트 스위트를 실행할 준비가되었습니다. GNU/Linux, macOS, 그외의 Unix "
"구현체를 사용한다면 다음을 실행합니다."

msgid ""
"Now sit back and relax. Django's entire test suite has thousands of tests, "
"and it takes at least a few minutes to run, depending on the speed of your "
"computer."
msgstr ""
" Django's entire test suite는 수천 개의 테스트로 이루어져 있어 컴퓨터 사양에 "
"따라 최소 몇 분은 걸립니다. 작업은 컴퓨터에 맡기고 자리에서 일어나셔서 스트레"
"칭을 한번 해보시는게 어떠세요?"

msgid ""
"While Django's test suite is running, you'll see a stream of characters "
"representing the status of each test as it completes. ``E`` indicates that "
"an error was raised during a test, and ``F`` indicates that a test's "
"assertions failed. Both of these are considered to be test failures. "
"Meanwhile, ``x`` and ``s`` indicated expected failures and skipped tests, "
"respectively. Dots indicate passing tests."
msgstr ""
"Django 테스트 스위트가 실행되는 동안 각각의 테스트가 완료되는 상태를 나타내"
"는 문자들이 흘러가는 것을 볼 수 있습니다. ``E``\\ 는 테스트 중에 오류가 발생"
"했음을 가리키며, ``F``\\ 는 테스트의 단정문이 실패한 것을 가리킵니다. 둘 다 "
"테스트 실패로 간주됩니다. ``x``\\ 는 예견된 실패를, ``s``\\ 는 테스트를 건너"
"뛴 것을 가리킵니다. 테스트가 통과하면 점이 찍힙니다."

msgid ""
"Skipped tests are typically due to missing external libraries required to "
"run the test; see :ref:`running-unit-tests-dependencies` for a list of "
"dependencies and be sure to install any for tests related to the changes you "
"are making (we won't need any for this tutorial). Some tests are specific to "
"a particular database backend and will be skipped if not testing with that "
"backend. SQLite is the database backend for the default settings. To run the "
"tests using a different backend, see :ref:`running-unit-tests-settings`."
msgstr ""
"건너뛴 테스트는 보통 테스트를 수행하기 위해 필요한 외부 라이브러리가 없는 경"
"우 발생합니다. :ref:`running-unit-tests-dependencies`\\ 를 참조하여, 변경과 "
"관련한 모든 테스트를 수행하기 위한 의존성을 확인하고 이를 설치하십시오(이 튜"
"토리얼에서는 필요하지 않습니다). 특정한 데이터베이스 백엔드를 필요로 하는 테"
"스트의 경우, 해당 데이터베이스 백엔드를 사용하지 않으면 자동으로 테스트를 건"
"너뜁니다. ``SQLite``\\ 는 기본 데이터베이스 백엔드입니다. 다른 백엔드를 테스"
"트하고 싶다면 :ref:`running-unit-tests-settings`\\ 를 참조하세요."

msgid ""
"Once the tests complete, you should be greeted with a message informing you "
"whether the test suite passed or failed. Since you haven't yet made any "
"changes to Django's code, the entire test suite **should** pass. If you get "
"failures or errors make sure you've followed all of the previous steps "
"properly. See :ref:`running-unit-tests` for more information."
msgstr ""
"검사가 완료되면, 테스트 스위트 통과했거나 실패했다는 메시지를 보게 될 것입니"
"다. 아직 Django의 코드를 전혀 변경하지 않았으므로, 전체 테스트를 **반드시** "
"통과해야 합니다. 실패하였으나 오류가 발생하였다면 이전의 모든 단계를 올바로 "
"따라서 문제를 해결해야 합니다. :ref:`running-unit-tests`\\ 에서 자세한 내용"
"을 확인하세요."

msgid ""
"Note that the latest Django \"main\" branch may not always be stable. When "
"developing against \"main\", you can check `Django's continuous integration "
"builds`__ to determine if the failures are specific to your machine or if "
"they are also present in Django's official builds. If you click to view a "
"particular build, you can view the \"Configuration Matrix\" which shows "
"failures broken down by Python version and database backend."
msgstr ""
"최신 Django \"main\" branch가 항상 안정적인 것은 아닙니다. \"main\"에 개발할 "
"때, `Django's continuous integration builds`__ 를 확인하여 실패들이 당신의 머"
"신과 관련이 있는지, 혹은 Django의 공식 빌드에도 존재하는지 확인할 수 있습니"
"다. 특정 빌드를 클릭하면 어느 Python 버전과 데이터베이스 백엔드에서 오류가 일"
"어나는지 보여주는 \"Configuration Matrix\"를 볼 수 있습니다."

msgid ""
"For this tutorial and the ticket we're working on, testing against SQLite is "
"sufficient, however, it's possible (and sometimes necessary) to :ref:`run "
"the tests using a different database <running-unit-tests-settings>`. When "
"making UI changes, you will need to :ref:`run the Selenium tests <running-"
"selenium-tests>`."
msgstr ""

msgid "Working on a feature"
msgstr "기능 추가하기"

msgid ""
"For this tutorial, we'll work on a \"fake ticket\" as a case study. Here are "
"the imaginary details:"
msgstr ""
"이 튜토리얼에서 우리는 사례 연구를 위해 \"가짜 티켓\"을 처리합니다. 내용은 다"
"음과 같습니다."

msgid "Ticket #99999 -- Allow making toast"
msgstr "티켓 #99999 -- 토스트 만들기"

msgid ""
"Django should provide a function ``django.shortcuts.make_toast()`` that "
"returns ``'toast'``."
msgstr ""
"Django는 `'toast'``\\를 반환하는 함수 ``django.shortcuts.make_toast()``\\를 "
"제공해야 한다."

msgid "We'll now implement this feature and associated tests."
msgstr "이 기능 및 관련된 테스트를 구현해봅시다."

msgid "Creating a branch for your patch"
msgstr "패치 용 branch 만들기"

msgid "Before making any changes, create a new branch for the ticket:"
msgstr "변경하기 전에 티켓의 새 branch를 생성합니다."

msgid ""
"You can choose any name that you want for the branch, \"ticket_99999\" is an "
"example. All changes made in this branch will be specific to the ticket and "
"won't affect the main copy of the code that we cloned earlier."
msgstr ""
"branch 이름을 원하는 대로 정할 수 있으며, \"ticket_99999\"는 예시입니다. 이 "
"branch에 대한 모든 변경은 특정한 티켓에만 적용되며 앞서 복제한 코드의 메인 사"
"본에는 영향을 끼치지 않습니다."

msgid "Writing some tests for your ticket"
msgstr "티켓에 대한 테스트를 작성하기"

msgid ""
"In most cases, for a patch to be accepted into Django it has to include "
"tests. For bug fix patches, this means writing a regression test to ensure "
"that the bug is never reintroduced into Django later on. A regression test "
"should be written in such a way that it will fail while the bug still exists "
"and pass once the bug has been fixed. For patches containing new features, "
"you'll need to include tests which ensure that the new features are working "
"correctly. They too should fail when the new feature is not present, and "
"then pass once it has been implemented."
msgstr ""
"대부분의 경우에, Django에 대한 패치를 접수할 때에는 테스트를 포함합니다. 버"
"그 수정 패치의 경우, 이것은 그 버그가 나중에 Django에서 다시 발생하지 않도록 "
"회귀 테스트를 작성하는 것을 의미합니다. 회귀 테스트는 버그가 존재하는 동안 실"
"패하다가 일단 버그가 수정되면 통과하도록 작성하여야 합니다. 새로운 기능을 포"
"함하는 패치의 경우 새로운 기능이 올바르게 작동하는지 확인하는 테스트를 포함해"
"야 합니다. 그러한 테스트들은 새로운 기능이 존재하지 않는 경우에는 실패하고, "
"구현이 되면 통과합니다."

msgid ""
"A good way to do this is to write your new tests first, before making any "
"changes to the code. This style of development is called `test-driven "
"development`__ and can be applied to both entire projects and single "
"patches. After writing your tests, you then run them to make sure that they "
"do indeed fail (since you haven't fixed that bug or added that feature yet). "
"If your new tests don't fail, you'll need to fix them so that they do. After "
"all, a regression test that passes regardless of whether a bug is present is "
"not very helpful at preventing that bug from reoccurring down the road."
msgstr ""
"이 작업을 수행하는 좋은 방법은 코드를 변경하기 전에, 먼저 새로운 테스트부터 "
"작성하는 것입니다. 이러한 개발 스타일은 `test-driven development`__\\ 이라고 "
"불리우며, 낱개의 패치에서부터 전체 프로젝트에 이르기까지 적용이 가능합니다. "
"테스트를 작성한 후에는 (당신이 버그를 수정하거나 아직이 기능을 추가하지 않았"
"기 때문에) 그것들이 실제로 실패하는지 확인하기 위해 실행시켜보도록 합니다. "
"새 테스트가 실패하지 않을 경우, 테스트가 실패하도록 수정해야합니다. 버그가 있"
"든없든 통과하는 회귀 테스트라면 다시 발생하는 버그를 방지하는 데에 그다지 도"
"움이 되지 않습니다."

msgid "Now for our hands-on example."
msgstr "이제 우리 예제를 살펴보도록 하겠습니다."

msgid "Writing a test for ticket #99999"
msgstr "티켓 #99999에 대한 테스트 작성하기"

msgid ""
"In order to resolve this ticket, we'll add a ``make_toast()`` function to "
"the ``django.shortcuts`` module. First we are going to write a test that "
"tries to use the function and check that its output looks correct."
msgstr ""
"이 티켓을 해결하기 위해 우리는 ``django.shortcuts`` 모듈에 ``make_toast()`` "
"기능을 추가할 것입니다. 먼저 함수를 사용하려는 테스트를 작성하여 출력이 올바"
"르게 보이는지 확인하겠습니다."

msgid ""
"Navigate to Django's ``tests/shortcuts/`` folder and create a new file "
"``test_make_toast.py``. Add the following code::"
msgstr ""
"Django의 ``tests/shortcuts/`` 폴더로 가서 새 파일 ``test_make_toast.py``\\를 "
"생성합니다. 다음의 코드를 추가합니다."

msgid "This test checks that the ``make_toast()`` returns ``'toast'``."
msgstr ""
"이 테스트는 ``make_toast()``\\가 ``'toast'``\\를 반환하는지 검사합니다."

msgid "But this testing thing looks kinda hard..."
msgstr "하지만 테스팅이 어려워보입니다..."

msgid ""
"If you've never had to deal with tests before, they can look a little hard "
"to write at first glance. Fortunately, testing is a *very* big subject in "
"computer programming, so there's lots of information out there:"
msgstr ""
"이전에 테스트를 한번도 다뤄보지 않았다면, 처음에는 작성하기에 까다로울 수도 "
"있습니다. 다행히도, 테스트는 컴퓨터 프로그래밍에서 *매우* 중요한 주제이기 때"
"문에, 많은 정보를 얻을 수 있습니다."

msgid ""
"A good first look at writing tests for Django can be found in the "
"documentation on :doc:`/topics/testing/overview`."
msgstr ""
"첫 Django 테스트 작성하기의 좋은 예제는 :doc:`/topics/testing/overview`\\에 "
"있는 문서에서 찾을 수 있습니다."

msgid ""
"Dive Into Python (a free online book for beginning Python developers) "
"includes a great `introduction to Unit Testing`__."
msgstr ""
"Dive Into Python (초보 파이썬 개발자를 위한 무료 온라인북)에 훌륭한 "
"`introduction to Unit Testing`__\\ 이 있습니다."

msgid ""
"After reading those, if you want something a little meatier to sink your "
"teeth into, there's always the Python :mod:`unittest` documentation."
msgstr ""
"그것들을 읽어본 후에, 좀 더 음미해보고 싶다면, Python :mod:`unittest` 문서를 "
"읽어보기 바랍니다."

msgid "Running your new test"
msgstr "새 테스트를 수행하기"

msgid ""
"Since we haven't made any modifications to ``django.shortcuts`` yet, our "
"test should fail. Let's run all the tests in the ``shortcuts`` folder to "
"make sure that's really what happens. ``cd`` to the Django ``tests/`` "
"directory and run:"
msgstr ""
"``django.shortcuts``\\를 아직 수정하지 않았기 때문에 테스트가 실패할 것입니"
"다. 실제로 무슨 일이 일어나는지 알기 위해 모든 테스트를 ``shortcuts`` 폴더에"
"서 수행합시다. Django ``tests/`` 디렉토리로 ``cd``\\하여 다음을 실행합니다."

msgid ""
"If the tests ran correctly, you should see one failure corresponding to the "
"test method we added, with this error:"
msgstr ""
"테스트가 올바르게 실행되면, 이 오류와 함께 우리가 추가한 테스트 방법에 해당하"
"는 하나의 실패가 표시됩니다."

msgid ""
"If all of the tests passed, then you'll want to make sure that you added the "
"new test shown above to the appropriate folder and file name."
msgstr ""
"모든 테스트가 통과하면 위에서 살펴본 새로운 테스트를 올바른 폴더와 파일명으"
"로 추가합니다."

msgid "Writing the code for your ticket"
msgstr "티켓에 대한 코드를 작성하기"

msgid "Next we'll be adding the ``make_toast()`` function."
msgstr "다음으로는 ``make_toast()`` 함수를 추가합니다."

msgid ""
"Navigate to the ``django/`` folder and open the ``shortcuts.py`` file. At "
"the bottom, add::"
msgstr ""
"``django/`` 폴더로 이동해 ``shortcuts.py`` 파일을 엽니다. 맨 아래에 다음을 추"
"가합니다."

msgid ""
"Now we need to make sure that the test we wrote earlier passes, so we can "
"see whether the code we added is working correctly. Again, navigate to the "
"Django ``tests/`` directory and run:"
msgstr ""
"이제 우리는 앞에서 작성한 테스트가 통과하는 것을 확인함으로써, 추가한 코드가 "
"올바로 동작함을 확신할 수 있습니다. Django ``tests/`` 디렉토리로 다시 이동해 "
"다음을 실행합니다."

msgid ""
"Everything should pass. If it doesn't, make sure you correctly added the "
"function to the correct file."
msgstr ""
"모든 테스트가 통과할 것입니다. 만약 그렇지 않다면, 함수를 올바른 파일에 올바"
"로 추가했는지 확인하세요."

msgid "Running Django's test suite for the second time"
msgstr "Django의 테스트 스위트를 두 번째로 실행하기"

msgid ""
"Once you've verified that your patch and your test are working correctly, "
"it's a good idea to run the entire Django test suite to verify that your "
"change hasn't introduced any bugs into other areas of Django. While "
"successfully passing the entire test suite doesn't guarantee your code is "
"bug free, it does help identify many bugs and regressions that might "
"otherwise go unnoticed."
msgstr ""
"패치와 테스트가 올바르게 작동하는 것을 확인했으면, 전체 Django test suite를 "
"실행하여 변경 사항이 Django의 다른 영역에 버그가 발생하지 않았는지 확인하는 "
"것이 좋습니다. 전체 test suite를 통과했다고 해서 버그가 없는 것을 확신할 수"
"는 없지만, 모르고 지나쳤을 수도 있는 많은 버그와 잘못을 찾아내는 데 도움이 됩"
"니다."

msgid ""
"To run the entire Django test suite, ``cd`` into the Django ``tests/`` "
"directory and run:"
msgstr ""
"Django 테스트 스위트 전체를 실행하려면, Django ``tests/`` 디렉토리로 "
"``cd``\\ 하여 다음과 같이 실행합니다:"

msgid "Writing Documentation"
msgstr "문서 작성하기"

msgid ""
"This is a new feature, so it should be documented. Open the file ``docs/"
"topics/http/shortcuts.txt`` and add the following at the end of the file:"
msgstr ""
"이것은 새로운 기능이므로 문서화해야합니다. ``docs/topics/http/shortcuts."
"txt`` 파일을 열고 파일 끝에 다음을 추가하십시오. "

msgid ""
"Since this new feature will be in an upcoming release it is also added to "
"the release notes for the next version of Django. Open the release notes for "
"the latest version in ``docs/releases/``, which at time of writing is ``2.2."
"txt``. Add a note under the \"Minor Features\" header:"
msgstr ""
"이 새로운 기능은 곧 출시될 예정이므로 Django의 다음 버전에 대한 릴리즈 노트에"
"도 추가해야 합니다.\n"
"작성 당시  ``2.2.txt``인 ``docs/releases/``의 최신 버전의 릴리즈 노트를 여십"
"시오. \"기본 기능\" 헤더를 노트에 추가하십시오."

msgid ""
"For more information on writing documentation, including an explanation of "
"what the ``versionadded`` bit is all about, see :doc:`/internals/"
"contributing/writing-documentation`. That page also includes an explanation "
"of how to build a copy of the documentation locally, so you can preview the "
"HTML that will be generated."
msgstr ""
"``versionadded``\\ 에 대한 설명을 포함하여, 문서 작성에 대한 자세한 내용은 :"
"doc:`/internals/contributing/writing-documentation`\\ 을 참조하시기 바랍니"
"다. 그 페이지에는 문서의 사본을 로컬에서 빌드하여, 생성되는 HTML을 미리 살펴"
"볼 수 있도록 하는 방법도 설명하고 있습니다."

msgid "Previewing your changes"
msgstr "변경사항 미리보기"

msgid ""
"Now it's time to go through all the changes made in our patch. To stage all "
"the changes ready for commit, run:"
msgstr ""
"우리의 패치의 모든 변경 사항을 훑어볼 시간입니다. 커밋 준비된 모든 변경사항"
"을 스테이지합니다."

msgid ""
"Then display the differences between your current copy of Django (with your "
"changes) and the revision that you initially checked out earlier in the "
"tutorial with:"
msgstr ""
"그 다음으로 Django의 현재 사본(변경 사항을 포함)과 튜토리얼을 시작할 때 처음 "
"체크아웃한 리비전 사이의 차이를 표시합니다."

msgid "Use the arrow keys to move up and down."
msgstr "위 아래로 움직이려면 화살표 키를 사용하세요."

msgid ""
"When you're done previewing the patch, hit the ``q`` key to return to the "
"command line. If the patch's content looked okay, it's time to commit the "
"changes."
msgstr ""
"패치 미리보기가 끝나면 ``q`` 키를 눌러 명령행으로 돌아갑니다. 패치의 내용이 "
"괜찮아 보이면 변경사항을 커밋해야 합니다."

msgid "Committing the changes in the patch"
msgstr "패치 변경사항 적용하기"

msgid "To commit the changes:"
msgstr "변경사항을 적용하려면:"

msgid ""
"This opens up a text editor to type the commit message. Follow the :ref:"
"`commit message guidelines <committing-guidelines>` and write a message like:"
msgstr ""
"그러면 커밋 메시지를 입력하기 위한 텍스트 편집기가 열립니다. :ref:`커밋 메시"
"지 가이드라인 <committing-guidelines>`\\ 에 따라 다음과 같은 메시지를 작성하"
"십시오."

msgid "Pushing the commit and making a pull request"
msgstr "commit 푸시 및 pull request 만들기"

msgid ""
"After committing the patch, send it to your fork on GitHub (substitute "
"\"ticket_99999\" with the name of your branch if it's different):"
msgstr ""
"패치를 커밋한 다음, 깃허브에서 포크한 저장소에 보냅니다(\"ticket_99999\"를 당"
"신의 브랜치 이름에 맞게 바꾸세요)."

msgid ""
"You can create a pull request by visiting the `Django GitHub page <https://"
"github.com/django/django/>`_. You'll see your branch under \"Your recently "
"pushed branches\". Click \"Compare & pull request\" next to it."
msgstr ""
"`Django GitHub 페이지 <https://github.com/django/django/>`_\\ 를 방문하여 "
"pull 요청을 할 수 있습니다. \"최근 푸시 된 브랜치\" 아래에 브랜치가 보일 것입"
"니다. 옆의 \"Compare & pull request\"를 클릭하십시오."

msgid ""
"Please don't do it for this tutorial, but on the next page that displays a "
"preview of the patch, you would click \"Create pull request\"."
msgstr ""
"이 자습서에서는 하지 말고, 패치의 미리보기를 표시하는 다음 페이지에서 \"pull "
"request 만들기\"를 클릭하십시오."

msgid "Next steps"
msgstr "다음 단계"

msgid ""
"Congratulations, you've learned how to make a pull request to Django! "
"Details of more advanced techniques you may need are in :doc:`/internals/"
"contributing/writing-code/working-with-git`."
msgstr ""
"축하합니다. Django에 풀 리퀘스트를 하는 법을 배웠습니다! 필요한 고급 기술에 "
"대한 자세한 내용은 :doc:`/internals/contributing/writing-code/working-with-"
"git`\\ 에 있습니다."

msgid ""
"Now you can put those skills to good use by helping to improve Django's "
"codebase."
msgstr ""
"이제 Django의 코드베이스를 개선하여 이러한 기술을 유용하게 사용할 수 있습니"
"다."

msgid "More information for new contributors"
msgstr "새로 오신 기여자분들을 위한 추가 정보"

msgid ""
"Before you get too into writing patches for Django, there's a little more "
"information on contributing that you should probably take a look at:"
msgstr ""
"Django를 위한 패치를 작성하기 전에, 한번 꼭 보셔야 할 정보들이 있습니다. "

msgid ""
"You should make sure to read Django's documentation on :doc:`claiming "
"tickets and submitting patches </internals/contributing/writing-code/"
"submitting-patches>`. It covers Trac etiquette, how to claim tickets for "
"yourself, expected coding style for patches, and many other important "
"details."
msgstr ""
"Django 문서 중, :doc:`티켓 생성과 패치 제출 </internals/contributing/writing-"
"code/submitting-patches>` 문서를 반드시 읽어보십시요. 이 문서는 Trac 사용 예"
"절과, 직접 티켓을 생성하는 방법, 패치 작성 시 지켜야 할 코딩 스타일과 다른 중"
"요한 것들을 자세히 설명합니다."

msgid ""
"First time contributors should also read Django's :doc:`documentation for "
"first time contributors</internals/contributing/new-contributors/>`. It has "
"lots of good advice for those of us who are new to helping out with Django."
msgstr ""
"기여가 처음이신 분들은 :doc:`첫 기여자를 위한 문서</internals/contributing/"
"new-contributors/>` 를 읽어주십시요. Django 를 도와주시려는 분들을 위한 좋은 "
"조언들이 가득합니다."

msgid ""
"After those, if you're still hungry for more information about contributing, "
"you can always browse through the rest of :doc:`Django's documentation on "
"contributing</internals/contributing/index>`. It contains a ton of useful "
"information and should be your first source for answering any questions you "
"might have."
msgstr ""
"기여에 대한 정보가 이것으로 충분하지 않으시면, :doc:`Django 문서의 기여 항목"
"</internals/contributing/index>` 의 나머지를 흝어보세요. 엄청나게 많은 정보들"
"이 있으며, 궁금하신 점들은 여기서 제일 먼저 찾으셔야 합니다. "

msgid "Finding your first real ticket"
msgstr "첫 번째 진짜 티켓을 찾기"

msgid ""
"Once you've looked through some of that information, you'll be ready to go "
"out and find a ticket of your own to write a patch for. Pay special "
"attention to tickets with the \"easy pickings\" criterion. These tickets are "
"often much simpler in nature and are great for first time contributors. Once "
"you're familiar with contributing to Django, you can move on to writing "
"patches for more difficult and complicated tickets."
msgstr ""
"여기까지 흝어 보셨다면, 이제 직접 패치를 작성해볼 티켓을 찾아봅시다. \"easy "
"pickings\" 제약이 걸린 티켓들을 주의깊게 살펴 봅시다. 이 티켓들은 처리하기 쉬"
"운편이라, 초보 기여자에게 적당합니다. 일단 Django 에 기여하는 과정에 익숙해지"
"면, 조금 더 복잡하고 어려운 티켓에 도전할 수 있습니다."

msgid ""
"If you just want to get started already (and nobody would blame you!), try "
"taking a look at the list of `easy tickets that need patches`__ and the "
"`easy tickets that have patches which need improvement`__. If you're "
"familiar with writing tests, you can also look at the list of `easy tickets "
"that need tests`__. Remember to follow the guidelines about claiming tickets "
"that were mentioned in the link to Django's documentation on :doc:`claiming "
"tickets and submitting patches </internals/contributing/writing-code/"
"submitting-patches>`."
msgstr ""
"지금 당장 시작해보고 싶다면(아무도 비난하지 않을 겁니다!), `easy tickets "
"that need patches`__ 목록과 `easy tickets that have patches which need "
"improvement`__ 목록을 살펴보십시오. 테스트를 작성하는데에 익숙하다면, `easy "
"tickets that need tests`__ 도 참고할 수 있습니다. Django 문서 :doc:`claiming "
"tickets and submitting patches </internals/contributing/writing-code/"
"submitting-patches>`  링크에 언급된 티켓 생성에 대한 지침을 잊지 마십시오."

msgid "What's next after creating a pull request?"
msgstr "pull request를 만든 후 다음은 무엇입니까?"

msgid ""
"After a ticket has a patch, it needs to be reviewed by a second set of eyes. "
"After submitting a pull request, update the ticket metadata by setting the "
"flags on the ticket to say \"has patch\", \"doesn't need tests\", etc, so "
"others can find it for review. Contributing doesn't necessarily always mean "
"writing a patch from scratch. Reviewing existing patches is also a very "
"helpful contribution. See :doc:`/internals/contributing/triaging-tickets` "
"for details."
msgstr ""
"티켓에 패치가 있는 경우 두 번째 눈으로 검토해야 합니다. pull 요청을 제출한 "
"후 티켓에 \"패치가 있음\", \"테스트가 필요 없음\" 등의 플래그를 설정하여 티"
"켓 메타데이터를 업데이트하여 다른 사람들이 검토할 수 있도록 합니다. 기여한다"
"고 해서 항상 패치를 처음부터 작성하는 것은 아닙니다. 기존 패치를 검토하는 것"
"도 매우 도움이 됩니다. 자세한 내용은 :doc:`/internals/contributing/triaging-"
"tickets`\\ 를 참조하십시오."

msgid "Getting started"
msgstr "시작하기"

msgid ""
"New to Django? Or to web development in general? Well, you came to the right "
"place: read this material to quickly get up and running."
msgstr ""
"Django가 처음이세요? 일반적인 웹 개발이 처음이신가요? 좋아요, 여기 잘 오셨습"
"니다. 빠르게 시작하기 위해 이 자료를 읽으십시오."

msgid ""
"If you're new to Python_, you might want to start by getting an idea of what "
"the language is like. Django is 100% Python, so if you've got minimal "
"comfort with Python you'll probably get a lot more out of Django."
msgstr ""
"Python_\\ 이 처음이라면, 그것이 어떤 언어인지 한번 알아보세요. Django는 100% "
"파이썬으로 작성되었으므로, Python에 익숙하다면 Django를 더욱 잘 이해할 수 있"
"을 것입니다."

msgid ""
"If you're new to programming entirely, you might want to start with this "
"`list of Python resources for non-programmers`_"
msgstr ""
"프로그래밍을 전혀 해보지 않았다면 `list of Python resources for non-"
"programmers`_\\ 에서 시작하시기를 권합니다."

msgid ""
"If you already know a few other languages and want to get up to speed with "
"Python quickly, we recommend `Dive Into Python`_. If that's not quite your "
"style, there are many other `books about Python`_."
msgstr ""
"여러분이 몇가지 다른 언어를 알고 파이썬으로 빠르게 시작하길 원한다면, 우리는 "
"`Dive Into Python`_ 을 추천합니다. 그 책이 여러분의 스타일이 아니더라도, 다"
"른 많은 `books about Python`_ 이 있습니다."

msgid "Quick install guide"
msgstr "빠른 설치 가이드"

msgid ""
"Before you can use Django, you'll need to get it installed. We have a :doc:"
"`complete installation guide </topics/install>` that covers all the "
"possibilities; this guide will guide you to a minimal installation that'll "
"work while you walk through the introduction."
msgstr ""
"Django를 사용하기 위해 설치를 해야합니다.  모든 설치 과정을 안내하는 :doc:"
"`complete installation guide 1`가 있습니다.  이 가이드를 통해 간단하게 설치안"
"내를 받을 수 있습니다."

msgid "Install Python"
msgstr "파이썬 설치하기"

msgid ""
"Being a Python web framework, Django requires Python. See :ref:`faq-python-"
"version-support` for details. Python includes a lightweight database called "
"SQLite_ so you won't need to set up a database just yet."
msgstr ""
"Python 웹 프레임워크이므로, Django는 Python이 필요합니다. 자세한 내용은 :ref:"
"`faq-python-version-support` 를 참조하십시오. Python은 SQLite_ 라 불리는 경"
"량 데이터베이스를 가지고 있어서 여러분은 아직 데이터베이스를 설정할 필요가 없"
"습니다."

msgid ""
"Get the latest version of Python at https://www.python.org/downloads/ or "
"with your operating system's package manager."
msgstr ""
"최신 Python 버전은 https://www.python.org/downloads/ 또는 운영 체제 패키지 관"
"리자에게 문의하십시오."

msgid ""
"You can verify that Python is installed by typing ``python`` from your "
"shell; you should see something like:"
msgstr ""
"Python이 설치되었는지 확인하려면 Shell에서 ``python`` 을 입력하십시오. 다음"
"과 같은 내용이 나타납니다."

msgid "Set up a database"
msgstr "데이터베이스 설정하기"

msgid ""
"This step is only necessary if you'd like to work with a \"large\" database "
"engine like PostgreSQL, MariaDB, MySQL, or Oracle. To install such a "
"database, consult the :ref:`database installation information <database-"
"installation>`."
msgstr ""
"이 단계는 PostgreSQL, MariaDB, MySQL, Oracle 과 같은 규모의 데이터베이스 엔진"
"을 사용하여 작업할 때만 필요합니다. 이러한 데이터베이스를 설치하려면 :ref:"
"`database installation information`를 참조하세요."

msgid "Install Django"
msgstr "장고 설치하기"

msgid "You've got three options to install Django:"
msgstr "세 가지 방법으로 장고를 설치할 수 있습니다:"

msgid ""
":ref:`Install an official release <installing-official-release>`. This is "
"the best approach for most users."
msgstr ""
"대부분의 유저들에게는 :ref:`공식 릴리즈 <installing-official-release>`\\ 를 "
"추천합니다."

msgid ""
"Install a version of Django :ref:`provided by your operating system "
"distribution <installing-distribution-package>`."
msgstr ""
":doc:`운영체제 <installing-distribution-package>` 에서 제공하는 Django 를 설"
"치하세요."

msgid ""
":ref:`Install the latest development version <installing-development-"
"version>`. This option is for enthusiasts who want the latest-and-greatest "
"features and aren't afraid of running brand new code. You might encounter "
"new bugs in the development version, but reporting them helps the "
"development of Django. Also, releases of third-party packages are less "
"likely to be compatible with the development version than with the latest "
"stable release."
msgstr ""
":ref:`최신 개발 버전 설치하기 <installing-development-version>`. 이 옵션은 가"
"장 최신 버전의 기능을 사용하기 원하는 열정적이고 도전적인 사람들을 위한 옵션"
"입니다. 개발 버전을 사용할 경우 예기치 못한 새로운 버그에 맞닥뜨릴수도 있습니"
"다. 이런 버그들을 발견하실 경우 버그 리포팅을 통해 Django개발에 도움을 주실 "
"수 있습니다. 또한, 3rd-party-패키지의 경우에는 현재 Stable로 제공되는 릴리즈 "
"버전보다는 호환성이 떨어질 수 있습니다."

msgid ""
"Always refer to the documentation that corresponds to the version of Django "
"you're using!"
msgstr "항상 현재 사용하는 Django 버전의 공식 문서를 참고하세요!"

msgid ""
"If you do either of the first two steps, keep an eye out for parts of the "
"documentation marked **new in development version**. That phrase flags "
"features that are only available in development versions of Django, and they "
"likely won't work with an official release."
msgstr ""
"여러분이 처음 두 단계중 하나를 실행한다면, 문서에서 **new in development "
"version** 라고 표시된 부분을 주의해서 보세요. 그 구문 플래그는 Django 개발 버"
"전에서만 사용가능하고, 공식 릴리즈에서는 작동하지 않을것을 알려주는 기능을 합"
"니다."

msgid "Verifying"
msgstr "검토하기"

msgid ""
"To verify that Django can be seen by Python, type ``python`` from your "
"shell. Then at the Python prompt, try to import Django:"
msgstr ""
"Python이 Djagno를 찾을 수 있는지 확인하기 위해, 쉘에서 ``python``\\이라고 입"
"력하고 Python 프롬프트에서 Django를 임포트해보세요."

msgid "You may have another version of Django installed."
msgstr "여러분은 다른 버전의 장고가 설치되어있을 수도 있습니다."

msgid "That's it!"
msgstr "끝입니다!"

msgid ""
"That's it -- you can now :doc:`move onto the tutorial </intro/tutorial01>`."
msgstr ""
"이게 끝입니다. 이제, :doc:`튜토리얼 </intro/tutorial01>` 을 시작해보세요."

msgid "Django at a glance"
msgstr "Django 훑어보기"

msgid ""
"Because Django was developed in a fast-paced newsroom environment, it was "
"designed to make common web development tasks fast and easy. Here's an "
"informal overview of how to write a database-driven web app with Django."
msgstr ""
"Django는 빠르게 변화하는 뉴스룸 환경에서 개발되었기 때문에 일반적인 웹 개발 "
"작업을 빠르고 쉽게 수행할 수 있도록 설계되었습니다. 다음은 Django로 데이터베"
"이스 기반 웹 앱을 작성하는 방법에 대한 알기쉬운 개요입니다."

msgid ""
"The goal of this document is to give you enough technical specifics to "
"understand how Django works, but this isn't intended to be a tutorial or "
"reference -- but we've got both! When you're ready to start a project, you "
"can :doc:`start with the tutorial </intro/tutorial01>` or :doc:`dive right "
"into more detailed documentation </topics/index>`."
msgstr ""
"이 문서의 목표는 Django가 어떻게 동작하는지 이해하는데 충분한 기술적 사항들"
"을 알려주는데 있습니다. 하지만 튜토리얼이나 레퍼런스의 역할을 의도하지는 않습"
"니다 -- 물론 우리는 그 두가지를 다 가지고있죠! 프로젝트를 시작할 준비가 되었"
"으면 :doc:`튜토리얼로 시작 </intro/tutorial01>`\\ 하거나 :doc:`바로 좀더 자세"
"한 문서로 뛰어들수 있습니다 </topics/index>`."

msgid "Design your model"
msgstr "모델 설계"

msgid ""
"Although you can use Django without a database, it comes with an `object-"
"relational mapper`_ in which you describe your database layout in Python "
"code."
msgstr ""
"설사 Django를 데이터베이스 없이 쓸 수 있을 지라도 데이터베이스 레이아웃을 파"
"이썬 코드로 표현할 수 있는 `object-relational mapper`_\\ 가 같이 딸려 옵니다."

msgid ""
"The :doc:`data-model syntax </topics/db/models>` offers many rich ways of "
"representing your models -- so far, it's been solving many years' worth of "
"database-schema problems. Here's a quick example:"
msgstr ""
":doc:`data-model 구문 </topics/db/models>`\\은 당신의 모델을 표현할 풍부한 방"
"법을 제공해줍니다 -- 이는 지금까지 수년간 데이터베이스 스키마 문제들을 해결하"
"는데에 많은 도움을 주어왔습니다. 아래의 간단한 예제를 보시죠."

msgid "``mysite/news/models.py``"
msgstr "``mysite/news/models.py``"

msgid "Install it"
msgstr "설치하기"

msgid ""
"Next, run the Django command-line utilities to create the database tables "
"automatically:"
msgstr ""
"다음으로, 데이터베이스를 자동으로 생성해주는 Django command-line 유틸리티를 "
"실행하여 줍니다:"

msgid ""
"The :djadmin:`makemigrations` command looks at all your available models and "
"creates migrations for whichever tables don't already exist. :djadmin:"
"`migrate` runs the migrations and creates tables in your database, as well "
"as optionally providing :doc:`much richer schema control </topics/"
"migrations>`."
msgstr ""
":djadmin:`makemigrations` 명령은 생성 가능한 모델을 찾아 테이블이 존재하지 않"
"을 경우 마이그레이션을 생성합니다. :djadmin:`migrate` 명령은 마이그레이션을 "
"실행하고 사용자의 데이터베이스에 테이블을 생성합니다. 이는 더욱 :doc:`풍부한 "
"스키마 제어</topics/migrations>`\\ 를 선택적으로 제공합니다."

msgid "Enjoy the free API"
msgstr "자유로운 API 즐기기"

msgid ""
"With that, you've got a free, and rich, :doc:`Python API </topics/db/"
"queries>` to access your data. The API is created on the fly, no code "
"generation necessary:"
msgstr ""
"이것으로 자료에 접근하기 위한 자유롭고 풍부한 :doc:`Python API </topics/db/"
"queries>`\\ 를 얻을 수 있습니다. API는 즉석에서 만들어지며, 코드 생성이 필요"
"하지 않습니다."

msgid ""
"A dynamic admin interface: it's not just scaffolding -- it's the whole house"
msgstr "동적인 관리자 인터페이스: 단순한 스캐폴딩이 아닙니다. 완성된 집입니다."

msgid ""
"Once your models are defined, Django can automatically create a "
"professional, production ready :doc:`administrative interface </ref/contrib/"
"admin/index>` -- a website that lets authenticated users add, change and "
"delete objects. The only step required is to register your model in the "
"admin site:"
msgstr ""
"일단 모델이 정의되면 Django는 전문적이고 바로 사용할 수 있는 :doc:"
"`administrative interface </ref/contrib/admin/index>`를 자동으로 만들 수 있습"
"니다. 관리자 인터페이스는 인증된 사용자가 객체를 추가, 변경 및 삭제할 수 있"
"는 웹 사이트입니다. 필요한 것은 관리자 페이지에 당신의 모델을 등록하는 것 뿐"
"입니다."

msgid "``mysite/news/admin.py``"
msgstr "``mysite/news/admin.py``"

msgid ""
"The philosophy here is that your site is edited by a staff, or a client, or "
"maybe just you -- and you don't want to have to deal with creating backend "
"interfaces only to manage content."
msgstr ""
"사이트 수정은 직원, 고객 또는 당신에 의해 수행되며, 컨텐츠 관리만을 위해 백엔"
"드 인터페이스를 생성할 필요는 없습니다."

msgid ""
"One typical workflow in creating Django apps is to create models and get the "
"admin sites up and running as fast as possible, so your staff (or clients) "
"can start populating data. Then, develop the way data is presented to the "
"public."
msgstr ""
"Django 앱을 생성하는 하나의 전형적인 작업 흐름은 일단 모델을 만들고 관리자 사"
"이트를 올려서 가능한 빨리 작동할 수 있게 만드는 것입니다, 그래서 당신의 운영"
"자(혹은 고객)이 데이터 입력을 시작할 수 있게 합니다. 그러면 밖으로 데이터를 "
"표현하는 방법을 개발합니다."

msgid "Design your URLs"
msgstr "URL 설계"

msgid ""
"A clean, elegant URL scheme is an important detail in a high-quality web "
"application. Django encourages beautiful URL design and doesn't put any "
"cruft in URLs, like ``.php`` or ``.asp``."
msgstr ""
"깔끔하고 우아한 URL 계획은 고품질의 웹 어플리케이션에 매우 중요한 부분입니"
"다. Django는 아름다운 URL 설계를 장려하며 URL에 ``.php`` 나 ``.asp`` 같은 불"
"필요한 내용들을 넣지 않습니다."

msgid ""
"To design URLs for an app, you create a Python module called a :doc:`URLconf "
"</topics/http/urls>`. A table of contents for your app, it contains a "
"mapping between URL patterns and Python callback functions. URLconfs also "
"serve to decouple URLs from Python code."
msgstr ""
"앱을 위한 URL을 설계하기 위해서 :doc:`URLconf 1` 파이썬 모듈을 생성해야 합니"
"다. 이것은 당신의 앱의 목차이며, URL패턴과 Python 콜백 함수의 매핑을 포함합니"
"다. URLconf는 Python 코드와 URL을 분리하는 역할도 합니다."

msgid ""
"Here's what a URLconf might look like for the ``Reporter``/``Article`` "
"example above:"
msgstr ""
"아래의 코드는 위의 ``Reporter``/``Article``  예제에 대해서 URLconf를 어떻게 "
"쓰는지 보여줍니다:"

msgid "``mysite/news/urls.py``"
msgstr "``mysite/news/urls.py``"

msgid ""
"The code above maps URL paths to Python callback functions (\"views\"). The "
"path strings use parameter tags to \"capture\" values from the URLs. When a "
"user requests a page, Django runs through each path, in order, and stops at "
"the first one that matches the requested URL. (If none of them matches, "
"Django calls a special-case 404 view.) This is blazingly fast, because the "
"paths are compiled into regular expressions at load time."
msgstr ""
"위 코드는 URL 경로들을 파이썬 콜백 함수들(\"views\")로 연결해 줍니다. 경로를 "
"나타내는 문자열들은 매개 변수 태그들을 사용하여 URL 로부터 값을 \"캡처\"합니"
"다. 사용자가 페이지를 요청하면, Django 는 각 경로를 순서대로 실행하고, 요청"
"된 URL 과 일치하는 첫번째 것에서 정지하게 됩니다. (만약 아무것도 매치하는 것"
"이 없다면, Django 는 특수한 사례인 404 view 를 호출합니다.) 이 경로들은 로드"
"할 때 정규표현식으로 컴파일 되어 있기 때문에 엄청나게 빠릅니다."

msgid ""
"Once one of the URL patterns matches, Django calls the given view, which is "
"a Python function. Each view gets passed a request object -- which contains "
"request metadata -- and the values captured in the pattern."
msgstr ""
"URL 패턴 중 하나가 일치하면 Django는 주어진 뷰를 호출합니다. 뷰는 파이썬 함수"
"로, 각각의 뷰에는 요청 메타데이터가 포함된 요청 개체와 패턴에 잡힌 값이 전달 "
"됩니다."

msgid ""
"For example, if a user requested the URL \"/articles/2005/05/39323/\", "
"Django would call the function ``news.views.article_detail(request, "
"year=2005, month=5, pk=39323)``."
msgstr ""
"예를 들어, 사용자가 URL \"/articles/2005/05/39323/\"로 요청을 보냅니다, 그러"
"면 Django는 다음처럼 함수를 호출하게 됩니다. ``news.views."
"article_detail(request, year=2005, month=5, pk=39323)``."

msgid "Write your views"
msgstr "뷰 작성하기"

msgid ""
"Each view is responsible for doing one of two things: Returning an :class:"
"`~django.http.HttpResponse` object containing the content for the requested "
"page, or raising an exception such as :class:`~django.http.Http404`. The "
"rest is up to you."
msgstr ""
"각각의 뷰는 다음 두 가지 중 하나를 수행할 책임이 있습니다. 요청된 페이지의 내"
"용을 담고 있는 :class:`~django.http.HttpResponse` 객체를 반환하거나, :class:"
"`~django.http.Http404` 같은 예외를 발생시키는 것 입니다. 나머지는 여러분에게 "
"달려있습니다."

msgid ""
"Generally, a view retrieves data according to the parameters, loads a "
"template and renders the template with the retrieved data. Here's an example "
"view for ``year_archive`` from above:"
msgstr ""
"일반적으로 뷰는 파라미터들에 따라 데이터를 가져오며 템플릿을 로드하고 템플릿"
"을 가져온 데이타로 렌더링합니다. 아래는 위에서 만든 ``year_archive``\\에 대"
"한 예제 뷰입니다."

msgid "``mysite/news/views.py``"
msgstr "``mysite/news/views.py``"

msgid ""
"This example uses Django's :doc:`template system </topics/templates>`, which "
"has several powerful features but strives to stay simple enough for non-"
"programmers to use."
msgstr ""
"이 예제는 Django의 :doc:`템플릿 시스템 </topics/templates>`\\ 을 사용합니다. "
"Django 템플릿 시스템은 몇몇 강력한 기능들을 가지고 있지만 프로그래머가 아닌 "
"사람도 사용하기에 어렵지 않도록 간결함을 유지하도록 노력하였습니다."

msgid "Design your templates"
msgstr "여러분만의 템플릿 작성"

msgid "The code above loads the ``news/year_archive.html`` template."
msgstr "위의 코드는 ``news/year_archive.html`` 템플릿을 로드합니다."

msgid ""
"Django has a template search path, which allows you to minimize redundancy "
"among templates. In your Django settings, you specify a list of directories "
"to check for templates with :setting:`DIRS <TEMPLATES-DIRS>`. If a template "
"doesn't exist in the first directory, it checks the second, and so on."
msgstr ""
"장고는 여러분이 템플릿들중 중복을 최소화할 수 있게 하는 템플릿 검색 경로를 가"
"지고 있습니다. 여러분의 장소 셋팅에 :setting:`DIRS <TEMPLATES-DIRS>` 템플릿"
"을 확인하기 위한 디렉토리의 목록을 명시합니다.  만약 첫번째 디렉토리에 템플릿"
"이 존재하지 않으면, 두번째 디렉토리, 그 외 디렉토리를 점검합니다."

msgid ""
"Let's say the ``news/year_archive.html`` template was found. Here's what "
"that might look like:"
msgstr ""
"``news/year_archive.html`` 템플릿을 발견했다고 합시다.  아마도 이런 모양일 것"
"입니다:"

msgid "``mysite/news/templates/news/year_archive.html``"
msgstr "``mysite/news/templates/news/year_archive.html``"

msgid ""
"Variables are surrounded by double-curly braces. ``{{ article.headline }}`` "
"means \"Output the value of the article's headline attribute.\" But dots "
"aren't used only for attribute lookup. They also can do dictionary-key "
"lookup, index lookup and function calls."
msgstr ""
"변수는 이중 중괄호로 둘러싸입니다. ``{{ article.headline }}`` 의 뜻은 "
"“article의 headline 속성의 값을 출력하겠다.” 입니다. 하지만 마침표가 속성의 "
"조회에만 사용되는것은 아닙니다. 점은 사전의 키 조회에도 사용될수 있으며 인덱"
"스 조회와 함수 호출에도 사용될 수 있습니다."

msgid ""
"Note ``{{ article.pub_date|date:\"F j, Y\" }}`` uses a Unix-style "
"\"pipe\" (the \"|\" character). This is called a template filter, and it's a "
"way to filter the value of a variable. In this case, the date filter formats "
"a Python datetime object in the given format (as found in PHP's date "
"function)."
msgstr ""
"참고로 ``{{ article.pub_date|date:\"F j, Y\" }}``\\ 는 유닉스 스타일의 “파이"
"프”(“|” 문자)를 사용한것입니다. 이 파이프는 템플릿 필터를 호출하며 이를 통해 "
"변수의 값을 필터링 할 수 있습니다. 이 코드에서 date 필터는 파이썬의 datetime "
"개체를 지정한 포맷으로 변환 시킵니다.(PHP의 date 함수처럼 말이죠, 네 PHP 의 "
"좋은 아이디어 중에 하나입니다.)"

msgid ""
"You can chain together as many filters as you'd like. You can write :ref:"
"`custom template filters <howto-writing-custom-template-filters>`. You can "
"write :doc:`custom template tags </howto/custom-template-tags>`, which run "
"custom Python code behind the scenes."
msgstr ""
"여러분은 좋아하는 여러 필터들을 함께 연결할 수 있습니다. 여러분은 :ref:`커스"
"텀 템플릿 필터 <howto-writing-custom-template-filters>`\\ 를 작성할 수 있습니"
"다. 여러분은 은밀하게 실행되는 커스텀 파이썬 코드인 :doc:`커스텀 템플릿 태그 "
"</howto/custom-template-tags>`\\ 를 작성할 수도 있습니다."

msgid ""
"Finally, Django uses the concept of \"template inheritance\". That's what "
"the ``{% extends \"base.html\" %}`` does. It means \"First load the template "
"called 'base', which has defined a bunch of blocks, and fill the blocks with "
"the following blocks.\" In short, that lets you dramatically cut down on "
"redundancy in templates: each template has to define only what's unique to "
"that template."
msgstr ""
"이제 마지막으로 Django의 “템플릿 상속” 개념을 사용해 보죠. 이를 통해 ``{% "
"extends \"base.html\" %}`` 코드가 무슨 일을 하는지 알 수 있습니다. 이 코드의 "
"의미는 ”한 뭉치의 block들이 정의된 ‘base’라는 템플릿을 먼저 로드하고 뒤따르"
"는 block들로 이 block들을 채운다는것”입니다. 간단히 말해 템플릿 안의 중복을 "
"극적으로 낮추게 합니다. 각각의 템플릿은 자신이 표현하려는 내용들만 정의할 수 "
"있게 되기 때문입니다."

msgid ""
"Here's what the \"base.html\" template, including the use of :doc:`static "
"files </howto/static-files/index>`, might look like:"
msgstr ""
"“base.html” 템플릿은 :doc:`정적 파일 </howto/static-files/index>`\\ 의 사용"
"을 포함하여, 다음과 같이 보일 것입니다."

msgid "``mysite/templates/base.html``"
msgstr "``mysite/templates/base.html``"

msgid ""
"Simplistically, it defines the look-and-feel of the site (with the site's "
"logo), and provides \"holes\" for child templates to fill. This means that a "
"site redesign can be done by changing a single file -- the base template."
msgstr ""
"간단하게 사이트의 look-and-feel(사이트의 로고)을 정의하고 하위 템플릿이 채울 "
"수 있는 “구멍”들을 제공합니다. 이 방식은 base template 라는 단일 파일을 변경"
"하여 사이트를 재설계할 수 있습니다."

msgid ""
"It also lets you create multiple versions of a site, with different base "
"templates, while reusing child templates. Django's creators have used this "
"technique to create strikingly different mobile versions of sites by only "
"creating a new base template."
msgstr ""
"또한 하위 템플릿을 재사용하면서 서로 다른 base 템플릿을으로 여러 버전의 사이"
"트를 생성할 수 있습니다. Django의 제작자들은 이 기술을 사용하여 단순히 새로"
"운 base 템플릿을 만듦으로써 완전히 다른 모바일 버전의 사이트를 만들었습니다."

msgid ""
"Note that you don't have to use Django's template system if you prefer "
"another system. While Django's template system is particularly well-"
"integrated with Django's model layer, nothing forces you to use it. For that "
"matter, you don't have to use Django's database API, either. You can use "
"another database abstraction layer, you can read XML files, you can read "
"files off disk, or anything you want. Each piece of Django -- models, views, "
"templates -- is decoupled from the next."
msgstr ""
"여러분이 선호하는 템플릿 시스템이 있다면 꼭 Django의 템플릿 시스템을 사용할 "
"필요는 없습니다. Django의 템플릿 시스템은 Django의 모델계층과 매우 잘 통합되"
"어 있지만 꼭 이를 사용하도록 강제하는 것은 아닙니다. 이러한 이유들로 Django"
"의 데이터베이스 API 역시 반드시 써야 할 필요는 없습니다. 여러분은 다른 데이터"
"베이스 추상화 계층을 사용할수 있으며 XML 파일이나 디스크에서 다른 파일을 사용"
"하거나 여러분이 원하는 다른 여러가지 방식으로 사용할수도 있습니다. 각각의 "
"Django 구성요소들 -- 모델, 뷰, 템플릿 -- 은 서로 결합도가 낮게 되어있습니다."

msgid "This is just the surface"
msgstr "이건 단지 껍데기일 뿐"

msgid ""
"This has been only a quick overview of Django's functionality. Some more "
"useful features:"
msgstr ""
"이건 Django의 기능에 대한 간략한 개요에 불과합니다. 다음과 같이 좀 더 유용한 "
"기능들도 많습니다."

msgid ""
"A :doc:`caching framework </topics/cache>` that integrates with memcached or "
"other backends."
msgstr ""
"memached나 기타 백엔드와 통합된 :doc:`캐시 프레임워크 </topics/cache>`."

msgid ""
"A :doc:`syndication framework </ref/contrib/syndication>` that lets you "
"create RSS and Atom feeds by writing a small Python class."
msgstr ""
"Python 클래스를 약간만 작성해도 RSS 및 Atom 피드를 만들어주는 :doc:"
"`syndication framework </ref/contrib/syndication>`"

msgid ""
"More attractive automatically-generated admin features -- this overview "
"barely scratched the surface."
msgstr ""
"이보다 더 매력적인 자동생성 관리자 기능 -- 이 개요는 극히 일부만 다루었습니"
"다."

msgid ""
"The next steps are for you to `download Django`_, read :doc:`the tutorial </"
"intro/tutorial01>` and join `the community`_. Thanks for your interest!"
msgstr ""
"다음 단계는 `Django`_를 다운로드하고 :doc:`the tutorial </intro/tutorial01>` "
"를 읽고 `the community`_에 가입하는 것입니다. 여러분의 관심에 감사드립니다."

msgid "Advanced tutorial: How to write reusable apps"
msgstr "심화 튜토리얼: 재사용 가능한 앱을 만드는 법"

msgid ""
"This advanced tutorial begins where :doc:`Tutorial 8 </intro/tutorial08>` "
"left off. We'll be turning our web-poll into a standalone Python package you "
"can reuse in new projects and share with other people."
msgstr ""
"이 심화 튜토리얼은 :doc:`Tutorial 8 1 </intro/tutorial08>` 의 완료 시점에서 "
"시작합니다. 이제 우리는 web-poll을 새로운 프로젝트에서 재사용하고 다른 사람들"
"과 공유할 수 있는 독립적인 Python 패키지로 만들 것입니다. \n"
"."

msgid ""
"If you haven't recently completed Tutorials 1–7, we encourage you to review "
"these so that your example project matches the one described below."
msgstr ""
"아직 튜토리얼 1~7장을 완료하지 않았다면, 읽어보고 당신의 예제 프로젝트를 아래"
"에 설명하는 것과 일치시킬 것을 권장합니다."

msgid "Reusability matters"
msgstr "재사용의 중요성"

msgid ""
"It's a lot of work to design, build, test and maintain a web application. "
"Many Python and Django projects share common problems. Wouldn't it be great "
"if we could save some of this repeated work?"
msgstr ""
"웹 어플리케이션을 설계, 빌드, 테스트, 유지하는 것은 꽤나 큰 일입니다. 수많은 "
"Python과 Django 프로젝트들에는 공통적인 문제가 있습니다. 만약 우리가 이러한 "
"반복적인 작업들 중에서 몇몇을 구해낼 수 있다면 정말 멋지지 않을까요?"

msgid ""
"Reusability is the way of life in Python. `The Python Package Index (PyPI) "
"<https://pypi.org/>`_ has a vast range of packages you can use in your own "
"Python programs. Check out `Django Packages <https://djangopackages.org>`_ "
"for existing reusable apps you could incorporate in your project. Django "
"itself is also a normal Python package. This means that you can take "
"existing Python packages or Django apps and compose them into your own web "
"project. You only need to write the parts that make your project unique."
msgstr ""
"재사용성은 Python의 핵심 가치입니다. `Python Package Index(PyPI) <https://"
"pypi.org/>`_\\에는 여러분의 Python 프로그램에 사용할 수 있는 방대한 패키지가 "
"있습니다. 여러분의 프로젝트에 활용할 수 있는 재사용 가능 앱을 `Django "
"Packages <https://djangopackages.org>`_\\에서 확인하세요. Django는 그 자체로"
"서 Python 패키지이기도 합니다. 이는 기존 Python 패키지 또는 Django 앱을 가져"
"다가 당신의 웹 프로젝트에 이용할 수 있음을 의미합니다. 프로젝트만의 고유한 부"
"분을 작성하기만 하면 됩니다."

msgid ""
"Let's say you were starting a new project that needed a polls app like the "
"one we've been working on. How do you make this app reusable? Luckily, "
"you're well on the way already. In :doc:`Tutorial 1 </intro/tutorial01>`, we "
"saw how we could decouple polls from the project-level URLconf using an "
"``include``. In this tutorial, we'll take further steps to make the app easy "
"to use in new projects and ready to publish for others to install and use."
msgstr ""
"이제 우리가 작업했던 것과 같은 설문조사 앱이 필요하여 새로운 프로젝트를 시작"
"했다고 가정해봅시다. 어떻게 이 앱을 재사용할 수 있게 만들 수 있을까요? 운 좋"
"게도, 여러분은 이미 방법을 알고 있습니다. :doc:`튜토리얼 1장</intro/"
"tutorial01>` 에서, 우리는 ``include`` 를 이용하여 프로젝트 수준의 URLconf에"
"서 설문조사를 분리하는 방법을 배웠습니다. 이 튜토리얼에서는, 새로운 프로젝트"
"에서 사용하기 쉬운 앱을 만들고 이 앱을 설치하고 사용할 다른 사람들을 위해 게"
"시할 준비를 하기 위한 추가적인 작업을 진행할 것입니다."

msgid "Package? App?"
msgstr "패키지? 앱?"

msgid ""
"A Python :term:`package` provides a way of grouping related Python code for "
"easy reuse. A package contains one or more files of Python code (also known "
"as \"modules\")."
msgstr ""
"Python :term:`package`\\는 재사용을 쉽게 하기 위해 연관된 Python 코드를 묶어 "
"놓은 것입니다. 패키지에는 Python 코드가 들어있는 하나 이상의 파일(\"모듈\"이"
"라고도 함)들이 포함되어  있습니다."

msgid ""
"A package can be imported with ``import foo.bar`` or ``from foo import "
"bar``. For a directory (like ``polls``) to form a package, it must contain a "
"special file ``__init__.py``, even if this file is empty."
msgstr ""
"``import foo.bar`` 나 ``from foo import bar`` 로 패키지를 import 할 수 있습니"
"다. 디렉토리(``polls``\\ 와 같은)는 패키지를 형성하기 위해, 특별한 파일 "
"``__init__.py``\\ 를 포함하고 있습니다, 그 파일이 빈파일일 경우에도 포함하고 "
"있습니다."

msgid ""
"A Django *application* is a Python package that is specifically intended for "
"use in a Django project. An application may use common Django conventions, "
"such as having ``models``, ``tests``, ``urls``, and ``views`` submodules."
msgstr ""
"Django *어플리케이션*\\ 은 Django 프로젝트에 사용하기 위한 파이썬 패키지일 뿐"
"입니다. 애플리케이션은 ``models``, ``tests``, ``urls``, ``views`` 서브모듈들"
"을 포함하고 있는 공통적인 Django 규칙을 이용할 수 있습니다."

msgid ""
"Later on we use the term *packaging* to describe the process of making a "
"Python package easy for others to install. It can be a little confusing, we "
"know."
msgstr ""
"여기서는 다른 사람들이 Python 패키지를 쉽게 설치할 수 있게 만드는 과정을 이르"
"는 데 *패키징*\\이라는 용어를 사용할 것입니다. 약간 혼동될 수도 있습니다."

msgid "Your project and your reusable app"
msgstr "프로젝트와 재사용가능한 앱"

msgid "After the previous tutorials, our project should look like this:"
msgstr "이전 튜토리얼을 마치면, 프로젝트는 다음과 같을 것입니다. "

msgid ""
"You created ``mysite/templates`` in :doc:`Tutorial 7 </intro/tutorial07>`, "
"and ``polls/templates`` in :doc:`Tutorial 3 </intro/tutorial03>`. Now "
"perhaps it is clearer why we chose to have separate template directories for "
"the project and application: everything that is part of the polls "
"application is in ``polls``. It makes the application self-contained and "
"easier to drop into a new project."
msgstr ""
"여러분은 :doc:`튜토리얼 7 </intro/tutorial07>` 에서 ``mysite/templates``  "
"나 :doc:`Tutorial 3 </intro/tutorial03>` 에서 ``polls/templates``  를 생성하"
"였습니다. 이제 프로젝트와 어플리케이션으로 분리한 이유가 명확합니다. "
"``polls`` 어플리케이션의 부분들은 ``polls``\\ 에 모두 있습니다.  It makes "
"the application self-contained and easier to drop into a new project."

msgid ""
"The ``polls`` directory could now be copied into a new Django project and "
"immediately reused. It's not quite ready to be published though. For that, "
"we need to package the app to make it easy for others to install."
msgstr ""
"``polls`` 디렉토리가 이제 새 Django 프로젝트로 복사되었고, 바로 재사용할 수 "
"있습니다. 그래도 게시 할 준비가 되지 않았습니다. 이를 위해, 다른 사람들이 쉽"
"게 설치할 수 있도록 앱을 패키지화해야합니다."

msgid "Installing some prerequisites"
msgstr "필수 구성 요소 설치"

msgid ""
"The current state of Python packaging is a bit muddled with various tools. "
"For this tutorial, we're going to use :pypi:`setuptools` to build our "
"package. It's the recommended packaging tool (merged with the ``distribute`` "
"fork). We'll also be using :pypi:`pip` to install and uninstall it. You "
"should install these two packages now. If you need help, you can refer to :"
"ref:`how to install Django with pip<installing-official-release>`. You can "
"install ``setuptools`` the same way."
msgstr ""
"Python  패키징의 현재 상태는 다양한 도구들로 인해 약간 혼란스럽습니다. 이 튜"
"토리얼에서는 패키지를 빌드하는데 :pypi:`setuptools`을 사용할 것입니다. 권장 "
"패키징 도구(``distribute`` 포크와 병합된)입니다. 설치하고 삭제하기 위해 :"
"pypi:`pip`을 사용할 것입니다. 당신은 이제 두 패키지를 설치해야합니다. 도움이 "
"필요하면 :ref:` pip로 Django 설치하는 법 <installing-official-release>`.을 참"
"조할 수 있습니다. 같은 방법으로  ``setuptools``도 설치할 수 있습니다. "

msgid "Packaging your app"
msgstr "앱 패키징하기"

msgid ""
"Python *packaging* refers to preparing your app in a specific format that "
"can be easily installed and used. Django itself is packaged very much like "
"this. For a small app like polls, this process isn't too difficult."
msgstr ""
"파이썬 *패키징* 은 쉽게 설치하고 사용할 수 있는 특별한 형식으로 앱을 준비하"
"는 것을 의미합니다. 장고 자체도 이와 같이 패키지화되어 있습니다. 설문조사처"
"럼 작은 앱은 이 과정이 어렵지 않습니다."

msgid ""
"First, create a parent directory for ``polls``, outside of your Django "
"project. Call this directory ``django-polls``."
msgstr ""
"먼저, Django 프로젝트 외부에 ``polls`` 의 상위 디렉토리를 만듭니다. 이 디렉토"
"리를 ``django-polls``\\ 라 부르겠습니다."

msgid "Choosing a name for your app"
msgstr "앱 이름 선택"

msgid ""
"When choosing a name for your package, check resources like PyPI to avoid "
"naming conflicts with existing packages. It's often useful to prepend "
"``django-`` to your module name when creating a package to distribute. This "
"helps others looking for Django apps identify your app as Django specific."
msgstr ""
"패키지 이름을 선택할 때, 기존 패키지들과 충돌을 피하기 위해 PyPI 같은 리소스"
"들을 점검하세요.  배포할 패키지를 생성할 때, 모듈 이름 앞에 ``django-`` 를 앞"
"에 붙이는 것이 좋습니다. 이러면 Django 앱을 찾는 다른 사용자가 여러분의 앱을 "
"Django 고유 앱으로 인식하는데 도움이 됩니다."

msgid ""
"Application labels (that is, the final part of the dotted path to "
"application packages) *must* be unique in :setting:`INSTALLED_APPS`. Avoid "
"using the same label as any of the Django :doc:`contrib packages </ref/"
"contrib/index>`, for example ``auth``, ``admin``, or ``messages``."
msgstr ""
"어플리케이션 라벨(즉, 애플리케이션 패키지 경로의 마지막 부분)은 :setting:"
"`INSTALLED_APPS`\\에서 *유일한* 것이어야 합니다. ``auth``, ``admin``, "
"``messages`` 같은 Django :doc:`contrib 패키지 </ref/contrib/index>`\\와 동일"
"한 라벨을 사용하지 마세요."

msgid "Move the ``polls`` directory into the ``django-polls`` directory."
msgstr "``django-polls`` 디렉토리의 ``polls`` 디렉토리로 이동하세요. "

msgid "Create a file ``django-polls/README.rst`` with the following contents:"
msgstr "다음과 같은 내용으로 ``django-polls/README.rst``\\ 를 생성합니다:"

msgid "``django-polls/README.rst``"
msgstr "``django-polls/README.rst``"

msgid ""
"Create a ``django-polls/LICENSE`` file. Choosing a license is beyond the "
"scope of this tutorial, but suffice it to say that code released publicly "
"without a license is *useless*. Django and many Django-compatible apps are "
"distributed under the BSD license; however, you're free to pick your own "
"license. Just be aware that your licensing choice will affect who is able to "
"use your code."
msgstr ""
"``django-polls/LICENSE`` 파일을 생성합니다. 라이선스 선택은 이 튜토리얼의 범"
"위를 벗어나므로, 라이선스 없이 공개된 코드는 *쓸모없음* 을 의미한다는 것만 말"
"해두겠습니다.  Django와 많은 Django 호환 앱들이 BSD 라이센스로 배포되고 있습"
"니다; 그러나 자신의 라이센스를 자유롭게 선택할 수 있습니다. 라이선스 선택이 "
"누군가 여러분의 코드를 사용하는데 영향이 미칠수 있다는 사실은 알고 있어야합니"
"다."

msgid ""
"Next we'll create ``pyproject.toml``, ``setup.cfg``, and ``setup.py`` files "
"which detail how to build and install the app. A full explanation of these "
"files is beyond the scope of this tutorial, but the `setuptools "
"documentation <https://setuptools.pypa.io/en/latest/>`_ has a good "
"explanation. Create the ``django-polls/pyproject.toml``, ``django-polls/"
"setup.cfg``, and ``django-polls/setup.py`` files with the following contents:"
msgstr ""
"이제 앱을 빌드하고 설치하는 방법을 자세히 설명하는 ``pyproject.toml``, "
"``setup.cfg``, ``setup.py`` 파일을 만들 것입니다. 이 파일에 대한 상세 설명은 "
"해당 튜토리얼의 범위에서 벗어나지만, `setuptools documentation <https://"
"setuptools.readthedocs.io/en/latest/>`_ 에 잘 설명되어 있습니다. 다음 내용을 "
"참고하여 ``django-polls/pyproject.toml``, ``django-polls/setup.cfg``, "
"``django-polls/setup.py`` 파일을 만드세요."

msgid "``django-polls/pyproject.toml``"
msgstr "``django-polls/pyproject.toml``"

msgid "``django-polls/setup.cfg``"
msgstr "``django-polls/setup.cfg``"

msgid "``django-polls/setup.py``"
msgstr "``django-polls/setup.py``"

msgid ""
"Only Python modules and packages are included in the package by default. To "
"include additional files, we'll need to create a ``MANIFEST.in`` file. The "
"``setuptools`` docs referred to in the previous step discuss this file in "
"more detail. To include the templates, the ``README.rst`` and our "
"``LICENSE`` file, create a file ``django-polls/MANIFEST.in`` with the "
"following contents:"
msgstr ""

msgid "``django-polls/MANIFEST.in``"
msgstr "``django-polls/MANIFEST.in``"

msgid ""
"It's optional, but recommended, to include detailed documentation with your "
"app. Create an empty directory ``django-polls/docs`` for future "
"documentation. Add an additional line to ``django-polls/MANIFEST.in``:"
msgstr ""
"선택사항이지만 앱에 세부 문서를 포함시키는 것을 권장합니다. 나중에 문서를 위"
"해 빈 디렉토리 ``django-polls/docs`` 를 생성하십시오. ``django-polls/"
"MANIFEST.in``에 다음 한줄을 추가하십시오."

msgid ""
"Note that the ``docs`` directory won't be included in your package unless "
"you add some files to it. Many Django apps also provide their documentation "
"online through sites like `readthedocs.org <https://readthedocs.org>`_."
msgstr ""
"파일을 추가하지 않으면 ``docs`` 디렉토리는 패키지에 포함되지 않을 것입니다. "
"많은 Django 앱들이 `readthedocs.org <https://readthedocs.org>`_ 같은 사이트들"
"을 통해 온라인 문서를 제공합니다. "

msgid ""
"Try building your package with ``python setup.py sdist`` (run from inside "
"``django-polls``). This creates a directory called ``dist`` and builds your "
"new package, ``django-polls-0.1.tar.gz``."
msgstr ""
"``python setup.py sdist`` 로 패키지를 빌드해보세요 (``django-polls`` 내에서 "
"실행). 이 명령은 ``dist`` 디렉토리를 생성하고, 새 패키지  ``django-polls-0.1."
"tar.gz`` 를 빌드합니다. "

msgid ""
"For more information on packaging, see Python's `Tutorial on Packaging and "
"Distributing Projects <https://packaging.python.org/tutorials/packaging-"
"projects/>`_."
msgstr ""
"패키징에 관한 더 자세한 정보는 파이썬의 `프로젝트 패키징 및 배포에 관한 튜토"
"리얼 <https://packaging.python.org/distributing/>`_을 참조하십시오."

msgid "Using your own package"
msgstr "여러분의 패키지 사용하기"

msgid ""
"Since we moved the ``polls`` directory out of the project, it's no longer "
"working. We'll now fix this by installing our new ``django-polls`` package."
msgstr ""
"우리가 ``polls`` 디렉토리를 프로젝트 바깥으로 이동했으므로, 작동하지 않을것입"
"니다. 우리의 새 ``django-polls`` 패키지를 설치하여 이 문제를 해결할 것입니다."

msgid "Installing as a user library"
msgstr "유저 라이브러리 설치하기"

msgid ""
"The following steps install ``django-polls`` as a user library. Per-user "
"installs have a lot of advantages over installing the package system-wide, "
"such as being usable on systems where you don't have administrator access as "
"well as preventing the package from affecting system services and other "
"users of the machine."
msgstr ""
"다음 단계는 ``django-polls`` 를 사용자 라이브러리로 설치합니다. 사용자 단위 "
"설치는  관리자권한 접근이 안되는 시스템 뿐만아니라 시스템 서비스나 다른 사용"
"자들의 영향으로부터 패키지를 보호하는 것 같은 이점이 많습니다."

msgid ""
"Note that per-user installations can still affect the behavior of system "
"tools that run as that user, so using a virtual environment is a more robust "
"solution (see below)."
msgstr ""
"사용자별 설치는 여전히 해당 사용자로 실행되는 시스템 도구의 동작에 영향을 미"
"칠 수 있으므로 가상 환경을 사용하는 것이 더 강력한 해결 방법입니다(아래 참"
"조)."

msgid ""
"To install the package, use pip (you already :ref:`installed it <installing-"
"reusable-apps-prerequisites>`, right?):"
msgstr ""
"패키지를 설치하기 위해 pip를 사용하세요 (당신은 이미 :ref:`설치하였습니다."
"<installing-reusable-apps-prerequisites>` 그렇죠?),"

msgid ""
"With luck, your Django project should now work correctly again. Run the "
"server again to confirm this."
msgstr ""
"운이 따라준다면, 여러분의 Django 프로젝트는 이제 잘 작동할 것입니다. 확인해보"
"기위해 서버를 다시 실행하세요."

msgid "To uninstall the package, use pip:"
msgstr "패키지를 삭제하기 위해 pip를 사용하시오."

msgid "Publishing your app"
msgstr "앱 퍼블리싱"

msgid ""
"Now that we've packaged and tested ``django-polls``, it's ready to share "
"with the world! If this wasn't just an example, you could now:"
msgstr ""
"우리는 ``django-polls`` 를 패키지화하고 테스트했기에, 세계와 공유할 준비가 되"
"었습니다. 단순한 예제가 아니면, 여러분은 이제 아래와 같은 것들을 할 수 있습니"
"다:"

msgid "Email the package to a friend."
msgstr "친구에게 패키지를 이메일로 보내기"

msgid "Upload the package on your website."
msgstr "웹사이트에 패키지 업로드"

msgid ""
"Post the package on a public repository, such as `the Python Package Index "
"(PyPI)`_. `packaging.python.org <https://packaging.python.org>`_ has `a good "
"tutorial <https://packaging.python.org/tutorials/packaging-projects/"
"#uploading-the-distribution-archives>`_ for doing this."
msgstr ""
"`the Python Package Index (PyPI)`_\\ 와 같은 공용 저장소에 패키지를 게시하십"
"시오. `packaging.python.org <https://packaging.python.org>`_\\ 에는 앱 퍼플리"
"싱을 위한  `좋은 튜토리얼 <https://packaging.python.org/tutorials/packaging-"
"projects/#uploading-the-distribution-archives>`_\\ 이 있습니다."

msgid "Installing Python packages with a virtual environment"
msgstr "파이썬 패키지를 가상 환경으로 설치하기"

msgid ""
"Earlier, we installed the polls app as a user library. This has some "
"disadvantages:"
msgstr ""
"앞에서, 우리는 설문 조사 앱을 사용자 라이브러리로 설치했습니다. 여기에는 몇 "
"가지 단점이 있습니다:"

msgid ""
"Modifying the user libraries can affect other Python software on your system."
msgstr ""
"사용자 라이브러리를 수정하면 시스템의 다른 파이썬 소프트웨어에 영향을 미칠 "
"수 있습니다."

msgid ""
"You won't be able to run multiple versions of this package (or others with "
"the same name)."
msgstr ""
"이 패키지의 여러 버전 (또는 이름이 같은 다른 버전)을 실행할 수 없습니다."

msgid ""
"Typically, these situations only arise once you're maintaining several "
"Django projects. When they do, the best solution is to use :doc:`venv "
"<python:tutorial/venv>`. This tool allows you to maintain multiple isolated "
"Python environments, each with its own copy of the libraries and package "
"namespace."
msgstr ""
"일반적으로 이러한 상황들은 여러 Django 프로젝트를 유지보수할 때만 발생합니"
"다. 이러한 경우, 최선의 해결책은 :doc:`venv <python:tutorial/venv>`를 사용하"
"는 것입니다. 이 도구를 사용하면 각각 고유한 라이브러리 및 패키지 네임스페이"
"스 복사본이 있는 다수의 분리된 Python 환경을 유지할 수 있습니다."

msgid "Writing your first Django app, part 1"
msgstr "첫 번째 장고 앱 작성하기, part 1"

msgid "Let's learn by example."
msgstr "예제로 배워봅시다."

msgid ""
"Throughout this tutorial, we'll walk you through the creation of a basic "
"poll application."
msgstr ""
"이 튜토리얼을 통해, 간단한 설문조사(Polls) 어플리케이션을 만드는 과정을 따라"
"해 보겠습니다."

msgid "It'll consist of two parts:"
msgstr "두 파트로 구성되어 있습니다."

msgid "A public site that lets people view polls and vote in them."
msgstr "사람들이 설문 내용을 보고 직접 투표할 수 있는 개방된 사이트"

msgid "An admin site that lets you add, change, and delete polls."
msgstr "관리자가 설문을 추가, 변경, 삭제할 수 있는 관리용 사이트"

msgid ""
"We'll assume you have :doc:`Django installed </intro/install>` already. You "
"can tell Django is installed and which version by running the following "
"command in a shell prompt (indicated by the $ prefix):"
msgstr ""
":doc:`Django 설치 </intro/install>`\\가 되어 있다고 가정합니다. 쉘 프롬프트 "
"($ 접두사로 표시)에서 다음 명령을 실행하여 Django가 설치되어 있고 어떤 버전인"
"지 알 수 있습니다."

msgid ""
"If Django is installed, you should see the version of your installation. If "
"it isn't, you'll get an error telling \"No module named django\"."
msgstr ""
"Django가 설치 되었다면, 설치된 Django의 버전을 확인할 수 있습니다. 만약 설치"
"가 제대로 되지 않았다면, \"No module named django\"와 같은 에러가 발생합니다."

msgid ""
"This tutorial is written for Django |version|, which supports Python 3.8 and "
"later. If the Django version doesn't match, you can refer to the tutorial "
"for your version of Django by using the version switcher at the bottom right "
"corner of this page, or update Django to the newest version. If you're using "
"an older version of Python, check :ref:`faq-python-version-support` to find "
"a compatible version of Django."
msgstr ""
"이 튜토리얼은 Django |version| 을 위해 작성된 것으로, Python 3.8 혹은 이후의 "
"버전을 지원합니다. 사용하시는 Django 의 버전이 다른 경우에는, 현재 페이지 오"
"른쪽 아래에 있는 버전 변경 기능을 이용하여 현재 사용하는 Django 버전에 맞는 "
"튜토리얼을 참조하거나 Django 를 최신 버전으로 업데이트할 수 있습니다. 이전 버"
"전의 Python을 사용중인 경우는 `faq-python-version-support` 에서 호환되는 "
"Django 버전을 확인하십시오."

msgid ""
"See :doc:`How to install Django </topics/install>` for advice on how to "
"remove older versions of Django and install a newer one."
msgstr ""
"예전 버전의 Django를 제거하고 새로운 버전의 Django를 설치하는 방법은 :doc:"
"`Django 설치하기 </topics/install>`\\를 참조하세요."

msgid ""
"If you're having trouble going through this tutorial, please head over to "
"the :doc:`Getting Help</faq/help>` section of the FAQ."
msgstr ""
"이 튜토리얼을 수행하는 데 문제가 있는 경우 FAQ 섹션인 :doc:`Getting Help </"
"faq/help>`으로 이동하십시오."

msgid "Creating a project"
msgstr "프로젝트 만들기"

msgid ""
"If this is your first time using Django, you'll have to take care of some "
"initial setup. Namely, you'll need to auto-generate some code that "
"establishes a Django :term:`project` -- a collection of settings for an "
"instance of Django, including database configuration, Django-specific "
"options and application-specific settings."
msgstr ""
"Django를 처음 사용한다면, 초기 설정에 주의를 기울여야 합니다. Django :term:"
"`project`\\를 구성하는 코드를 자동 생성해야 하는데, 이 과정에서 데이터베이스 "
"설정, Django 위한 옵션들, 어플리케이션을 위한 설정들과 같은 Django 인스턴스"
"를 구성하는 수많은 설정들이 생성되기 때문입니다."

msgid ""
"From the command line, ``cd`` into a directory where you'd like to store "
"your code, then run the following command:"
msgstr ""
"커맨드라인에서 ``cd`` 명령으로 코드를 저장할 디렉토리로 이동 한 후, 다음의 명"
"령을 수행합니다."

msgid ""
"This will create a ``mysite`` directory in your current directory. If it "
"didn't work, see :ref:`troubleshooting-django-admin`."
msgstr ""
"이 명령은 현재 디렉토리에서 ``mysite``\\라는 디렉토리를 생성할 것입니다. 만"
"약 이 명령이 동작하지 않는다면, :ref:`troubleshooting-django-admin`\\를 확인"
"하세요."

msgid ""
"You'll need to avoid naming projects after built-in Python or Django "
"components. In particular, this means you should avoid using names like "
"``django`` (which will conflict with Django itself) or ``test`` (which "
"conflicts with a built-in Python package)."
msgstr ""
"프로젝트를 생성할 때, Python 또는 Django에서 사용 중인 이름은 피해야 합니다. "
"특히, ``django``\\ (Django 그 자체와 충돌이 일어납니다)나, ``test``\\ "
"(Python 패키지의 이름중 하나입니다) 같은 이름은 피해야 한다는 의미입니다."

msgid "Where should this code live?"
msgstr "코드가 어디에서 서비스 되어야 할까요?"

msgid ""
"If your background is in plain old PHP (with no use of modern frameworks), "
"you're probably used to putting code under the web server's document root "
"(in a place such as ``/var/www``). With Django, you don't do that. It's not "
"a good idea to put any of this Python code within your web server's document "
"root, because it risks the possibility that people may be able to view your "
"code over the web. That's not good for security."
msgstr ""
"과거의 PHP 를 작성해본 경험이 있다면(최근의 프레임워크가 아닌) 아마 코드 전체"
"를 (``/var/www`` 같은) 웹 서버의 최상단 문서에 넣는 것에 익숙할 것입니다. "
"Django 에서는 그렇게 하지 마십시오. Python 코드가 웹 서버의 최상단 문서에 존"
"재하는것은 좋은 생각이 아닙니다. 왜냐하면 사람들이 웹을 통해 당신의 코드를 "
"볼 수 있을 가능성이 있기 때문입니다. 그건 보안에 좋지 않습니다."

msgid ""
"Put your code in some directory **outside** of the document root, such as :"
"file:`/home/mycode`."
msgstr ""
"작성한 코드를 :file:`/home/mycode` 와 같은 DocumentRoot 의 **바깥에** 두는것"
"을 권합니다."

msgid "Let's look at what :djadmin:`startproject` created:"
msgstr ":djadmin:`startproject`에서 무엇이 생성되는지 확인해 봅시다."

msgid "These files are:"
msgstr "이 파일들은,"

msgid ""
"The outer :file:`mysite/` root directory is a container for your project. "
"Its name doesn't matter to Django; you can rename it to anything you like."
msgstr ""
"file:`mysite/` 디렉토리 밖은 프로젝트를 담는 공간입니다. 그 이름은 Django 와 "
"아무 상관이 없으니, 원하는 이름으로 변경해도 됩니다."

msgid ""
":file:`manage.py`: A command-line utility that lets you interact with this "
"Django project in various ways. You can read all the details about :file:"
"`manage.py` in :doc:`/ref/django-admin`."
msgstr ""
":file:`manage.py`: Django 프로젝트와 다양한 방법으로 상호작용 하는 커맨드라인"
"의 유틸리티 입니다. :file:`manage.py` 에 대한 자세한 정보는 :doc:`/ref/"
"django-admin` 에서 확인할 수 있습니다."

msgid ""
"The inner :file:`mysite/` directory is the actual Python package for your "
"project. Its name is the Python package name you'll need to use to import "
"anything inside it (e.g. ``mysite.urls``)."
msgstr ""
":file:`mysite/` 디렉토리 내부에는 프로젝트를 위한 실제 Python 패키지들이 저장"
"됩니다. 이 디렉토리 내의 이름을 이용하여, (``mysite.urls`` 와 같은 식으로) 프"
"로젝트의 어디서나 Python 패키지들을 임포트할 수 있습니다. "

msgid ""
":file:`mysite/__init__.py`: An empty file that tells Python that this "
"directory should be considered a Python package. If you're a Python "
"beginner, read :ref:`more about packages <tut-packages>` in the official "
"Python docs."
msgstr ""
":file:`mysite/__init__.py`: Python으로 하여금 이 디렉토리를 패키지처럼 다루라"
"고 알려주는 용도의 단순한 빈 파일입니다. Python 초심자라면, Python 공식 홈페"
"이지의 :ref:`패키지 <tut-packages>`\\를 읽어보세요. "

msgid ""
":file:`mysite/settings.py`: Settings/configuration for this Django "
"project.  :doc:`/topics/settings` will tell you all about how settings work."
msgstr ""
":file:`mysite/settings.py`: 현재 Django 프로젝트의 환경 및 구성을 저장합니"
"다. :doc:`/topics/settings`\\에서 환경 설정이 어떻게 동작하는지 확인할 수 있"
"습니다."

msgid ""
":file:`mysite/urls.py`: The URL declarations for this Django project; a "
"\"table of contents\" of your Django-powered site. You can read more about "
"URLs in :doc:`/topics/http/urls`."
msgstr ""
":file:`mysite/urls.py`: 현재 Django project 의 URL 선언을 저장합니다. Django "
"로 작성된 사이트의 \"목차\" 라고 할 수 있습니다. :doc:`/topics/http/urls` 에"
"서 URL 에 대한 자세한 내용을 읽어보세요."

msgid ""
":file:`mysite/asgi.py`: An entry-point for ASGI-compatible web servers to "
"serve your project. See :doc:`/howto/deployment/asgi/index` for more details."
msgstr ""
":file:`mysite/asgi.py`: 현재 프로젝트를 서비스하기 위한 ASGI-호환 웹 서버의 "
"진입점입니다. 자세한 내용은 :doc:`/howto/deployment/asgi/index` 를 참조하십시"
"오."

msgid ""
":file:`mysite/wsgi.py`: An entry-point for WSGI-compatible web servers to "
"serve your project. See :doc:`/howto/deployment/wsgi/index` for more details."
msgstr ""
":file:`mysite/wsgi.py`: 현재 프로젝트를 서비스하기 위한 WSGI 호환 웹 서버의 "
"진입점입니다. :doc:`/howto/deployment/wsgi/index`\\를 읽어보세요."

msgid "The development server"
msgstr "개발 서버"

msgid ""
"Let's verify your Django project works. Change into the outer :file:`mysite` "
"directory, if you haven't already, and run the following commands:"
msgstr ""
"당신의 Django 프로젝트가 제대로 동작하는지 확인해 봅시다. :file:`mysite` 디렉"
"토리로 이동하고, 다음 명령어를 입력하세요."

msgid "You'll see the following output on the command line:"
msgstr "커맨드라인에서 다음과 같은 출력을 볼 수 있습니다."

msgid ""
"Ignore the warning about unapplied database migrations for now; we'll deal "
"with the database shortly."
msgstr ""
"현재 데이터베이스에 적용되지 않은 변경사항들(migrations)에 대한 경고들은 무시"
"해도 됩니다. 데이터베이스에 대한 부분은 간단히 다루도록 하겠습니다."

msgid ""
"You've started the Django development server, a lightweight web server "
"written purely in Python. We've included this with Django so you can develop "
"things rapidly, without having to deal with configuring a production server "
"-- such as Apache -- until you're ready for production."
msgstr ""
"Django 개발 서버를 시작했습니다. 개발 서버는 순수 Python으로 작성된 경량 웹 "
"서버입니다. 운영 준비가 될 때까지 Apache와 같은 운영 서버를 구성할 필요 없이 "
"신속하게 개발할 수 있도록 Django에 포함했습니다."

msgid ""
"Now's a good time to note: **don't** use this server in anything resembling "
"a production environment. It's intended only for use while developing. "
"(We're in the business of making web frameworks, not web servers.)"
msgstr ""
"이쯤에서 하나 기억할 것이 있습니다. 이 서버를 운영 환경과 유사한 환경에서 **"
"사용하지 마십시오.** 개발 중에만 사용할 수 있도록 되어 있습니다. (우리는 웹 "
"서버가 아닌 웹 프레임워크를 만드는 사업을 하고 있습니다.)"

msgid ""
"Now that the server's running, visit http://127.0.0.1:8000/ with your web "
"browser. You'll see a \"Congratulations!\" page, with a rocket taking off. "
"It worked!"
msgstr ""
"이제 서버가 실행 중이니 웹 브라우저의 http://127.0.0.1:8000/ 를 통해 접속할 "
"수 있습니다. 여러분은 로켓이 이륙하는 \"Congratulations!\" 페이지가 보일 것입"
"니다. 잘 동작하네요!"

msgid "Changing the port"
msgstr "포트 변경하기"

msgid ""
"By default, the :djadmin:`runserver` command starts the development server "
"on the internal IP at port 8000."
msgstr ""
"기본적으로, :djadmin:`runserver` 명령은 내부 IP 의 8000 번 포트로 개발 서버"
"를 띄웁니다."

msgid ""
"If you want to change the server's port, pass it as a command-line argument. "
"For instance, this command starts the server on port 8080:"
msgstr ""
"만약 이 서버의 포트를 변경하고 싶다면, 커맨드라인에서 인수를 전달해주면 됩니"
"다. 예를들어, 이 명령은 포트를 8080 으로 서버를 시작할 것입니다."

msgid ""
"If you want to change the server's IP, pass it along with the port. For "
"example, to listen on all available public IPs (which is useful if you are "
"running Vagrant or want to show off your work on other computers on the "
"network), use:"
msgstr ""
"서버의 IP를 변경하려면 포트와 함께 전달하십시오. 예를 들어, 사용 가능한 모든 "
"공용 IP를 청취하려면 (이는 Vagrant를 실행 중이거나 네트워크의 다른 컴퓨터에"
"서 작업하고 싶을 때 유용합니다) 다음을 사용하십시오."

msgid ""
"Full docs for the development server can be found in the :djadmin:"
"`runserver` reference."
msgstr "개발 서버에 대한 자세한 내용은 :djadmin:`runserver` 를 참조하세요."

msgid "Automatic reloading of :djadmin:`runserver`"
msgstr ":djadmin:`runserver` 의 자동 변경 기능"

msgid ""
"The development server automatically reloads Python code for each request as "
"needed. You don't need to restart the server for code changes to take "
"effect. However, some actions like adding files don't trigger a restart, so "
"you'll have to restart the server in these cases."
msgstr ""
"개발 서버는 요청이 들어올 때마다 자동으로 Python 코드를 다시 불러옵니다. 코드"
"의 변경사항을 반영하기 위해서 굳이 서버를 재기동 하지 않아도 됩니다. 그러나, "
"파일을 추가하는 등의 몇몇의 동작은 개발서버가 자동으로 인식하지 못하기 때문"
"에, 이런 상황에서는 서버를 재기동 해야 적용됩니다."

msgid "Creating the Polls app"
msgstr "설문조사 앱 만들기"

msgid ""
"Now that your environment -- a \"project\" -- is set up, you're set to start "
"doing work."
msgstr "이제, 작업을 시작하기 위해 당신의 환경(프로젝트)이 설치되었습니다."

msgid ""
"Each application you write in Django consists of a Python package that "
"follows a certain convention. Django comes with a utility that automatically "
"generates the basic directory structure of an app, so you can focus on "
"writing code rather than creating directories."
msgstr ""
"Django에서 당신이 작성하는 각 어플리케이션들은 다음과 같은 관례로 Python 패키"
"지가 구성됩니다. Django 는 앱(app) 의 기본 디렉토리 구조를 자동으로 생성할 "
"수 있는 도구를 제공하기 때문에, 코드에만 더욱 집중할 수 있습니다."

msgid "Projects vs. apps"
msgstr "프로젝트 대 앱"

msgid ""
"What's the difference between a project and an app? An app is a web "
"application that does something -- e.g., a blog system, a database of public "
"records or a small poll app. A project is a collection of configuration and "
"apps for a particular website. A project can contain multiple apps. An app "
"can be in multiple projects."
msgstr ""
"프로젝트와 앱은 무엇이 다를까요? 앱은 블로그 시스템, 공개 기록 데이터베이스 "
"또는 소규모 의견조사 앱과 같은 작업을 수행하는 웹 애플리케이션입니다. 프로젝"
"트는 특정 웹 사이트에 대한 구성 및 앱의 모음입니다. 한 프로젝트에 여러 개의 "
"앱이 포함될 수 있습니다. 앱은 여러 프로젝트에 있을 수 있습니다."

msgid ""
"Your apps can live anywhere on your :ref:`Python path <tut-searchpath>`. In "
"this tutorial, we'll create our poll app in the same directory as your :file:"
"`manage.py` file so that it can be imported as its own top-level module, "
"rather than a submodule of ``mysite``."
msgstr ""
"당신의 앱은 :ref:`Python path <tut-searchpath>`의 모든 위치에서 사용할 수 있"
"습니다. 이 튜토리얼에서는 :file:`manage.py` 와 동일한 디렉터리에 의견조사 앱"
"을 만들어서 파일을 ``mysite``.의 하위 모듈이 아닌 자체 최상위 모듈로 가져올 "
"수 있습니다."

msgid ""
"To create your app, make sure you're in the same directory as :file:`manage."
"py` and type this command:"
msgstr ""
"앱을 생성하기 위해 :file:`manage.py`\\가 존재하는 디렉토리에서 다음의 명령을 "
"입력해 봅시다."

msgid "That'll create a directory :file:`polls`, which is laid out like this:"
msgstr ""
"그러면 디렉토리 :file:`polls`가 생성되며, 이 디렉토리는 다음과 같이 배치됩니"
"다."

msgid "This directory structure will house the poll application."
msgstr "이 디렉토리 구조는 투표 어플리케이션의 집이 되어줄 것입니다."

msgid "Write your first view"
msgstr "첫 번째 뷰 작성하기"

msgid ""
"Let's write the first view. Open the file ``polls/views.py`` and put the "
"following Python code in it:"
msgstr ""
"첫 번째 뷰를 작성해봅시다. \"polls/view.py\"를 열어 다음과 같은 파이썬 코드"
"를 입력합니다"

msgid "``polls/views.py``"
msgstr "``polls/views.py``"

msgid ""
"This is the simplest view possible in Django. To call the view, we need to "
"map it to a URL - and for this we need a URLconf."
msgstr ""
"Django에서 가장 간단한 형태의 뷰입니다. 뷰를 호출하려면 이와 연결된 URL 이 있"
"어야 하는데, 이를 위해 URLconf가 사용됩니다."

msgid ""
"To create a URLconf in the polls directory, create a file called ``urls."
"py``. Your app directory should now look like:"
msgstr ""
"polls 디렉토리에서 URLconf를 생성하려면  ``urls.py``라는 파일을 생성해야 합니"
"다. 이제 당신의 앱 디렉토리는 다음과 같이 보일 겁니다."

msgid "In the ``polls/urls.py`` file include the following code:"
msgstr "\"polls/urls.py\" 파일에는 다음과 같은 코드가 포함되어 있습니다."

msgid "``polls/urls.py``"
msgstr "``polls/urls.py``"

msgid ""
"The next step is to point the root URLconf at the ``polls.urls`` module. In "
"``mysite/urls.py``, add an import for ``django.urls.include`` and insert an :"
"func:`~django.urls.include` in the ``urlpatterns`` list, so you have:"
msgstr ""
"다음 단계는, 최상위 URLconf 에서 ``polls.urls`` 모듈을 바라보게 설정합니다. "
"``mysite/urls.py`` 파일을 열고, ``django.urls.include``\\를 import 하고, "
"``urlpatterns`` 리스트에 :func:`~django.urls.include` 함수를 다음과 같이 추가"
"합니다."

msgid "``mysite/urls.py``"
msgstr "``mysite/urls.py``"

msgid ""
"The :func:`~django.urls.include` function allows referencing other URLconfs. "
"Whenever Django encounters :func:`~django.urls.include`, it chops off "
"whatever part of the URL matched up to that point and sends the remaining "
"string to the included URLconf for further processing."
msgstr ""
":func:`~django.urls.include` 함수는 다른 URLconf들을 참조할 수 있도록 도와줍"
"니다. Django가 함수 :func:`~django.urls.include`\\를 만나게 되면, URL의 그 시"
"점까지 일치하는 부분을 잘라내고, 남은 문자열 부분을 후속 처리를 위해 include "
"된 URLconf로 전달합니다."

msgid ""
"The idea behind :func:`~django.urls.include` is to make it easy to plug-and-"
"play URLs. Since polls are in their own URLconf (``polls/urls.py``), they "
"can be placed under \"/polls/\", or under \"/fun_polls/\", or under \"/"
"content/polls/\", or any other path root, and the app will still work."
msgstr ""
":func:`~django.urls.include`\\에 숨은 아이디어 덕분에 URL을 쉽게 연결할 수 있"
"습니다. polls 앱에 그 자체의 URLconf(``polls/urls.py``)가 존재하는 한, \"/"
"polls/\", 또는 \"/fun_polls/\", \"/content/polls/\"와 같은 경로, 또는 그 어"
"떤 다른 root 경로에 연결하더라도, 앱은 여전히 잘 동작할 것입니다."

msgid "When to use :func:`~django.urls.include()`"
msgstr "언제 :func:`~django.urls.include()`\\를 사용해야 하나요?"

msgid ""
"You should always use ``include()`` when you include other URL patterns. "
"``admin.site.urls`` is the only exception to this."
msgstr ""
"다른 URL 패턴을 포함할 때마다 항상 ``include()``\\를 사용해야 합니다. "
"``admin.site.urls``\\가 유일한 예외입니다."

msgid ""
"You have now wired an ``index`` view into the URLconf. Verify it's working "
"with the following command:"
msgstr ""
"이제 ``index`` 뷰가 URLconf에 연결되었습니다. 잘 작동하는지 확인하기 위해 다"
"음 명령을 입력해 보세요."

msgid ""
"Go to http://localhost:8000/polls/ in your browser, and you should see the "
"text \"*Hello, world. You're at the polls index.*\", which you defined in "
"the ``index`` view."
msgstr ""
"브라우저에서 http://localhost:8000/polls/\\를 입력하면 ``index`` 뷰에 정의한 "
"\"*Hello, world. You're at the polls index.*\" 가 보일 것입니다."

msgid "Page not found?"
msgstr "페이지가 보이지 않나요?"

msgid ""
"If you get an error page here, check that you're going to http://"
"localhost:8000/polls/ and not http://localhost:8000/."
msgstr ""
"에러 페이지가 표시된다면, http://localhost:8000/ 이 아니라 http://"
"localhost:8000/polls/가 정확히 주소 창에 입력되었는지 확인하세요."

msgid ""
"The :func:`~django.urls.path` function is passed four arguments, two "
"required: ``route`` and ``view``, and two optional: ``kwargs``, and "
"``name``. At this point, it's worth reviewing what these arguments are for."
msgstr ""
":func:`~django.urls.path` 함수에는 2개의 필수 인수인  ``route`` 와 ``view``, "
"2개의 선택 가능한 인수로 ``kwargs`` 와 ``name`` 까지 모두 4개의 인수가 전달 "
"되었습니다. 이 시점에서, 이 인수들이 무엇인지 살펴보는 것은 의미가 있습니다."

msgid ":func:`~django.urls.path` argument: ``route``"
msgstr ":func:`~django.urls.path` 인수: ``route``"

msgid ""
"``route`` is a string that contains a URL pattern. When processing a "
"request, Django starts at the first pattern in ``urlpatterns`` and makes its "
"way down the list, comparing the requested URL against each pattern until it "
"finds one that matches."
msgstr ""
"``route`` 는 URL 패턴을 가진 문자열 입니다.  요청이 처리될 때, Django 는 "
"``urlpatterns`` 의 첫 번째 패턴부터 시작하여, 일치하는 패턴을 찾을 때 까지 요"
"청된 URL 을 각 패턴과 리스트의 순서대로 비교합니다."

msgid ""
"Patterns don't search GET and POST parameters, or the domain name. For "
"example, in a request to ``https://www.example.com/myapp/``, the URLconf "
"will look for ``myapp/``. In a request to ``https://www.example.com/myapp/?"
"page=3``, the URLconf will also look for ``myapp/``."
msgstr ""
"패턴들은 GET 이나 POST 의 매개 변수들, 혹은 도메인 이름을 검색하지 않습니다. "
"예를 들어, ``https://www.example.com/myapp/`` 이 요청된 경우, URLconf 는 오"
"직 ``myapp/`` 부분만 바라 봅니다. ``https://www.example.com/myapp/?page=3``, "
"같은 요청에도, URLconf 는 역시 ``myapp/`` 부분만 신경씁니다."

msgid ":func:`~django.urls.path` argument: ``view``"
msgstr ":func:`~django.urls.path` 인수: ``view``"

msgid ""
"When Django finds a matching pattern, it calls the specified view function "
"with an :class:`~django.http.HttpRequest` object as the first argument and "
"any \"captured\" values from the route as keyword arguments. We'll give an "
"example of this in a bit."
msgstr ""
"Django 에서 일치하는 패턴을 찾으면, :class:`~django.http.HttpRequest` 객체를 "
"첫번째 인수로 하고, 경로로 부터 '캡처된' 값을 키워드 인수로하여 특정한 view "
"함수를 호출합니다. 나중에 이에 대한 간단한 예제를 살펴보겠습니다."

msgid ":func:`~django.urls.path` argument: ``kwargs``"
msgstr ":func:`~django.urls.path` 인수: ``kwargs``"

msgid ""
"Arbitrary keyword arguments can be passed in a dictionary to the target "
"view. We aren't going to use this feature of Django in the tutorial."
msgstr ""
"임의의 키워드 인수들은 목표한 view 에 사전형으로 전달됩니다. 그러나 이 튜토리"
"얼에서는 사용하지 않을겁니다."

msgid ":func:`~django.urls.path` argument: ``name``"
msgstr ":func:`~django.urls.path` 인수: ``name``"

msgid ""
"Naming your URL lets you refer to it unambiguously from elsewhere in Django, "
"especially from within templates. This powerful feature allows you to make "
"global changes to the URL patterns of your project while only touching a "
"single file."
msgstr ""
"URL 에 이름을 지으면, 템플릿을 포함한 Django 어디에서나 명확하게 참조할 수 있"
"습니다. 이 강력한 기능을 이용하여, 단 하나의 파일만 수정해도 project 내의 모"
"든 URL 패턴을 바꿀 수 있도록 도와줍니다."

msgid ""
"When you're comfortable with the basic request and response flow, read :doc:"
"`part 2 of this tutorial </intro/tutorial02>` to start working with the "
"database."
msgstr ""
"request 와 response 의 기본 흐름을 이해하셨다면, :doc:`튜토리얼 2장 </intro/"
"tutorial02>` 에서 데이터베이스 작업을 시작해보세요."

msgid "Writing your first Django app, part 2"
msgstr "첫 번째 장고 앱 작성하기, part 2"

msgid ""
"This tutorial begins where :doc:`Tutorial 1 </intro/tutorial01>` left off. "
"We'll set up the database, create your first model, and get a quick "
"introduction to Django's automatically-generated admin site."
msgstr ""
"이 튜토리얼은 :doc:`Tutorial 1 </intro/tutorial01>`\\에서 이어집니다. 데이터"
"베이스를 설치하고 첫 모델을 생성한 후, Django에서 자동 생성되는 관리자 사이트"
"에 대해 짧게 소개합니다."

msgid "Database setup"
msgstr "데이터베이스 설치"

msgid ""
"Now, open up :file:`mysite/settings.py`. It's a normal Python module with "
"module-level variables representing Django settings."
msgstr ""
"이제, :file:`mysite/settings.py` 파일을 열어보세요. 이 파일은 Django 설정을 "
"모듈 변수로 표현한 보통의 Python 모듈입니다. "

msgid ""
"By default, the configuration uses SQLite. If you're new to databases, or "
"you're just interested in trying Django, this is the easiest choice. SQLite "
"is included in Python, so you won't need to install anything else to support "
"your database. When starting your first real project, however, you may want "
"to use a more scalable database like PostgreSQL, to avoid database-switching "
"headaches down the road."
msgstr ""
"기본적으로는 SQLite을 사용하도록 구성되어 있습니다. 만약 데이터베이스를 처음 "
"경험해보거나, Django에서 데이터베이스를 한번 경험해 보고 싶다면, SQLite가 가"
"장 간단한 방법입니다. SQLite는 Python에서 기본으로 제공되기 때문에 별도로 설"
"치할 필요가 없습니다. 그러나 실제 프로젝트를 시작할 때에는, 나중에 데이터베이"
"스를 교체하느라 골치 아파질 일을 피하기 위해서라도 PostgreSQL 같이 좀 더 확장"
"성 있는 데이터베이스를 사용하는 것이 좋습니다."

msgid ""
"If you wish to use another database, install the appropriate :ref:`database "
"bindings <database-installation>` and change the following keys in the :"
"setting:`DATABASES` ``'default'`` item to match your database connection "
"settings:"
msgstr ""
"다른 데이터베이스를 사용해보고 싶다면, 적절한 :ref:`데이터베이스 바인딩 "
"<database-installation>`\\을 설치하고, 데이터베이스 연결 설정과 맞게끔 :"
"setting:`DATABASES` ``'default'`` 항목의 값을 다음의 키 값으로 바꿔주세요. "

msgid ""
":setting:`ENGINE <DATABASE-ENGINE>` -- Either ``'django.db.backends."
"sqlite3'``, ``'django.db.backends.postgresql'``, ``'django.db.backends."
"mysql'``, or ``'django.db.backends.oracle'``. Other backends are :ref:`also "
"available <third-party-notes>`."
msgstr ""
":setting:`ENGINE <DATABASE-ENGINE>` -- ``'django.db.backends.sqlite3'``, "
"``'django.db.backends.postgresql'``, ``'django.db.backends.mysql'``, 또는 "
"``'django.db.backends.oracle'``. 그외에 :ref:`서드파티 백엔드 <third-party-"
"notes>` 참조."

msgid ""
":setting:`NAME` -- The name of your database. If you're using SQLite, the "
"database will be a file on your computer; in that case, :setting:`NAME` "
"should be the full absolute path, including filename, of that file. The "
"default value, ``BASE_DIR / 'db.sqlite3'``, will store the file in your "
"project directory."
msgstr ""
":setting:`NAME` -- 데이터베이스의 이름입니다. SQLite를 사용하는 경우 데이터베"
"이스는 컴퓨터의 파일이 됩니다. 이 경우 :setting:`NAME`은 파일 이름을 포함한 "
"해당 파일의 전체 절대 경로여야 합니다. 기본값인 ``BASE_DIR / 'db.sqlite3'``"
"은 파일을 프로젝트 디렉토리에 저장합니다."

msgid ""
"If you are not using SQLite as your database, additional settings such as :"
"setting:`USER`, :setting:`PASSWORD`, and :setting:`HOST` must be added. For "
"more details, see the reference documentation for :setting:`DATABASES`."
msgstr ""
"SQLite 를 데이터베이스로 사용하지 않는 경우, :setting:`USER`, :setting:"
"`PASSWORD`, :setting:`HOST` 같은 추가 설정이 반드시 필요합니다. 더 자세한 내"
"용은 :setting:`DATABASES` 문서를 참조해 주세요."

msgid "For databases other than SQLite"
msgstr "SQLite 이외의 데이터베이스라면"

msgid ""
"If you're using a database besides SQLite, make sure you've created a "
"database by this point. Do that with \"``CREATE DATABASE database_name;``\" "
"within your database's interactive prompt."
msgstr ""
"만약 SQLite 이외의 데이터베이스를 사용하는 경우, 이 시점에서 데이터베이스를 "
"생성해야 합니다. 데이터베이스의 대화형 프롬프트 내에서 \"``CREATE DATABASE "
"database_name;``\" 명령을 실행하면 됩니다."

msgid ""
"Also make sure that the database user provided in :file:`mysite/settings.py` "
"has \"create database\" privileges. This allows automatic creation of a :ref:"
"`test database <the-test-database>` which will be needed in a later tutorial."
msgstr ""
"또한, :file:`mysite/settings.py` 에 설정된 데이터베이스 사용자가 \"create "
"database\" 권한이 있는지도 확인해 봐야 합니다. 튜토리얼을 진행하며 필요한 경"
"우 :ref:`테스트 데이터베이스 <the-test-database>`\\를 자동으로 생성할 수 있도"
"록 해줍니다."

msgid ""
"If you're using SQLite, you don't need to create anything beforehand - the "
"database file will be created automatically when it is needed."
msgstr ""
"SQLite를 사용한다면 아무것도 미리 생성할 필요가 없습니다. 데이터베이스 파일"
"은 필요할 때마다 자동으로 생성됩니다."

msgid ""
"While you're editing :file:`mysite/settings.py`, set :setting:`TIME_ZONE` to "
"your time zone."
msgstr ""
":file:`mysite/settings.py`\\를 편집할 때, 당신의 시간대에 맞춰 :setting:"
"`TIME_ZONE` 값을 설정하세요."

msgid ""
"Also, note the :setting:`INSTALLED_APPS` setting at the top of the file. "
"That holds the names of all Django applications that are activated in this "
"Django instance. Apps can be used in multiple projects, and you can package "
"and distribute them for use by others in their projects."
msgstr ""
"또한, 이 파일의 윗쪽에 있는 :setting:`INSTALLED_APPS` 에 대해 언급하자면, 이 "
"파일은 현재 Django 인스턴스에서 활성화된 모든 Django 어플리케이션들의 이름이 "
"담겨 있습니다. 앱들은 다수의 프로젝트에서 사용될 수 있고, 다른 프로젝트에서 "
"쉽게 사용될 수 있도록 패키징하여 배포할 수 있습니다."

msgid ""
"By default, :setting:`INSTALLED_APPS` contains the following apps, all of "
"which come with Django:"
msgstr ""
"기본적으로는, :setting:`INSTALLED_APPS`\\는 Django와 함께 딸려오는 다음의 앱"
"들을 포함합니다."

msgid ":mod:`django.contrib.admin` -- The admin site. You'll use it shortly."
msgstr ":mod:`django.contrib.admin` -- 관리용 사이트. 곧 사용하게 될 겁니다."

msgid ":mod:`django.contrib.auth` -- An authentication system."
msgstr ":mod:`django.contrib.auth` -- 인증 시스템."

msgid ":mod:`django.contrib.contenttypes` -- A framework for content types."
msgstr ":mod:`django.contrib.contenttypes` -- 컨텐츠 타입을 위한 프레임워크."

msgid ":mod:`django.contrib.sessions` -- A session framework."
msgstr ":mod:`django.contrib.sessions` -- 세션 프레임워크."

msgid ":mod:`django.contrib.messages` -- A messaging framework."
msgstr ":mod:`django.contrib.messages` -- 메세징 프레임워크."

msgid ""
":mod:`django.contrib.staticfiles` -- A framework for managing static files."
msgstr ":mod:`django.contrib.staticfiles` -- 정적 파일을 관리하는 프레임워크."

msgid ""
"These applications are included by default as a convenience for the common "
"case."
msgstr ""
"이 어플리케이션들은 일반적인 경우에 사용하기 편리하도록 기본으로 제공됩니다. "

msgid ""
"Some of these applications make use of at least one database table, though, "
"so we need to create the tables in the database before we can use them. To "
"do that, run the following command:"
msgstr ""
"이러한 기본 어플리케이션들 중 몇몇은 최소한 하나 이상의 데이터베이스 테이블"
"을 사용하는데, 그러기 위해서는 데이터베이스에서 테이블을 미리 만들 필요가 있"
"습니다. 이를 위해, 다음의 명령을 실행해봅시다."

msgid ""
"The :djadmin:`migrate` command looks at the :setting:`INSTALLED_APPS` "
"setting and creates any necessary database tables according to the database "
"settings in your :file:`mysite/settings.py` file and the database migrations "
"shipped with the app (we'll cover those later). You'll see a message for "
"each migration it applies. If you're interested, run the command-line client "
"for your database and type ``\\dt`` (PostgreSQL), ``SHOW TABLES;`` (MariaDB, "
"MySQL), ``.tables`` (SQLite), or ``SELECT TABLE_NAME FROM USER_TABLES;`` "
"(Oracle) to display the tables Django created."
msgstr ""
":djadmin:`migrate` 명령은 :setting:`INSTALLED_APPS` 의 설정을 탐색하여, :"
"file:`mysite/settings.py` 의 데이터베이스 설정과 app 과 함께 제공되는 "
"database migrations(나중에 다루겠습니다) 에 따라, 필요한 데이터베이스 테이블"
"을 생성합니다. 이 명령을 수행하면 각 migration 이 적용되는 메세지가 화면에 출"
"력되는 것을 확인할 수 있습니다. 어떤 내용이 생성되었는지 궁금하다면, 데이터베"
"이스 클라이언트로 접속한 후, ``\\dt`` (PostgreSQL), ``SHOW TABLES;`` "
"(MariaDB, MySQL), ``.tables`` (SQLite), ``SELECT TABLE_NAME FROM USER_TABLES;"
"`` (Oracle) 을 통해 Django 가 생성한 테이블을 확인해 볼 수 있습니다."

msgid "For the minimalists"
msgstr "최소주의자(minimalists)들을 위하여"

msgid ""
"Like we said above, the default applications are included for the common "
"case, but not everybody needs them. If you don't need any or all of them, "
"feel free to comment-out or delete the appropriate line(s) from :setting:"
"`INSTALLED_APPS` before running :djadmin:`migrate`. The :djadmin:`migrate` "
"command will only run migrations for apps in :setting:`INSTALLED_APPS`."
msgstr ""
"위에서 언급했다시피, 기본으로 제공되는 어플리케이션은 일반적인 상황을 염두에 "
"두었으나, 모두에게 필요한 것은 아닙니다. 만약 이것들이 필요 없다고 생각되시"
"면, :djadmin:`migrate` 를 실행하기 전에 :setting:`INSTALLED_APPS` 에서 제거"
"할 어플리케이션들을 그냥 주석처리(comment-out) 하시거나 삭제하시면 됩니다. :"
"djadmin:`migrate` 명령은 :setting:`INSTALLED_APPS` 에 등록된 어플리케이션에 "
"한하여 실행될 것입니다."

msgid "Creating models"
msgstr "모델 만들기"

msgid ""
"Now we'll define your models -- essentially, your database layout, with "
"additional metadata."
msgstr ""
"이제, 모델을 정의해 보겠습니다. 본질적으로, 모델이란 부가적인 메타데이터를 가"
"진 데이터베이스의 구조(layout)를 말합니다."

msgid "Philosophy"
msgstr "철학"

msgid ""
"A model is the single, definitive source of information about your data. It "
"contains the essential fields and behaviors of the data you're storing. "
"Django follows the :ref:`DRY Principle <dry>`. The goal is to define your "
"data model in one place and automatically derive things from it."
msgstr ""
"모델은 데이터에 대한 단 하나의 확실한 정보 출처입니다. 여기에는 저장 중인 데"
"이터의 필수 필드 및 동작이 포함됩니다. Django 는 :ref:`DRY Principle <dry>` "
"을 따릅니다. 목표는 데이터 모델을 한 곳에서 정의하고 데이터 모델을 자동으로 "
"파생하는 것입니다."

msgid ""
"This includes the migrations - unlike in Ruby On Rails, for example, "
"migrations are entirely derived from your models file, and are essentially a "
"history that Django can roll through to update your database schema to match "
"your current models."
msgstr ""
"여기에는 migration이 포함됩니다. 예를 들어, Ruby On Rails 와 달리 migration"
"은 모두 모델 파일에서 파생되며, 기본적으로 Django가 데이터베이스 스키마를 현"
"재의 모델에 도달할 수 있게 해주는 기록입니다. "

msgid ""
"In our poll app, we'll create two models: ``Question`` and ``Choice``. A "
"``Question`` has a question and a publication date. A ``Choice`` has two "
"fields: the text of the choice and a vote tally. Each ``Choice`` is "
"associated with a ``Question``."
msgstr ""
"여론조사 앱에서 ``Question`` 과 ``Choice``이라는 두 가지 모델을 만들 것입니"
"다. ``Question`` 에는 질문과 발행일을 위한 두 개의 필드를 가집니다. "
"``Choice`` 는 선택 텍스트와 투표 집계를 위한 두 개의 필드를 가집니다. 각각의 "
"``Choice``모델은  ``Question``과 연관됩니다."

msgid ""
"These concepts are represented by Python classes. Edit the :file:`polls/"
"models.py` file so it looks like this:"
msgstr ""
"이러한 개념은 Python 클래스로 표현됩니다. file:`polls/models.py` 파일을 다음"
"과 같이 수정하십시오."

msgid "``polls/models.py``"
msgstr "``polls/models.py``"

msgid ""
"Here, each model is represented by a class that subclasses :class:`django.db."
"models.Model`. Each model has a number of class variables, each of which "
"represents a database field in the model."
msgstr ""
"여기서 각 모델은 :class:`django.db.models.Model`의 하위 클래스로 표현됩니다. "
"모델마다 여러 클래스 변수가 있으며, 각 클래스 변수는 모델에서 데이터베이스 필"
"드를 나타냅니다."

msgid ""
"Each field is represented by an instance of a :class:`~django.db.models."
"Field` class -- e.g., :class:`~django.db.models.CharField` for character "
"fields and :class:`~django.db.models.DateTimeField` for datetimes. This "
"tells Django what type of data each field holds."
msgstr ""
"데이터베이스의 각 필드는 :class:`~django.db.models.Field` 클래스의 인스턴스로"
"서 표현됩니다. :class:`~django.db.models.CharField` 는 문자(character) 필드"
"를 표현하고, :class:`~django.db.models.DateTimeField` 는 날짜와 시간"
"(datetime) 필드를 표현합니다. 이것은 각 필드가 어떤 자료형을 가질 수 있는지"
"를 Django 에게 말해줍니다."

msgid ""
"The name of each :class:`~django.db.models.Field` instance (e.g. "
"``question_text`` or ``pub_date``) is the field's name, in machine-friendly "
"format. You'll use this value in your Python code, and your database will "
"use it as the column name."
msgstr ""
"각각의 :class:`~django.db.models.Field` 인스턴스의 이름(``question_text`` 또"
"는 ``pub_date``)은 기계가 읽기 좋은 형식(machine-friendly format)의 데이터베"
"이스 필드 이름입니다. 이 필드명을 Python 코드에서 사용할 수 있으며, 데이터베"
"이스에서는 컬럼명으로 사용할 것입니다. "

msgid ""
"You can use an optional first positional argument to a :class:`~django.db."
"models.Field` to designate a human-readable name. That's used in a couple of "
"introspective parts of Django, and it doubles as documentation. If this "
"field isn't provided, Django will use the machine-readable name. In this "
"example, we've only defined a human-readable name for ``Question.pub_date``. "
"For all other fields in this model, the field's machine-readable name will "
"suffice as its human-readable name."
msgstr ""
":class:`~django.db.models.Field` 클래스의 생성자에 선택적인 첫번째 위치 인수"
"를 전달하여 사람이 읽기 좋은(human-readable) 이름을 지정할 수도 있습니다. 이 "
"방법은 Django 의 내부를 설명하는 용도로 종종 사용되는데, 이는 마치 문서가 늘"
"어나는 것 같은 효과를 가집니다. 만약 이 선택적인 첫번째 위치 인수를 사용하지 "
"않으면, Django 는 기계가 읽기 좋은 형식의 이름을 사용합니다. 이 예제에서는, "
"``Question.pub_date`` 에 한해서만 인간이 읽기 좋은 형태의 이름을 정의하겠습니"
"다. 그 외의 다른 필드들은, 기계가 읽기 좋은 형태의 이름이라도 사람이 읽기에"
"는 충분합니다. "

msgid ""
"Some :class:`~django.db.models.Field` classes have required arguments. :"
"class:`~django.db.models.CharField`, for example, requires that you give it "
"a :attr:`~django.db.models.CharField.max_length`. That's used not only in "
"the database schema, but in validation, as we'll soon see."
msgstr ""
"몇몇 :class:`~django.db.models.Field` 클래스들은 필수 인수가 필요합니다. 예"
"를 들어, :class:`~django.db.models.CharField` 의 경우 :attr:`~django.db."
"models.CharField.max_length` 를 입력해 주어야 합니다. 이것은 데이터베이스 스"
"키마에서만 필요한것이 아닌 값을 검증할때도 쓰이는데, 곧 보게 될것입니다."

msgid ""
"A :class:`~django.db.models.Field` can also have various optional arguments; "
"in this case, we've set the :attr:`~django.db.models.Field.default` value of "
"``votes`` to 0."
msgstr ""
"또한 :class:`~django.db.models.Field` 는 다양한 선택적 인수들을 가질 수 있습"
"니다. 이 예제에서는, :attr:`~django.db.models.Field.default` 로 하여금 "
"``votes`` 의 기본값을 0 으로 설정하였습니다."

msgid ""
"Finally, note a relationship is defined, using :class:`~django.db.models."
"ForeignKey`. That tells Django each ``Choice`` is related to a single "
"``Question``. Django supports all the common database relationships: many-to-"
"one, many-to-many, and one-to-one."
msgstr ""
"마지막으로, :class:`~django.db.models.ForeignKey` 를 사용한 관계설정에 대해 "
"설명하겠습니다. 이 예제에서는 각각의 ``Choice`` 가 하나의 ``Question`` 에 관"
"계된다는 것을 Django 에게 알려줍니다. Django 는 다-대-일(many-to-one), 다-대-"
"다(many-to-many), 일-대-일(one-to-one) 과 같은 모든 일반 데이터베이스의 관계"
"들를 지원합니다."

msgid "Activating models"
msgstr "모델의 활성화"

msgid ""
"That small bit of model code gives Django a lot of information. With it, "
"Django is able to:"
msgstr ""
"모델에 대한 이 작은 코드가, Django에게는 상당한 양의 정보를 전달합니다. "
"Django는 이 정보를 가지고 다음과 같은 일을 할 수 있습니다."

msgid "Create a database schema (``CREATE TABLE`` statements) for this app."
msgstr "이 앱을 위한 데이터베이스 스키마 생성(``CREATE TABLE`` 문)"

msgid ""
"Create a Python database-access API for accessing ``Question`` and "
"``Choice`` objects."
msgstr ""
"``Question``\\과 ``Choice`` 객체에 접근하기 위한 Python 데이터베이스 접근 API"
"를 생성"

msgid ""
"But first we need to tell our project that the ``polls`` app is installed."
msgstr ""
"그러나, 가장 먼저 현재 프로젝트에게 ``polls`` 앱이 설치되어 있다는 것을 알려"
"야 합니다."

msgid ""
"Django apps are \"pluggable\": You can use an app in multiple projects, and "
"you can distribute apps, because they don't have to be tied to a given "
"Django installation."
msgstr ""
"Django의 앱들은 \"꼈다뺐다\"할 수 있습니다. 앱을 다수의 프로젝트에서 사용할 "
"수 있으며, 앱을 배포할 수도 있습니다. 특정 Django 사이트에 앱들이 묶여있지 않"
"아도 되기 때문입니다."

msgid ""
"To include the app in our project, we need to add a reference to its "
"configuration class in the :setting:`INSTALLED_APPS` setting. The "
"``PollsConfig`` class is in the :file:`polls/apps.py` file, so its dotted "
"path is ``'polls.apps.PollsConfig'``. Edit the :file:`mysite/settings.py` "
"file and add that dotted path to the :setting:`INSTALLED_APPS` setting. "
"It'll look like this:"
msgstr ""
"앱을 현재의 프로젝트에 포함시키기 위해서는, 앱의 구성 클래스에 대한 참조를 :"
"setting:`INSTALLED_APPS` 설정에 추가해야 합니다. ``PollsConfig`` 클래스는 :"
"file:`polls/apps.py` 파일 내에 존재합니다. 따라서, 점으로 구분된 경로는 "
"``'polls.apps.PollsConfig'``\\가 됩니다. 이 점으로 구분된 경로를, :file:"
"`mysite/settings.py` 파일을 편집하여 :setting:`INSTALLED_APPS` 설정에 추가하"
"면 됩니다. 이는 다음과 같이 보일 것입니다."

msgid "``mysite/settings.py``"
msgstr "``mysite/settings.py``"

msgid ""
"Now Django knows to include the ``polls`` app. Let's run another command:"
msgstr ""
"이제, Django는 ``polls`` 앱이 포함된 것을 알게 되었습니다. 다른 명령을 내려봅"
"시다."

msgid "You should see something similar to the following:"
msgstr "다음과 비슷한 것이 보일 겁니다."

msgid ""
"By running ``makemigrations``, you're telling Django that you've made some "
"changes to your models (in this case, you've made new ones) and that you'd "
"like the changes to be stored as a *migration*."
msgstr ""
"``makemigrations`` 을 실행시킴으로서, 당신이 모델을 변경시킨 사실과(이 경우에"
"는 새로운 모델을 만들었습니다) 이 변경사항을 *migration*\\으로 저장시키고 싶"
"다는 것을 Django에게 알려줍니다."

msgid ""
"Migrations are how Django stores changes to your models (and thus your "
"database schema) - they're files on disk. You can read the migration for "
"your new model if you like; it's the file ``polls/migrations/0001_initial."
"py``. Don't worry, you're not expected to read them every time Django makes "
"one, but they're designed to be human-editable in case you want to manually "
"tweak how Django changes things."
msgstr ""
"Migration은 Django가 모델(즉, 당신의 데이터베이스 스키마)의 변경사항을 디스크"
"에 저장하는 방법입니다. 원하는 경우 ``polls/migrations/0001_initial.py`` 파일"
"로 저장된 새 모델에 대한 migration을 읽어볼 수 있습니다. 걱정하지 마세요, 여"
"러분이 Django가 migration을 만들 때마다 읽을 것으로 기대되지는 않지만, Django"
"의 변경점을 수동으로 수정하기를 원할 때를 대비해서 사람이 수정할 수 있도록 설"
"계되었습니다."

msgid ""
"There's a command that will run the migrations for you and manage your "
"database schema automatically - that's called :djadmin:`migrate`, and we'll "
"come to it in a moment - but first, let's see what SQL that migration would "
"run. The :djadmin:`sqlmigrate` command takes migration names and returns "
"their SQL:"
msgstr ""
"당신을 위해 migration들을 실행시켜주고, 자동으로 데이터베이스 스키마를 관리해"
"주는 :djadmin:`migrate` 명령어가 있습니다. 이 명령을 알아보기 전에 migration"
"이 내부적으로 어떤 SQL 문장을 실행하는지 살펴봅시다. :djadmin:`sqlmigrate` 명"
"령은 migration 이름을 인수로 받아, 실행하는 SQL 문장을 보여줍니다."

msgid ""
"You should see something similar to the following (we've reformatted it for "
"readability):"
msgstr ""
"다음과 비슷한 결과를 보실 수 있습니다. (가독성을 위해 결과물을 조금 다듬었습"
"니다)"

msgid "Note the following:"
msgstr "다음을 참고하세요."

msgid ""
"The exact output will vary depending on the database you are using. The "
"example above is generated for PostgreSQL."
msgstr ""
"사용하는 데이터베이스에 따라서 출력결과는 다를 수 있습니다. 위의 출력결과는 "
"PostgreSQL에서 생성되었습니다."

msgid ""
"Table names are automatically generated by combining the name of the app "
"(``polls``) and the lowercase name of the model -- ``question`` and "
"``choice``. (You can override this behavior.)"
msgstr ""
"테이블 이름은 앱의 이름과 모델의 이름(소문자)이 조합되어 자동으로 생성됩니"
"다. 이 경우, 앱의 이름인 ``polls`` 와 소문자로 표기된 모델의 이름인 "
"``question`` 과 ``choice``\\가 합쳐집니다. (이 동작을 재지정(override)하여 수"
"정할 수 있습니다.)"

msgid ""
"Primary keys (IDs) are added automatically. (You can override this, too.)"
msgstr ""
"기본 키(ID)가 자동으로 추가됩니다. (역시 이 동작도 재지정할 수 있습니다.)"

msgid ""
"By convention, Django appends ``\"_id\"`` to the foreign key field name. "
"(Yes, you can override this, as well.)"
msgstr ""
"관례에 따라, Django는 외래 키 필드명에 ``\"_id\"`` 이름을 자동으로 추가합니"
"다. (물론 이것도 재지정할 수 있습니다.)"

msgid ""
"The foreign key relationship is made explicit by a ``FOREIGN KEY`` "
"constraint. Don't worry about the ``DEFERRABLE`` parts; it's telling "
"PostgreSQL to not enforce the foreign key until the end of the transaction."
msgstr ""
"외래 키 관계는 ``FOREIGN KEY`` 라는 제약에 의해 명시됩니다. ``DEFERRABLE`` 부"
"분에 대해서는 걱정하지 마십시오. 이것은 PostgreSQL에 트랜잭션이 끝날 때까지 "
"외래 키를 강제하지 말라고 알려주는 것입니다."

msgid ""
"It's tailored to the database you're using, so database-specific field types "
"such as ``auto_increment`` (MySQL), ``bigint PRIMARY KEY GENERATED BY "
"DEFAULT AS IDENTITY`` (PostgreSQL), or ``integer primary key autoincrement`` "
"(SQLite) are handled for you automatically. Same goes for the quoting of "
"field names -- e.g., using double quotes or single quotes."
msgstr ""
"사용하는 데이터베이스에 따라, 데이터베이스 고유의 필드타입이 조정됩니다. 따라"
"서, 자동 증가 필드를 생성할 경우 ``auto_increment``(MySQL), ``bigint PRIMARY "
"KEY GENERATED BY DEFAULT AS IDENTITY``(PostgreSQL) 또는 ``integer primary "
"key autoincrement``(SQLite)와 같이 사용하는 데이터베이스에 따라 적절한 필드타"
"입이 자동으로 선택됩니다. 필드 명에 사용되는 인용부호도 상황에 따라 겹따옴표"
"나 홑따옴표가 적절히 선택됩니다."

msgid ""
"The :djadmin:`sqlmigrate` command doesn't actually run the migration on your "
"database - instead, it prints it to the screen so that you can see what SQL "
"Django thinks is required. It's useful for checking what Django is going to "
"do or if you have database administrators who require SQL scripts for "
"changes."
msgstr ""
":djadmin:`sqlmigrate` 명령은 실제로 데이터베이스에서 마이그레이션을 실행하는 "
"것이 아니라 화면에 인쇄하여 필요한 SQL Django를 확인할 수 있도록 합니다. 이것"
"은 Django가 수행할 작업이나 변경을 위해 SQL 스크립트를 필요로 하는 데이터베이"
"스 관리자가 있는지 확인하는 데 유용합니다."

msgid ""
"If you're interested, you can also run :djadmin:`python manage.py check "
"<check>`; this checks for any problems in your project without making "
"migrations or touching the database."
msgstr ""
"관심이 있다면, :djadmin:`python manage.py check <check>` 명령을 통해 마이그레"
"이션을 수행하거나 데이터베이스를 건드리지 않고도 프로젝트의 문제를 확인할 수 "
"있습니다. "

msgid ""
"Now, run :djadmin:`migrate` again to create those model tables in your "
"database:"
msgstr ""
"이제, :djadmin:`migrate` 를 실행시켜 데이터베이스에 모델과 관련된 테이블을 생"
"성해봅시다."

msgid ""
"The :djadmin:`migrate` command takes all the migrations that haven't been "
"applied (Django tracks which ones are applied using a special table in your "
"database called ``django_migrations``) and runs them against your database - "
"essentially, synchronizing the changes you made to your models with the "
"schema in the database."
msgstr ""
":djadmin:`migrate` 명령은 아직 적용되지 않은 마이그레이션을 모두 수집해 이를 "
"실행하며(Django는 ``django_migrations`` 테이블을 두어 마이그레이션 적용 여부"
"를 추적합니다) 이 과정을 통해 모델에서의 변경 사항들과 데이터베이스의 스키마"
"의 동기화가 이루어집니다."

msgid ""
"Migrations are very powerful and let you change your models over time, as "
"you develop your project, without the need to delete your database or tables "
"and make new ones - it specializes in upgrading your database live, without "
"losing data. We'll cover them in more depth in a later part of the tutorial, "
"but for now, remember the three-step guide to making model changes:"
msgstr ""
"마이그레이션은 매우 기능이 강력하여, 마치 프로젝트를 개발할 때처럼 데이터베이"
"스나 테이블에 손대지 않고도 모델의 반복적인 변경을 가능하게 해줍니다. 동작 중"
"인 데이터베이스를 자료 손실 없이 업그레이드 하는 데 최적화 되어 있습니다. 튜"
"토리얼의 나머지 부분에서 이 부분을 조금 더 살펴보겠습니다만, 지금은 모델의 변"
"경을 만드는 세 단계의 지침을 기억하세요."

msgid "Change your models (in ``models.py``)."
msgstr "(``models.py`` 에서) 모델을 변경합니다."

msgid ""
"Run :djadmin:`python manage.py makemigrations <makemigrations>` to create "
"migrations for those changes"
msgstr ""
":djadmin:`python manage.py makemigrations <makemigrations>`\\을 통해 이 변경"
"사항에 대한 마이그레이션을 만드세요."

msgid ""
"Run :djadmin:`python manage.py migrate <migrate>` to apply those changes to "
"the database."
msgstr ""
":djadmin:`python manage.py migrate <migrate>` 명령을 통해 변경사항을 데이터베"
"이스에 적용하세요."

msgid ""
"The reason that there are separate commands to make and apply migrations is "
"because you'll commit migrations to your version control system and ship "
"them with your app; they not only make your development easier, they're also "
"usable by other developers and in production."
msgstr ""
"마이그레이션을 만드는 명령과 적용하는 명령이 분리된 것은 버전 관리 시스템에 "
"마이그레이션을 커밋하고 앱과 함께 출시할 수 있도록 하기 위해서입니다. 이는 당"
"신의 개발을 쉽게 해줄 뿐 아니라, 다른 개발자가 프로덕션에서 사용할 수 있게 해"
"줍니다."

msgid ""
"Read the :doc:`django-admin documentation </ref/django-admin>` for full "
"information on what the ``manage.py`` utility can do."
msgstr ""
"``manage.py`` 유틸리티로 어떤 일들을 할 수 있는지 :doc:`django-admin 문서 </"
"ref/django-admin>`\\를 읽어보세요."

msgid "Playing with the API"
msgstr "API 가지고 놀기"

msgid ""
"Now, let's hop into the interactive Python shell and play around with the "
"free API Django gives you. To invoke the Python shell, use this command:"
msgstr ""
"이제, 대화식 Python 쉘에 뛰어들어 Django API를 자유롭게 가지고 놀아봅시다. "
"Python 쉘을 실행하려면 다음의 명령을 입력합니다."

msgid ""
"We're using this instead of simply typing \"python\", because :file:`manage."
"py` sets the :envvar:`DJANGO_SETTINGS_MODULE` environment variable, which "
"gives Django the Python import path to your :file:`mysite/settings.py` file."
msgstr ""
"단순히 \"python\"을 입력하는 대신 이것을 사용한 이유는 :file:`manage.py` 에 "
"설정된 ``DJANGO_SETTINGS_MODULE`` 환경변수 때문입니다. 이 변수는 Django에게 :"
"file:`mysite/settings.py` 의 Python 가져오기 경로를 제공합니다."

msgid ""
"Once you're in the shell, explore the :doc:`database API </topics/db/"
"queries>`:"
msgstr ""
"일단 shell에 들어오면, :doc:`database API </topics/db/queries>` 탐색해보십시"
"오."

msgid ""
"Wait a minute. ``<Question: Question object (1)>`` isn't a helpful "
"representation of this object. Let's fix that by editing the ``Question`` "
"model (in the ``polls/models.py`` file) and adding a :meth:`~django.db."
"models.Model.__str__` method to both ``Question`` and ``Choice``:"
msgstr ""
"여기서 잠깐. ``<Question: Question object (1)>``\\은 이 객체를 표현하는 데 별"
"로 도움이 되지 않습니다. (``polls/models.py`` 파일의) ``Question`` 모델을 수"
"정하여, :meth:`~django.db.models.Model.__str__` 메소드를 ``Question``\\과 "
"``Choice``\\에 추가해 봅시다."

msgid ""
"It's important to add :meth:`~django.db.models.Model.__str__` methods to "
"your models, not only for your own convenience when dealing with the "
"interactive prompt, but also because objects' representations are used "
"throughout Django's automatically-generated admin."
msgstr ""
"당신의 모델에 :meth:`~django.db.models.Model.__str__` 메소드를 추가하는것은 "
"객체의 표현을 대화식 프롬프트에서 편하게 보려는 이유 말고도, Django 가 자동으"
"로 생성하는 관리 사이트 에서도 객체의 표현이 사용되기 때문입니다."

msgid "Let's also add a custom method to this model:"
msgstr "이 모델에 커스텀 메소드 또한 추가해봅시다:"

msgid ""
"Note the addition of ``import datetime`` and ``from django.utils import "
"timezone``, to reference Python's standard :mod:`datetime` module and "
"Django's time-zone-related utilities in :mod:`django.utils.timezone`, "
"respectively. If you aren't familiar with time zone handling in Python, you "
"can learn more in the :doc:`time zone support docs </topics/i18n/timezones>`."
msgstr ""
"``import datetime``\\은 Python의 표준 모듈인 :mod:`datetime` 모듈을, ``from "
"django.utils import timezone``\\은 Django의 시간대 관련 유틸리티인 :mod:"
"`django.utils.timezone`\\을 참조하기 위해 추가한 것입니다. 만약 Python에서 시"
"간대를 조작하는 방법에 대해 익숙하지 않다면, :doc:`시간대 지원 문서 </topics/"
"i18n/timezones>`\\에서 더 많은 것을 배울 수 있습니다."

msgid ""
"Save these changes and start a new Python interactive shell by running "
"``python manage.py shell`` again:"
msgstr ""
"이러한 변경 사항을 저장하고, ``python manage.py shell``을 다시 실행하여 새로"
"운 대화형 shell을 실행하십시오."

msgid ""
"For more information on model relations, see :doc:`Accessing related objects "
"</ref/models/relations>`. For more on how to use double underscores to "
"perform field lookups via the API, see :ref:`Field lookups <field-lookups-"
"intro>`. For full details on the database API, see our :doc:`Database API "
"reference </topics/db/queries>`."
msgstr ""
"모델의 관계에 대한 더 많은 정보는 :doc:`관련 객체에 접근하기 </ref/models/"
"relations>`\\를 참조하세요. API에서 이중 밑줄(``__``) 을 이용해서 어떻게 필드"
"를 조회할 수 있는지는 :ref:`필드 조회 <field-lookups-intro>`\\를 읽어보세요."
"데이터베이스 API에 대한 자세한 내용을 보려면, :doc:`데이터베이스 API 레퍼런"
"스 </topics/db/queries>`\\를 읽어보세요."

msgid "Introducing the Django Admin"
msgstr "Django 관리자 소개"

msgid ""
"Generating admin sites for your staff or clients to add, change, and delete "
"content is tedious work that doesn't require much creativity. For that "
"reason, Django entirely automates creation of admin interfaces for models."
msgstr ""
"직원들이나 고객들이 컨텐츠를 수정하기 위한 관리자 사이트를 만드는 것은 딱히 "
"창의적일 필요없는 지루한 작업입니다. 이런 이유로, Django는 모델에 대한 관리"
"용 인터페이스를 모두 자동으로 생성합니다."

msgid ""
"Django was written in a newsroom environment, with a very clear separation "
"between \"content publishers\" and the \"public\" site. Site managers use "
"the system to add news stories, events, sports scores, etc., and that "
"content is displayed on the public site. Django solves the problem of "
"creating a unified interface for site administrators to edit content."
msgstr ""
"Django는 ``Lawrence Journal-World`` 신문사의 프로그래머가 처음 개발하였습니"
"다. 이런 태생적인 이유 때문에, \"컨텐츠 게시자\" 와 \"공개\" 사이트의 구분이 "
"명확합니다. 사이트 관리자는 뉴스 기사, 사건, 스포츠 경기 결과 같은 것들을 시"
"스템에 추가합니다. 그렇게 추가된 컨텐츠는 \"공개\" 사이트에 노출됩니다. "
"Django는 사이트 관리자가 컨텐츠를 편집할 수 있는 통합적인 인터페이스를 생성하"
"는 문제를 해결합니다."

msgid ""
"The admin isn't intended to be used by site visitors. It's for site managers."
msgstr ""
"관리자 사이트는 사이트 방문자를 위한 것이 아니라, 사이트 관리자를 위한 것입니"
"다."

msgid "Creating an admin user"
msgstr "관리자 생성하기"

msgid ""
"First we'll need to create a user who can login to the admin site. Run the "
"following command:"
msgstr ""
"우선, 관리 사이트에 로그인 할 수 있는 사용자를 생성해 봅시다. 다음과 같은 명"
"령을 수행합니다."

msgid "Enter your desired username and press enter."
msgstr "원하는 username 을 입력하고 엔터를 누르세요"

msgid "You will then be prompted for your desired email address:"
msgstr "그런 다음 원하는 이메일 주소를 입력하라는 메시지가 표시됩니다."

msgid ""
"The final step is to enter your password. You will be asked to enter your "
"password twice, the second time as a confirmation of the first."
msgstr ""
"마지막으로, 암호를 입력하세요. 암호를 두번 물어보게 되는데, 두번째 입력하는 "
"암호를 올바로 입력했는지를 확인하기 위한 암호입니다. "

msgid "Start the development server"
msgstr "개발 서버 시작"

msgid ""
"The Django admin site is activated by default. Let's start the development "
"server and explore it."
msgstr ""
"Django 관리자 사이트는 기본으로 활성화되어 있습니다. 개발 서버를 켜고, 탐색"
"해 봅시다."

msgid "If the server is not running start it like so:"
msgstr "서버가 동작하고 있지 않다면 다음 명령으로 시작합니다."

msgid ""
"Now, open a web browser and go to \"/admin/\" on your local domain -- e.g., "
"http://127.0.0.1:8000/admin/. You should see the admin's login screen:"
msgstr ""
"이제 웹 브라우저를 열고 로컬 도메인의 \"/admin/\"으로 이동합니다(예: "
"http://127.0.0.1:8000/admin/). 그러면 관리자의 로그인 화면이 나타날 것입니다."

msgid "Django admin login screen"
msgstr "Django 관리자 로그인 화면"

msgid ""
"Since :doc:`translation </topics/i18n/translation>` is turned on by default, "
"if you set :setting:`LANGUAGE_CODE`, the login screen will be displayed in "
"the given language (if Django has appropriate translations)."
msgstr ""
":doc:`translation </topics/i18n/translation>` 이 기본적으로 설정되어 있으므"
"로 :setting:`LANGUAGE_CODE` 를 설정하면, 로그인 화면이 지정된 언어로 표시됩니"
"다(Django 번역이 적절한 경우)."

msgid "Enter the admin site"
msgstr "관리자 사이트에 들어가기"

msgid ""
"Now, try logging in with the superuser account you created in the previous "
"step. You should see the Django admin index page:"
msgstr ""
"앞서 생성한 슈퍼유저(superuser) 계정으로 로그인해봅시다. 다음과 같은 Django "
"관리 인덱스 페이지가 보일 것입니다."

msgid "Django admin index page"
msgstr "Django 관리자 색인 페이지"

msgid ""
"You should see a few types of editable content: groups and users. They are "
"provided by :mod:`django.contrib.auth`, the authentication framework shipped "
"by Django."
msgstr ""
"편집 가능한 그룹과 사용자와 같은 몇 종류의 컨텐츠를 볼 수 있습니다. 이것들"
"은 :mod:`django.contrib.auth` 모듈에서 제공되는데, Django 에서 제공되는 인증 "
"프레임워크 입니다."

msgid "Make the poll app modifiable in the admin"
msgstr "관리 사이트에서 poll app 을 변경가능하도록 만들기"

msgid "But where's our poll app? It's not displayed on the admin index page."
msgstr ""
"그런데, poll app 이 관리 인덱스 페이지에서 보이지 않네요. 어디에 있을까요?"

msgid ""
"Only one more thing to do: we need to tell the admin that ``Question`` "
"objects have an admin interface. To do this, open the :file:`polls/admin.py` "
"file, and edit it to look like this:"
msgstr ""
"한 가지 더 해야 할 일은 관리자에게 ''질문'' 대상에는 관리 인터페이스가 있다"
"고 알려주는 것입니다. 이렇게 하려면 :file:`polls/admin.py` 파일을 열어 다음"
"과 같이 편집하십시오."

msgid "``polls/admin.py``"
msgstr "``polls/admin.py``"

msgid "Explore the free admin functionality"
msgstr "자유로운 관리 기능을 탐색하기"

msgid ""
"Now that we've registered ``Question``, Django knows that it should be "
"displayed on the admin index page:"
msgstr ""
"이제, ``Question`` 을 등록시켰으니 Django 는 이를 알아채고 관리 인덱스 페이지"
"에 이를 표시할 것입니다:"

msgid "Django admin index page, now with polls displayed"
msgstr "Django 관리자 색인 페이지, 이제 투표가 표시됨"

msgid ""
"Click \"Questions\". Now you're at the \"change list\" page for questions. "
"This page displays all the questions in the database and lets you choose one "
"to change it. There's the \"What's up?\" question we created earlier:"
msgstr ""
"\"Questions\" 을 클릭하십시요. 그러면 질문들을 위한 \"change list\" 로 이동합"
"니다. 이 페이지는 데이터베이스에 저장된 모든 질문들을 보여주며, 그 중 하나를 "
"선택하여 변경할 수 있습니다. 이전에 등록했던 \"What's up?\" 질문이 있을 것입"
"니다."

msgid "Polls change list page"
msgstr "투표 변경 목록 페이지"

msgid "Click the \"What's up?\" question to edit it:"
msgstr "\"What's up?\" 질문을 클릭하여 수정합니다."

msgid "Editing form for question object"
msgstr "질문 개체에 대한 편집 양식"

msgid "Things to note here:"
msgstr "여기서 알아둘 것들:"

msgid "The form is automatically generated from the ``Question`` model."
msgstr "이 서식은 ``Question`` 모델에서 자동으로 생성되었습니다"

msgid ""
"The different model field types (:class:`~django.db.models.DateTimeField`, :"
"class:`~django.db.models.CharField`) correspond to the appropriate HTML "
"input widget. Each type of field knows how to display itself in the Django "
"admin."
msgstr ""
"모델의 각 필드 유형들은 (:class:`~django.db.models.DateTimeField`, :class:"
"`~django.db.models.CharField`) 적절한 HTML 입력 위젯으로 표현됩니다. 필드의 "
"각 유형들은 Django 관리 사이트에서 어떻게 표현해되어야 할지 알고 있습니다."

msgid ""
"Each :class:`~django.db.models.DateTimeField` gets free JavaScript "
"shortcuts. Dates get a \"Today\" shortcut and calendar popup, and times get "
"a \"Now\" shortcut and a convenient popup that lists commonly entered times."
msgstr ""
"각각의 :class:`~django.db.models.DateTimeField` 는 JavaScript 로 작성된 단축 "
"기능과 연결됩니다. 날짜는 \"오늘\"(\"Today\") 버튼과 달력 팝업에서 입력할 수 "
"있으며, 시간은 \"지금\"(\"Now\") 버튼과 일반적으로 입력하는 시간들을 제공하"
"는 편리한 팝업을 통해서도 입력할 수 있습니다."

msgid "The bottom part of the page gives you a couple of options:"
msgstr "페이지의 아래 부분에서 다음과 같은 몇가지 옵션을 제공합니다."

msgid ""
"Save -- Saves changes and returns to the change-list page for this type of "
"object."
msgstr ""
"저장(Save) -- 이 유형의 객체에 대한 변경사항을 저장하고, 변경된 목록 페이지"
"를 보여줍니다"

msgid ""
"Save and continue editing -- Saves changes and reloads the admin page for "
"this object."
msgstr ""
"저장 및 편집 계속(Save and continue editing) -- 이 객체에 대한 변경사항을 저"
"장하고, 현재 편집창을 갱신합니다"

msgid ""
"Save and add another -- Saves changes and loads a new, blank form for this "
"type of object."
msgstr ""
"저장 및 다른 이름으로 추가(Save and add another) -- 변경사항을 저장하고, 이 "
"유형의 객체에 대한 비어있는 새로운 입력창을 불러옵니다"

msgid "Delete -- Displays a delete confirmation page."
msgstr "삭제(Delete) -- 삭제를 확인하는 페이지를 띄웁니다."

msgid ""
"If the value of \"Date published\" doesn't match the time when you created "
"the question in :doc:`Tutorial 1</intro/tutorial01>`, it probably means you "
"forgot to set the correct value for the :setting:`TIME_ZONE` setting. Change "
"it, reload the page and check that the correct value appears."
msgstr ""
"만약 \"Date published\" 의 값이 :doc:`Tutorial 1</intro/tutorial01>` 에서 질"
"문을 생성했을때의 시간과 일치하지 않는다면, :setting:`TIME_ZONE` (시간대) 설"
"정을 깜빡 하신것일지도 모릅니다. 이 설정을 바꾸시고 다시 페이지를 불러오시면 "
"올바른 값이 표현됩니다."

msgid ""
"Change the \"Date published\" by clicking the \"Today\" and \"Now\" "
"shortcuts. Then click \"Save and continue editing.\" Then click \"History\" "
"in the upper right. You'll see a page listing all changes made to this "
"object via the Django admin, with the timestamp and username of the person "
"who made the change:"
msgstr ""
"\"Date published\" 의 값을 \"오늘\"(\"Today\") 과 \"지금\"(\"Now\") 단축버튼"
"을 눌러 바꾸십시요. 그런 후, \"저장 및 편집 계속\"(\"Save and continue "
"editing\") 을 누르십시요. 그런 후, 우측 상단의 \"히스토리\"(\"History\") 버튼"
"을 누르십시요. Django 관리사이트를 통해 누가(username) 언제(timestamp) 무엇"
"을 바꾸었는지 목록을 확인할 수 있습니다."

msgid "History page for question object"
msgstr "질문 개체의 역사 페이지"

msgid ""
"When you're comfortable with the models API and have familiarized yourself "
"with the admin site, read :doc:`part 3 of this tutorial</intro/tutorial03>` "
"to learn about how to add more views to our polls app."
msgstr ""
"모델 API와 관리 사이트에 익숙해졌다면, :doc:`이 튜토리얼의 3장 </intro/"
"tutorial03>`\\에서 투표 앱에 뷰를 추가하는 방법을 배워보세요."

msgid "Writing your first Django app, part 3"
msgstr "첫 번째 장고 앱 작성하기, part 3"

msgid ""
"This tutorial begins where :doc:`Tutorial 2 </intro/tutorial02>` left off. "
"We're continuing the web-poll application and will focus on creating the "
"public interface -- \"views.\""
msgstr ""
"이 튜토리얼은 :doc:`튜토리얼 2장 </intro/tutorial02>` 에서 이어집니다. 이제 "
"Web-poll 애플리케이션에 공용 인터페이스인 \"views\"를 만드는 데 초점을 맞출 "
"것입니다."

msgid "Overview"
msgstr "개요"

msgid ""
"A view is a \"type\" of web page in your Django application that generally "
"serves a specific function and has a specific template. For example, in a "
"blog application, you might have the following views:"
msgstr ""
"view는 일반적으로 특정한 기능을 제공하고 특정한 템플릿을 가진 Django 애플리케"
"이션에 있는 웹 페이지의 \"type\"입니다. 예를 들어, 블로그 애플리케이션에서 다"
"음과 같은 view를 가질 수 있습니다."

msgid "Blog homepage -- displays the latest few entries."
msgstr "Blog 홈페이지 -- 가장 최근의 항목들을 보여줍니다"

msgid "Entry \"detail\" page -- permalink page for a single entry."
msgstr ""
"항목 \"세부\"(detail) 페이지 -- 하나의 항목에 연결하는 영구적인 링크"
"(permalink)를 제공합니다."

msgid ""
"Year-based archive page -- displays all months with entries in the given "
"year."
msgstr "년도별 축적 페이지 -- 주어진 연도의 모든 월별 항목들을 표시합니다."

msgid ""
"Month-based archive page -- displays all days with entries in the given "
"month."
msgstr "월별 축적 페이지 -- 주어진 월의 날짜별 항목들을 표시합니다."

msgid "Day-based archive page -- displays all entries in the given day."
msgstr "날짜별 축적 페이지 -- 주어진 날짜의 모든 항목들을 표시합니다."

msgid "Comment action -- handles posting comments to a given entry."
msgstr "댓글 기능 -- 특정 항목의 댓글을 다룰 수 있는 기능"

msgid "In our poll application, we'll have the following four views:"
msgstr ""
"우리가 만드는 poll 어플리케이션에서 다음과 같은 네개의 view 를 만들어 보겠습"
"니다."

msgid "Question \"index\" page -- displays the latest few questions."
msgstr "질문 \"색인\" 페이지 -- 최근의 질문들을 표시합니다."

msgid ""
"Question \"detail\" page -- displays a question text, with no results but "
"with a form to vote."
msgstr "질문 \"세부\" 페이지 -- 질문 내용과, 투표할 수 있는 서식을 표시합니다."

msgid ""
"Question \"results\" page -- displays results for a particular question."
msgstr "질문 \"결과\" 페이지 -- 특정 질문에 대한 결과를 표시합니다"

msgid ""
"Vote action -- handles voting for a particular choice in a particular "
"question."
msgstr ""
"투표 기능 -- 특정 질문에 대해 특정 선택을 할 수 있는 투표 기능을 제공합니다."

msgid ""
"In Django, web pages and other content are delivered by views. Each view is "
"represented by a Python function (or method, in the case of class-based "
"views). Django will choose a view by examining the URL that's requested (to "
"be precise, the part of the URL after the domain name)."
msgstr ""
"Django에서는 웹 페이지와 기타 콘텐츠가 view로 전달됩니다. 각 view는 Python 함"
"수(또는 클래스 기반 view의 경우 메소드)로 표현됩니다. Django는 요청한 URL(더 "
"정확하게 말하면 도메인 이름 뒤의 URL 부분)을 확인하여 보기를 선택합니다."

msgid ""
"Now in your time on the web you may have come across such beauties as ``ME2/"
"Sites/dirmod.htm?sid=&type=gen&mod=Core+Pages&gid=A6CD4967199A42D9B65B1B``. "
"You will be pleased to know that Django allows us much more elegant *URL "
"patterns* than that."
msgstr ""
"지금 웹 상에서 여러분은 ``ME2/Sites/dirmod.htm?"
"sid=&type=gen&mod=Core+Pages&gid=A6CD4967199A42D9B65B1B``와 같은 아름다움을 "
"접했을 것입니다. Django는 우리에게 그것보다 훨씬 더 우아한 *URL 패턴*을 허용"
"해줍니다."

msgid ""
"A URL pattern is the general form of a URL - for example: ``/newsarchive/"
"<year>/<month>/``."
msgstr ""
"URL 패턴은 URL의 일반적인 형식입니다(예: ``/newsarchive/<year>/<month>/``)."

msgid ""
"To get from a URL to a view, Django uses what are known as 'URLconfs'. A "
"URLconf maps URL patterns to views."
msgstr ""
"URL로부터 뷰를 얻기 위해, Django는 'URLconfs'라는 것을 사용합니다. URLconf는 "
"URL 패턴을 뷰에 연결합니다."

msgid ""
"This tutorial provides basic instruction in the use of URLconfs, and you can "
"refer to :doc:`/topics/http/urls` for more information."
msgstr ""
"이 튜토리얼은 URLconfs를 사용하는 기초 지식을 제공하며, 좀 더 자세한 정보는 :"
"doc:`/topics/http/urls`\\를 참조하세요."

msgid "Writing more views"
msgstr "뷰 추가하기"

msgid ""
"Now let's add a few more views to ``polls/views.py``. These views are "
"slightly different, because they take an argument:"
msgstr ""
"이제, ``polls/views.py`` 에 뷰를 추가해 봅시다. 이 뷰들은 인수를 받기 때문에 "
"조금 모양이 다릅니다."

msgid ""
"Wire these new views into the ``polls.urls`` module by adding the following :"
"func:`~django.urls.path` calls:"
msgstr ""
"다음의 :func:`~django.urls.path` 호출을 추가하여 이러한 새로운 뷰를 ``polls."
"urls`` 모듈로 연결하세요."

msgid ""
"Take a look in your browser, at \"/polls/34/\". It'll run the ``detail()`` "
"method and display whatever ID you provide in the URL. Try \"/polls/34/"
"results/\" and \"/polls/34/vote/\" too -- these will display the placeholder "
"results and voting pages."
msgstr ""
"브라우저에 \"/polls/34/\" 를 입력해 보세요. 이 주소에 접속하면 ``detail()`` "
"함수를 호출하여 URL 에 입력한 ID 를 출력할 것입니다. \"/polls/34/results/\" "
"와 \"/polls/34/vote/\" 도 실행해 보세요. 투표 결과와 투표 페이지의 뼈대가 되"
"는 페이지가 출력될 것입니다."

msgid ""
"When somebody requests a page from your website -- say, \"/polls/34/\", "
"Django will load the ``mysite.urls`` Python module because it's pointed to "
"by the :setting:`ROOT_URLCONF` setting. It finds the variable named "
"``urlpatterns`` and traverses the patterns in order. After finding the match "
"at ``'polls/'``, it strips off the matching text (``\"polls/\"``) and sends "
"the remaining text -- ``\"34/\"`` -- to the 'polls.urls' URLconf for further "
"processing. There it matches ``'<int:question_id>/'``, resulting in a call "
"to the ``detail()`` view like so:"
msgstr ""
"누군가 당신의 웹사이트에 페이지 - 예를 들어 : \"/polls/34\" 요청하면, Django"
"는 :setting:`ROOT_URLCONF` 설정이 가리키고 있는 ``mysite.urls`` Python 모듈"
"을 로드합니다. 이 모듈은 ``urlpatterns``라는 변수를 찾아서 패턴을 순서대로 순"
"회합니다. ``'polls/'`` 에서 일치하는 패턴을 찾은 후 일치하는 텍스트"
"(``\"polls/\"``)를 제거하고 나머지 텍스트인 --``\"34/\"``--를 추가 처리를 위"
"해 'polls.urls' URLconf로 보냅니다. 거기에서 ``'1/'`와 일치하는 패턴을 찾아 "
"다음과 같이 ``detail()`` 뷰를 호출합니다:"

msgid ""
"The ``question_id=34`` part comes from ``<int:question_id>``. Using angle "
"brackets \"captures\" part of the URL and sends it as a keyword argument to "
"the view function. The ``question_id`` part of the string defines the name "
"that will be used to identify the matched pattern, and the ``int`` part is a "
"converter that determines what patterns should match this part of the URL "
"path. The colon (``:``) separates the converter and pattern name."
msgstr ""
"``question_id=34`` 부분은 ``<int:question_id>`` 에서 왔습니다. 꺾쇠 괄호를 사"
"용하면 URL의 일부가 \"캡처\"되어 키워드 인수로 view 함수에 전송됩니다. 문자열"
"의 ``question_id`` 부분은 일치하는 패턴을 식별하는 데 사용할 이름을 정의하"
"고, ``int`` 부분은 URL 경로의 이 부분과 일치하는 패턴을 결정하는 변환기입니"
"다. 콜론(``:``)은 컨버터와 패턴 이름을 구분합니다."

msgid "Write views that actually do something"
msgstr "뷰가 실제로 뭔가를 하도록 만들기"

msgid ""
"Each view is responsible for doing one of two things: returning an :class:"
"`~django.http.HttpResponse` object containing the content for the requested "
"page, or raising an exception such as :exc:`~django.http.Http404`. The rest "
"is up to you."
msgstr ""
"각 뷰는 두 가지 중 하나를 하도록 되어 있습니다. 요청된 페이지의 내용이 담긴 :"
"class:`~django.http.HttpResponse` 객체를 반환하거나, 혹은 :exc:`~django.http."
"Http404` 같은 예외를 발생하게 해야합니다. 나머지는 당신에게 달렸습니다."

msgid ""
"Your view can read records from a database, or not. It can use a template "
"system such as Django's -- or a third-party Python template system -- or "
"not. It can generate a PDF file, output XML, create a ZIP file on the fly, "
"anything you want, using whatever Python libraries you want."
msgstr ""
"당신이 작성한 뷰는 데이터베이스의 레코드를 읽을 수도 있습니다. 또한 뷰는 "
"Django나 Python에서 서드파티로 제공되는 템플릿 시스템을 사용할 수도 있습니"
"다. 뷰는 PDF를 생성하거나, XML을 출력하거나, 실시간으로 ZIP 파일을 만들 수 있"
"습니다. 뷰는 당신이 원하는 무엇이든, Python의 어떤 라이브러리라도 사용할 수 "
"있습니다."

msgid ""
"All Django wants is that :class:`~django.http.HttpResponse`. Or an exception."
msgstr ""
"Django에 필요한 것은 :class:`~django.http.HttpResponse` 객체 혹은 예외입니다."

msgid ""
"Because it's convenient, let's use Django's own database API, which we "
"covered in :doc:`Tutorial 2 </intro/tutorial02>`. Here's one stab at a new "
"``index()`` view, which displays the latest 5 poll questions in the system, "
"separated by commas, according to publication date:"
msgstr ""
"왜냐면, 그렇게 다루는게 편리하기 때문입니다. :doc:`튜토리얼 2장 </intro/"
"tutorial02>`\\의 예제에서 다룬 Django 자체 데이터베이스 API를 사용해봅시다. "
"새로운 ``index()`` 뷰 하나를 호출했을 때, 시스템에 저장된 최소한 5 개의 투표 "
"질문이 콤마로 분리되어, 발행일에 따라 출력됩니다."

msgid ""
"There's a problem here, though: the page's design is hard-coded in the view. "
"If you want to change the way the page looks, you'll have to edit this "
"Python code. So let's use Django's template system to separate the design "
"from Python by creating a template that the view can use."
msgstr ""
"여기 몇가지 문제가 있습니다. 뷰에서 페이지의 디자인이 하드코딩 되어 있다고 합"
"시다. 만약 페이지가 보여지는 방식을 바꾸고 싶다면, 이 Python 코드를 편집해야"
"만 할 겁니다. 그럼, 뷰에서 사용할 수 있는 템플릿을 작성하여, Python 코드로부"
"터 디자인을 분리하도록 Django의 템플릿 시스템을 사용해 봅시다."

msgid ""
"First, create a directory called ``templates`` in your ``polls`` directory. "
"Django will look for templates in there."
msgstr ""
"우선, ``polls`` 디렉토리에 ``templates``\\라는 디렉토리를 만듭니다. Django는 "
"여기서 템플릿을 찾게 될 것입니다."

msgid ""
"Your project's :setting:`TEMPLATES` setting describes how Django will load "
"and render templates. The default settings file configures a "
"``DjangoTemplates`` backend whose :setting:`APP_DIRS <TEMPLATES-APP_DIRS>` "
"option is set to ``True``. By convention ``DjangoTemplates`` looks for a "
"\"templates\" subdirectory in each of the :setting:`INSTALLED_APPS`."
msgstr ""
"프로젝트의 :setting:`TEMPLATES` 설정은 Django가 어떻게 템플릿을 불러오고 렌더"
"링 할 것인지 기술합니다. 기본 설정 파일은 :setting:`APP_DIRS <TEMPLATES-"
"APP_DIRS>` 옵션이 ``True``\\로 설정된 ``DjangoTemplates`` 백엔드를 구성합니"
"다. 관례에 따라, ``DjangoTemplates``\\은 각 :setting:`INSTALLED_APPS` 디렉토"
"리의 \"templates\" 하위 디렉토리를 탐색합니다."

msgid ""
"Within the ``templates`` directory you have just created, create another "
"directory called ``polls``, and within that create a file called ``index."
"html``. In other words, your template should be at ``polls/templates/polls/"
"index.html``. Because of how the ``app_directories`` template loader works "
"as described above, you can refer to this template within Django as ``polls/"
"index.html``."
msgstr ""
"방금 만든 ``templates`` 디렉터리 내에 ``polls`` 라는 다른 디렉터리를 만들고 "
"그 안에 ``index.html`` 이라는 파일을 만듭니다. 즉, 템플릿은 ``polls/"
"templates/polls/index.html``이어야 합니다. 위에서 설명한 것처럼 "
"``app_directories`` 템플릿 로더가 작동하는 방식 때문에 Django 내에 있는 이 템"
"플릿을 ``polls/index.html``로 지칭할 수 있습니다."

msgid "Template namespacing"
msgstr "템플릿 네임스페이싱"

msgid ""
"Now we *might* be able to get away with putting our templates directly in "
"``polls/templates`` (rather than creating another ``polls`` subdirectory), "
"but it would actually be a bad idea. Django will choose the first template "
"it finds whose name matches, and if you had a template with the same name in "
"a *different* application, Django would be unable to distinguish between "
"them. We need to be able to point Django at the right one, and the best way "
"to ensure this is by *namespacing* them. That is, by putting those templates "
"inside *another* directory named for the application itself."
msgstr ""
"이제 우리는 템플릿을 ``polls/templates`` 에 직접 넣는 것에서 벗어날 수 *있을"
"지도 모르지만* (또 다른 ``polls`` 하위 디렉토리를 만드는 것보다는) 실제로는 "
"좋은 생각이 아닙니다. Django는 이름이 일치하는 첫 번째 템플릿을 선택하는데 만"
"약 *다른* 응용 프로그램에 같은 이름의 템플릿이 있으면 Django는 이러한 템플릿"
"을 구별할 수 없습니다. Django에게 정확한 템플릿을 지정하기 위해서 가장 편리"
"한 방법은 *이름공간*으로 구분짓는 것입니다. 이것은 애플리케이션의 이름으로 "
"된 디렉토리에 이러한 템플릿들을 넣으면 됩니다."

msgid "Put the following code in that template:"
msgstr "템플릿에 다음과 같은 코드를 입력합니다."

msgid "``polls/templates/polls/index.html``"
msgstr "``polls/templates/polls/index.html``"

msgid ""
"To make the tutorial shorter, all template examples use incomplete HTML. In "
"your own projects you should use `complete HTML documents`__."
msgstr ""
"튜토리얼을 짧게 하기 위해 모든 템플릿 예제가 불완전한 HTML을 사용합니다. 자신"
"의 프로젝트에서는 `complete HTML documents`__를 사용해야 합니다."

msgid ""
"Now let's update our ``index`` view in ``polls/views.py`` to use the "
"template:"
msgstr ""
"이제, 템플릿을 이용하여 ``polls/views.py``\\에 ``index`` 뷰를 업데이트 해보도"
"록 하겠습니다."

msgid ""
"That code loads the template called  ``polls/index.html`` and passes it a "
"context. The context is a dictionary mapping template variable names to "
"Python objects."
msgstr ""
"이 코드는 ``polls/index.html`` 템플릿을 불러온 후, context를 전달합니다. "
"context는 템플릿에서 쓰이는 변수명과 Python 객체를 연결하는 사전형 값입니다."

msgid ""
"Load the page by pointing your browser at \"/polls/\", and you should see a "
"bulleted-list containing the \"What's up\" question from :doc:`Tutorial 2 </"
"intro/tutorial02>`. The link points to the question's detail page."
msgstr ""
"브라우저에서 \"/polls/\" 페이지를 불러오면, :doc:`튜토리얼 2장 </intro/"
"tutorial02>`\\에서 작성한 \"What's up\" 질문이 포함된 리스트가 표시됩니다. 표"
"시된 질문의 링크는 해당 질문에 대한 세부 페이지를 가리킵니다."

msgid "A shortcut: :func:`~django.shortcuts.render`"
msgstr "지름길: :func:`~django.shortcuts.render`"

msgid ""
"It's a very common idiom to load a template, fill a context and return an :"
"class:`~django.http.HttpResponse` object with the result of the rendered "
"template. Django provides a shortcut. Here's the full ``index()`` view, "
"rewritten:"
msgstr ""
"템플릿에 context 를 채워넣어 표현한 결과를 :class:`~django.http."
"HttpResponse` 객체와 함께 돌려주는 구문은 자주 쓰는 용법입니다. 따라서 Django"
"는 이런 표현을 쉽게 표현할 수 있도록 단축 기능(shortcuts)을 제공합니다. "
"``index()`` 뷰를 단축 기능으로 작성하면 다음과 같습니다."

msgid ""
"Note that once we've done this in all these views, we no longer need to "
"import :mod:`~django.template.loader` and :class:`~django.http.HttpResponse` "
"(you'll want to keep ``HttpResponse`` if you still have the stub methods for "
"``detail``, ``results``, and ``vote``)."
msgstr ""
"모든 뷰에 적용한다면, 더 이상 :mod:`~django.template.loader`\\와 :class:"
"`~django.http.HttpResponse`\\를 가져오지 않아도 됩니다. (만약 ``detail``, "
"``results``, ``vote``\\에서 stub 메소드를 가지고 있다면, "
"``HttpResponse``\\를 유지해야 할 것입니다.)"

msgid ""
"The :func:`~django.shortcuts.render` function takes the request object as "
"its first argument, a template name as its second argument and a dictionary "
"as its optional third argument. It returns an :class:`~django.http."
"HttpResponse` object of the given template rendered with the given context."
msgstr ""
":func:`~django.shortcuts.render` 함수는 request 객체를 첫번째 인수로 받고, 템"
"플릿 이름을 두번째 인수로 받으며, context 사전형 객체를 세전째 선택적"
"(optional) 인수로 받습니다. 인수로 지정된 context로 표현된 템플릿의 :class:"
"`~django.http.HttpResponse` 객체가 반환됩니다."

msgid "Raising a 404 error"
msgstr "404 에러 일으키기"

msgid ""
"Now, let's tackle the question detail view -- the page that displays the "
"question text for a given poll. Here's the view:"
msgstr ""
"이제, 질문의 상세 뷰에 태클을 걸어보겠습니다. 상세 뷰는 지정된 설문조사의 질"
"문 내용을 보여줍니다. 다음과 같습니다."

msgid ""
"The new concept here: The view raises the :exc:`~django.http.Http404` "
"exception if a question with the requested ID doesn't exist."
msgstr ""
"여기 새로운 내용이 추가되었습니다. 뷰는 요청된 질문의 ID 가 없을 경우 :exc:"
"`~django.http.Http404` 예외를 발생시킵니다."

msgid ""
"We'll discuss what you could put in that ``polls/detail.html`` template a "
"bit later, but if you'd like to quickly get the above example working, a "
"file containing just:"
msgstr ""
"조금 후에 ``polls/detail.html`` 템플릿에 무엇을 넣을 수 있는지 논의하겠지만, "
"일단 위의 예제를 동작시키기 위해 아래의 내용이 들어있는 파일을 작성하세요."

msgid "``polls/templates/polls/detail.html``"
msgstr "``polls/templates/polls/detail.html``"

msgid "will get you started for now."
msgstr "이제 시작해도 됩니다."

msgid "A shortcut: :func:`~django.shortcuts.get_object_or_404`"
msgstr "지름길: :func:`~django.shortcuts.get_object_or_404`"

msgid ""
"It's a very common idiom to use :meth:`~django.db.models.query.QuerySet.get` "
"and raise :exc:`~django.http.Http404` if the object doesn't exist. Django "
"provides a shortcut. Here's the ``detail()`` view, rewritten:"
msgstr ""
"만약 객체가 존재하지 않을 때 :meth:`~django.db.models.query.QuerySet.get` 을 "
"사용하여 :exc:`~django.http.Http404` 예외를 발생시키는것은 자주 쓰이는 용법입"
"니다. Django에서 이 기능에 대한 단축 기능을 제공합니다. ``detail()`` 뷰를 단"
"축 기능으로 작성하면 다음과 같습니다."

msgid ""
"The :func:`~django.shortcuts.get_object_or_404` function takes a Django "
"model as its first argument and an arbitrary number of keyword arguments, "
"which it passes to the :meth:`~django.db.models.query.QuerySet.get` function "
"of the model's manager. It raises :exc:`~django.http.Http404` if the object "
"doesn't exist."
msgstr ""
":func:`~django.shortcuts.get_object_or_404` 함수는 Django 모델을 첫번째 인자"
"로 받고, 몇개의 키워드 인수를 모델 관리자의 :meth:`~django.db.models.query."
"QuerySet.get` 함수에 넘깁니다. 만약 객체가 존재하지 않을 경우, :exc:`~django."
"http.Http404` 예외가 발생합니다."

msgid ""
"Why do we use a helper function :func:`~django.shortcuts.get_object_or_404` "
"instead of automatically catching the :exc:`~django.core.exceptions."
"ObjectDoesNotExist` exceptions at a higher level, or having the model API "
"raise :exc:`~django.http.Http404` instead of :exc:`~django.core.exceptions."
"ObjectDoesNotExist`?"
msgstr ""
"상위 계층에서 :exc:`~django.core.exceptions.ObjectDoesNotExist` 예외를 자동으"
"로 잡아 내는 대신 :func:`~django.shortcuts.get_object_or_404` 도움 함수"
"(helper functoin)를 사용하거나, :exc:`~django.core.exceptions."
"ObjectDoesNotExist` 예외를 사용하는 대신 :exc:`~django.http.Http404` 를 사용"
"하는 이유는 무엇일까요?"

msgid ""
"Because that would couple the model layer to the view layer. One of the "
"foremost design goals of Django is to maintain loose coupling. Some "
"controlled coupling is introduced in the :mod:`django.shortcuts` module."
msgstr ""
"왜냐하면, 모델 계층을 뷰 계층에 연결하는 방법이기 때문입니다. Django의 중요"
"한 설계 목표는, 약결합(loose coupling)을 관리하는 데에 있습니다. 일부 제어된 "
"결합이 :mod:`django.shortcuts` 모듈에서 도입되었습니다."

msgid ""
"There's also a :func:`~django.shortcuts.get_list_or_404` function, which "
"works just as :func:`~django.shortcuts.get_object_or_404` -- except using :"
"meth:`~django.db.models.query.QuerySet.filter` instead of :meth:`~django.db."
"models.query.QuerySet.get`. It raises :exc:`~django.http.Http404` if the "
"list is empty."
msgstr ""
"또한, :func:`~django.shortcuts.get_object_or_404` 함수처럼 동작하는 :func:"
"`~django.shortcuts.get_list_or_404` 함수가 있습니다. :meth:`~django.db."
"models.query.QuerySet.get` 대신 :meth:`~django.db.models.query.QuerySet."
"filter` 를 쓴다는 것이 다릅니다. 리스트가 비어있을 경우, :exc:`~django.http."
"Http404` 예외를 발생시킵니다."

msgid "Use the template system"
msgstr "템플릿 시스템 사용하기"

msgid ""
"Back to the ``detail()`` view for our poll application. Given the context "
"variable ``question``, here's what the ``polls/detail.html`` template might "
"look like:"
msgstr ""
"투표 어플리케이션의 ``detail()`` 뷰로 되돌아가 봅시다. context 변수 "
"``question``\\이 주어졌을때, ``polls/detail.html``\\이라는 템플릿이 어떻게 보"
"이는지 봅시다."

msgid ""
"The template system uses dot-lookup syntax to access variable attributes. In "
"the example of ``{{ question.question_text }}``, first Django does a "
"dictionary lookup on the object ``question``. Failing that, it tries an "
"attribute lookup -- which works, in this case. If attribute lookup had "
"failed, it would've tried a list-index lookup."
msgstr ""
"템플릿 시스템은 변수의 속성에 접근하기 위해 점-탐색(dot-lookup) 문법을 사용합"
"니다. 예제의 ``{{ question.question_text }}`` 구문을 보면, Django는 먼저 "
"``question`` 객체에 대해 사전형으로 탐색합니다. 탐색에 실패하게 되면 속성값으"
"로 탐색합니다. (이 예에서는 속성값에서 탐색이 완료됩니다만) 만약 속성 탐색에"
"도 실패한다면 리스트의 인덱스 탐색을 시도하게 됩니다. "

msgid ""
"Method-calling happens in the :ttag:`{% for %}<for>` loop: ``question."
"choice_set.all`` is interpreted as the Python code ``question.choice_set."
"all()``, which returns an iterable of ``Choice`` objects and is suitable for "
"use in the :ttag:`{% for %}<for>` tag."
msgstr ""
":ttag:`{% for %}<for>` 반복 구문에서 메소드 호출이 일어납니다. ``question."
"choice_set.all``\\은 Python에서 ``question.choice_set.all()`` 코드로 해석되는"
"데, 이때 반환된 ``Choice`` 객체의 반복자는 :ttag:`{% for %}<for>`\\에서 사용"
"하기 적당합니다."

msgid ""
"See the :doc:`template guide </topics/templates>` for more about templates."
msgstr ""
"템플릿에 대한 더 많은 정보는 :doc:`템플릿 지침서 </topics/templates>`\\를 참"
"고하세요."

msgid "Removing hardcoded URLs in templates"
msgstr "템플릿에서 하드코딩된 URL 제거하기"

msgid ""
"Remember, when we wrote the link to a question in the ``polls/index.html`` "
"template, the link was partially hardcoded like this:"
msgstr ""
"``polls/index.html`` 템플릿에 링크를 적으면, 이 링크는 다음과 같이 부분적으"
"로 하드코딩된다는 것을 기억하세요."

msgid ""
"The problem with this hardcoded, tightly-coupled approach is that it becomes "
"challenging to change URLs on projects with a lot of templates. However, "
"since you defined the name argument in the :func:`~django.urls.path` "
"functions in the ``polls.urls`` module, you can remove a reliance on "
"specific URL paths defined in your url configurations by using the ``{% url "
"%}`` template tag:"
msgstr ""
"이러한 강력하게 결합되고 하드코딩된 접근방식의 문제는 수 많은 템플릿을 가진 "
"프로젝트들의 URL을 바꾸는 게 어려운 일이 된다는 점입니다. 그러나, ``polls."
"urls`` 모듈의 :func:`~django.urls.path` 함수에서 인수의 이름을 정의했으므로, "
"``{% url %}`` template 태그를 사용하여 url 설정에 정의된 특정한 URL 경로들의 "
"의존성을 제거할 수 있습니다."

msgid ""
"The way this works is by looking up the URL definition as specified in the "
"``polls.urls`` module. You can see exactly where the URL name of 'detail' is "
"defined below::"
msgstr ""
"이것이 ``polls.urls`` 모듈에 서술된 URL 의 정의를 탐색하는 식으로 동작합니"
"다. 다음과 같이 'detail' 이라는 이름의 URL 이 어떻게 정의되어 있는지 확인할 "
"수 있습니다."

msgid ""
"If you want to change the URL of the polls detail view to something else, "
"perhaps to something like ``polls/specifics/12/`` instead of doing it in the "
"template (or templates) you would change it in ``polls/urls.py``::"
msgstr ""
"만약 상세 뷰의 URL을 ``polls/specifics/12/``\\로 바꾸고 싶다면, 템플릿에서 바"
"꾸는 것이 아니라 ``polls/urls.py``\\에서 바꿔야 합니다."

msgid "Namespacing URL names"
msgstr "URL의 이름공간 정하기"

msgid ""
"The tutorial project has just one app, ``polls``. In real Django projects, "
"there might be five, ten, twenty apps or more. How does Django differentiate "
"the URL names between them? For example, the ``polls`` app has a ``detail`` "
"view, and so might an app on the same project that is for a blog. How does "
"one make it so that Django knows which app view to create for a url when "
"using the ``{% url %}`` template tag?"
msgstr ""
"튜토리얼의 프로젝트는 ``polls``\\라는 앱 하나만 가지고 진행했습니다. 실제 "
"Django 프로젝트는 앱이 몇개라도 올 수 있습니다. Django는 이 앱들의 URL을 어떻"
"게 구별해 낼까요? 예를 들어, ``polls`` 앱은 ``detail``\\이라는 뷰를 가지고 있"
"고, 동일한 프로젝트에 블로그를 위한 앱이 있을 수도 있습니다. Django가 ``{% "
"url %}`` 템플릿태그를 사용할 때, 어떤 앱의 뷰에서 URL을 생성할지 알 수 있을까"
"요?"

msgid ""
"The answer is to add namespaces to your  URLconf. In the ``polls/urls.py`` "
"file, go ahead and add an ``app_name`` to set the application namespace:"
msgstr ""
"정답은 URLconf에 이름공간(namespace)을 추가하는 것입니다. ``polls/urls.py`` "
"파일에 ``app_name``\\을 추가하여 어플리케이션의 이름공간을 설정할 수 있습니"
"다."

msgid "Now change your ``polls/index.html`` template from:"
msgstr "이제, ``polls/index.html`` 템플릿을 변경하십시오."

msgid "to point at the namespaced detail view:"
msgstr "아래와 같이 이름공간으로 나눠진 상세 뷰를 가리키도록 변경하세요."

msgid ""
"When you're comfortable with writing views, read :doc:`part 4 of this "
"tutorial </intro/tutorial04>` to learn the basics about form processing and "
"generic views."
msgstr ""
"view를 작성하는 것에 익숙해졌다면, :doc:`part 4 of this tutorial </intro/"
"tutorial04>` 에서 폼 처리 및 제너릭 뷰에 대한 기본 사항을 알아보십시오."

msgid "Writing your first Django app, part 4"
msgstr "첫 번째 장고 앱 작성하기, part 4"

msgid ""
"This tutorial begins where :doc:`Tutorial 3 </intro/tutorial03>` left off. "
"We're continuing the web-poll application and will focus on form processing "
"and cutting down our code."
msgstr ""
"이 튜토리얼은 :doc:`Tutorial 3 </intro/tutorial03>`에서 이어집니다. 우리는 계"
"속해서 Web-poll 애플리케이션을 진행하고 있고, 간단한 폼 처리와 소스코드를 줄"
"이는 데 중점을 둘 것입니다."

msgid "Write a minimal form"
msgstr "간단한 폼 쓰기"

msgid ""
"Let's update our poll detail template (\"polls/detail.html\") from the last "
"tutorial, so that the template contains an HTML ``<form>`` element:"
msgstr ""
"앞장의 투표 상세 템플릿(\"polls/detail.html\")을 수정하여, 템플릿에 HTML "
"``<form>`` 요소를 포함시켜 봅시다."

msgid "A quick rundown:"
msgstr "간략하게 설명하면:"

msgid ""
"The above template displays a radio button for each question choice. The "
"``value`` of each radio button is the associated question choice's ID. The "
"``name`` of each radio button is ``\"choice\"``. That means, when somebody "
"selects one of the radio buttons and submits the form, it'll send the POST "
"data ``choice=#`` where # is the ID of the selected choice. This is the "
"basic concept of HTML forms."
msgstr ""
"위의 템플릿은 각 질문 선택 항목에 대한 라디오 버튼을 표시합니다. 각 라디오 버"
"튼의 ``value``\\는 연관된 질문 선택 항목의 ID입니다. 각 라디오 버튼의 "
"``name``\\은  ``\"choice\"``\\입니다. 즉, 누군가가 라디오 버튼 중 하나를 선택"
"하여 폼을 제출하면, POST 데이터 인 ``choice=#``\\ 을 보낼 것입니다. 여기서 #"
"은 선택한 항목의 ID입니다. 이것은 HTML 폼의 기본 개념입니다."

msgid ""
"We set the form's ``action`` to ``{% url 'polls:vote' question.id %}``, and "
"we set ``method=\"post\"``. Using ``method=\"post\"`` (as opposed to "
"``method=\"get\"``) is very important, because the act of submitting this "
"form will alter data server-side. Whenever you create a form that alters "
"data server-side, use ``method=\"post\"``. This tip isn't specific to "
"Django; it's good web development practice in general."
msgstr ""
"양식의 ``action``을 ``{% url 'polls:vote' question.id %}``로 설정하고, "
"``method=\"post\"``로 설정합니다. 이 양식을 제출하는 행위는 데이터 서버측을 "
"변화시키기 때문에 ``method=\"post\"`` (``method=\"get\"``과 반대로)를 사용하"
"는 것은 매우 중요합니다. 데이터 서버측을 변경하는 양식을 만들 때마다 "
"``method=\"post\"``를 사용하십시오. 이 팁은 Django에만 국한된 것이 아니라 일"
"반적인 좋은 웹 개발 관행입니다."

msgid ""
"``forloop.counter`` indicates how many times the :ttag:`for` tag has gone "
"through its loop"
msgstr "``forloop.counter`` 는 :ttag:`for` 태그가 반복을 한 횟수를 나타냅니다."

msgid ""
"Since we're creating a POST form (which can have the effect of modifying "
"data), we need to worry about Cross Site Request Forgeries. Thankfully, you "
"don't have to worry too hard, because Django comes with a helpful system for "
"protecting against it. In short, all POST forms that are targeted at "
"internal URLs should use the :ttag:`{% csrf_token %}<csrf_token>` template "
"tag."
msgstr ""
"POST 양식을 만들고 있기 때문에(데이터를 수정하는 효과가 있을 수 있음), 교차 "
"사이트 요청 위조(Cross Site Request Forgeries)에 대해 걱정해야 합니다. 다행히"
"도, 여러분은 너무 걱정하지 않아도 됩니다, 왜냐하면 Django는 그것으로부터 보호"
"하는 유용한 시스템을 가지고 있기 때문입니다. 간단히 말하자면, 내부 URL을 대상"
"으로 하는 모든 POST 양식은 :ttag:`{% csrf_token %}<csrf_token>` 템플릿 태그"
"를 사용해야 합니다."

msgid ""
"Now, let's create a Django view that handles the submitted data and does "
"something with it. Remember, in :doc:`Tutorial 3 </intro/tutorial03>`, we "
"created a URLconf for the polls application that includes this line:"
msgstr ""
"이제 제출된 데이터를 처리하고 그 데이터로 무언가를 수행하는 Django 뷰를 작성"
"하겠습니다. :doc:`튜토리얼 3 </intro/tutorial03>` 에서 설문조사 어플리케이션"
"을 위해 아래에 나와있는 코드를 포함하는 URLconf 를 만들었습니다:"

msgid ""
"We also created a dummy implementation of the ``vote()`` function. Let's "
"create a real version. Add the following to ``polls/views.py``:"
msgstr ""
"또, 우리는 ``vote()`` 함수를 가상으로 만들었습니다. 실제로 구현을 해봅시다. "
"``polls/views.py`` 에 다음을 추가합시다:"

msgid ""
"This code includes a few things we haven't covered yet in this tutorial:"
msgstr ""
"위 코드는 이 튜토리얼에서 아직 다루지 않은 몇 가지를 포함하고 있습니다:"

msgid ""
":attr:`request.POST <django.http.HttpRequest.POST>` is a dictionary-like "
"object that lets you access submitted data by key name. In this case, "
"``request.POST['choice']`` returns the ID of the selected choice, as a "
"string. :attr:`request.POST <django.http.HttpRequest.POST>` values are "
"always strings."
msgstr ""
":attr:`request.POST <django.http.HttpRequest.POST>` 는 키로 전송된 자료에 접"
"근할 수 있도록 해주는 사전과 같은 객체입니다. 이 경우, ``request."
"POST['choice']`` 는 선택된 설문의 ID를 문자열로 반환합니다. :attr:`request."
"POST <django.http.HttpRequest.POST>` 의 값은 항상 문자열들입니다."

msgid ""
"Note that Django also provides :attr:`request.GET <django.http.HttpRequest."
"GET>` for accessing GET data in the same way -- but we're explicitly using :"
"attr:`request.POST <django.http.HttpRequest.POST>` in our code, to ensure "
"that data is only altered via a POST call."
msgstr ""
"Django는 같은 방법으로 GET 자료에 접근하기 위해 :attr:`request.GET <django."
"http.HttpRequest.GET>` 를 제공합니다 -- 그러나 POST 요청을 통해서만 자료가 수"
"정되게하기 위해서, 명시적으로 코드에 :attr:`request.POST <django.http."
"HttpRequest.POST>` 를 사용하고 있습니다."

msgid ""
"``request.POST['choice']`` will raise :exc:`KeyError` if ``choice`` wasn't "
"provided in POST data. The above code checks for :exc:`KeyError` and "
"redisplays the question form with an error message if ``choice`` isn't given."
msgstr ""
"만약 POST 자료에 ``choice`` 가 없으면, ``request.POST['choice']`` 는 :exc:"
"`KeyError` 가 일어납니다. 위의 코드는 :exc:`KeyError` 를 체크하고, choice가 "
"주어지지 않은 경우에는 에러 메시지와 함께 설문조사 폼을 다시보여줍니다."

msgid ""
"After incrementing the choice count, the code returns an :class:`~django."
"http.HttpResponseRedirect` rather than a normal :class:`~django.http."
"HttpResponse`. :class:`~django.http.HttpResponseRedirect` takes a single "
"argument: the URL to which the user will be redirected (see the following "
"point for how we construct the URL in this case)."
msgstr ""
"설문지의 수가 증가한 이후에, 코드는 일반 :class:`~django.http.HttpResponse` "
"가 아닌 :class:`~django.http.HttpResponseRedirect` 를 반환하고, :class:"
"`~django.http.HttpResponseRedirect` 는 하나의 인수를 받습니다: 그 인수는 사용"
"자가 재전송될 URL 입니다. (이 경우에 우리가 URL을 어떻게 구성하는지 다음 항목"
"을 보세요)."

msgid ""
"As the Python comment above points out, you should always return an :class:"
"`~django.http.HttpResponseRedirect` after successfully dealing with POST "
"data. This tip isn't specific to Django; it's good web development practice "
"in general."
msgstr ""
"위의 Python 주석에서 지적한 바와 같이 POST 데이터를 성공적으로 처리 한 후에"
"는 항상 :class:`~django.http.HttpResponseRedirect` 를 반환해야 합니다. 이 팁"
"은 Django에만 국한된 것이 아니라 일반적으로 좋은 웹 개발 관행입니다."

msgid ""
"We are using the :func:`~django.urls.reverse` function in the :class:"
"`~django.http.HttpResponseRedirect` constructor in this example. This "
"function helps avoid having to hardcode a URL in the view function. It is "
"given the name of the view that we want to pass control to and the variable "
"portion of the URL pattern that points to that view. In this case, using the "
"URLconf we set up in :doc:`Tutorial 3 </intro/tutorial03>`, this :func:"
"`~django.urls.reverse` call will return a string like ::"
msgstr ""
"우리는 이 예제에서 :class:`~django.http.HttpResponseRedirect` 생성자 안에서 :"
"func:`~django.urls.reverse` 함수를 사용하고 있습니다. 이 함수는 뷰 함수에서 "
"URL을 하드코딩하지 않도록 도와줍니다. 제어를 전달하기 원하는 뷰의 이름을, URL"
"패턴의 변수부분을 조합해서 해당 뷰를 가리킵니다. 여기서 우리는 :doc:`튜토리"
"얼 3장 </intro/tutorial03>`\\에서 설정했던 URLconf를 사용하였으며, 이 :func:"
"`~django.urls.reverse` 호출은 아래와 같은 문자열을 반환할 것입니다."

msgid ""
"where the ``3`` is the value of ``question.id``. This redirected URL will "
"then call the ``'results'`` view to display the final page."
msgstr ""
"여기서 ``3`` 은 ``question.id`` 값입니다. 이렇게 리디렉션된 URL은 최종 페이지"
"를 표시하기 위해 ``'results'`` 뷰를 호출합니다."

msgid ""
"As mentioned in :doc:`Tutorial 3 </intro/tutorial03>`, ``request`` is an :"
"class:`~django.http.HttpRequest` object. For more on :class:`~django.http."
"HttpRequest` objects, see the :doc:`request and response documentation </ref/"
"request-response>`."
msgstr ""
":doc:`튜토리얼 3장 </intro/tutorial03>`\\에서 언급했듯이, ``request`` 는 :"
"class:`~django.http.HttpRequest` 개체입니다. :class:`~django.http."
"HttpRequest` 개체에 대해 더 알고 싶다면  :doc:`request와 response 문서 </ref/"
"request-response>`\\를 참고하세요."

msgid ""
"After somebody votes in a question, the ``vote()`` view redirects to the "
"results page for the question. Let's write that view:"
msgstr ""
"어떤 이가 설문조사에 설문을 하고난 뒤에는, ``vote()`` 뷰는 설문조사 결과 페이"
"지로 리다이렉트합니다. 그 뷰를 작성해봅시다:"

msgid ""
"This is almost exactly the same as the ``detail()`` view from :doc:`Tutorial "
"3 </intro/tutorial03>`. The only difference is the template name. We'll fix "
"this redundancy later."
msgstr ""
":doc:`튜토리얼 3장 </intro/tutorial03>`\\의 ``detail()`` 뷰와 거의 동일합니"
"다. 템플릿 이름만 다릅니다. 나중에 이 중복을 수정할 겁니다."

msgid "Now, create a ``polls/results.html`` template:"
msgstr "이제, ``polls/results.html`` 템플릿을 만듭니다."

msgid "``polls/templates/polls/results.html``"
msgstr "``polls/templates/polls/results.html``"

msgid ""
"Now, go to ``/polls/1/`` in your browser and vote in the question. You "
"should see a results page that gets updated each time you vote. If you "
"submit the form without having chosen a choice, you should see the error "
"message."
msgstr ""
"이제, 웹 브라우저에서 ``/polls/1/`` 페이지로 가서, 투표를 해보세요. 당신이 투"
"표를 할 때마다 값이 반영된 결과 페이지를 볼 수 있을 것입니다. 만약 당신이 설"
"문지를 선택하지 않고 폼을 전송했다면, 오류 메시지를 보게 될 것입니다."

msgid ""
"The code for our ``vote()`` view does have a small problem. It first gets "
"the ``selected_choice`` object from the database, then computes the new "
"value of ``votes``, and then saves it back to the database. If two users of "
"your website try to vote at *exactly the same time*, this might go wrong: "
"The same value, let's say 42, will be retrieved for ``votes``. Then, for "
"both users the new value of 43 is computed and saved, but 44 would be the "
"expected value."
msgstr ""
"우리의 ``vote()`` 뷰에는 작은 문제가 있습니다. 먼저 데이터베이스에서 "
"``selected_choice`` 객체를 가져온 다음, ``votes`` 의 새 값을 계산하고 나서,  "
"데이터베이스에 다시 저장합니다. 만약 여러분의 웹사이트에 두 명의 사용자가 *정"
"확하게 같은 시간* 에 투표를 할려고 시도할 경우, 잘못될 수 있습니다.  "
"``votes`` 의 조회값이 42라고 할 경우, 두 명의 사용자에게 새로운 값인 43이 계"
"산 되고, 저장됩니다. 그러나 44가 되야되겠죠."

msgid ""
"This is called a *race condition*. If you are interested, you can read :ref:"
"`avoiding-race-conditions-using-f` to learn how you can solve this issue."
msgstr ""
"이를 *경쟁 상태* 라 합니다. 이 문제를 해결할 수 있는 방법을 알아보려면 :ref:"
"`avoiding-race-conditions-using-f` 를 참고하세요."

msgid "Use generic views: Less code is better"
msgstr "제너릭 뷰 사용하기: 적은 코드가 더 좋습니다."

msgid ""
"The ``detail()`` (from :doc:`Tutorial 3 </intro/tutorial03>`) and "
"``results()`` views are very short -- and, as mentioned above, redundant. "
"The ``index()`` view, which displays a list of polls, is similar."
msgstr ""
"``detail()`` (from :doc:`Tutorial 3 </intro/tutorial03>`)과 ``results()``의 "
"view들은 매우 간단하며, 위에서 언급한 바와 같이 중복됩니다. 여론조사 목록을 "
"보여주는 ``index()`` view도 비슷합니다."

msgid ""
"These views represent a common case of basic web development: getting data "
"from the database according to a parameter passed in the URL, loading a "
"template and returning the rendered template. Because this is so common, "
"Django provides a shortcut, called the \"generic views\" system."
msgstr ""
"이러한 보기는 URL에 전달된 매개 변수에 따라 데이터베이스에서 데이터를 가져오"
"고, 템플릿을 로드하고, 렌더링된 템플릿을 반환하는 기본 웹 개발의 일반적인 경"
"우를 나타냅니다. 이것이 매우 흔하기 때문에, Django는 \"generic views\" 시스템"
"이라고 불리는 단축키를 제공합니다."

msgid ""
"Generic views abstract common patterns to the point where you don't even "
"need to write Python code to write an app. For example, the :class:`~django."
"views.generic.list.ListView` and :class:`~django.views.generic.detail."
"DetailView` generic views abstract the concepts of \"display a list of "
"objects\" and \"display a detail page for a particular type of object\" "
"respectively."
msgstr ""

msgid ""
"Let's convert our poll app to use the generic views system, so we can delete "
"a bunch of our own code. We'll have to take a few steps to make the "
"conversion. We will:"
msgstr ""
"우리 설문조사 애플리케이션을 제너릭 뷰 시스템으로 변환해서 우리의 코드를 많"
"이 삭제하도록 합시다. 이러한 전환을 하려면 다음과 같은 몇 가지 단계만 거치면 "
"됩니다:"

msgid "Convert the URLconf."
msgstr "URLconf를 변환하십시오."

msgid "Delete some of the old, unneeded views."
msgstr "불필요한 오래된보기 중 일부를 삭제하십시오."

msgid "Introduce new views based on Django's generic views."
msgstr "Django의 제너릭 뷰를 기반으로 새로운 뷰를 도입하십시오."

msgid "Read on for details."
msgstr "자세한 내용은 계속 읽어 나가십시오."

msgid "Why the code-shuffle?"
msgstr "왜 코드 셔플인가?"

msgid ""
"Generally, when writing a Django app, you'll evaluate whether generic views "
"are a good fit for your problem, and you'll use them from the beginning, "
"rather than refactoring your code halfway through. But this tutorial "
"intentionally has focused on writing the views \"the hard way\" until now, "
"to focus on core concepts."
msgstr ""
"일반적으로 Django 앱을 작성할 때 일반 뷰가 문제에 적합한 지 여부를 평가할 것"
"이며 코드를 중간에서 다시 리팩토링하지 않고 처음부터 사용하게됩니다. 그러나 "
"이 튜토리얼은 의도적으로 현재까지 핵심 개념에 초점을 맞추기 위해 \"어려운 방"
"법\"으로 뷰를 작성하는 데 중점을 두었습니다."

msgid "You should know basic math before you start using a calculator."
msgstr "계산기를 사용하기 전에 기본 수학을 알아야합니다."

msgid "Amend URLconf"
msgstr "URLconf 수정"

msgid "First, open the ``polls/urls.py`` URLconf and change it like so:"
msgstr "먼저, ``polls/urls.py`` URLconf를 열어 다음과 같이 변경하십시오:"

msgid ""
"Note that the name of the matched pattern in the path strings of the second "
"and third patterns has changed from ``<question_id>`` to ``<pk>``. This is "
"necessary because we'll use the :class:`~django.views.generic.detail."
"DetailView` generic view to replace our ``detail()`` and ``results()`` "
"views, and it expects the primary key value captured from the URL to be "
"called ``\"pk\"``."
msgstr ""

msgid "Amend views"
msgstr "views 수정"

msgid ""
"Next, we're going to remove our old ``index``, ``detail``, and ``results`` "
"views and use Django's generic views instead. To do so, open the ``polls/"
"views.py`` file and change it like so:"
msgstr ""
"다음으로 이전의 ``index``, ``detail``, ``results``\\ 뷰를 제거하고 장고의 일"
"반적인 뷰를 대신 사용하겠습니다. 그렇게하려면 ``polls/views.py`` 파일을 열고 "
"다음과 같이 변경하십시오:"

msgid ""
"Each generic view needs to know what model it will be acting upon. This is "
"provided using either the ``model`` attribute (in this example, ``model = "
"Question`` for  ``DetailView`` and ``ResultsView``) or by defining the :meth:"
"`~django.views.generic.list.MultipleObjectMixin.get_queryset` method (as "
"shown in ``IndexView``)."
msgstr ""

msgid ""
"By default, the :class:`~django.views.generic.detail.DetailView` generic "
"view uses a template called ``<app name>/<model name>_detail.html``. In our "
"case, it would use the template ``\"polls/question_detail.html\"``. The "
"``template_name`` attribute is used to tell Django to use a specific "
"template name instead of the autogenerated default template name. We also "
"specify the ``template_name`` for the ``results`` list view -- this ensures "
"that the results view and the detail view have a different appearance when "
"rendered, even though they're both a :class:`~django.views.generic.detail."
"DetailView` behind the scenes."
msgstr ""
"기본적으로 :class:`~django.views.generic.detail.DetailView` 제너릭 뷰는 "
"``<app name>/<model name>_detail.html`` 템플릿을 사용합니다. 우리의 경우에는 "
"``\"polls/question_detail.html\"``\\ 템플릿을 사용할 것입니다. "
"``template_name`` 속성은 Django에게 자동 생성 된 기본 템플릿 이름 대신에 특"
"정 템플릿 이름을 사용하도록 알려주기 위해 사용됩니다. ``results``\\ 리스트 뷰"
"에 대해서 ``template_name``\\ 을 지정합니다 - 결과 뷰와 상세 뷰가 렌더링 될 "
"때 서로 다른 모습을 갖도록합니다. 이들이 둘다 동일한 :class:`~django.views."
"generic.detail.DetailView`\\ 를 사용하고 있더라도 말이지요."

msgid ""
"Similarly, the :class:`~django.views.generic.list.ListView` generic view "
"uses a default template called ``<app name>/<model name>_list.html``; we use "
"``template_name`` to tell :class:`~django.views.generic.list.ListView` to "
"use our existing ``\"polls/index.html\"`` template."
msgstr ""
"마찬가지로, :class:`~django.views.generic.list.ListView` 제네릭 뷰는 ``<app "
"name>/<model name>_list.html`` 템플릿을 기본으로 사용합니다; 이미 있는 "
"``\"polls/index.html\"`` 템플릿을 사용하기 위해 :class:`~django.views."
"generic.list.ListView` 에 ``template_name`` 를 전달했습니다."

msgid ""
"In previous parts of the tutorial, the templates have been provided with a "
"context that contains the ``question`` and ``latest_question_list`` context "
"variables. For ``DetailView`` the ``question`` variable is provided "
"automatically -- since we're using a Django model (``Question``), Django is "
"able to determine an appropriate name for the context variable. However, for "
"ListView, the automatically generated context variable is ``question_list``. "
"To override this we provide the ``context_object_name`` attribute, "
"specifying that we want to use ``latest_question_list`` instead. As an "
"alternative approach, you could change your templates to match the new "
"default context variables -- but it's a lot easier to tell Django to use the "
"variable you want."
msgstr ""
"튜토리얼의 이전 부분에서 템플릿은 ``question`` 및 ``latest_question_list`` 컨"
"텍스트 변수를 포함하는 컨텍스트와 함께 제공되었습니다. ``DetailView`` 의 경"
"우 ``question`` 변수가 자동으로 제공되는데, 이는 우리가 Django 모델"
"(``Question``)을 사용하고 있기 때문에 Django가 컨텍스트 변수의 적절한 이름을 "
"결정할 수 있습니다. 그러나 ListView의 경우 자동으로 생성되는 컨텍스트 변수는 "
"``question_list``입니다. 이것을 덮어 쓰려면 ``context_object_name`` 속성을 제"
"공하고, 대신에 ``latest_question_list`` 를 사용하도록 지정하십시오. 새로운 기"
"본 컨텍스트 변수와 일치하도록 템플릿을 변경할 수도 있지만, 원하는 변수를 사용"
"하도록 Django에게 지시하는 것이 훨씬 쉽습니다."

msgid "Run the server, and use your new polling app based on generic views."
msgstr "서버를 실행하고 제너릭 뷰를 기반으로한 새 설문조사 앱을 사용하십시오."

msgid ""
"For full details on generic views, see the :doc:`generic views documentation "
"</topics/class-based-views/index>`."
msgstr ""
"제너릭 뷰에 대한 자세한 내용은 :doc:`제너릭 뷰 문서 </topics/class-based-"
"views/index>`\\ 를 참조하십시오."

msgid ""
"When you're comfortable with forms and generic views, read :doc:`part 5 of "
"this tutorial</intro/tutorial05>` to learn about testing our polls app."
msgstr ""
"폼 및 제너릭 뷰가 마음에 들면, 이 설문조사 앱의 테스트에 대해 :doc:`튜토리얼"
"의 5장</intro/tutorial05>`\\ 을 읽어 배워 보기 바랍니다."

msgid "Writing your first Django app, part 5"
msgstr "첫 번째 장고 앱 작성하기, part 5"

msgid ""
"This tutorial begins where :doc:`Tutorial 4 </intro/tutorial04>` left off. "
"We've built a web-poll application, and we'll now create some automated "
"tests for it."
msgstr ""
"이 튜토리얼은 :doc:`튜토리얼 4장</intro/tutorial04>` 에서 이어집니다. 우리는 "
"Web-poll 어플리케이션을 구축했으며 이제 이를 위한 자동화된 테스트를 생성할 것"
"입니다."

msgid "Introducing automated testing"
msgstr "자동화된 테스트 소개"

msgid "What are automated tests?"
msgstr "자동화된 테스트란 무엇입니까?"

msgid "Tests are routines that check the operation of your code."
msgstr "테스트는 코드 작동을 확인하는 루틴입니다."

msgid ""
"Testing operates at different levels. Some tests might apply to a tiny "
"detail (*does a particular model method return values as expected?*) while "
"others examine the overall operation of the software (*does a sequence of "
"user inputs on the site produce the desired result?*). That's no different "
"from the kind of testing you did earlier in :doc:`Tutorial 2 </intro/"
"tutorial02>`, using the :djadmin:`shell` to examine the behavior of a "
"method, or running the application and entering data to check how it behaves."
msgstr ""
"테스트는 다양한 수준에서 작동합니다. 일부 테스트는 작은 세부 사항에 적용될 "
"수 있습니다 (*특정 모델 메서드는 예상대로 값을 반환합니까?*) 또 다른 테스트"
"는 소프트웨어의 전반적인 작동을 검사합니다 (*사이트에서 사용자 입력 시퀀스가 "
"원하는 결과를 생성합니까?*). 이것은 이전 :doc:`튜토리얼 2장 </intro/"
"tutorial02>`\\ 에서 :djadmin:`shell`\\ 을 사용하여 메소드의 동작을 검사하거"
"나 애플리케이션을 실행하고 어떻게 작동하는지 확인하기 위해 데이터를 입력해서 "
"테스트했던 것과 다르지 않습니다."

msgid ""
"What's different in *automated* tests is that the testing work is done for "
"you by the system. You create a set of tests once, and then as you make "
"changes to your app, you can check that your code still works as you "
"originally intended, without having to perform time consuming manual testing."
msgstr ""
"*자동화 된* 테스트에서 다른 점은 테스트 작업이 시스템에서 수행된다는 것입니"
"다. 한 번 테스트 세트를 작성한 이후에는 앱을 변경할 때 수동 테스트를 수행하"
"지 않아도 원래 의도대로 코드가 작동하는지 확인할 수 있습니다."

msgid "Why you need to create tests"
msgstr "테스트를 만들어야하는 이유"

msgid "So why create tests, and why now?"
msgstr "그래서 왜 테스트를 만들어야하고, 굳이 지금 해야할까요?"

msgid ""
"You may feel that you have quite enough on your plate just learning Python/"
"Django, and having yet another thing to learn and do may seem overwhelming "
"and perhaps unnecessary. After all, our polls application is working quite "
"happily now; going through the trouble of creating automated tests is not "
"going to make it work any better. If creating the polls application is the "
"last bit of Django programming you will ever do, then true, you don't need "
"to know how to create automated tests. But, if that's not the case, now is "
"an excellent time to learn."
msgstr ""
"아마 당신은 Python/Django를 배우는 것 만으로도 충분하다고 느낄수 있고 또 다른"
"것을 배우고 써보는것은 지나치거나 불필요해 보일수 있습니다. 어쨋든 간에 우리"
"의 설문조사 어플리케이션은 지금 꽤 잘 돌아고 있습니다. 문제들을 해쳐 나가며 "
"자동화된 테스트를 만드는게 이 어플리케이션을 작동하게 하거나 더 좋게 하지는 "
"않습니다. 만약 투표 어플리케이션을 만드는게 Django 프로그래밍의 최종 단계라"
"면, 자동화된 테스트를 어떻게 만드는지 알 필요는 없습니다. 하지만 아직 더 많은"
"것을 하려 한다면 지금이 자동화된 테스트 작성을 배우기 딱 좋은 시간입니다."

msgid "Tests will save you time"
msgstr "테스트를 통해 시간을 절약 할 수 있습니다."

msgid ""
"Up to a certain point, 'checking that it seems to work' will be a "
"satisfactory test. In a more sophisticated application, you might have "
"dozens of complex interactions between components."
msgstr ""
"특정 시점까지는 '제대로 작동하는지 확인' 하는것이 테스트로서 충분할 것 입니"
"다. 더 정교한 어플리케이션에서는 구성 요소간에 수십 개의 복잡한 상호 작용이있"
"을 수 있습니다."

msgid ""
"A change in any of those components could have unexpected consequences on "
"the application's behavior. Checking that it still 'seems to work' could "
"mean running through your code's functionality with twenty different "
"variations of your test data to make sure you haven't broken something - not "
"a good use of your time."
msgstr ""
"그러한 컴포넌트들 중 어느 하나에 대한 변경이 어플리케이션의 동작에 예기치 않"
"은 결과를 초래할 수 있습니다. 그것이 여전히 '작동하는 것처럼 보인다'는 것은 "
"당신이 무언가를 망가뜨리지 않았는지 확인하기 위해 당신의 코드 기능을 20가지"
"의 다른 시험 데이터 변형과 함께 실행한다는 것을 의미할 수 있습니다. - 그렇게"
"까지 할 필요는 없습니다."

msgid ""
"That's especially true when automated tests could do this for you in "
"seconds. If something's gone wrong, tests will also assist in identifying "
"the code that's causing the unexpected behavior."
msgstr ""
"이 수동 테스트 작업을 자동화된 테스트가 몇초만에 해낼수 있다면 귀한시간을 많"
"이 아낄수 있겠죠?. 무언가가 잘못되어도 테스트를 통해 예기치 않은 동작을 일으"
"키는 코드를 식별하는 데 도움이됩니다."

msgid ""
"Sometimes it may seem a chore to tear yourself away from your productive, "
"creative programming work to face the unglamorous and unexciting business of "
"writing tests, particularly when you know your code is working properly."
msgstr ""
"때로는 코드가 제대로 작동하고 있음을 알 때 테스트를 작성하는 것은 허드렛일로 "
"보여서 당신의 생산적이고 창의적인 프로그래밍 작업에서 떠나 매력적이지도 흥분"
"되지도 않는 테스트 작성이라는 일을 하는게 어려울수도 있습니다. "

msgid ""
"However, the task of writing tests is a lot more fulfilling than spending "
"hours testing your application manually or trying to identify the cause of a "
"newly-introduced problem."
msgstr ""
"그러나 테스트를 작성하는 작업은 어플리케이션을 수동으로 테스트하거나 새로 발"
"견된 문제의 원인을 확인하는 데 많은 시간을 투자하는 것보다 훨씬 더 효과적입니"
"다."

msgid "Tests don't just identify problems, they prevent them"
msgstr "테스트는 문제를 그저 식별하는 것이 아니라 예방합니다."

msgid ""
"It's a mistake to think of tests merely as a negative aspect of development."
msgstr "테스트를 그저 개발의 부정적 측면으로 생각하는 것은 실수입니다."

msgid ""
"Without tests, the purpose or intended behavior of an application might be "
"rather opaque. Even when it's your own code, you will sometimes find "
"yourself poking around in it trying to find out what exactly it's doing."
msgstr ""
"테스트가 없으면 어플리케이션의 목적 또는 의도 된 동작이 다소 불투명 할 수 있"
"습니다. 심지어 자신의 코드 일 때도, 정확히 무엇을하고 있는지 알아 내려고 노력"
"하게 됩니다."

msgid ""
"Tests change that; they light up your code from the inside, and when "
"something goes wrong, they focus light on the part that has gone wrong - "
"*even if you hadn't even realized it had gone wrong*."
msgstr ""
"테스트는 이 불투명함을 바꿉니다. 그들은 내부에서 코드를 밝혀 내고, 어떤 것이 "
"잘못 될 때, *그것이 잘못되었다는 것을 깨닫지 못했다고 할지라도, 잘못된 부분"
"에 빛을 집중시킵니다*."

msgid "Tests make your code more attractive"
msgstr "테스트가 코드를 더 매력적으로 만듭니다."

msgid ""
"You might have created a brilliant piece of software, but you will find that "
"many other developers will refuse to look at it because it lacks tests; "
"without tests, they won't trust it. Jacob Kaplan-Moss, one of Django's "
"original developers, says \"Code without tests is broken by design.\""
msgstr ""
"당신은 훌륭한 소프트웨어를 만들었을지 모르지만, 다른 많은 개발자들이 테스트"
"가 부족하기 때문에 그것을 사용하려 하지 않을 것입니다. 테스트가 없다면, 그들"
"은 그것을 신뢰하지 않을 것입니다. Django의 최초 개발자 중 한 명인 Jacob "
"Kaplan-Moss는 \"테스트없는 코드는 설계상 망가져 있는것\" 이라고 말합니다."

msgid ""
"That other developers want to see tests in your software before they take it "
"seriously is yet another reason for you to start writing tests."
msgstr ""
"테스트 작성을 시작해야하는 또다른 이유는 다른 개발자들이 당신의 소프트웨어를 "
"사용하는것을 진지하게 고려하기 전에 테스트 코드를 보기를 원하기 때문입니다."

msgid "Tests help teams work together"
msgstr "테스트는 팀이 함께 일하는것을 돕습니다"

msgid ""
"The previous points are written from the point of view of a single developer "
"maintaining an application. Complex applications will be maintained by "
"teams. Tests guarantee that colleagues don't inadvertently break your code "
"(and that you don't break theirs without knowing). If you want to make a "
"living as a Django programmer, you must be good at writing tests!"
msgstr ""
"이전의 내용은 어플리케이션을 유지 관리하는 단일 개발자의 관점에서 작성되었습"
"니다. 복잡한 애플리케이션은 팀별로 유지 관리됩니다. 테스트는 동료가 실수로 코"
"드를 손상시키지 않는다는 것을 보증합니다 (그리고 당신이 동료의 코드를 모르는"
"새에 망가트리는것도). 장고 프로그래머로서 생계를 꾸려 나가려면 테스트를 잘해"
"야합니다!"

msgid "Basic testing strategies"
msgstr "기초 테스팅 전략"

msgid "There are many ways to approach writing tests."
msgstr "테스트 작성에 대한 많은 접근법이 있습니다."

msgid ""
"Some programmers follow a discipline called \"`test-driven development`_\"; "
"they actually write their tests before they write their code. This might "
"seem counter-intuitive, but in fact it's similar to what most people will "
"often do anyway: they describe a problem, then create some code to solve it. "
"Test-driven development formalizes the problem in a Python test case."
msgstr ""
"어떤 프로그래머들은 \"`test-driven development`_\"; 이라는 분야를 따르는데, "
"그들은 실제로 코드를 작성하기 전에 그들의 테스트를 작성합니다. 이것은 직관에 "
"반하는 것처럼 보일 수 있지만, 사실은 대부분의 사람들이 자주 하는 방식과 비슷"
"합니다. 그들은 문제를 설명하고, 그것을 해결하기 위한 몇 가지 코드를 만들어 냅"
"니다. 테스트 주도 개발은 Python 테스트 사례에서 문제를 공식화합니다."

msgid ""
"More often, a newcomer to testing will create some code and later decide "
"that it should have some tests. Perhaps it would have been better to write "
"some tests earlier, but it's never too late to get started."
msgstr ""
"더 흔하게는, 테스팅 입문자들은 코드를 작성하고 시간이 흐른 뒤에 테스트들이 필"
"요하다고 판단할 것입니다. 아마도 몇몇의 테스트는 더 빨리 작성하는 것이 나을지"
"도 모릅니다. 하지만 시작하기에 너무 늦어서는 안 됩니다."

msgid ""
"Sometimes it's difficult to figure out where to get started with writing "
"tests. If you have written several thousand lines of Python, choosing "
"something to test might not be easy. In such a case, it's fruitful to write "
"your first test the next time you make a change, either when you add a new "
"feature or fix a bug."
msgstr ""
"어디서부터 테스트를 작성해야 할지 종잡을 수 없을 때가 있습니다. 당신이 수천 "
"줄의 파이썬 코드를 작성해 놓았다면, 테스트할 것을 고르는 것이 쉽지 않을지도 "
"모릅니다. 그럴 때는 다음에 새로운 기능을 넣거나 버그를 수정하는 등, 코드를 변"
"경할 일이 있을 때, 당신의 첫 테스트를 작성하는 것이 유익할 것입니다."

msgid "So let's do that right away."
msgstr "그러니 지금 당장 해봅시다."

msgid "Writing our first test"
msgstr "첫 번째 테스트 작성하기"

msgid "We identify a bug"
msgstr "버그 식별하기"

msgid ""
"Fortunately, there's a little bug in the ``polls`` application for us to fix "
"right away: the ``Question.was_published_recently()`` method returns "
"``True`` if the ``Question`` was published within the last day (which is "
"correct) but also if the ``Question``’s ``pub_date`` field is in the future "
"(which certainly isn't)."
msgstr ""
"다행스럽게도 ``polls`` 어플리케이션에는 우리가 즉시 해결할 수있는 약간의 버그"
"가 있습니다. ``Question.was_published_recently()`` 메소드는 ``Question``\\ "
"이 어제 게시된 경우 ``True``\\ 를 반환(올바른 동작)할 뿐만 아니라 "
"``Question``\\ 의 ``pub_date`` 필드가 미래로 설정되어 있을 때도 그렇습니다(틀"
"린 동작)."

msgid ""
"Confirm the bug by using the :djadmin:`shell` to check the method on a "
"question whose date lies in the future:"
msgstr ""
":djadmin:`shell`\\을 사용해 미래의 날짜로 메소드를 실행해 버그를 확인합니다."

msgid "Since things in the future are not 'recent', this is clearly wrong."
msgstr "미래는 '최근(recent)'이 아니기 때문에 이는 분명히 잘못된 것입니다."

msgid "Create a test to expose the bug"
msgstr "버그를 노출하는 테스트 만들기"

msgid ""
"What we've just done in the :djadmin:`shell` to test for the problem is "
"exactly what we can do in an automated test, so let's turn that into an "
"automated test."
msgstr ""
"문제를 테스트하기 위해 :djadmin:`shell` 에서 방금 수행한 작업은 자동화된 테스"
"트에서 수행할 수 있는 작업이므로 자동화된 테스트로 바꾸도록 합시다."

msgid ""
"A conventional place for an application's tests is in the application's "
"``tests.py`` file; the testing system will automatically find tests in any "
"file whose name begins with ``test``."
msgstr ""
"애플리케이션 테스트는 일반적으로 애플리케이션의 ``tests.py`` 파일에 있습니"
"다. 테스트 시스템은 ``test`` 로 시작하는 파일에서 테스트를 자동으로 찾습니다."

msgid ""
"Put the following in the ``tests.py`` file in the ``polls`` application:"
msgstr "``polls`` 어플리케이션의 ``tests.py`` 파일에 다음을 입력하십시오:"

msgid "``polls/tests.py``"
msgstr "``polls/tests.py``"

msgid ""
"Here we have created a :class:`django.test.TestCase` subclass with a method "
"that creates a ``Question`` instance with a ``pub_date`` in the future. We "
"then check the output of ``was_published_recently()`` - which *ought* to be "
"False."
msgstr ""
"우리는 미래의 ``pub_date``\\를 가진 ``Question`` 인스턴스를 생성하는 메소드"
"를 가진 :class:`django.test.TestCase` 하위 클래스를 생성했습니다. 그런 다음 "
"``was_published_recently()``\\의 출력이 False가 되는지 확인했습니다."

msgid "Running tests"
msgstr "테스트 실행"

msgid "In the terminal, we can run our test:"
msgstr "터미널에서 테스트를 실행합니다."

msgid "and you'll see something like:"
msgstr "그러면 다음과 같이 볼 수 있습니다."

msgid "Different error?"
msgstr "다른 오류가 발생하나요?"

msgid ""
"If instead you're getting a ``NameError`` here, you may have missed a step "
"in :ref:`Part 2 <tutorial02-import-timezone>` where we added imports of "
"``datetime`` and ``timezone`` to ``polls/models.py``. Copy the imports from "
"that section, and try running your tests again."
msgstr ""
"만약 위 오류 대신 ``NameError``\\ 가 발생한다면, 당신은 :ref:`Part "
"2<tutorial02-import-timezone>`\\ 의 한 단계를 놓쳤던 것일지도 모릅니다. 이 단"
"계에서 우리는 ``datetime``\\ 과 ``timezone``\\ 의 import를 ``polls/models."
"py``\\ 에 추가하였습니다. 해당 섹션에서 임포트를 복사한 후, 테스트를 다시 돌"
"려보시길 바랍니다."

msgid "What happened is this:"
msgstr "무슨 일이 일어 났습니까?"

msgid "``manage.py test polls`` looked for tests in the ``polls`` application"
msgstr ""
"``manage.py test polls``\\는 ``polls`` 어플리케이션에서 테스트를 찾습니다."

msgid "it found a subclass of the :class:`django.test.TestCase` class"
msgstr ":class:`django.test.TestCase` 클래스의 서브 클래스를 찾았습니다."

msgid "it created a special database for the purpose of testing"
msgstr "테스트 목적으로 특별한 데이터베이스를 만들었습니다."

msgid "it looked for test methods - ones whose names begin with ``test``"
msgstr "테스트 메소드 - 이름이 ``test``\\ 로 시작하는 것들을 찾습니다."

msgid ""
"in ``test_was_published_recently_with_future_question`` it created a "
"``Question`` instance whose ``pub_date`` field is 30 days in the future"
msgstr ""
"``test_was_published_recently_with_future_question``\\ 에서 ``pub_date``\\ 필"
"드가 30일 미래인 ``Question`` 인스턴스를 생성했습니다"

msgid ""
"... and using the ``assertIs()`` method, it discovered that its "
"``was_published_recently()`` returns ``True``, though we wanted it to return "
"``False``"
msgstr ""
"... ``assertIs()`` 메소드를 사용하여, 우리가 ``False``\\ 가 반환되기를 원함에"
"도 불구하고 ``was_published_recently()`` 가 ``True``\\ 를 반환한다는 것을 발"
"견했습니다."

msgid ""
"The test informs us which test failed and even the line on which the failure "
"occurred."
msgstr "테스트는 어떤 테스트가 실패했는지와 실패가 발생한 행까지 알려줍니다."

msgid "Fixing the bug"
msgstr "버그 수정"

msgid ""
"We already know what the problem is: ``Question.was_published_recently()`` "
"should return ``False`` if its ``pub_date`` is in the future. Amend the "
"method in ``models.py``, so that it will only return ``True`` if the date is "
"also in the past:"
msgstr ""
"우리는 이미 문제가 무엇인지 알고 있습니다: ``Question."
"was_published_recently()``\\ 는 ``pub_date``\\가 미래에 있다면 ``False``\\를 "
"반환해야 합니다. ``models.py``\\ 에서 날짜가 과거에 있을 때에만 ``True``\\ "
"를 반환하도록 메소드를 수정하십시오."

msgid "and run the test again:"
msgstr "그리고 테스트를 다시 실행합니다."

msgid ""
"After identifying a bug, we wrote a test that exposes it and corrected the "
"bug in the code so our test passes."
msgstr ""
"버그를 확인한 후에 우리는 이를 드러내는 테스트를 작성 하였으며 코드에서 버그"
"를 수정하고 테스트를 통과했습니다."

msgid ""
"Many other things might go wrong with our application in the future, but we "
"can be sure that we won't inadvertently reintroduce this bug, because "
"running the test will warn us immediately. We can consider this little "
"portion of the application pinned down safely forever."
msgstr ""
"다른 많은 것들이 미래에 우리의 어플리케이션에 해를 끼칠 수 있지만, 테스트를 "
"실행하면 즉시 우리에게 경고를 줄 것이기 때문에 부주의하게 이 버그를 다시 도입"
"하지 않을 것이라고 확신할 수 있습니다. 우리는 애플리케이션의 작은 부분이 영원"
"히 안전하게 고정 되었다고 생각할 수 있습니다."

msgid "More comprehensive tests"
msgstr "보다 포괄적인 테스트"

msgid ""
"While we're here, we can further pin down the ``was_published_recently()`` "
"method; in fact, it would be positively embarrassing if in fixing one bug we "
"had introduced another."
msgstr ""
"우리가 여기있는 동안, 우리는 ``was_published_recently()``\\ 메소드를 고정하는"
"것 이상을 할수 있습니다; 사실 하나의 버그를 고치면서 다른 새로운 버그를 만들"
"어 낸다면 분명 곤란할것입니다."

msgid ""
"Add two more test methods to the same class, to test the behavior of the "
"method more comprehensively:"
msgstr ""
"메소드의 동작을보다 포괄적으로 테스트하기 위해 동일한 클래스에 두 가지 테스"
"트 메소드를 추가하십시오:"

msgid ""
"And now we have three tests that confirm that ``Question."
"was_published_recently()`` returns sensible values for past, recent, and "
"future questions."
msgstr ""
"이제 우리는 ``Question.was_published_recently()``\\ 가 과거, 최근, 미래의 질"
"문에 대해 올바른 값을 반환한다는걸 확인시켜주는 세가지 테스트를 가졌습니다."

msgid ""
"Again, ``polls`` is a minimal application, but however complex it grows in "
"the future and whatever other code it interacts with, we now have some "
"guarantee that the method we have written tests for will behave in expected "
"ways."
msgstr ""
"다시 말해,  ``polls`` 는 조그만 어플리케이션이지만, 미래에 그것이 얼마나 복잡"
"해지든 그리고 그것이 다른 코드와 상호 작용하든 간에, 테스트를 한 메서드가 예"
"상대로 동작할 것이라는 것을 어느 정도 보장하고 있습니다."

msgid "Test a view"
msgstr "뷰 테스트"

msgid ""
"The polls application is fairly undiscriminating: it will publish any "
"question, including ones whose ``pub_date`` field lies in the future. We "
"should improve this. Setting a ``pub_date`` in the future should mean that "
"the Question is published at that moment, but invisible until then."
msgstr ""
"설문조사 어플리케이션은 상당히 대충대충 만들어져 있습니다. 이 어플리케이션은 "
"``pub_date``\\ 필드가 미래에있는 질문 까지도 포함하여 게시합니다. 이것을 개"
"선 해야합니다. 미래로 ``pub_date``\\ 를 설정하는 것은 그 시기가 되면 질문이 "
"게시되지만 그때까지는 보이지 않는 것을 의미 해야 합니다."

msgid "A test for a view"
msgstr "뷰에 대한 테스트"

msgid ""
"When we fixed the bug above, we wrote the test first and then the code to "
"fix it. In fact that was an example of test-driven development, but it "
"doesn't really matter in which order we do the work."
msgstr ""
"위의 버그를 고칠 때 우리는 먼저 테스트를 작성한 후 코드를 수정했습니다. 사실 "
"그것은 테스트 주도의 개발의 한 예였지만, 어떤 순서로 일을 하느냐가 중요한 것"
"은 아닙니다."

msgid ""
"In our first test, we focused closely on the internal behavior of the code. "
"For this test, we want to check its behavior as it would be experienced by a "
"user through a web browser."
msgstr ""
"첫 번째 테스트에서 코드의 내부 동작에 대해 자세히 설명했습니다. 이 테스트에서"
"는 웹 브라우저를 통해 사용자가 경험하는대로 동작을 확인하려고합니다."

msgid ""
"Before we try to fix anything, let's have a look at the tools at our "
"disposal."
msgstr "버그를 수정하기 전에 우리가 사용 할 수있는 도구를 살펴 보겠습니다."

msgid "The Django test client"
msgstr "장고 테스트 클라이언트"

msgid ""
"Django provides a test :class:`~django.test.Client` to simulate a user "
"interacting with the code at the view level.  We can use it in ``tests.py`` "
"or even in the :djadmin:`shell`."
msgstr ""
"Django는 뷰 레벨에서 코드와 상호 작용하는 사용자를 시뮬레이트하기위해 테스트 "
"클라이언트 클래스 :class:`~django.test.Client`\\ 를 제공합니다. 이 테스트 클"
"라이언트를 ``tests.py``\\ 또는 :djadmin:`shell`\\ 에서 사용할 수 있습니다."

msgid ""
"We will start again with the :djadmin:`shell`, where we need to do a couple "
"of things that won't be necessary in ``tests.py``. The first is to set up "
"the test environment in the :djadmin:`shell`:"
msgstr ""
"우리는 또다시 :djadmin:`shell`\\에서 시작할 것인데, ``tests.py``\\에서 필요하"
"지 않았던 두 가지 일을 해야 합니다. 첫 번째는 :djadmin:`shell`\\에서 테스트 "
"환경을 구성하는 것입니다."

msgid ""
":meth:`~django.test.utils.setup_test_environment` installs a template "
"renderer which will allow us to examine some additional attributes on "
"responses such as ``response.context`` that otherwise wouldn't be available. "
"Note that this method *does not* set up a test database, so the following "
"will be run against the existing database and the output may differ slightly "
"depending on what questions you already created. You might get unexpected "
"results if your ``TIME_ZONE`` in ``settings.py`` isn't correct. If you don't "
"remember setting it earlier, check it before continuing."
msgstr ""
"`response.context` 와 같은 추가적인 속성을 사용할 수 있게 하기위해서 :meth:"
"`~django.test.utils.setup_test_environment`\\ 를 사용하여 템플릿 "
"renderer               를 설치합니다. 이 메서드는 테스트 데이터베이스를 설정"
"하지 *않으므로* 기존 데이터베이스에 대해 다음이 실행되며 이미 작성한 질문에 "
"따라 출력이 약간 달라질 수 있습니다. ``settings.py``의 ``TIME_ZONE`` 이 올바"
"르지 않으면 예상치 못한 결과가 나올 수 있습니다. 초기에 설정했는지 기억이 나"
"지 않으면 계속하기 전에 확인하십시오."

msgid ""
"Next we need to import the test client class (later in ``tests.py`` we will "
"use the :class:`django.test.TestCase` class, which comes with its own "
"client, so this won't be required):"
msgstr ""
"다음으로 우리는 테스트 클라이언트 클래스를 가져와야합니다. (나중에 ``tests."
"py``에서 우리는 자체 클라이언트와 함께 제공되는 :class:`django.test."
"TestCase` 클래스를 사용할 것이므로 이것은 필요하지 않을 것입니다.)"

msgid "With that ready, we can ask the client to do some work for us:"
msgstr "준비가 되면, 우리는 고객에게 우리를 위해 작업을 요청할 수 있습니다. "

msgid "Improving our view"
msgstr "뷰를 개선시키기"

msgid ""
"The list of polls shows polls that aren't published yet (i.e. those that "
"have a ``pub_date`` in the future). Let's fix that."
msgstr ""
"설문 조사 목록에는 아직 게시되지 않은 설문 조사 (즉, 장래에 ``pub_date``\\가 "
"있는 설문 조사)가 표시됩니다. 그것을 수정합시다."

msgid ""
"In :doc:`Tutorial 4 </intro/tutorial04>` we introduced a class-based view, "
"based on :class:`~django.views.generic.list.ListView`:"
msgstr ""
":doc:`튜토리얼 4장 </intro/tutorial04>`\\에서 :class:`~django.views.generic."
"list.ListView` 클래스 기반 뷰를 소개했습니다."

msgid ""
"We need to amend the ``get_queryset()`` method and change it so that it also "
"checks the date by comparing it with ``timezone.now()``. First we need to "
"add an import:"
msgstr ""
"우리는 ``get_queryset()`` 메소드를 수정하여 ``timezone.now()``\\와 비교하여 "
"날짜를 검사하도록 변경해야 합니다. 먼저 가져 오기를 추가해야 합니다."

msgid "and then we must amend the ``get_queryset`` method like so:"
msgstr "그리고 다음과 같이 ``get_queryset`` 메소드를 수정해야합니다:"

msgid ""
"``Question.objects.filter(pub_date__lte=timezone.now())`` returns a queryset "
"containing ``Question``\\s whose ``pub_date`` is less than or equal to - "
"that is, earlier than or equal to - ``timezone.now``."
msgstr ""
"``Question.objects.filter (pub_date__lte = timezone.now ())``\\는 ``timezone."
"now``\\보다 ``pub_date``\\가 작거나 같은 ``Question``\\을 포함하는 queryset"
"을 반환합니다."

msgid "Testing our new view"
msgstr "새로운 뷰 테스트"

msgid ""
"Now you can satisfy yourself that this behaves as expected by firing up "
"``runserver``, loading the site in your browser, creating ``Questions`` with "
"dates in the past and future, and checking that only those that have been "
"published are listed. You don't want to have to do that *every single time "
"you make any change that might affect this* - so let's also create a test, "
"based on our :djadmin:`shell` session above."
msgstr ""
"이제 ``runserver``\\를 실행하면 브라우저에 사이트가 적재되고 과거와 미래 날짜"
"의 ``Questions``\\이 생성되고, 퍼블리시된 것들만 리스트에 나타나는 것을 확인"
"으로써 예상대로 동작하는 것에 만족할 수 있을 것입니다. 앞으로 *어떤 변화를 일"
"으키더라도 이러한 점에 영향을 끼치지 않도록* 하고 싶을 것이므로, 위의 :"
"djadmin:`shell`\\에 기초를 둔 테스트를 작성합시다."

msgid "Add the following to ``polls/tests.py``:"
msgstr "``polls/tests.py``\\에 다음을 추가하십시오:"

msgid ""
"and we'll create a shortcut function to create questions as well as a new "
"test class:"
msgstr "새로운 테스트 클래스와 함께 질문들을 생성하는 함수를 만들 것입니다."

msgid "Let's look at some of these more closely."
msgstr "이 중 일부를 더 자세히 살펴 보겠습니다."

msgid ""
"First is a question shortcut function, ``create_question``, to take some "
"repetition out of the process of creating questions."
msgstr ""
"먼저, 질문 생성 함수인 ``create_question``\\은 테스트 과정 중 설문을 생성하"
"는 부분에서 반복 사용합니다."

msgid ""
"``test_no_questions`` doesn't create any questions, but checks the message: "
"\"No polls are available.\" and verifies the ``latest_question_list`` is "
"empty. Note that the :class:`django.test.TestCase` class provides some "
"additional assertion methods. In these examples, we use :meth:`~django.test."
"SimpleTestCase.assertContains()` and :meth:`~django.test.TransactionTestCase."
"assertQuerySetEqual()`."
msgstr ""
"``test_no_questions``은 질문을 생성하지 않지만 \"No polls are available.\" 메"
"시지를 확인하고 ``latest_question_list``가 비어있는지 확인합니다. :class:"
"`django.test.TestCase` 클래스는 몇가지 추가적인 선언 메소드를 제공하니 유의하"
"세요. 이 예제에서 우리는 :meth:`:meth:`~django.test.SimpleTestCase."
"assertContains()` 와 :meth:`~django.test.TransactionTestCase."
"assertQuerySetEqual()`을 사용합니다. "

msgid ""
"In ``test_past_question``, we create a question and verify that it appears "
"in the list."
msgstr ""
"``test_past_question``\\에서 우리는 질문을 생성하고 그 질문이 리스트에 나타나"
"는지 확인합니다."

msgid ""
"In ``test_future_question``, we create a question with a ``pub_date`` in the "
"future. The database is reset for each test method, so the first question is "
"no longer there, and so again the index shouldn't have any questions in it."
msgstr ""
"``test_future_question``\\에서 우리는 미래의 ``pub_date``\\로 질문을 만듭니"
"다. 데이터베이스는 각 테스트 메소드마다 재설정되므로 첫 번째 질문은 더 이상 "
"존재하지 않으므로 다시 인덱스에 질문이 없어야 합니다."

msgid ""
"And so on. In effect, we are using the tests to tell a story of admin input "
"and user experience on the site, and checking that at every state and for "
"every new change in the state of the system, the expected results are "
"published."
msgstr ""
"요컨데, 사이트에서 관리자 입력 및 사용자 경험에 대한 이야기를 하는 테스트를 "
"만들었고, 모든 상태와 시스템 상태의 모든 새로운 변경 사항에 대해 예상하는 결"
"과가 출력되는지 확인합니다."

msgid "Testing the ``DetailView``"
msgstr "``DetailView`` 테스트하기"

msgid ""
"What we have works well; however, even though future questions don't appear "
"in the *index*, users can still reach them if they know or guess the right "
"URL. So we need to add a similar  constraint to ``DetailView``:"
msgstr ""
"우리가 만든 것이 잘 작동합니다. 그러나 미래의 설문들은 *목록*\\ 에 나타나지"
"는 않지만, 사용자가 URL을 알고 있거나, 추측하면 접근할 수 있습니다. 그래서 우"
"리는 ``DetailView``\\ 에 비슷한 제약 조건을 추가할 필요가 있습니다."

msgid ""
"We should then add some tests, to check that a ``Question`` whose "
"``pub_date`` is in the past can be displayed, and that one with a "
"``pub_date`` in the future is not:"
msgstr ""
"그런 다음 ``pub_date``가 과거이고 미래에 ``pub_date``가 있는 ``Question``이 "
"표시되지 않는지 확인하기 위해 몇 가지 테스트를 추가해야 합니다."

msgid "Ideas for more tests"
msgstr "더 많은 테스트를위한 아이디어"

msgid ""
"We ought to add a similar ``get_queryset`` method to ``ResultsView`` and "
"create a new test class for that view. It'll be very similar to what we have "
"just created; in fact there will be a lot of repetition."
msgstr ""
"우리는 비슷한 ``get_queryset`` 메소드를 ``ResultsView``\\에 추가하고 그 뷰에 "
"대한 새로운 테스트 클래스를 생성해야합니다. 그것은 우리가 방금 만든 것과 매"
"우 유사합니다. 사실 계속 반복 작업을 할 것입니다."

msgid ""
"We could also improve our application in other ways, adding tests along the "
"way. For example, it's silly that ``Questions`` can be published on the site "
"that have no ``Choices``. So, our views could check for this, and exclude "
"such ``Questions``. Our tests would create a ``Question`` without "
"``Choices`` and then test that it's not published, as well as create a "
"similar ``Question`` *with* ``Choices``, and test that it *is* published."
msgstr ""
"테스트를 추가하면서 다른 방법으로 애플리케이션을 개선 할 수도 있습니다. 예를 "
"들어, ``선택 사항``\\ 이 없는 사이트에 ``설문``\\ 을 게시 할 수 있다는 것은 "
"바보같은 일입니다. 그래서 우리의 뷰는 이를 확인하고 그러한 질문을 배제 할 것"
"입니다. 우리의 테스트는 ``선택사항``\\ 이 없는 ``설문``\\ 을 생성 한 다음, 실"
"제로 게시되지 않는지 테스트하고, ``선택사항``\\ 이 있는 ``설문``\\ 을 작성하"
"고 게시 여부를 테스트합니다."

msgid ""
"Perhaps logged-in admin users should be allowed to see unpublished "
"``Questions``, but not ordinary visitors. Again: whatever needs to be added "
"to the software to accomplish this should be accompanied by a test, whether "
"you write the test first and then make the code pass the test, or work out "
"the logic in your code first and then write a test to prove it."
msgstr ""
"아마도 일반 사용자가 아닌 로그인 한 관리자는 게시되지 않은 ``설문``\\을 볼 "
"수 있어야합니다. 다시 말하면: 소프트웨어를 추가하기 위해 필요한 것은 무엇이"
"든 테스트를 수반해야합니다, 먼저 테스트를 작성한 다음 코드가 테스트를 통과하"
"게 만들 것인지, 아니면 먼저 코드에서 로직을 처리 한 다음 이를 증명할 테스트"
"를 작성하십시오."

msgid ""
"At a certain point you are bound to look at your tests and wonder whether "
"your code is suffering from test bloat, which brings us to:"
msgstr ""
"어느 순간엔가 너무 많은 테스트 코드들을 보고 관리하기 힘들도록 너무 비대해 지"
"는것은 아닌가 생각할수도 있습니다."

msgid "When testing, more is better"
msgstr "테스트 할 때는, 많이 할 수록 좋습니다."

msgid ""
"It might seem that our tests are growing out of control. At this rate there "
"will soon be more code in our tests than in our application, and the "
"repetition is unaesthetic, compared to the elegant conciseness of the rest "
"of our code."
msgstr ""
"우리의 테스트가 통제 불능으로 성장하고있는 것처럼 보일 수 있습니다. 이 속도라"
"면 곧 우리의 어플리케이션에서 보다 우리의 테스트의 코드가 더 많아질 것이고,  "
"나머지 코드의 우아한 간결함과 비교했을 때, 반복하는 것은 미학적입니다."

msgid ""
"**It doesn't matter**. Let them grow. For the most part, you can write a "
"test once and then forget about it. It will continue performing its useful "
"function as you continue to develop your program."
msgstr ""
"**사실 비대해지는것은 중요하지 않습니다**. 테스트 코드들이 늘어나게 하십시"
"오. 대부분의 경우 테스트를 한 번 작성한 다음 신경을 끄게 됩니다. 그래도 이 테"
"스트 코드의 유용한 기능들은 프로그램을 개발하는 동안 계속 해서 작동할것입니"
"다."

msgid ""
"Sometimes tests will need to be updated. Suppose that we amend our views so "
"that only ``Questions`` with ``Choices`` are published. In that case, many "
"of our existing tests will fail - *telling us exactly which tests need to be "
"amended to bring them up to date*, so to that extent tests help look after "
"themselves."
msgstr ""
"때로는 테스트를 업데이트해야합니다. 우리가 ``선택지``\\ 를 가진 ``설문들``\\ "
"만 출력되도록 뷰를 수정한다고 가정 해 보겠습니다. 이 경우 기존 테스트 중 상당"
"수가 실패 할 것입니다. *테스트 결과를 최신으로 유지하기 위해 어떤 테스트를 수"
"정해야하는지 정확하게 알려주므로* 테스트가 스스로를 돌보는 데 도움이됩니다."

msgid ""
"At worst, as you continue developing, you might find that you have some "
"tests that are now redundant. Even that's not a problem; in testing "
"redundancy is a *good* thing."
msgstr ""
"최악의 경우 개발을 계속할 때 중복되는 테스트가 있을 수 있습니다. 그것은 문제"
"가 아닙니다.  테스팅에서 반복하는 것은 *좋은* 일입니다."

msgid ""
"As long as your tests are sensibly arranged, they won't become unmanageable. "
"Good rules-of-thumb include having:"
msgstr ""
"테스트들이 현명하게 배열되어있는 한 관리가 어려워지지 않을 것입니다. 경험에 "
"근거한 좋은 방법 중에는 다음과 같은 내용이 있습니다."

msgid "a separate ``TestClass`` for each model or view"
msgstr "각 모델이나 뷰에 대한 별도의 ``TestClass``"

msgid "a separate test method for each set of conditions you want to test"
msgstr "테스트하려는 각 조건 집합에 대해 분리된 테스트 방법"

msgid "test method names that describe their function"
msgstr "기능를 설명하는 테스트 메소드 이름 "

msgid "Further testing"
msgstr "추가 테스팅"

msgid ""
"This tutorial only introduces some of the basics of testing. There's a great "
"deal more you can do, and a number of very useful tools at your disposal to "
"achieve some very clever things."
msgstr ""
"이 튜토리얼에서는 테스트의 기본 사항에 대해서만 소개합니다. 여러분은 더 많은 "
"것을 할 수도 있고,  또 사용할 수 있는 똑똑한 도구들이 많이 있습니다."

msgid ""
"For example, while our tests here have covered some of the internal logic of "
"a model and the way our views publish information, you can use an \"in-"
"browser\" framework such as Selenium_ to test the way your HTML actually "
"renders in a browser. These tools allow you to check not just the behavior "
"of your Django code, but also, for example, of your JavaScript. It's quite "
"something to see the tests launch a browser, and start interacting with your "
"site, as if a human being were driving it! Django includes :class:`~django."
"test.LiveServerTestCase` to facilitate integration with tools like Selenium."
msgstr ""
"예를 들어, 이 전에 수행 한 테스트에서는 모델의 내부 로직과 뷰에서 정보를 게시"
"하는 방법을 다루었지만 Selenium_ 같은 \"브라우저 내\" 프레임 워크를 사용하여 "
"HTML이 브라우저에서 실제로 렌더링되는 방식을 테스트 할 수 있습니다. 이러한 도"
"구를 사용하면 장고 코드의 동작뿐만 아니라 JavaScript도 확인할 수 있습니다. 테"
"스트가 브라우저를 시작하고 인간이 그것을 다루는 것처럼 사이트와 상호 작용 것"
"은 매우 중요합니다! Django에는 :class:`~django.test.LiveServerTestCase`\\가 "
"포함되어있어 Selenium과 같은 도구와 쉽게 통합할 수 있게 해줍니다."

msgid ""
"If you have a complex application, you may want to run tests automatically "
"with every commit for the purposes of `continuous integration`_, so that "
"quality control is itself - at least partially - automated."
msgstr ""
"복잡한 어플리케이션을 사용하는 경우 `연속적으로 통합`_\\하기 위해 모든 커밋마"
"다 자동으로 테스트를 실행하여 품질 제어가 적어도 부분적으로 자동화되도록 할 "
"수 있습니다."

msgid ""
"A good way to spot untested parts of your application is to check code "
"coverage. This also helps identify fragile or even dead code. If you can't "
"test a piece of code, it usually means that code should be refactored or "
"removed. Coverage will help to identify dead code. See :ref:`topics-testing-"
"code-coverage` for details."
msgstr ""
"어플리케이션에서 테스트되지 않은 부분을 탐지하는 좋은 방법은 코드 커버리지를 "
"확인하는 것입니다. 이것은 또한 깨지기 쉬운 코드나 심지어는 죽은 코드를 식별하"
"는 데 도움이됩니다. 코드를 테스트 할 수 없다는 것은 대개 코드가 리팩터링해야"
"하거나 제거해야 함을 의미합니다. 커버리지는 죽은 코드를 확인하는 데 도움이됩"
"니다. 자세한 내용은 :ref:`topics-testing-code-coverage` 를 참조하십시오."

msgid ""
":doc:`Testing in Django </topics/testing/index>` has comprehensive "
"information about testing."
msgstr ""
":doc:`장고 테스트 </topics/testing/index>`\\는 테스트에 대한 포괄적인 정보를 "
"제공합니다."

msgid "What's next?"
msgstr "다음 내용은?"

msgid ""
"For full details on testing, see :doc:`Testing in Django </topics/testing/"
"index>`."
msgstr ""
"테스트에 대한 자세한 내용은 :doc:`장고 테스트 </topics/testing/index>`\\를 참"
"조하십시오."

msgid ""
"When you're comfortable with testing Django views, read :doc:`part 6 of this "
"tutorial</intro/tutorial06>` to learn about static files management."
msgstr ""
"Django 뷰를 테스트하는 것이 익숙해졌으면, 정적 파일 관리에 대해 배울 수 있"
"는 :doc:`이 튜토리얼의 6장</intro/tutorial06>`\\을 보세요."

msgid "Writing your first Django app, part 6"
msgstr "첫 번째 장고 앱 작성하기, part 6"

msgid ""
"This tutorial begins where :doc:`Tutorial 5 </intro/tutorial05>` left off. "
"We've built a tested web-poll application, and we'll now add a stylesheet "
"and an image."
msgstr ""
"이 튜토리얼은 :doc:`튜토리얼 5장 </intro/tutorial05>`에 이어서 시작합니다. 우"
"리는 테스트된 Web-poll 애플리케이션을 구축했으며, 이제 스타일시트와 이미지를 "
"추가할 것입니다."

msgid ""
"Aside from the HTML generated by the server, web applications generally need "
"to serve additional files — such as images, JavaScript, or CSS — necessary "
"to render the complete web page. In Django, we refer to these files as "
"\"static files\"."
msgstr ""
"서버에서 생성 된 HTML을 제외하고,  웹 어플리케이션은 일반적으로 전체 웹 페이"
"지를 렌더링하는 데 필요한 추가 파일 — 예:이미지, JavaScript 또는 CSS — 을 제"
"공해야합니다. Django에서는 이러한 파일을 \"정적 파일\" 이라고 부릅니다. "

msgid ""
"For small projects, this isn't a big deal, because you can keep the static "
"files somewhere your web server can find it. However, in bigger projects -- "
"especially those comprised of multiple apps -- dealing with the multiple "
"sets of static files provided by each application starts to get tricky."
msgstr ""
"소규모 프로젝트에서는 정적 파일을 웹 서버에서 찾을 수 있는 위치에 보관할 수 "
"있으므로 이는 큰 문제가 되지 않습니다. 그러나 대형 프로젝트, 특히 여러 앱으"
"로 구성된 프로젝트에서는 각 애플리케이션에서 제공하는 여러 정적 파일 세트를 "
"처리하는 것이 까다로워지기 시작합니다."

msgid ""
"That's what ``django.contrib.staticfiles`` is for: it collects static files "
"from each of your applications (and any other places you specify) into a "
"single location that can easily be served in production."
msgstr ""
"이것이 ``django.contrib.staticfiles``\\ 의 목적입니다: 이것은 각 응용 프로그"
"램(및 여러분이 지정한 다른 위치)의 정적 파일들을 프로덕션 환경에서 쉽게 제공 "
"할 수있는 단일 위치로 수집합니다."

msgid "Customize your *app's* look and feel"
msgstr "*앱*\\의 모양과 느낌을 원하는 대로 바꿔보세요."

msgid ""
"First, create a directory called ``static`` in your ``polls`` directory. "
"Django will look for static files there, similarly to how Django finds "
"templates inside ``polls/templates/``."
msgstr ""
"먼저, ``polls`` 디렉토리에 ``static`` 디렉토리를 만듭니다.  ``polls/"
"templates/`` 안의 템플릿을 찾는 것과 비슷하게 정적 파일을 찾습니다."

msgid ""
"Django's :setting:`STATICFILES_FINDERS` setting contains a list of finders "
"that know how to discover static files from various sources. One of the "
"defaults is ``AppDirectoriesFinder`` which looks for a \"static\" "
"subdirectory in each of the :setting:`INSTALLED_APPS`, like the one in "
"``polls`` we just created. The admin site uses the same directory structure "
"for its static files."
msgstr ""
"Django의 :setting:`STATICFILES_FINDERS`  설정은 다양한 소스에서 정적 파일을 "
"찾는 방법을 알고 있는 파인더 목록을 가지고 있습니다. 기본값 중 하나는 "
"``AppDirectoriesFinder`` 인데,  :setting:`INSTALLED_APPS` 에서 \"정적\" 하위 "
"디렉토리를 찾습니다, 방금 생성 한 ``polls`` 의 경우입니다. 관리 사이트는 정"
"적 파일에 대해 동일한 디렉토리 구조를 사용합니다."

msgid ""
"Within the ``static`` directory you have just created, create another "
"directory called ``polls`` and within that create a file called ``style."
"css``. In other words, your stylesheet should be at ``polls/static/polls/"
"style.css``. Because of how the ``AppDirectoriesFinder`` staticfile finder "
"works, you can refer to this static file in Django as ``polls/style.css``, "
"similar to how you reference the path for templates."
msgstr ""
"방금 생성한 ``static`` 디렉토리 안에 ``polls`` 라는 또 다른 디렉토리를 만들"
"고 그 안에 ``style.css`` 라는 파일을 만듭니다. 즉, 스타일 시트는 ``polls/"
"static/polls/style.css``\\ 에 있어야합니다.  ``AppDirectoriesFinder`` 정적 파"
"일 검색기 작동 방식 때문에 장고에 있는 이 정적 파일을 템플릿 경로를 참조하는 "
"방식과 유사하게 ``polls/style.css`` 라고 부를 수 있습니다."

msgid "Static file namespacing"
msgstr "정적 파일 네임스페이싱"

msgid ""
"Just like templates, we *might* be able to get away with putting our static "
"files directly in ``polls/static`` (rather than creating another ``polls`` "
"subdirectory), but it would actually be a bad idea. Django will choose the "
"first static file it finds whose name matches, and if you had a static file "
"with the same name in a *different* application, Django would be unable to "
"distinguish between them. We need to be able to point Django at the right "
"one, and the best way to ensure this is by *namespacing* them. That is, by "
"putting those static files inside *another* directory named for the "
"application itself."
msgstr ""
"템플릿과 마찬가지로 정적 파일을 ``polls/static``에 직접 저장하면 (다른 "
"``polls`` 하위 디렉토리를 만드는 대신) 벗어날 수 있지만, 실제로는 좋지 않은 "
"생각입니다. Django는 이름이 일치하는 첫 번째 정적 파일을 선택합니다. 그런데 "
"만약 *다른* 응용 프로그램에 같은 이름의 정적 파일이 있으면 Django는 이들 파일"
"을 구별할 수 없습니다. 우리는 Django가 올바른 것을 가리킬 수 있게 해야하는"
"데, 이것을 보장하는 가장 쉬운 방법은 *namespacing* 입니다. 즉, 정적 파일을 애"
"플리케이션과 *다른* 디렉토리에 두는 것입니다."

msgid ""
"Put the following code in that stylesheet (``polls/static/polls/style.css``):"
msgstr ""
"그 스타일 시트(``polls/static/polls/style.css``)에 다음 코드를 넣으세요."

msgid "``polls/static/polls/style.css``"
msgstr "``polls/static/polls/style.css``"

msgid ""
"Next, add the following at the top of ``polls/templates/polls/index.html``:"
msgstr ""
"다음으로, ``polls/templates/polls/index.html``\\의 맨 위에 다음을 추가하세요."

msgid ""
"The ``{% static %}`` template tag generates the absolute URL of static files."
msgstr "``{% static %}`` 템플릿 태그는 정적 파일의 절대 URL을 생성합니다."

msgid "That's all you need to do for development."
msgstr "개발에 필요한 것은 이것이 전부입니다."

msgid "Start the server (or restart it if it's already running):"
msgstr "서버를 시작합니다(이미 실행 중이라면 재시작합니다)."

msgid ""
"Reload ``http://localhost:8000/polls/`` and you should see that the question "
"links are green (Django style!) which means that your stylesheet was "
"properly loaded."
msgstr ""
"``http://localhost:8000/polls/``\\를 새로고침하면 질문의 링크가 녹색(Django "
"스타일!)로 표시되는 것을 볼 수 있으며, 이는 스타일시트가 올바로 적재된 것을 "
"의미합니다."

msgid "Adding a background-image"
msgstr "배경 이미지 추가하기"

msgid ""
"Next, we'll create a subdirectory for images. Create an ``images`` "
"subdirectory in the ``polls/static/polls/`` directory. Inside this "
"directory, add any image file that you'd like to use as a background. For "
"the purposes of this tutorial, we're using a file named ``background.png``, "
"which will have the full path ``polls/static/polls/images/background.png``."
msgstr ""
"다음으로 이미지들을 위 하위 디렉터리를 만듭니다. ``polls/static/polls/`` 디렉"
"토리에 ``images`` 하위 디렉토리를 만듭니다. 이 디렉토리 안에 배경으로 사용하"
"려는 이미지 파일을 추가합니다. 이번 튜토리얼에서는 전체 경로가 ``polls/"
"static/polls/images/background.png``인 ``background.png``라는 파일을 사용합니"
"다."

msgid ""
"Then, add a reference to your image in your stylesheet (``polls/static/polls/"
"style.css``):"
msgstr ""
"그런 다음, 스타일시트(``polls/static/polls/style.css``)에 이미지에 대한 참조"
"를 추가합니다:"

msgid ""
"Reload ``http://localhost:8000/polls/`` and you should see the background "
"loaded in the top left of the screen."
msgstr ""
"``http://localhost:8000/polls/``\\을 새로고침하면 화면의 왼쪽 상단에 배경이 "
"나타날 것입니다."

msgid ""
"The ``{% static %}`` template tag is not available for use in static files "
"which aren't generated by Django, like your stylesheet. You should always "
"use **relative paths** to link your static files between each other, because "
"then you can change :setting:`STATIC_URL` (used by the :ttag:`static` "
"template tag to generate its URLs) without having to modify a bunch of paths "
"in your static files as well."
msgstr ""
"스타일시트와 같이 Django가 생성하지 않은 정적 파일에는 ``{% static %}`` 템플"
"릿 태그를 사용할 수 없습니다. 정적 파일을 서로 연결할 때는 항상 **상대 경로**"
"를 사용해야 합니다. 그러면 정적 파일의 여러 경로를 수정할 필요 없이 :setting:"
"`STATIC_URL`( :ttag:`static` 템플릿 태그에서 URL을 생성하는 데 사용됨)을 변경"
"할 수 있습니다."

msgid ""
"These are the **basics**. For more details on settings and other bits "
"included with the framework see :doc:`the static files howto </howto/static-"
"files/index>` and :doc:`the staticfiles reference </ref/contrib/"
"staticfiles>`. :doc:`Deploying static files </howto/static-files/"
"deployment>` discusses how to use static files on a real server."
msgstr ""
"지금까지의 내용은 **기본**\\ 입니다. 프레임워크에 포함된 설정 및 다른 것들에 "
"대한 자세한 내용은 :doc:`정적 파일 howto </howto/static-files/index>`\\와 :"
"doc:`정적 파일 레퍼런스 </ref/contrib/staticfiles>`\\ 를 참조하십시오. :doc:`"
"정적 파일 배포 </howto/static-files/deployment>`\\ 는 실제 서버에서 정적 파일"
"을 사용하는 방법을 설명합니다."

msgid ""
"When you're comfortable with the static files, read :doc:`part 7 of this "
"tutorial </intro/tutorial07>` to learn how to customize Django's "
"automatically-generated admin site."
msgstr ""
"정적 파일에 익숙해졌으면, Django의 자동 생성되는 관리자 사이트를 커스터마이징"
"하는 법에 대해 배울 수 있는 :doc:`이 튜토리얼의 7장 </intro/tutorial07>`\\을 "
"보세요."

msgid "Writing your first Django app, part 7"
msgstr "첫 번째 장고 앱 작성하기, part 7"

msgid ""
"This tutorial begins where :doc:`Tutorial 6 </intro/tutorial06>` left off. "
"We're continuing the web-poll application and will focus on customizing "
"Django's automatically-generated admin site that we first explored in :doc:"
"`Tutorial 2 </intro/tutorial02>`."
msgstr ""
"이 튜토리얼은 :doc:`튜토리얼 6장 </intro/tutorial06>` 에 이어서 시작합니다. "
"우리는 웹 설문조사 어플리케이션을 계속 다루고 있으며, :doc:`Tutorial 2 </"
"intro/tutorial02>` 에서 봤었던 자동으로 생성된 관리자 사이트를 커스터마이징하"
"는 데 초점을 맞출 것입니다."

msgid "Customize the admin form"
msgstr "관리자 폼 커스터마이징"

msgid ""
"By registering the ``Question`` model with ``admin.site."
"register(Question)``, Django was able to construct a default form "
"representation. Often, you'll want to customize how the admin form looks and "
"works. You'll do this by telling Django the options you want when you "
"register the object."
msgstr ""
"``Question`` 모델을 ``admin.site.register(Question)``\\에 등록함으로써, "
"Django는 디폴트 폼 표현을 구성 할 수 있었습니다. 관리 폼이 보이고 작동하는 방"
"법을 커스터마이징하려는 경우가 있습니다. 객체를 등록 할 때 Django에 원하는 옵"
"션을 알려주면 커스터마이징 할 수 있습니다."

msgid ""
"Let's see how this works by reordering the fields on the edit form. Replace "
"the ``admin.site.register(Question)`` line with:"
msgstr ""
"수정 폼의 필드를 재정렬하여 이것이 작동하는 법을 보겠습니다. ``admin.site."
"register(Question)`` 줄을 다음과 같이 바꾸세요:"

msgid ""
"You'll follow this pattern -- create a model admin class, then pass it as "
"the second argument to ``admin.site.register()`` -- any time you need to "
"change the admin options for a model."
msgstr ""
"모델의 관리자 옵션을 변경해야 할 때마다 이 패턴 -- 모델 어드민 클래스를 만든 "
"다음, ``admin.site.register()``\\에 두 번째 인수로 전달합니다 -- 을 따라하면 "
"됩니다."

msgid ""
"This particular change above makes the \"Publication date\" come before the "
"\"Question\" field:"
msgstr ""
"여기서 특별한 변경 사항은 \"발행일\"이 \"설문\" 필드 앞에 오게 만듭니다."

msgid "Fields have been reordered"
msgstr "필드가 재정렬되었습니다."

msgid ""
"This isn't impressive with only two fields, but for admin forms with dozens "
"of fields, choosing an intuitive order is an important usability detail."
msgstr ""
"단지 2개의 필드만으로는 인상적이지는 않지만, 수십 개의 필드가 있는 관리 폼의 "
"경우에는 직관적인 순서을 선택하는 것이 사용 편리성의 중요한 부분입니다."

msgid ""
"And speaking of forms with dozens of fields, you might want to split the "
"form up into fieldsets:"
msgstr ""
"수십 개의 필드가 있는 폼에 관해서는 폼을 fieldset으로 분할하는 것이 좋습니다."

msgid ""
"The first element of each tuple in :attr:`~django.contrib.admin.ModelAdmin."
"fieldsets` is the title of the fieldset. Here's what our form looks like now:"
msgstr ""
":attr:`~django.contrib.admin.ModelAdmin.fieldsets`\\의 각 튜플의 첫 번째 요소"
"는 fieldset의 제목입니다. 우리의 폼이 다음과 같이 변했네요."

msgid "Form has fieldsets now"
msgstr "이제 양식에 필드 세트가 있습니다."

msgid "Adding related objects"
msgstr "관련된 객체 추가"

msgid ""
"OK, we have our Question admin page, but a ``Question`` has multiple "
"``Choice``\\s, and the admin page doesn't display choices."
msgstr ""
"OK, 우리는 Question 관리자 페이지를 가지고 있습니다. 그러나, ``Question``\\ "
"은 여러 개의 ``Choice``\\들을 가지고 있음에도, admin 페이지는 선택 사항을 표"
"시하지 않습니다."

msgid "Yet."
msgstr "아직까진 말이죠."

msgid ""
"There are two ways to solve this problem. The first is to register "
"``Choice`` with the admin just as we did with ``Question``:"
msgstr ""
"이 문제를 해결하는 방법은 두 가지가 있습니다. 첫 번째는 ``Question``:과 마찬"
"가지로 ``Choice``를 관리자에 등록하는 것입니다."

msgid ""
"Now \"Choices\" is an available option in the Django admin. The \"Add "
"choice\" form looks like this:"
msgstr ""
"이제 \"Choices\"\\는 Django 관리자가 사용할 수 있는 옵션입니다. \"Add "
"choice\" 폼은 다음과 같습니다."

msgid "Choice admin page"
msgstr "선택 관리자 페이지"

msgid ""
"In that form, the \"Question\" field is a select box containing every "
"question in the database. Django knows that a :class:`~django.db.models."
"ForeignKey` should be represented in the admin as a ``<select>`` box. In our "
"case, only one question exists at this point."
msgstr ""
"이 양식에서 \"Question\" 필드는 데이터베이스의 모든 질문을 포함하는 select "
"box입니다. Django는 :class:`~django.db.models.ForeignKey`\\ 가 admin에서 "
"``<select>``\\ 로 표현되어야 함을 알고 있습니다. 우리의 경우, 지금은 단 하나"
"의 질문만이 존재합니다."

msgid ""
"Also note the \"Add another question\" link next to \"Question.\" Every "
"object with a ``ForeignKey`` relationship to another gets this for free. "
"When you click \"Add another question\", you'll get a popup window with the "
"\"Add question\" form. If you add a question in that window and click "
"\"Save\", Django will save the question to the database and dynamically add "
"it as the selected choice on the \"Add choice\" form you're looking at."
msgstr ""
"또한  \"Question.\"  옆에 \"Add another question\" 링크를 확인하세요. 모든 객"
"체는 ``ForeignKey`` 관계가 있는 모든 객체는 이것을 무료로 받습니다. \"Add "
"another question\"을 누르면 \"Add question\"양식이 있는 팝업 창이 나타납니"
"다. 해당 창에 질문을 추가하고 \"Save\"을 누르면, Django는 질문을 데이터베이스"
"에 저장하고 이를 선택항목으로 현재 보고 있는 \"Add choice\"양식에  추가합니"
"다. "

msgid ""
"But, really, this is an inefficient way of adding ``Choice`` objects to the "
"system. It'd be better if you could add a bunch of Choices directly when you "
"create the ``Question`` object. Let's make that happen."
msgstr ""
"그러나 실제로 이것은 ``Choice`` 객체를 시스템에 추가하는 비효율적인 방법입니"
"다. ``Question`` 객체를 생성할 때 여러 개의 Choices를 직접 추가할 수 있다면 "
"더 좋을 것입니다. 그것을 만들어 봅시다."

msgid ""
"Remove the ``register()`` call for the ``Choice`` model. Then, edit the "
"``Question`` registration code to read:"
msgstr ""
"``Choice`` 모델에 대한 ``register()`` 호출을 제거하십시오. 그런 다음 "
"``Question`` 등록 코드를 다음과 같이 편집하십시오:"

msgid ""
"This tells Django: \"``Choice`` objects are edited on the ``Question`` admin "
"page. By default, provide enough fields for 3 choices.\""
msgstr ""
"위 소소는 Django에게  \"``Choice`` 객체는 ``Question`` 관리자 페이지에서 편집"
"된다. 기본으로 3가지 선택 항목을 제공함.\" 이라고 알려줍니다."

msgid "Load the \"Add question\" page to see how that looks:"
msgstr "모양을 보려면 \"Add question\" 페이지를 로드하십시오."

msgid "Add question page now has choices on it"
msgstr "이제 질문 추가 페이지에 선택 항목이 있습니다."

msgid ""
"It works like this: There are three slots for related Choices -- as "
"specified by ``extra`` -- and each time you come back to the \"Change\" page "
"for an already-created object, you get another three extra slots."
msgstr ""
"이 화면은 다음과 같이 작동합니다. 관련된 선택 사항을 위한 슬롯이 세 개 있으"
"며-- ``extra``\\ 로 지정됨 -- 이미 생성된 객체의 \"Change\" 페이지의 경우에"
"도 빈 세 개의 슬롯이 생깁니다."

msgid ""
"At the end of the three current slots you will find an \"Add another "
"Choice\" link.  If you click on it, a new slot will be added. If you want to "
"remove the added slot, you can click on the X to the top right of the added "
"slot. This image shows an added slot:"
msgstr ""
"세 개의 현재 슬롯 끝에 \"Add another Choice\" 링크가 있습니다. 클릭하면 새로"
"운 슬롯이 추가됩니다. 추가된 슬롯을 제거하려면 추가된 슬롯의 오른쪽 상단에 있"
"는 X를 누르면 됩니다. 이 이미지에는 추가된 슬롯이 표시됩니다."

msgid "Additional slot added dynamically"
msgstr "동적으로 추가된 추가 슬롯"

msgid ""
"One small problem, though. It takes a lot of screen space to display all the "
"fields for entering related ``Choice`` objects. For that reason, Django "
"offers a tabular way of displaying inline related objects. To use it, change "
"the ``ChoiceInline`` declaration to read:"
msgstr ""
"작은 문제가 하나 있습니다. 관련 ``Choice`` 객체를 입력하기 위한 모든 필드를 "
"표시하는 데는 많은 화면 공간이 필요합니다. 이러한 이유로 Django는 인라인 관"
"련 객체를 표시하는 표 형식의 방법을 제공합니다. 이를 사용하려면 "
"``ChoiceInline`` 선언을 다음과 같이 변경하면 됩니다."

msgid ""
"With that ``TabularInline`` (instead of ``StackedInline``), the related "
"objects are displayed in a more compact, table-based format:"
msgstr ""
"``StackedInline`` 대신에 ``TabularInline``\\ 을 사용하면, 관련된 객체는 좀 "
"더 조밀하고 테이블 기반 형식으로 표시됩니다:"

msgid "Add question page now has more compact choices"
msgstr "이제 질문 추가 페이지에 더 간결한 선택 항목이 있습니다."

msgid ""
"Note that there is an extra \"Delete?\" column that allows removing rows "
"added using the \"Add another Choice\" button and rows that have already "
"been saved."
msgstr ""
"추가적인 \"Delete?\" 열은 \"Add another Choice\"버튼을 사용하여 추가된 행과 "
"이미 저장된 행을 삭제할 수 있으므로 유의하세요."

msgid "Customize the admin change list"
msgstr "관리자 변경 목록(change list) 커스터마이징"

msgid ""
"Now that the Question admin page is looking good, let's make some tweaks to "
"the \"change list\" page -- the one that displays all the questions in the "
"system."
msgstr ""
"이제 질문 관리 페이지가 괜찮아 보이므로, 시스템의 모든 질문을 표시하는 \"변"
"경 목록\" 페이지를 약간 조정하십시오."

msgid "Here's what it looks like at this point:"
msgstr "다음은 이 시점의 모습입니다."

msgid ""
"By default, Django displays the ``str()`` of each object. But sometimes it'd "
"be more helpful if we could display individual fields. To do that, use the :"
"attr:`~django.contrib.admin.ModelAdmin.list_display` admin option, which is "
"a tuple of field names to display, as columns, on the change list page for "
"the object:"
msgstr ""
"기본적으로 Django는 각 객체의 ``str()``\\ 을 표시합니다. 그러나 개별 필드를 "
"표시 할 수 있는 경우 가끔 도움이 될 수 있습니다. 이렇게 하려면 :attr:"
"`~django.contrib.admin.ModelAdmin.list_display` admin 옵션을 사용합니다. 이 "
"옵션은 객체의 변경 목록 페이지에서 열로 표시 할 필드 이름들의 튜플입니다."

msgid ""
"For good measure, let's also include the ``was_published_recently()`` method "
"from :doc:`Tutorial 2 </intro/tutorial02>`:"
msgstr ""
"좋은 측정을 위해 :doc:`Tutorial 2 </intro/tutorial02>`:의 "
"``was_published_recently()`` 메소드를 추가해봅시다."

msgid "Now the question change list page looks like this:"
msgstr "이제 질문 변경 목록 페이지는 다음과 같습니다."

msgid "Polls change list page, updated"
msgstr "설문조사 변경 목록 페이지, 업데이트됨"

msgid ""
"You can click on the column headers to sort by those values -- except in the "
"case of the ``was_published_recently`` header, because sorting by the output "
"of an arbitrary method is not supported. Also note that the column header "
"for ``was_published_recently`` is, by default, the name of the method (with "
"underscores replaced with spaces), and that each line contains the string "
"representation of the output."
msgstr ""
"``was_published_recently`` 헤더의 경우를 제외하고 그 값으로 정렬하기 위해 열 "
"머리글을 클릭 할 수 있습니다. 왜냐하면 임의의 메서드의 출력에 의한 정렬은 지"
"원되지 않기 때문입니다. 또한 ``was_published_recently``\\ 에 대한 열 머리글"
"은 기본적으로 메서드 이름 (밑줄을 공백으로 대체)이며 각 줄에는 출력의 문자열 "
"표현이 포함되어 있습니다."

msgid ""
"You can improve that by using the :func:`~django.contrib.admin.display` "
"decorator on that method (in :file:`polls/models.py`), as follows:"
msgstr ""
":func:`~django.contrib.admin.display` decorator를 해당 메서드( :file:`polls/"
"models.py`에 있는)에 사용하면 다음과 같이 개선할 수 있습니다."

msgid ""
"For more information on the properties configurable via the decorator, see :"
"attr:`~django.contrib.admin.ModelAdmin.list_display`."
msgstr ""
"Decorator를 통해 구성할 수 있는 속성에 대한 자세한 내용은 :attr:`~django."
"contrib.admin.ModelAdmin.list_display`을 참조하십시오."

msgid ""
"Edit your :file:`polls/admin.py` file again and add an improvement to the "
"``Question`` change list page: filters using the :attr:`~django.contrib."
"admin.ModelAdmin.list_filter`. Add the following line to ``QuestionAdmin``::"
msgstr ""
":file:`polls/admin.py` 파일을 다시 편집하고 `Question`  변경 목록 페이지에 개"
"선점을 추가하십시오: :attr:`~django.contrib.admin.ModelAdmin.list_filter`\\ "
"를 사용하는 필터. ``QuestionAdmin``\\ 에 다음 줄을 추가하십시오::"

msgid ""
"That adds a \"Filter\" sidebar that lets people filter the change list by "
"the ``pub_date`` field:"
msgstr ""
"``pub_date`` 필드에 의해 사람들이 변경 목록을 필터링 할 수 있게 해주는 "
"\"Filter\" 사이드 바가 추가되었습니다:"

msgid ""
"The type of filter displayed depends on the type of field you're filtering "
"on. Because ``pub_date`` is a :class:`~django.db.models.DateTimeField`, "
"Django knows to give appropriate filter options: \"Any date\", \"Today\", "
"\"Past 7 days\", \"This month\", \"This year\"."
msgstr ""
"표시되는 필터의 유형은 필터링중인 필드의 유형에 따라 다릅니다. "
"``pub_date``\\ 는 :class:`~django.db.models.DateTimeField`\\ 이므로, Django"
"는 \"Any date\", \"Today\", \"Past 7 days\", \"This month\", \"This year\" 등"
"의 적절한 필터 옵션을 제공합니다."

msgid "This is shaping up well. Let's add some search capability::"
msgstr "잘 만들어지고 있습니다. 이제 검색 기능을 추가해 보겠습니다::"

msgid ""
"That adds a search box at the top of the change list. When somebody enters "
"search terms, Django will search the ``question_text`` field. You can use as "
"many fields as you'd like -- although because it uses a ``LIKE`` query "
"behind the scenes, limiting the number of search fields to a reasonable "
"number will make it easier for your database to do the search."
msgstr ""
"그러면 변경 목록 맨 위에 검색 창이 추가됩니다. 누군가가 검색어를 입력하면, 장"
"고는 ``question_text`` 필드를 검색합니다. 당신이 원하는 만큼의 필드를 사용할 "
"수 있습니다 -- 그것은 내부적으로 ``LIKE`` 쿼리를 사용하기 때문에 검색 필드의 "
"수를 적당한 수로 제한하면 데이터베이스가 검색을 더 쉽게 할 수 있습니다."

msgid ""
"Now's also a good time to note that change lists give you free pagination. "
"The default is to display 100 items per page. :attr:`Change list pagination "
"<django.contrib.admin.ModelAdmin.list_per_page>`, :attr:`search boxes "
"<django.contrib.admin.ModelAdmin.search_fields>`, :attr:`filters <django."
"contrib.admin.ModelAdmin.list_filter>`, :attr:`date-hierarchies <django."
"contrib.admin.ModelAdmin.date_hierarchy>`, and :attr:`column-header-ordering "
"<django.contrib.admin.ModelAdmin.list_display>` all work together like you "
"think they should."
msgstr ""
"이제 변경 목록이 자동 페이징 기능을 제공한다는 점을 기억하십시오. 기본값은 페"
"이지 당 100 개의 항목을 표시하는 것입니다. :attr:`변경 목록 페이지내이션 "
"<django.contrib.admin.ModelAdmin.list_per_page>`, :attr:`검색 상자 <django."
"contrib.admin.ModelAdmin.search_fields>`, :attr:`필터 <django.contrib.admin."
"ModelAdmin.list_filter>`, :attr:`날짜-계층구조<django.contrib.admin."
"ModelAdmin.date_hierarchy>`, 그리고 :attr:`컬럼-헤더-정렬 <django.contrib."
"admin.ModelAdmin.list_display>` 모두 함께 작동합니다."

msgid "Customize the admin look and feel"
msgstr "관리자 룩앤필 커스터마이징"

msgid ""
"Clearly, having \"Django administration\" at the top of each admin page is "
"ridiculous. It's just placeholder text."
msgstr ""
"명백히, 모든 관리자 페이지 상단에 \"Django administration\"\\이 있다는 것은 "
"우스꽝스럽습니다. 이건 그저 자리를 채워넣기 위한 문자열입니다."

msgid ""
"You can change it, though, using Django's template system. The Django admin "
"is powered by Django itself, and its interfaces use Django's own template "
"system."
msgstr ""
"그러나 Django의 템플릿 시스템을 사용하여 변경할 수 있습니다. Django 관리자는 "
"Django 자체에 의해 구동되며, 인터페이스는 Django 자신의 템플릿 시스템을 사용"
"합니다."

msgid "Customizing your *project's* templates"
msgstr "*프로젝트의* 템플릿 커스터마이징"

msgid ""
"Create a ``templates`` directory in your project directory (the one that "
"contains ``manage.py``). Templates can live anywhere on your filesystem that "
"Django can access. (Django runs as whatever user your server runs.) However, "
"keeping your templates within the project is a good convention to follow."
msgstr ""
"프로젝트 디렉토리 (``manage.py``\\ 를 포함하고있는)에 ``templates`` 디렉토리"
"를 만듭니다. 템플릿은 장고가 액세스 할 수있는 파일 시스템 어디에서나 사용할 "
"수 있습니다. (Django는 서버가 실행되는 사용자로 실행됩니다.) 그러나 프로젝트 "
"내에 템플릿을 유지하는 것은 따라야 할 좋은 규칙입니다."

msgid ""
"Open your settings file (:file:`mysite/settings.py`, remember) and add a :"
"setting:`DIRS <TEMPLATES-DIRS>` option in the :setting:`TEMPLATES` setting:"
msgstr ""
"설정 파일 (:file:`mysite/settings.py`\\를 기억하세요)을 열고 :setting:`DIRS "
"<TEMPLATES-DIRS>` 옵션을 :setting:`TEMPLATES` 설정에 추가하십시오:"

msgid ""
":setting:`DIRS <TEMPLATES-DIRS>` is a list of filesystem directories to "
"check when loading Django templates; it's a search path."
msgstr ""
":setting:`DIRS <TEMPLATES-DIRS>`\\는 Django 템플릿을 로드 할 때 검사 할 파일 "
"시스템 디렉토리 목록입니다. 바로 검색 경로입니다."

msgid "Organizing templates"
msgstr "템플릿 구성"

msgid ""
"Just like the static files, we *could* have all our templates together, in "
"one big templates directory, and it would work perfectly well. However, "
"templates that belong to a particular application should be placed in that "
"application's template directory (e.g. ``polls/templates``) rather than the "
"project's (``templates``). We'll discuss in more detail in the :doc:"
"`reusable apps tutorial </intro/reusable-apps>` *why* we do this."
msgstr ""
"정적 파일과 마찬가지로, 하나의 커다란 템플릿 디렉토리에 모든 템플릿을 함께 넣"
"을 수 있습니다. 그렇게 해도 완벽하게 잘 작동할 것입니다. 그러나, 특정 애플리"
"케이션에 속한 템플릿은 프로젝트(``templates``) 가 아닌 해당 애플리케이션의 템"
"플릿 디렉토리(예: ``polls/templates``)에 있어야 합니다. 우리는 왜 우리가 이렇"
"게 해야하는 지에 대한 더 자세한 내용을 :doc:`reusable apps tutorial </intro/"
"reusable-apps>` 에서 논의할 것입니다."

msgid ""
"Now create a directory called ``admin`` inside ``templates``, and copy the "
"template ``admin/base_site.html`` from within the default Django admin "
"template directory in the source code of Django itself (:source:`django/"
"contrib/admin/templates`) into that directory."
msgstr ""
"이제 ``admin`` inside ``templates``라는 디렉토리를 만들고 Django 자체 소스 코"
"드(:source:`django/contrib/admin/templates`) 에 있는 기본 Django 관리자 템플"
"릿 디렉토리 내에 ``admin/base_site.html`` 템플릿을 해당 디렉토리로 복사합니"
"다. "

msgid "Where are the Django source files?"
msgstr "Django 소스 파일은 어디에 있습니까?"

msgid ""
"If you have difficulty finding where the Django source files are located on "
"your system, run the following command:"
msgstr ""
"Django 소스 파일이 시스템에있는 위치를 찾는 데 어려움이있는 경우 다음 명령을 "
"실행하십시오."

msgid ""
"Then, edit the file and replace ``{{ site_header|default:_('Django "
"administration') }}`` (including the curly braces) with your own site's name "
"as you see fit. You should end up with a section of code like:"
msgstr ""
"그런 다음 파일을 편집하고 ``{{ site_header|default:_('Django "
"administration') }}``  (중괄호 포함)을 적합한 사이트 이름으로 바꿉니다. 코드 "
"섹션은 다음과 같습니다."

msgid ""
"We use this approach to teach you how to override templates. In an actual "
"project, you would probably use the :attr:`django.contrib.admin.AdminSite."
"site_header` attribute to more easily make this particular customization."
msgstr ""
"이 방법을 사용하여 템플릿을 재정의하는 방법을 학습합니다. 실제 프로젝트에서"
"는 아마 :attr:`django.contrib.admin.AdminSite.site_header` 속성을 사용하여 "
"이 개별 커스터마이징을 보다 쉽게 만들 수 있습니다."

msgid ""
"This template file contains lots of text like ``{% block branding %}`` and "
"``{{ title }}``. The ``{%`` and ``{{`` tags are part of Django's template "
"language. When Django renders ``admin/base_site.html``, this template "
"language will be evaluated to produce the final HTML page, just like we saw "
"in :doc:`Tutorial 3 </intro/tutorial03>`."
msgstr ""
"이 템플릿 파일에는 ``{% block branding %}``\\ 및 ``{{title}}``\\ 과 같은 텍스"
"트가 많이 포함되어 있습니다. ``{%``\\ 와 ``{{``\\ 태그들은 장고의 템플릿 언어"
"의 일부입니다. Django가 ``admin/base_site.html``\\ 을 렌더링 할 때, 이 템플"
"릿 언어는 :doc:`튜토리얼 3장 </intro/tutorial03>`\\ 에서 보았 듯이 최종 HTML "
"페이지를 생성하기 위해 평가 될 것입니다."

msgid ""
"Note that any of Django's default admin templates can be overridden. To "
"override a template, do the same thing you did with ``base_site.html`` -- "
"copy it from the default directory into your custom directory, and make "
"changes."
msgstr ""
"Django의 기본 관리 템플릿은 재정의할 수 있습니다. 템플릿을 재정의하려면 "
"``base_site.html``에서 수행한 작업을 동일하게 수행하십시오. 즉, 기본 디렉토리"
"에서 사용자 지정 디렉토리로 복사한 후 변경하십시오."

msgid "Customizing your *application's* templates"
msgstr "*어플리케이션의* 템플릿 사용자 정의"

msgid ""
"Astute readers will ask: But if :setting:`DIRS <TEMPLATES-DIRS>` was empty "
"by default, how was Django finding the default admin templates? The answer "
"is that, since :setting:`APP_DIRS <TEMPLATES-APP_DIRS>` is set to ``True``, "
"Django automatically looks for a ``templates/`` subdirectory within each "
"application package, for use as a fallback (don't forget that ``django."
"contrib.admin`` is an application)."
msgstr ""
"그러나 :setting:`DIRS <TEMPLATES-DIRS>`\\ 가 기본설정으로 비어 있다면, 장고"
"는 기본 관리자 템플릿을 어떻게 찾을까요? 그 해답은 :setting:`APP_DIRS "
"<TEMPLATES-APP_DIRS>` 설정이 ``True``\\ 로 설정되어 있기 때문에 Django는 각 "
"어플리케이션 패키지 내에서 ``templates/`` 서브 디렉토리를 자동으로 찾아서 대"
"체하게 됩니다. (``django.contrib.admin``\\ 이 어플리케이션 임을 잊지 마십시"
"오.)"

msgid ""
"Our poll application is not very complex and doesn't need custom admin "
"templates. But if it grew more sophisticated and required modification of "
"Django's standard admin templates for some of its functionality, it would be "
"more sensible to modify the *application's* templates, rather than those in "
"the *project*. That way, you could include the polls application in any new "
"project and be assured that it would find the custom templates it needed."
msgstr ""
"투표 어플리케이션은 복잡하지 않으며 사용자 정의 admin 템플릿이 필요하지 않습"
"니다. 그러나 Django의 표준 admin 템플릿을 좀더 정교하게 필요에 맞게 수정 할 "
"경우 *프로젝트* 템플릿 대신 *어플리케이션*\\ 의 템플릿을 수정하는 것이 더 현"
"명합니다. 그렇게 하면 다른 새 프로젝트에 투표 애플리케이션을 포함시킬 수 있"
"고, 필요할때는 커스텀 템플릿을 찾을수 있습니다."

msgid ""
"See the :ref:`template loading documentation <template-loading>` for more "
"information about how Django finds its templates."
msgstr ""
"Django가 템플릿을 찾는 방법에 대한 자세한 정보는 :ref:`템플릿 로딩 문서 "
"<template-loading>`\\ 를 보십시오."

msgid "Customize the admin index page"
msgstr "admin 인덱스 페이지 수정하기"

msgid ""
"On a similar note, you might want to customize the look and feel of the "
"Django admin index page."
msgstr ""
"제목과 같이, Django admin 인덱스 페이지의 모양과 느낌을 수정하고 싶을 수도 있"
"습니다."

msgid ""
"By default, it displays all the apps in :setting:`INSTALLED_APPS` that have "
"been registered with the admin application, in alphabetical order. You may "
"want to make significant changes to the layout. After all, the index is "
"probably the most important page of the admin, and it should be easy to use."
msgstr ""
"기본적으로 admin 어플리케이션과 함께 등록된 :setting:`INSTALLED_APPS`\\ 의 모"
"든 어플리케이션을 사전순으로 표시합니다. 어쩌면 레이아웃을 크게 변경하고자 "
"할 수 있습니다. 설사 그렇게 하더라도 인덱스는 admin의 가장 중요한 페이지이"
"고, 사용하기 쉬워야 합니다."

msgid ""
"The template to customize is ``admin/index.html``. (Do the same as with "
"``admin/base_site.html`` in the previous section -- copy it from the default "
"directory to your custom template directory). Edit the file, and you'll see "
"it uses a template variable called ``app_list``. That variable contains "
"every installed Django app. Instead of using that, you can hard-code links "
"to object-specific admin pages in whatever way you think is best."
msgstr ""
"커스터마이징 할 템플릿은 ``admin/index.html``\\ 입니다. (이전 섹션의 ``admin/"
"base_site.html``\\ 와 같은 작업을 합니다 - 기본 디렉토리에서 커스텀 템플릿 디"
"렉토리로 복사하십시오). 파일을 편집하면 ``app_list``\\ 라는 템플릿 변수를 사"
"용하는 것을 볼 수 있습니다. 이 변수는 설치된 모든 장고 앱을 포함합니다. 이를 "
"사용하는 대신 최선의 방법이라고 생각한다면  개체 별 admin 페이지에 대한 링크"
"를 하드 코딩 할 수 있습니다."

msgid ""
"When you're comfortable with the admin, read :doc:`part 8 of this tutorial </"
"intro/tutorial08>` to learn how to use third-party packages."
msgstr ""
"admin에 익숙해졌으면, 서드파티 패키지 사용 방법에 대해 배울 수 있는 :doc:"
"`part 8 of this tutorial </intro/tutorial08>`을 보세요."

msgid "Writing your first Django app, part 8"
msgstr "첫 번째 Django 앱 작성하기, part 8"

msgid ""
"This tutorial begins where :doc:`Tutorial 7 </intro/tutorial07>` left off. "
"We've built our web-poll application and will now look at third-party "
"packages. One of Django's strengths is the rich ecosystem of third-party "
"packages. They're community developed packages that can be used to quickly "
"improve the feature set of an application."
msgstr ""
"이 튜토리얼은 :doc:`튜토리얼 7`에서 중단된 부분부터 시작합니다. 웹 설문조사 "
"애플리케이션을 구축했으니 이제 서드파티 패키지를 살펴보겠습니다. 장고의 강점 "
"중 하나는 풍부한 서드파티 패키지 생태계입니다. 커뮤니티에서 개발한 패키지로 "
"애플리케이션의 기능 세트를 빠르게 개선하는 데 사용할 수 있습니다."

msgid ""
"This tutorial will show how to add `Django Debug Toolbar <https://django-"
"debug-toolbar.readthedocs.io>`_, a commonly used third-party package. The "
"Django Debug Toolbar has ranked in the top three most used third-party "
"packages in the Django Developers Survey in recent years."
msgstr ""
"이 튜토리얼에서는 일반적으로 사용되는 서드파티 패키지인 `Django Debug "
"Toolbar <https://django-debug-toolbar.readthedocs.io>`_를 추가하는 방법을 보"
"여드립니다. Django 디버그 도구 모음은 최근 몇 년 동안 Django 개발자 설문조사"
"에서 가장 많이 사용된 서드파티 패키지 상위 3위에 올랐습니다."

msgid "Installing Django Debug Toolbar"
msgstr "Django 디버그 툴바 설치하기"

msgid ""
"Django Debug Toolbar is a useful tool for debugging Django web applications. "
"It's a third-party package maintained by the `Jazzband <https://jazzband."
"co>`_ organization. The toolbar helps you understand how your application "
"functions and to identify problems. It does so by providing panels that "
"provide debug information about the current request and response."
msgstr ""
"장고 디버그 툴바는 장고 웹 애플리케이션을 디버깅하는 유용한 도구입니다. 이 서"
"드파티 패키지는 재즈밴드 <https://jazzband.co>`_ 조직에서 유지 관리하고 있습"
"니다. 이 도구 모음은 현재 요청 및 응답에 대한 디버그 정보를 제공하는 패널을 "
"제공함으로써 애플리케이션의 작동 방식을 이해하고 문제를 식별하도록 돕습니다."

msgid ""
"To install a third-party application like the toolbar, you need to install "
"the package by running the below command within an activated virtual "
"environment. This is similar to our earlier step to :ref:`install Django "
"<installing-official-release>`."
msgstr ""
"서드 파티 애플리케이션을 설치하려면 활성화된 가상 환경 내에서 아래 명령을 실"
"행하여 패키지를 설치해야 합니다. 이는 이전 단계인 :ref:`install Django 1`과 "
"유사합니다."

msgid ""
"Third-party packages that integrate with Django need some post-installation "
"setup to integrate them with your project. Often you will need to add the "
"package's Django app to your :setting:`INSTALLED_APPS` setting. Some "
"packages need other changes, like additions to your URLconf (``urls.py``)."
msgstr ""
"Django와 통합되는 서드 파티 패키지를 프로젝트와 통합하기 위해 설치 후 몇 가"
"지 설정이 필요합니다. 패키지의 Django 앱을 :setting:`INSTALLED_APPS` 설정에 "
"추가해야 할 수 있습니다. 일부 패키지는 URLconf(``urls.py``)에 추가하는 등 다"
"른 변경이 필요합니다."

msgid ""
"Django Debug Toolbar requires several setup steps. Follow them in `its "
"installation guide <https://django-debug-toolbar.readthedocs.io/en/latest/"
"installation.html>`_. The steps are not duplicated in this tutorial, because "
"as a third-party package, it may change separately to Django's schedule."
msgstr ""
"장고 디버그 툴바에는 몇 가지 설정 단계가 필요합니다. 설치 가이드 <https://"
"django-debug-toolbar.readthedocs.io/en/latest/installation.html>`_에서 해당 "
"단계를 따르세요. Django의 일정과 독립적으로 변경되는 서드 파티 패키지이므로 "
"이 자습서에서는 중복하여 기술하지 않겠습니다."

msgid ""
"Once installed, you should be able to see the DjDT \"handle\" on the right "
"side of the browser window when you refresh the polls application. Click it "
"to open the debug toolbar and use the tools in each panel. See the `panels "
"documentation page <https://django-debug-toolbar.readthedocs.io/en/latest/"
"panels.html>`__ for more information on what the panels show."
msgstr ""
"설치가 완료되면, 설문 어플리케이션을 새로 고침할 때 브라우저 창의 오른쪽에 "
"DjDT \"handle\"이 표시됩니다. 디버그 툴바를 클릭하여 열고 각 패널의 도구를 사"
"용하십시오. 패널에 표시되는 내용에 대한 자세한 정보는 `패널 설명 페이지 "
"<https://django-debug-toolbar.readthedocs.io/en/latest/panels.html>`__를 참조"
"하십시오."

msgid "Getting help from others"
msgstr "다른 사람의 도움 받기"

msgid ""
"At some point you will run into a problem, for example the toolbar may not "
"render. When this happens and you're unable to resolve the issue yourself, "
"there are options available to you."
msgstr ""
"예를 들어 툴바가 렌더링 되지 않는 등의 문제가 어느 순간에 발생할 수 있습니"
"다. 이러한 문제가 발생하고 직접 문제를 해결할 수 없는 경우에 사용할 수 있는 "
"옵션이 있습니다. "

msgid ""
"If the problem is with a specific package, check if there's a "
"troubleshooting of FAQ in the package's documentation. For example the "
"Django Debug Toolbar has a `Tips section <https://django-debug-toolbar."
"readthedocs.io/en/latest/tips.html>`_ that outlines troubleshooting options."
msgstr ""
"특정 패키지에 문제가 있는 경우 해당 패키지의 문서에 FAQ의 문제 해결 방법이 있"
"는지 확인하세요. 예를 들어 Django 디버그 도구 모음에는 문제 해결 옵션을 간략"
"하게 설명하는 '팁 섹션 <https://django-debug-toolbar.readthedocs.io/en/"
"latest/tips.html>`_'이 있습니다."

msgid ""
"Search for similar issues on the package's issue tracker. Django Debug "
"Toolbar’s is `on GitHub <https://github.com/jazzband/django-debug-toolbar/"
"issues?q=is%3Aissue+is%3Aopen+sort%3Aupdated-desc>`_."
msgstr ""
"패키지의 이슈 트래커에서 유사한 이슈를 검색하세요. Django 디버그 도구 모음은 "
"`온 GitHub <https://github.com/jazzband/django-debug-toolbar/issues?"
"q=is%3Aissue+is%3Aopen+sort%3Aupdated-desc>`_입니다."

msgid "Consult the `Django Forum <https://forum.djangoproject.com/>`_."
msgstr "`Django Forum <https://forum.djangoproject.com/>`_ 을 참고하십시오."

msgid "Join the `Django Discord server <https://discord.gg/xcRH6mN4fa>`_."
msgstr ""
"`Django Discord server <https://discord.gg/xcRH6mN4fa>`_에 가입하십시오."

msgid "Join the #Django IRC channel on `Libera.chat <https://libera.chat/>`_."
msgstr "`Libera.chat <https://libera.chat/>`_의 #Django IRC 채에 가입하십시오."

msgid "Installing other third-party packages"
msgstr "다른 서드파티 패키지 설치하기"

msgid ""
"There are many more third-party packages, which you can find using the "
"fantastic Django resource, `Django Packages <https://djangopackages.org/>`_."
msgstr ""
"더 많은 서드파티 패키지가 있습니다. 이 패키지는 훌륭한 Django 리소스인 "
"`Django Packages <https://djangopackages.org/>`_ 에서 찾을 수 있습니다. "

msgid ""
"It can be difficult to know what third-party packages you should use. This "
"depends on your needs and goals. Sometimes it's fine to use a package that's "
"in its alpha state. Other times, you need to know it's production ready. "
"`Adam Johnson has a blog post <https://adamj.eu/tech/2021/11/04/the-well-"
"maintained-test/>`_ that outlines a set of characteristics that qualifies a "
"package as \"well maintained\". Django Packages shows data for some of these "
"characteristics, such as when the package was last updated."
msgstr ""
"어떤 서드파티 패키지를 사용해야 하는지 알기 어려울 수 있습니다. 이는 여러분"
"의 필요와 목표에 따라 달라집니다. 때로는 알파 상태의 패키지를 사용해도 괜찮"
"을 때가 있습니다. 다른 경우에는 프로덕션 준비가 완료된 패키지를 사용해야 할 "
"수도 있습니다. Adam Johnson의 블로그 게시물 <https://adamj.eu/"
"tech/2021/11/04/the-well-maintained-test/>`_에는 패키지를 \"잘 유지 관리된"
"(well maintained)\" 것으로 간주하는 일련의 특징에 대한 설명이 나와 있습니다. "
"Django 패키지는 패키지가 마지막으로 업데이트된 시기와 같은 일부 특징들에 대"
"한 데이터를 보여줍니다."

msgid ""
"As Adam points out in his post, when the answer to one of the questions is "
"\"no\", that's an opportunity to contribute."
msgstr ""
"Adam이 그의 게시물에서 지적했듯이, 질문 중 하나에 대한 대답이 \"아니오\"일 "
"때, 그것은 기여할 수 있는 기회입니다."

msgid ""
"The beginner tutorial ends here. In the meantime, you might want to check "
"out some pointers on :doc:`where to go from here </intro/whatsnext>`."
msgstr ""
"초보 자습서는 여기서 끝납니다. 아울러 :doc:`앞으로 무엇을 해야할 지 </intro/"
"whatsnext>` 문서를 좀 더 읽어볼 수 있습니다."

msgid ""
"If you are familiar with Python packaging and interested in learning how to "
"turn polls into a \"reusable app\", check out :doc:`Advanced tutorial: How "
"to write reusable apps</intro/reusable-apps>`."
msgstr ""
"파이썬 패키징에 익숙하고 설문 조사를 \"재사용 가능한 앱\"으로 바꾸는 방법을 "
"배우고 싶다면 :doc:`심화 튜토리얼:재사용 가능한 애플리케이션을 만드는 법 </"
"intro/reusable-apps>`\\ 을 읽어보십시오."

msgid "What to read next"
msgstr "다음에 읽을 내용"

msgid ""
"So you've read all the :doc:`introductory material </intro/index>` and have "
"decided you'd like to keep using Django. We've only just scratched the "
"surface with this intro (in fact, if you've read every single word, you've "
"read about 5% of the overall documentation)."
msgstr ""
"당신은 지금까지 :doc:`소개 자료 </intro/index>`\\ 를 모두 읽었으며 Django를 "
"계속 사용하기로 결정했습니다. 하지만 우리는 이 소개 자료로 그저 겉핥기를 했을"
"뿐 입니다 (실제로 단어수로 세어보면 전체 문서의 약 5%를 읽은것 입니다.)."

msgid "So what's next?"
msgstr "그럼 다음은 뭘 하죠?"

msgid ""
"Well, we've always been big fans of learning by doing. At this point you "
"should know enough to start a project of your own and start fooling around. "
"As you need to learn new tricks, come back to the documentation."
msgstr ""
"글쎄요, 우린 항상 해보는것을 통한 배움의 열성팬이었습니다. 이 시점에서 자신"
"의 프로젝트를 시작할 수 있는 충분한 지식을 가지고 있으며 무언가 잘 안 되어 새"
"로운 트릭을 배워야 할 때 문서로 돌아가십시오."

msgid ""
"We've put a lot of effort into making Django's documentation useful, clear "
"and as complete as possible. The rest of this document explains more about "
"how the documentation works so that you can get the most out of it."
msgstr ""
"우리는 Django의 문서를 최대한 유용하고 명확하며 완벽하게 만들기 위해 많은 노"
"력을 기울였습니다. 이 문서의 나머지 부분에서는 문서를 최대한 활용할 수 있도"
"록 설명서의 작동 방식에 대해 자세히 설명할 것입니다."

msgid ""
"(Yes, this is documentation about documentation. Rest assured we have no "
"plans to write a document about how to read the document about "
"documentation.)"
msgstr ""
"(예, 이것은 문서에 대한 문서입니다. 문서에 대한 문서를 읽는 방법에 대한 문서"
"를 작성할 계획이 없으니 안심하십시오.)"

msgid "Finding documentation"
msgstr "문서 찾기"

msgid ""
"Django's got a *lot* of documentation -- almost 450,000 words and counting "
"-- so finding what you need can sometimes be tricky. A good place to start "
"is the :ref:`genindex`. We also recommend using the builtin search feature."
msgstr ""
"Django는 약 45만 개의 단어와 숫자를 셀 수 있는 *많은* 문서를 가지고 있습니"
"다. 그래서 필요한 것을 찾는 것은 가끔 어려울 수 있습니다. 먼저 :ref:"
"`genindex`를 사용하는 것이 좋습니다. 또한 기본 제공 검색 기능을 사용하는 것"
"이 좋습니다."

msgid "Or you can just browse around!"
msgstr "아니면 그냥 둘러 볼 수 있습니다!"

msgid "How the documentation is organized"
msgstr "이 문서의 구조"

msgid ""
"Django's main documentation is broken up into \"chunks\" designed to fill "
"different needs:"
msgstr ""
"Django의 주요 문서는 서로 다른 필요를 채우기 위해 설계된 \"덩어리\"로 나뉩니"
"다."

msgid ""
"The :doc:`introductory material </intro/index>` is designed for people new "
"to Django -- or to web development in general. It doesn't cover anything in "
"depth, but instead gives a high-level overview of how developing in Django "
"\"feels\"."
msgstr ""
":doc:`introductory material </intro/index>` 는 일반적으로 Django를 처음 접하"
"거나 웹 개발을 하는 사람들을 위해 만들어졌습니다. 이 책은 깊이 있는 내용을 다"
"루지 않고, Djagno의 발전 과정을 개괄적으로 보여줍니다."

msgid ""
"The :doc:`topic guides </topics/index>`, on the other hand, dive deep into "
"individual parts of Django. There are complete guides to Django's :doc:"
"`model system </topics/db/index>`, :doc:`template engine </topics/"
"templates>`, :doc:`forms framework </topics/forms/index>`, and much more."
msgstr ""
"반면에 :doc:`주제 가이드 </topics/index>`\\ 는 장고의 각 부분에 깊이 들어가 "
"있습니다. Django에 대한 완전한 가이드가 있습니다 :doc:`모델 시스템 </topics/"
"db/index>`, :doc:`템플릿 엔진 </topics/templates>`, :doc:`폼 프레임워크 </"
"topics/forms/index>`, 그리고 이외에 더 많은것들이 있지요."

msgid ""
"This is probably where you'll want to spend most of your time; if you work "
"your way through these guides you should come out knowing pretty much "
"everything there is to know about Django."
msgstr ""
"아마도 여기서 대부분의 시간을 보내고 싶어 할 것입니다. 이 가이드를 통해 길을 "
"찾으면 장고에 대해 알아야 할 모든 것을 알게됩니다."

msgid ""
"Web development is often broad, not deep -- problems span many domains. "
"We've written a set of :doc:`how-to guides </howto/index>` that answer "
"common \"How do I ...?\" questions. Here you'll find information about :doc:"
"`generating PDFs with Django </howto/outputting-pdf>`, :doc:`writing custom "
"template tags </howto/custom-template-tags>`, and more."
msgstr ""
"웹 개발은 종종 광범위하지 않고 심층적이지 않은 문제가 많은 영역에 걸쳐 있습니"
"다. 우리는 공통적인 \"어떻게 해야 합니까?\"에 대해 답하는 :doc:`how-to 가이"
"드 </howto/index>` 세트를 작성했습니다. :doc:`Django로 PDF 생성하기 </howto/"
"outputting-pdf>`, :doc:`사용자 정의 템플릿 태그 작성하기 </howto/custom-"
"template-tags>` 등의 정보를 찾을 수 있습니다."

msgid ""
"Answers to really common questions can also be found in the :doc:`FAQ </faq/"
"index>`."
msgstr ""
"정말로 일반적인 질문에 대한 답은 :doc:`FAQ </faq/index>` 에서도 찾을 수 있습"
"니다."

msgid ""
"The guides and how-to's don't cover every single class, function, and method "
"available in Django -- that would be overwhelming when you're trying to "
"learn. Instead, details about individual classes, functions, methods, and "
"modules are kept in the :doc:`reference </ref/index>`. This is where you'll "
"turn to find the details of a particular function or whatever you need."
msgstr ""
"가이드와 하우투는 장고에서 사용 가능한 모든 클래스, 함수 및 메소드를 다루지"
"는 않습니다. 이는 그저 배우려고 할 때 보기에는 좀 지나친 것입니다. 대신 개별 "
"클래스, 함수, 메소드 및 모듈에 대한 세부 정보는 :doc:`reference </ref/"
"index>` 에 보관됩니다. 여기서 특정 기능 또는 원하는 기능의 세부 정보를 찾을 "
"수 있습니다."

msgid ""
"If you are interested in deploying a project for public use, our docs have :"
"doc:`several guides</howto/deployment/index>` for various deployment setups "
"as well as a :doc:`deployment checklist</howto/deployment/checklist>` for "
"some things you'll need to think about."
msgstr ""
"공개적으로 프로젝트를 배포하는 데 관심이 있다면, 다양한 배포 설정을 위한 :"
"doc:`여러 가지 안내서 </howto/deployment/index>` 뿐만 아니라 생각해볼 만한 :"
"doc:`배포 체크리스트 </howto/deployment/checklist>` 가 있습니다."

msgid ""
"Finally, there's some \"specialized\" documentation not usually relevant to "
"most developers. This includes the :doc:`release notes </releases/index>` "
"and :doc:`internals documentation </internals/index>` for those who want to "
"add code to Django itself, and a :doc:`few other things that don't fit "
"elsewhere </misc/index>`."
msgstr ""
"마지막으로, 대부분의 개발자와는 관련이 없는 \"전문화 된\" 설명서가 있습니다. "
"여기에는 Django 자체에 코드를 추가하려는 사람들을 위한 :doc:`release notes </"
"releases/index>` 및 :doc:`internals documentation </internals/index>`, 그리"
"고 :doc:`few other things that don't fit elsewhere </misc/index>`들이 있습니"
"다."

msgid "How documentation is updated"
msgstr "문서는 어떻게 업데이트 되는가"

msgid ""
"Just as the Django code base is developed and improved on a daily basis, our "
"documentation is consistently improving. We improve documentation for "
"several reasons:"
msgstr ""
"Django 코드 기반이 매일 개발되고 개선되는 것처럼 우리의 문서는 지속적으로 개"
"선되고 있습니다. 몇 가지 이유로 문서를 개선합니다."

msgid "To make content fixes, such as grammar/typo corrections."
msgstr "문법/오타 수정과 같은 내용 수정."

msgid ""
"To add information and/or examples to existing sections that need to be "
"expanded."
msgstr "확장해야 할 기존 섹션에 정보 또는 예제를 추가합니다."

msgid ""
"To document Django features that aren't yet documented. (The list of such "
"features is shrinking but exists nonetheless.)"
msgstr ""
"아직 문서화되지 않은 Django 기능을 문서화합니다. (이러한 기능 목록은 줄어들"
"지 만 그럼에도 불구하고 존재합니다.)"

msgid ""
"To add documentation for new features as new features get added, or as "
"Django APIs or behaviors change."
msgstr ""
"새로운 기능이 추가되거나 Django API 또는 동작이 변경됨에 따라 새로운 기능에 "
"대한 문서를 추가 할 수 있습니다."

msgid ""
"Django's documentation is kept in the same source control system as its "
"code. It lives in the :source:`docs` directory of our Git repository. Each "
"document online is a separate text file in the repository."
msgstr ""
"Django의 문서는 소스 코드와 동일한 소스 코드 관리 시스템에서 보관됩니다. 이 "
"문서는 Git 저장소의 :source: `docs` 디렉토리에 있습니다. 각 온라인 문서는 저"
"장소에 있는 분리된 텍스트 파일입니다."

msgid "Where to get it"
msgstr "어디서 구할 수 있습니까?"

msgid ""
"You can read Django documentation in several ways. They are, in order of "
"preference:"
msgstr ""
"Django 문서는 여러 가지 방법으로 읽을 수 있습니다. 그들은 선호 순서대로:"

msgid "On the web"
msgstr "웹 상에서"

msgid ""
"The most recent version of the Django documentation lives at https://docs."
"djangoproject.com/en/dev/. These HTML pages are generated automatically from "
"the text files in source control. That means they reflect the \"latest and "
"greatest\" in Django -- they include the very latest corrections and "
"additions, and they discuss the latest Django features, which may only be "
"available to users of the Django development version. (See :ref:`differences-"
"between-doc-versions` below.)"
msgstr ""
"Django 최신 버전 문서는 https://docs.djangoproject.com/en/dev/\\에 있습니다. "
"소스 컨트롤의 텍스트 파일에서 이 HTML 페이지들이 자동으로 생성됩니다. 즉 "
"Django의 \"최신이자 최고\"가 반영됩니다. 최신 수정 및 추가사항을 포함하며, "
"Django 개발 버전에만 있을 수도 있는 최신 Django 기능을 다룹니다.(아래의 :ref:"
"`differences-between-doc-versions` 참조)"

msgid ""
"We encourage you to help improve the docs by submitting changes, corrections "
"and suggestions in the `ticket system`_. The Django developers actively "
"monitor the ticket system and use your feedback to improve the documentation "
"for everybody."
msgstr ""
"`ticket system`_\\에서 변경 사항, 수정 사항 및 제안 사항을 제출하여 문서 개선"
"에 도움을 받으시기 바랍니다. Django 개발자는 티켓 시스템을 적극적으로 모니터"
"링하고 여러분의 피드백을 사용하여 모든 사람의 문서를 개선합니다."

msgid ""
"Note, however, that tickets should explicitly relate to the documentation, "
"rather than asking broad tech-support questions. If you need help with your "
"particular Django setup, try the |django-users| mailing list or the `#django "
"IRC channel`_ instead."
msgstr ""
"그러나 티켓은 광범위한 기술 지원 질문을 하기보다는 문서와 명시적으로 관련되어"
"야합니다. 특정 장고 설정에 대한 도움이 필요하면 |django-users| 메일링 리스트 "
"또는 `#django IRC channel`_\\을 사용하세요."

msgid "In plain text"
msgstr "일반 텍스트"

msgid ""
"For offline reading, or just for convenience, you can read the Django "
"documentation in plain text."
msgstr ""
"오프라인 읽기 또는 편의를 위해 Django 문서를 일반 텍스트로 읽을 수 있습니다."

msgid ""
"If you're using an official release of Django, the zipped package (tarball) "
"of the code includes a ``docs/`` directory, which contains all the "
"documentation for that release."
msgstr ""
"Django 공식 릴리스를 사용하고 있다면, 코드의 압축된 패키지(tarball)에 ``docs/"
"`` 디렉터리가 있으며, 그곳에 해당 릴리스 문서가 있습니다."

msgid ""
"If you're using the development version of Django (aka the main branch), the "
"``docs/`` directory contains all of the documentation. You can update your "
"Git checkout to get the latest changes."
msgstr ""
"Django의 개발 버전(일명 main branch)을 사용하는 경우 ''docs/'' 디렉토리에 모"
"든 문서가 포함되어 있습니다. Git checkout을 업데이트하여 최신 변경 사항을 얻"
"을 수 있습니다."

msgid ""
"One low-tech way of taking advantage of the text documentation is by using "
"the Unix ``grep`` utility to search for a phrase in all of the "
"documentation. For example, this will show you each mention of the phrase "
"\"max_length\" in any Django document:"
msgstr ""
"텍스트 문서를 활용하는 하나의 낡은 기술은 Unix의 ``grep`` 유틸리티를 사용하"
"여 모든 문서에서 문구를 검색하는 것입니다. 예를 들어 이 명령은 Django 문서에"
"서 \"max_length\" 라는 문구가 언급된걸 보여줍니다:"

msgid "As HTML, locally"
msgstr "로컬 HTML"

msgid ""
"You can get a local copy of the HTML documentation following a few steps:"
msgstr "다음 몇 단계를 거쳐 HTML 문서의 로컬 복사본을 얻을 수 있습니다."

msgid ""
"Django's documentation uses a system called Sphinx__ to convert from plain "
"text to HTML. You'll need to install Sphinx by either downloading and "
"installing the package from the Sphinx website, or with ``pip``:"
msgstr ""
"Django의 문서에서는 Sphinx__\\라는 시스템을 사용하여 일반 텍스트를 HTML로 변"
"환합니다. Sphinx 웹 사이트에서 패키지를 다운로드하고 설치하거나 \"pip\"로 설"
"치해야합니다."

msgid ""
"Then, use the included ``Makefile`` to turn the documentation into HTML:"
msgstr "포함된 ``Makefile``을 사용해서 문서를 HTML로 바꾸세요:"

msgid "You'll need `GNU Make`__ installed for this."
msgstr "이것을 위해 `GNU Make`__\\가 설치되어 있어야 합니다."

msgid "If you're on Windows you can alternatively use the included batch file:"
msgstr "Windows를 사용하는 경우 포함 된 배치 파일을 대신 사용할 수 있습니다."

msgid "The HTML documentation will be placed in ``docs/_build/html``."
msgstr "HTML 문서는 ``docs/_build/html``\\ 에 있습니다."

msgid "Differences between versions"
msgstr "버전 간 차이점"

msgid ""
"The text documentation in the main branch of the Git repository contains the "
"\"latest and greatest\" changes and additions. These changes include "
"documentation of new features targeted for Django's next :term:`feature "
"release <Feature release>`. For that reason, it's worth pointing out our "
"policy to highlight recent changes and additions to Django."
msgstr ""
"Git 저장소의 main branch에 있는 문서에는 \"최신이자 최고의\" 변경사항과 추가"
"사항이 포함되어 있습니다. 이러한 변경사항에는 Django의 다음 :term:`feature "
"release <Feature release>`를 대상으로 하는 새로운 기능에 대한 문서화가 포함됩"
"니다. 그런 이유로 최근 Django에 대한 변화와 추가 사항을 부각시키는 우리 정책"
"을 짚어볼 필요가 있습니다."

msgid "We follow this policy:"
msgstr "우리는 다음과 같은 정책을 따릅니다."

msgid ""
"The development documentation at https://docs.djangoproject.com/en/dev/ is "
"from the main branch. These docs correspond to the latest feature release, "
"plus whatever features have been added/changed in the framework since then."
msgstr ""
"https://docs.djangoproject.com/en/dev/의 개발 문서는 main branch에서 가져온 "
"것입니다. 이 문서는 최신 기능 release와 그 이후 프레임워크에 추가/변경된 모"
"든 기능에 해당합니다."

msgid ""
"As we add features to Django's development version, we update the "
"documentation in the same Git commit transaction."
msgstr ""
"Django의 개발 버전에 기능을 추가함에 따라, 같은 Git 커밋 트랜잭션에 문서를 갱"
"신합니다."

msgid ""
"To distinguish feature changes/additions in the docs, we use the phrase: "
"\"New in Django Development version\" for the version of Django that hasn't "
"been released yet, or \"New in version X.Y\" for released versions."
msgstr ""
"문서에서 기능 변경/추가를 구분하기 위해, 아직 릴리스되지 않은 Django 버전에 "
"대해서는 \"New in Django Development version\"으로, 릴리스된 버전에 대해서는 "
"\"New in version X.Y\"로 표현합니다."

msgid ""
"Documentation fixes and improvements may be backported to the last release "
"branch, at the discretion of the merger, however, once a version of Django "
"is :ref:`no longer supported<supported-versions-policy>`, that version of "
"the docs won't get any further updates."
msgstr ""
"문서 수정 및 개선은 커미터의 재량에 따라 최신 릴리스 브랜치에 백포트될 수 있"
"습니다. 그러나, Django 버전이 :ref:`더 이상 지원되지 않는 경우 <supported-"
"versions-policy>`, 해당 버전 문서는 갱신되지 않습니다."

msgid ""
"The `main documentation web page`_ includes links to documentation for "
"previous versions. Be sure you are using the version of the docs "
"corresponding to the version of Django you are using!"
msgstr ""
"The `main documentation web page`_에는 이전 버전의 설명서에 대한 링크가 포함"
"되어 있습니다. 사용 중인 Django 버전에 해당하는 문서 버전을 사용하고 있는지 "
"확인하십시오!"
