# SOME DESCRIPTIVE TITLE.
# Copyright (C) Django Software Foundation and contributors
# This file is distributed under the same license as the Django package.
#
# Translators:
# bgchoi <choi.byunggil@gmail.com>, 2017
# ByungChul Kim <bcking92@gmail.com>, 2019
# DONGHO JEONG <nearermg@gmail.com>, 2020
# Geonho Kim / Leo Kim <gh.leokim@gmail.com>, 2019
# Gyeongjun Paik <paikend@gmail.com>, 2022
# Hwang, Geon Gu <under_09@naver.com>, 2016
# hj.park <imcreator3@gmail.com>, 2017
# Jay Oh <theanswer.jay@gmail.com>, 2020
# JinSang Park <jsgd1254@gmail.com>, 2019
# 전세옥 <jso4967@gmail.com>, 2019
# Seho Noh <iam@sehonoh.kr>, 2018
# Peace Kim, 2019
# SeongSoo Cho <ppiyakk2@printf.kr>, 2019
# silee9019 <silee9019@gmail.com>, 2015
# Song M. Kim <songmink@hawaii.edu>, 2018
# WooSuck Ko <ryanko7@ajou.ac.kr>, 2020
# yangbeom <yangbeomsu@gmail.com>, 2016
# Yang Chan Woo <oizys18@gmail.com>, 2019
# Yeon Haeng Cho <ntype.joe@gmail.com>, 2019
# Yong Choi <sk8er.choi@gmail.com>, 2019
# Yongjin Jo <wnrhd114@gmail.com>, 2018
# Yongtaek Jun <guardian.yong@gmail.com>, 2019
# Yoon Kim, 2017
# Youngjun Lee, 2022
msgid ""
msgstr ""
"Project-Id-Version: django-docs\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-02-21 01:06-0600\n"
"PO-Revision-Date: 2022-02-25 08:50+0000\n"
"Last-Translator: Youngjun Lee\n"
"Language-Team: Korean (http://www.transifex.com/django/django-docs/language/"
"ko/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ko\n"
"Plural-Forms: nplurals=1; plural=0;\n"

msgid "How to authenticate using ``REMOTE_USER``"
msgstr "\"REMOTE_USER\"를 이용해 인증하는 방법"

msgid ""
"This document describes how to make use of external authentication sources "
"(where the web server sets the ``REMOTE_USER`` environment variable) in your "
"Django applications.  This type of authentication solution is typically seen "
"on intranet sites, with single sign-on solutions such as IIS and Integrated "
"Windows Authentication or Apache and `mod_authnz_ldap`_, `CAS`_, `Cosign`_, "
"`WebAuth`_, `mod_auth_sspi`_, etc."
msgstr ""

msgid ""
"When the web server takes care of authentication it typically sets the "
"``REMOTE_USER`` environment variable for use in the underlying application.  "
"In Django, ``REMOTE_USER`` is made available in the :attr:`request.META "
"<django.http.HttpRequest.META>` attribute.  Django can be configured to make "
"use of the ``REMOTE_USER`` value using the ``RemoteUserMiddleware`` or "
"``PersistentRemoteUserMiddleware``, and :class:`~django.contrib.auth."
"backends.RemoteUserBackend` classes found in :mod:`django.contrib.auth`."
msgstr ""

msgid "Configuration"
msgstr "설정"

msgid ""
"First, you must add the :class:`django.contrib.auth.middleware."
"RemoteUserMiddleware` to the :setting:`MIDDLEWARE` setting **after** the :"
"class:`django.contrib.auth.middleware.AuthenticationMiddleware`::"
msgstr ""
"우선,  :class:`django.contrib.auth.middleware.AuthenticationMiddleware`\\를 "
"설정하기 전에 :setting:`MIDDLEWARE`\\에 :class:`django.contrib.auth."
"middleware.RemoteUserMiddleware`\\를 추가해야 합니다."

msgid ""
"Next, you must replace the :class:`~django.contrib.auth.backends."
"ModelBackend` with :class:`~django.contrib.auth.backends.RemoteUserBackend` "
"in the :setting:`AUTHENTICATION_BACKENDS` setting::"
msgstr ""
"그 다음 , :setting:`AUTHENTICATION_BACKENDS` 세팅에 있는 :class:`~django."
"contrib.auth.backends.ModelBackend`\\를 :class:`~django.contrib.auth."
"backends.RemoteUserBackend`\\로 바꿔야 합니다."

msgid ""
"With this setup, ``RemoteUserMiddleware`` will detect the username in "
"``request.META['REMOTE_USER']`` and will authenticate and auto-login that "
"user using the :class:`~django.contrib.auth.backends.RemoteUserBackend`."
msgstr ""
"설정을 마치고 난 후, ``RemoteUserMiddleware``\\는 유저네임을 ``request."
"META['REMOTE_USER']``\\에서 찾을 수 있을 것 입니다. 그리고 :class:`~django."
"contrib.auth.backends.RemoteUserBackend`\\를 이용하여 사용자를 증명하고 자동 "
"로그인을 할 것입니다."

msgid ""
"Be aware that this particular setup disables authentication with the default "
"``ModelBackend``. This means that if the ``REMOTE_USER`` value is not set "
"then the user is unable to log in, even using Django's admin interface. "
"Adding ``'django.contrib.auth.backends.ModelBackend'`` to the "
"``AUTHENTICATION_BACKENDS`` list will use ``ModelBackend`` as a fallback if "
"``REMOTE_USER`` is absent, which will solve these issues."
msgstr ""
"이 설정은 인증을 기본 ``ModelBackend``\\로 사용하지 못하게 합니다. 그 말은 만"
"약 ``REMOTE_USER`` 값이 설정되어 있지 않으면 Django의 관리 인터페이스를 사용"
"한다 하더라도 사용자는 로그인할 수 없다는 것입니다. ``django.contrib.auth."
"backends.ModelBackend``\\를 ``AUTHENTICATION_BACKENDS`` 리스트에 추가하면 "
"``REMOTE_USER``\\가 없을 경우``ModelBackend``\\로 대체하여 이 문제를 해결할 "
"수 있습니다."

msgid ""
"Django's user management, such as the views in ``contrib.admin`` and the :"
"djadmin:`createsuperuser` management command, doesn't integrate with remote "
"users. These interfaces work with users stored in the database regardless of "
"``AUTHENTICATION_BACKENDS``."
msgstr ""
"``contrib.admin``\\의 뷰와 :djadmin:`createsuperuser` 관리 명령과 같은 Django"
"의 사용자 관리는 원격 사용자와 통합할 수 없습니다. 이 인터페이스들은 "
"``AUTHENTICATION_BACKENDS``\\와 상관없이 데이터페이스에 저장된 사용자와만 작"
"동합니다."

msgid ""
"Since the ``RemoteUserBackend`` inherits from ``ModelBackend``, you will "
"still have all of the same permissions checking that is implemented in "
"``ModelBackend``."
msgstr ""
"``RemoteUserBackend``\\는 ``ModelBackend``\\를 상속하기 때문에 독자는 "
"``ModelBackend``\\에서 구현된 권한 확인을 모두 그대로 가지고 있습니다."

msgid ""
"Users with :attr:`is_active=False <django.contrib.auth.models.User."
"is_active>` won't be allowed to authenticate. Use :class:`~django.contrib."
"auth.backends.AllowAllUsersRemoteUserBackend` if you want to allow them to."
msgstr ""
" :attr:`is_active=False <django.contrib.auth.models.User.is_active>`\\인 사용"
"자에게는 인증이 허락되지 않을 것입니다. 허락을 하기 위해서는 :class:`~django."
"contrib.auth.backends.AllowAllUsersRemoteUserBackend`\\를 사용하세요."

msgid ""
"If your authentication mechanism uses a custom HTTP header and not "
"``REMOTE_USER``, you can subclass ``RemoteUserMiddleware`` and set the "
"``header`` attribute to the desired ``request.META`` key.  For example::"
msgstr ""
"만약에 여러분의 인증 메커니즘이 ``REMOTE_USER``\\가 아닌 맞춤 HTTP 헤더를 사"
"용한다면 독자는 ``RemoteUserMiddleware``\\를 서브클래스화할 수 있고 "
"``header`` 속성을 요구되는 ``request.META`` 키로 설정할 수 있습니다. 다음의 "
"예를 보세요."

msgid ""
"Be very careful if using a ``RemoteUserMiddleware`` subclass with a custom "
"HTTP header. You must be sure that your front-end web server always sets or "
"strips that header based on the appropriate authentication checks, never "
"permitting an end-user to submit a fake (or \"spoofed\") header value. Since "
"the HTTP headers ``X-Auth-User`` and ``X-Auth_User`` (for example) both "
"normalize to the ``HTTP_X_AUTH_USER`` key in ``request.META``, you must also "
"check that your web server doesn't allow a spoofed header using underscores "
"in place of dashes."
msgstr ""
"맞춤 HTTP 헤더로 ``RemoteUserMiddleware`` 서브클래스를 사용한다면 매우 조심해"
"야 합니다. 독자는 반드시 자신의 프론트엔드 웹서버가 최종 사용자가 가짜 헤더 "
"값을 보내는 것을 허용하지 않도록 헤더를 적절한 인증 확인을 기반으로 설정하여"
"야 합니다. HTTP 헤더 ``X-Auth-User``\\와 ``X-Auth_User`` (예를 들어) 모두 "
"``request.META``\\에서 ``HTTP_X_AUTH_USER`` 키로 표준화되기 때문에 독자는 또"
"한 본인의 웹 서버가 밑줄을 사용한 스푸핑된 헤더를 허용하지 않도록 확인하여야 "
"합니다."

msgid ""
"This warning doesn't apply to ``RemoteUserMiddleware`` in its default "
"configuration with ``header = 'REMOTE_USER'``, since a key that doesn't "
"start with ``HTTP_`` in ``request.META`` can only be set by your WSGI "
"server, not directly from an HTTP request header."
msgstr ""
"이 경고는 ``header = 'REMOTE_USER'``\\인 기본 설정에서 "
"``RemoteUserMiddleware``\\를 적용하지 않습니다. ``request.META``\\에서 "
"``HTTP_``\\로 시작하지 않는 키는 HTTP 요청 헤더로부터 직접이 아닌 WSGI 서버"
"를 통해서만 설정될 수 있기 때문입니다."

msgid ""
"If you need more control, you can create your own authentication backend "
"that inherits from :class:`~django.contrib.auth.backends.RemoteUserBackend` "
"and override one or more of its attributes and methods."
msgstr ""
"만약 독자가 더 많은 제어를 필요로 할 경우, :class:`~django.contrib.auth."
"backends.RemoteUserBackend`\\를 상속하는 인증 백엔드를 스스로 만들어 하나 이"
"상의 속성과 메소드를 오버라이드할 수 있습니다."

msgid "Using ``REMOTE_USER`` on login pages only"
msgstr "``REMOTE_USER``\\는 로그인 페이지에서만 사용할 수 있습니다."

msgid ""
"The ``RemoteUserMiddleware`` authentication middleware assumes that the HTTP "
"request header ``REMOTE_USER`` is present with all authenticated requests. "
"That might be expected and practical when Basic HTTP Auth with ``htpasswd`` "
"or similar mechanisms are used, but with Negotiate (GSSAPI/Kerberos) or "
"other resource intensive authentication methods, the authentication in the "
"front-end HTTP server is usually only set up for one or a few login URLs, "
"and after successful authentication, the application is supposed to maintain "
"the authenticated session itself."
msgstr ""
"인증 미들웨어인 ``RemoteUserMiddleware``\\는 HTTP 요청 헤더인 ``REMOTE_USER``"
"\\가 모든 인증된 요청과 함께 존재한다는 것을 가정합니다. 이것은 Basic HTTP "
"Auth가 ``htpasswd`` 또는 기타 간단한 메커니즘들과 함께일 때 기대거나 실용적이"
"지만,  Negotiate(GSSAPI / Kerberos) 또는 기타 자원 집약적인 인증 방법과 함께 "
"일 때는, 프런트엔드 HTTP 서버에서의 인증은 일반적으로 하나 또는 몇 개의 로그"
"인 URL을 설정해야하고, 인증이 성공하면 응용 프로그램은 인증된 세션 자체가 유"
"지 관리된다라는 조건이여야합니다."

msgid ""
":class:`~django.contrib.auth.middleware.PersistentRemoteUserMiddleware` "
"provides support for this use case. It will maintain the authenticated "
"session until explicit logout by the user. The class can be used as a drop-"
"in replacement of :class:`~django.contrib.auth.middleware."
"RemoteUserMiddleware` in the documentation above."
msgstr ""
":class:`~django.contrib.auth.middleware.PersistentRemoteUserMiddleware`\\는 "
"사용 사례에 대한 지원을 제공합니다. 이것은 사용자에 의하여 명시적으로 로그아"
"웃할 때까지 인증된 세션을 유지 관리할 것 입니다. 이 클래스는 위의 문서에서 :"
"class:`~django.contrib.auth.middleware.RemoteUserMiddleware` 일시 대체품으로 "
"사용되어질 수 있습니다. "

msgid "How to write a custom storage class"
msgstr ""

msgid ""
"If you need to provide custom file storage -- a common example is storing "
"files on some remote system -- you can do so by defining a custom storage "
"class. You'll need to follow these steps:"
msgstr ""
"만일 사용자 정의 파일 스토리지를 제공하고자 하는 경우 -- 흔한 예로 원격 시스"
"템에 파일을 저장할 때 -- 사용자 정의 스토리지 클래스를 정의하면 됩니다. 다음 "
"단계들을 진행해주세요."

msgid ""
"Your custom storage system must be a subclass of ``django.core.files.storage."
"Storage``::"
msgstr ""
"당신의 커스텀 저장소 시스템은 ``django.core.files.storage.Storage``\\의 하위 "
"클래스여야만 합니다."

msgid ""
"Django must be able to instantiate your storage system without any "
"arguments. This means that any settings should be taken from ``django.conf."
"settings``::"
msgstr ""
"Django는 어떤 인자없이도 너의 저장 시스템을 인스턴스화 할 수 있습니다. 이는 "
"\"django.conf.settings\"로 부터 설정을 받아 사용한다는 것을 의미합니다."

msgid ""
"Your storage class must implement the :meth:`_open()` and :meth:`_save()` "
"methods, along with any other methods appropriate to your storage class. See "
"below for more on these methods."
msgstr ""
"당신의 저장 클래스는 적절한 다른 메소드와 함께 :meth:'_open()'과 :"
"meth:'_save()' 메소드로 구현돼야합니다. 더 많은 메소드를 아래에서 볼 수 있습"
"니다."

msgid ""
"In addition, if your class provides local file storage, it must override the "
"``path()`` method."
msgstr ""
"추가적으로, 만약 당신의 클래스가 로컬 파일 저장을 하면 \"path()\" 메소드로 오"
"버라이드 되어야만 합니다."

msgid ""
"Your storage class must be :ref:`deconstructible <custom-deconstruct-"
"method>` so it can be serialized when it's used on a field in a migration. "
"As long as your field has arguments that are themselves :ref:`serializable "
"<migration-serializing>`, you can use the ``django.utils.deconstruct."
"deconstructible`` class decorator for this (that's what Django uses on "
"FileSystemStorage)."
msgstr ""
"너의 기억장치 클래스는:ref: '불변` 이여야 하는데, 이로 인해 마이그레이션내의 "
"필드에서 기억장치 클래스가 직렬화되기 때문이다. 필드에 인수가 남아있는한:"
"ref:'직렬가능한', 당신은 ``django.utils.deconstruct.deconstructible`` 클래스 "
"데커레이터를 사용할 수 있다.(이 데커레이터가 Django가 파일체계기억장치에서 사"
"용하는 것이다)"

msgid ""
"By default, the following methods raise ``NotImplementedError`` and will "
"typically have to be overridden:"
msgstr ""
"디폴트로, 다음의 메소드는 ``NotImplementedError``를 일으키고, 일반적으로 오버"
"라이드 되어야 합니다. "

msgid ":meth:`Storage.delete`"
msgstr ":meth:`Storage.delete`"

msgid ":meth:`Storage.exists`"
msgstr ":meth:`Storage.exists`"

msgid ":meth:`Storage.listdir`"
msgstr ":meth:`Storage.listdir`"

msgid ":meth:`Storage.size`"
msgstr ":meth:`Storage.size`"

msgid ":meth:`Storage.url`"
msgstr ":meth:`Storage.url`"

msgid ""
"Note however that not all these methods are required and may be deliberately "
"omitted. As it happens, it is possible to leave each method unimplemented "
"and still have a working Storage."
msgstr ""
"하지만 앞의 모든 메소드들이 필수적인 것은 아니며, 자율적으로 생략될 수 있다"
"는 것을 유의하십시오. 그럴 경우에 각 메소드를 미구현 상태로 내버려 두면서도 "
"작동하는 저장소를 만들 수 있습니다."

msgid ""
"By way of example, if listing the contents of certain storage backends turns "
"out to be expensive, you might decide not to implement ``Storage.listdir()``."
msgstr ""
"한 예시로, 만약 특정 콘텐츠를 지니고 있는 리스트를 백엔드에 저장하는게 고비용"
"이 될 경우 당신은 ``Storage.listdir()``을 구현하지 않아도 된다."

msgid ""
"Another example would be a backend that only handles writing to files. In "
"this case, you would not need to implement any of the above methods."
msgstr ""
"다른 예시로 파일을 쓰기만 하는 백엔드가 있는 경우 당신은 위의 메소드를 구현"
"할 필요가 없을 수 있다."

msgid ""
"Ultimately, which of these methods are implemented is up to you. Leaving "
"some methods unimplemented will result in a partial (possibly broken) "
"interface."
msgstr ""
"궁극적으로, 어떠한 메소드가 구현될 것인가는 당신이 정할 수 있습니다. 몇 몇의 "
"메소드를 미구현 상태로 내버려둔다면 완전하지 않은(혹은 망가진) 인터페이스를 "
"낳을 것입니다."

msgid ""
"You'll also usually want to use hooks specifically designed for custom "
"storage objects. These are:"
msgstr ""
"당신은 또한 커스텀 저장 객체를 위해 특별히 제작된 훅을 사용하고 싶을 것입니"
"다. 이것들은:"

msgid "**Required**."
msgstr "**필수**."

msgid ""
"Called by ``Storage.open()``, this is the actual mechanism the storage class "
"uses to open the file. This must return a ``File`` object, though in most "
"cases, you'll want to return some subclass here that implements logic "
"specific to the backend storage system."
msgstr ""
"\"Storage.open()\"으로 호출하게 되는것이 저장 클래스가 실제로 파일을 열기 위"
"해 사용하는 매커니즘이다. 이는 항상 \"File\" 오브젝트를 반환하는데, 대부분의 "
"경우, 백엔드 저장 시스템에 특정한 논리를 실행하는 몇몇개의 상속들을 너는 반환"
"하고 싶을것이다."

msgid ""
"Called by ``Storage.save()``. The ``name`` will already have gone through "
"``get_valid_name()`` and ``get_available_name()``, and the ``content`` will "
"be a ``File`` object itself."
msgstr ""
"``Storage.save()``으로 호출되다. \"name\" 은 ``get_valid_name()`` 과  "
"``get_available_name()`` 을 이미 통과했을 것이고, ``content`` 는 ``파일`` 객"
"체 자신이 될 것이다."

msgid ""
"Should return the actual name of name of the file saved (usually the "
"``name`` passed in, but if the storage needs to change the file name return "
"the new name instead)."
msgstr ""
"저장된 파일의 실제 이름을 반환해야 합니다(일반적으로 \"이름\"이 전달되지만 저"
"장소의 파일 이름을 변경해야 할 경우 새 이름을 반환합니다.)"

msgid ""
"Returns a filename suitable for use with the underlying storage system. The "
"``name`` argument passed to this method is either the original filename sent "
"to the server or, if ``upload_to`` is a callable, the filename returned by "
"that method after any path information is removed. Override this to "
"customize how non-standard characters are converted to safe filenames."
msgstr ""
"기본 저장 시스템에 사용할 수 있는 파일 이름을 반환합니다. 이 메서드에 전달된 "
"\"name\" 호출 인자는 서버에 전송된 원래의 파일 이름이거나 \"Upload_to\"가 호"
"출 가능한 경우 경로 정보가 제거된 후 해당 메서드에 의해 반환된 파일 이름입니"
"다. 표준 문자가 아닌 문자가 안전한 파일 이름으로 변환되는 방법을 커스터마이즈"
"하려면 이 옵션을 재정의하십시오."

msgid ""
"The code provided on ``Storage`` retains only alpha-numeric characters, "
"periods and underscores from the original filename, removing everything else."
msgstr ""
"\"Storage\"에 제공된 코드는 원래 파일 이름에서 영숫자, 마침표 및 밑줄만 유지"
"하며 다른 모든 것을 제거한다."

msgid ""
"Returns an alternative filename based on the ``file_root`` and ``file_ext`` "
"parameters. By default, an underscore plus a random 7 character alphanumeric "
"string is appended to the filename before the extension."
msgstr ""
"\"file_root\" 및 \"file_ext\" 매개 변수를 기준으로 대체 파일 이름을 반환합니"
"다. 기본적으로 확장명 앞에 밑줄과 임의의 7자 영숫자 문자열이 파일 이름에 추가"
"됩니다."

msgid ""
"Returns a filename that is available in the storage mechanism, possibly "
"taking the provided filename into account. The ``name`` argument passed to "
"this method will have already cleaned to a filename valid for the storage "
"system, according to the ``get_valid_name()`` method described above."
msgstr ""
"저장 메커니즘에서 사용할 수 있는 파일 이름을 반환합니다. 제공된 파일 이름을 "
"고려할 수 있습니다. 위에서 설명한 \"get_valid_name()\" 방법에 따르면 이 방법"
"에 전달된 \"name\" 인수는 이미 스토리지 시스템에 유효한 파일 이름으로 정리될 "
"것입니다."

msgid ""
"The length of the filename will not exceed ``max_length``, if provided. If a "
"free unique filename cannot be found, a :exc:`SuspiciousFileOperation "
"<django.core.exceptions.SuspiciousOperation>` exception is raised."
msgstr ""
"파일 이름의 길이는 제공되는 경우 \"max_length\"를 초과하지 않는다. 사용 가능"
"한 고유 파일 이름을 찾을 수 없는 경우 a:exc:의심스러운 파일 작업 <django."
"core.exceptions.SuspiciousOperation >의 예외가 발생했습니다."

msgid ""
"If a file with ``name`` already exists, ``get_alternative_name()`` is called "
"to obtain an alternative name."
msgstr ""
" ``name``이 이미 존재하는 파일일 경우``get_alternative_name ()``가 호출되어 "
"대체이름을 얻습니다."

msgid "How to write custom lookups"
msgstr ""

msgid ""
"Django offers a wide variety of :ref:`built-in lookups <field-lookups>` for "
"filtering (for example, ``exact`` and ``icontains``). This documentation "
"explains how to write custom lookups and how to alter the working of "
"existing lookups. For the API references of lookups, see the :doc:`/ref/"
"models/lookups`."
msgstr ""
"django는 필터링(예: \"exeact\" 및 \"icontains\")을 위한 다양한 ref:'내장 검"
"색'을 제공한다. 이 문서에서는 사용자 정의 룩업을 작성하는 방법과 기존 조회의 "
"작업을 변경하는 방법에 대해 설명합니다. 조회에 대한 API 참조는 :doc:'/ref/"
"models/lookups'를 참조하십시오."

msgid "A lookup example"
msgstr "조회 예제"

msgid ""
"Let's start with a small custom lookup. We will write a custom lookup ``ne`` "
"which works opposite to ``exact``. ``Author.objects."
"filter(name__ne='Jack')`` will translate to the SQL:"
msgstr ""
"소규모 사용자 맞춤 조회부터 시작하겠습니다. 우리는 \"exact\"와 상반되는 맞춤"
"형 조회 \"ne\"을 작성할 것이다. \"Author.objects.filter(name__ne = 'Jack')는 "
"SQL로 변환됩니다."

msgid ""
"This SQL is backend independent, so we don't need to worry about different "
"databases."
msgstr ""
"이 SQL은 백엔드에 독립적이어서 다른 데이터베이스에 대해서 염려를 안해도 됩니"
"다."

msgid ""
"There are two steps to making this work. Firstly we need to implement the "
"lookup, then we need to tell Django about it::"
msgstr ""
"이 작업을 수행하는 데는 두 가지 단계가 있습니다. 먼저 조회를 구현한 후 Django"
"에게 다음과 같이 알려야 합니다."

msgid ""
"To register the ``NotEqual`` lookup we will need to call ``register_lookup`` "
"on the field class we want the lookup to be available for. In this case, the "
"lookup makes sense on all ``Field`` subclasses, so we register it with "
"``Field`` directly::"
msgstr ""
"``NotEqual`` 조회를 등록하기 위해서는 우리가 원하는 현장수업을 "
"``register_lookup`` 라고 불러야 할 것이다. 이 경우, 모든 \"Field\" 하위 클래"
"스에 대한 조회가 타당하므로 \"Field\"에 직접 등록한다."

msgid "Lookup registration can also be done using a decorator pattern::"
msgstr "decorator 패턴을 사용하여 조회 등록을 수행 할 수 있습니다."

msgid ""
"We can now use ``foo__ne`` for any field ``foo``. You will need to ensure "
"that this registration happens before you try to create any querysets using "
"it. You could place the implementation in a ``models.py`` file, or register "
"the lookup in the ``ready()`` method of an ``AppConfig``."
msgstr ""
"이제 우리는 ``foo_ne\"를 어떤 \"foo\" 의 어떠한 필드에서도 사용할 수 있다. "
"이 등록을 사용하여 쿼리 세트를 만들기 전에 이 등록이 수행되는지 확인해야 합니"
"다. 당신은 그 실행을 ``models.py\"파일 안에 구현할 수 있고, \"AppConfig\"안"
"의 \"ready()함수를 사용하여 조회를 등록할 수 있다."

msgid ""
"Taking a closer look at the implementation, the first required attribute is "
"``lookup_name``. This allows the ORM to understand how to interpret "
"``name__ne`` and use ``NotEqual`` to generate the SQL. By convention, these "
"names are always lowercase strings containing only letters, but the only "
"hard requirement is that it must not contain the string ``__``."
msgstr ""
"그 구현을 자세히 들여다보면, 가장 먼저 요구되는 속성은 ``lookup_name\"이다. "
"이를 통해 ORM은 ``name__ne\"의 해석 방법을 이해하고 \"Not Equal\"을 사용하여 "
"SQL을 생성할 수 있다. 관례적으로, 이 이름들은 항상 소문자 문자열로 문자만 포"
"함하고 있지만, 유일한 어려운 요구조건은 문자열 \"__\"를 포함해서는 안 된다는 "
"것이다."

msgid ""
"We then need to define the ``as_sql`` method. This takes a ``SQLCompiler`` "
"object, called ``compiler``,  and the active database connection. "
"``SQLCompiler`` objects are not documented, but the only thing we need to "
"know about them is that they have a ``compile()`` method which returns a "
"tuple containing an SQL string, and the parameters to be interpolated into "
"that string. In most cases, you don't need to use it directly and can pass "
"it on to ``process_lhs()`` and ``process_rhs()``."
msgstr ""
"그다음 우리는 ``as_sql\" 방식을 정의할 필요가 있다. 이것은\"compiler\"라고 불"
"리는 ``SQLCompiler\"객체와 활성화된 데이터베이스 연결이 필요하다. \n"
"\"SQL Compiler\" 객체는 문서화되어 있지 않지만 그것들에 대해 우리가 알아야 "
"할 것은 SQL 문자열이 들어 있는 튜플을 반환하는 ``compile()\" 방법과 그 문자열"
"에 삽입될 파라미터가 있다는 것뿐이다. 대부분의 경우 직접 사용할 필요가 없으"
"며 ``process_lhs()\"와 ``process_rhs()\"로 직접전달할 수 있다."

msgid ""
"A ``Lookup`` works against two values, ``lhs`` and ``rhs``, standing for "
"left-hand side and right-hand side. The left-hand side is usually a field "
"reference, but it can be anything implementing the :ref:`query expression "
"API <query-expression>`. The right-hand is the value given by the user. In "
"the example ``Author.objects.filter(name__ne='Jack')``, the left-hand side "
"is a reference to the ``name`` field of the ``Author`` model, and ``'Jack'`` "
"is the right-hand side."
msgstr ""
"\"Lookup\"은 \"lhs\" 와 \"rhs\"라는 값에서 동작하는데, 각각 왼쪽과 오른쪽을 "
"뜻한다. 왼쪽은 대부분 필드 레퍼런스이지만, :ref:'쿼리 표현 API' 를 구현하는 "
"모든 것이 될 수 있습니다. 오른쪽 값은 유저에 의해서 정해진다. \"Author."
"objects.filter(name__ne='Jack)\" 예시에서, 왼쪽은 \"Author\" 모델의 \"name\" "
"필드의 레퍼런스이고, 오른쪽은 \"Jack\"이다."

msgid ""
"We call ``process_lhs`` and ``process_rhs`` to convert them into the values "
"we need for SQL using the ``compiler`` object described before. These "
"methods return tuples containing some SQL and the parameters to be "
"interpolated into that SQL, just as we need to return from our ``as_sql`` "
"method. In the above example, ``process_lhs`` returns ``('\"author\".\"name"
"\"', [])`` and ``process_rhs`` returns ``('\"%s\"', ['Jack'])``. In this "
"example there were no parameters for the left hand side, but this would "
"depend on the object we have, so we still need to include them in the "
"parameters we return."
msgstr ""
"\"process_lhs\"와 \"process_rhs\"는 앞에서 설명한 \"compiler\" 개체를 사용하"
"여 SQL에 필요한 값으로 변환하기 위해 \"process_lhs\"와 \"process_rhs\"라고 부"
"른다. 이러한 방법들은 우리가 우리의 \"as_sql\" 방법에서 돌아올 때처럼 일부 "
"SQL을 포함하는 튜플과 그 SQL에 보간될 파라미터를 반환한다. 위의 예에서 "
"\"process_lhs\"는 ``('author'.name\", []), \"process_rhs\"는 \"('\"%s\"', "
"['Jack'])\"을 반환합니다.\"이 예에서는 좌익에 대한 매개변수가 없었지만 이것"
"은 우리가 가지고 있는 대상에 따라 달라지므로 우리는 여전히 그것들을 반환하는 "
"매개변수에 포함시킬 필요가 있다."

msgid ""
"Finally we combine the parts into an SQL expression with ``<>``, and supply "
"all the parameters for the query. We then return a tuple containing the "
"generated SQL string and the parameters."
msgstr ""
"마지막으로 부품을 SQL 표현식과 \"<>\"로 결합하고 질의에 대한 모든 매개 변수"
"를 제공한다. 그런 다음 생성된 SQL 문자열과 매개 변수가 포함된 튜플을 반환합니"
"다."

msgid "A transformer example"
msgstr "변압기 예제"

msgid ""
"The custom lookup above is great, but in some cases you may want to be able "
"to chain lookups together. For example, let's suppose we are building an "
"application where we want to make use of the ``abs()`` operator. We have an "
"``Experiment`` model which records a start value, end value, and the change "
"(start - end). We would like to find all experiments where the change was "
"equal to a certain amount (``Experiment.objects.filter(change__abs=27)``), "
"or where it did not exceed a certain amount (``Experiment.objects."
"filter(change__abs__lt=27)``)."
msgstr ""
"위의 사용자 지정 조회는 훌륭하지만 경우에 따라 조회를 함께 연결할 수 있습니"
"다. 예를 들어, 우리가 \"abs()\" 연산자를 사용하고자 하는 응용 프로그램을 만들"
"고 있다고 가정해 보자. 우리는 시작값, 끝값, 변화(시작-끝)를 기록하는 "
"\"Experimental\" 모델을 가지고 있다. 우리는 그 변화가 일정량과 동일한 모든 실"
"험(\"Experiment.objects.filter(change__abs =27') 또는 일정량을 초과하지 않는 "
"(\"Experiment.objects.filter(change__abs__lt |27)\")을 찾고자 한다."

msgid ""
"This example is somewhat contrived, but it nicely demonstrates the range of "
"functionality which is possible in a database backend independent manner, "
"and without duplicating functionality already in Django."
msgstr ""
"이 예제는 다소 작위적이지만, 이미 Django에 있는 기능을 복제하지 않고 데이터베"
"이스 백엔드에 독립적인 방식으로 가능한 기능의 범위를 잘 보여준다."

msgid ""
"We will start by writing an ``AbsoluteValue`` transformer. This will use the "
"SQL function ``ABS()`` to transform the value before comparison::"
msgstr ""
"\"우리는 'Absolute' 변압기를 쓰는 것으로 시작할 것이다. 이는 SQL 함수 "
"\"ABS()\"를 사용하여 비교 전에 값을 변환한다."

msgid "Next, let's register it for ``IntegerField``::"
msgstr "다음으로, ``IntegerField``\\를 등록해봅시다."

msgid ""
"We can now run the queries we had before. ``Experiment.objects."
"filter(change__abs=27)`` will generate the following SQL:"
msgstr ""
"이제 이전의 쿼리를 실행할 수 있습니다. \n"
"``Experiment.objects.filter(change__abs=27)`` 은 다음의 SQL을 생성합니다."

msgid ""
"By using ``Transform`` instead of ``Lookup`` it means we are able to chain "
"further lookups afterward. So ``Experiment.objects."
"filter(change__abs__lt=27)`` will generate the following SQL:"
msgstr ""

msgid ""
"Note that in case there is no other lookup specified, Django interprets "
"``change__abs=27`` as ``change__abs__exact=27``."
msgstr ""
"다른 조회가 지정되지 않은 경우, Django는 \"change__abs abs=27\"을 "
"\"change__abs_exact=27\"로 해석합니다."

msgid ""
"This also allows the result to be used in ``ORDER BY`` and ``DISTINCT ON`` "
"clauses. For example ``Experiment.objects.order_by('change__abs')`` "
"generates:"
msgstr ""
"이는 또한 이 결과를 \"ORDER BY\"와 \"DISTINCT ON\" 조항에 사용할 수 있게 한"
"다. 예를 들어 \"Experiment.objects.order_by('change__abs')\"는 다음을 생성합"
"니다:"

msgid ""
"And on databases that support distinct on fields (such as PostgreSQL), "
"``Experiment.objects.distinct('change__abs')`` generates:"
msgstr ""
"필드에서의 구별을 지원하는 데이터베이스(PostgreSQL같은), \"Experiment."
"objects.distinct('change__abs')\"는 다음을 생성합니다."

msgid ""
"When looking for which lookups are allowable after the ``Transform`` has "
"been applied, Django uses the ``output_field`` attribute. We didn't need to "
"specify this here as it didn't change, but supposing we were applying "
"``AbsoluteValue`` to some field which represents a more complex type (for "
"example a point relative to an origin, or a complex number) then we may have "
"wanted to specify that the transform returns a ``FloatField`` type for "
"further lookups. This can be done by adding an ``output_field`` attribute to "
"the transform::"
msgstr ""
"\"Transform\"이 적용된 후 어떤 룩업이 허용되는지를 찾을 때, Django는 "
"\"output_field\" 속성을 사용한다. 변화가 되지 않았기 때문에 여기에 명시할 필"
"요는 없지만,  보다 복잡한 유형(예:기원에 상대적인 점, 또는 복합적인 수)을 나"
"타내는 어떤 분야에 \"AbsoluteValue\"을 적용한다고 가정하면 변환이 추가 조회"
"를 위해 \"FloatField\" 타입을 반환한다고 명시하고 싶었을 수도 있다. 이는 "
"\"output_field\" 속성을 변환에 추가하여 수행할 수 있다::"

msgid ""
"This ensures that further lookups like ``abs__lte`` behave as they would for "
"a ``FloatField``."
msgstr ""
"이를 통해 \"abs_lte\"와 같은 추가적인 룩업이 \"FloatField\"에서 처럼 행동할 "
"수 있다."

msgid "Writing an efficient ``abs__lt`` lookup"
msgstr "효율적인 \"abs_lt\" 룩업 작성법"

msgid ""
"When using the above written ``abs`` lookup, the SQL produced will not use "
"indexes efficiently in some cases. In particular, when we use "
"``change__abs__lt=27``, this is equivalent to ``change__gt=-27`` AND "
"``change__lt=27``. (For the ``lte`` case we could use the SQL ``BETWEEN``)."
msgstr ""
"위에서 작성한 \"abs\" 룩업을 사용할 때 생성된 SQL은 경우에 따라 인덱스를 효율"
"적으로 사용하지 않을 것이다. 특히 우리가 ``change_abs__lt=27\"을 사용할 때 이"
"는 ``change_gt =-27\"과 \"change_lt =27\"에 해당한다(\"lte\"케이스에서는 우리"
"는 SQL \"BETWEEN\"을 사용할 수 있다). "

msgid ""
"So we would like ``Experiment.objects.filter(change__abs__lt=27)`` to "
"generate the following SQL:"
msgstr ""
"그래서 우리는 \"Experiment.objects.filter(change__abs__lt=27)\"을 다음 SQL문"
"을 생성하기를 원한다:"

msgid "The implementation is::"
msgstr "구현은 다음과 같습니다."

msgid ""
"There are a couple of notable things going on. First, "
"``AbsoluteValueLessThan`` isn't calling ``process_lhs()``. Instead it skips "
"the transformation of the ``lhs`` done by ``AbsoluteValue`` and uses the "
"original ``lhs``. That is, we want to get ``\"experiments\".\"change\"`` not "
"``ABS(\"experiments\".\"change\")``. Referring directly to ``self.lhs.lhs`` "
"is safe as ``AbsoluteValueLessThan`` can be accessed only from the "
"``AbsoluteValue`` lookup, that is the ``lhs`` is always an instance of "
"``AbsoluteValue``."
msgstr ""
"몇 가지 주목할 만한 일들이 벌어지고 있다.  첫째,\"AbsoluteValueLessThan\"은 "
"``process_lhs()\"를 호출하지 않는다. 대신에 그것은 ``AbsoluteValue\"가 행한 "
"``lhs\"의 변형을 생략하고 원래의 \"lhs\"을 사용한다. 즉, 우리는 "
"\"ABS(\"experiments\".\"change\")\"가 아니라 \"experiments\"\"를 원한다. "
"``self.lhs.lhs\"를 직접 지칭하는 것은 ``AbsouleValueLessThan\"이라고 해도 무"
"방하다.Than'은 ``AbsoluteValue\" 조회에서만 접근할 수 있는데 그것은 ``lhs"
"\"은 항상 ``AbsoluteValue\"의 한 예이다."

msgid ""
"Notice also that  as both sides are used multiple times in the query the "
"params need to contain ``lhs_params`` and ``rhs_params`` multiple times."
msgstr ""
"또한 양쪽이 쿼리에서 여러 번 사용되므로 \"lhs_params\"와 \"rhs_params\"를 여"
"러 번 포함해야 한다."

msgid ""
"The final query does the inversion (``27`` to ``-27``) directly in the "
"database. The reason for doing this is that if the ``self.rhs`` is something "
"else than a plain integer value (for example an ``F()`` reference) we can't "
"do the transformations in Python."
msgstr ""
"마지막 쿼리는 데이터베이스에서 직접 반전(\"27\"to \"-27\")을 수행합니다. 그 "
"이유는 \"self.rhs\"가 단순한 정수 값(예: \"F() reference)이 아니면 파이썬으"
"로 변환을 할 수 없기 때문이다."

msgid ""
"In fact, most lookups with ``__abs`` could be implemented as range queries "
"like this, and on most database backends it is likely to be more sensible to "
"do so as you can make use of the indexes. However with PostgreSQL you may "
"want to add an index on ``abs(change)`` which would allow these queries to "
"be very efficient."
msgstr ""
"실제로 ``__abs\"가 있는 대부분의 조회는 이와 같은 범위 쿼리로 구현될 수 있으"
"며 대부분의 데이터베이스 백엔드에서는 인덱스를 사용할 수 있으므로 그렇게 하"
"는 것이 더 현명할 것이다. 그러나 Postgre와 함께SQL ``abs(change)\"에 인덱스"
"를 추가할 수 있고 이러한 쿼리들은 매우 효율적일 것이다."

msgid "A bilateral transformer example"
msgstr "쌍방향 변압기 예제"

msgid ""
"The ``AbsoluteValue`` example we discussed previously is a transformation "
"which applies to the left-hand side of the lookup. There may be some cases "
"where you want the transformation to be applied to both the left-hand side "
"and the right-hand side. For instance, if you want to filter a queryset "
"based on the equality of the left and right-hand side insensitively to some "
"SQL function."
msgstr ""
"앞에서 논의한 \"AbsoluteValue\"의 예는 룩업의 왼쪽에 적용되는 변화이다. 변환"
"을 왼쪽과 오른쪽 모두에 적용하려는 경우가 있을 수 있습니다. 예를 들어 일부 "
"SQL 함수에 대해 왼쪽과 오른쪽의 동일성을 기준으로 쿼리 세트를 필터링하려는 경"
"우"

msgid ""
"Let's examine case-insensitive transformations here. This transformation "
"isn't very useful in practice as Django already comes with a bunch of built-"
"in case-insensitive lookups, but it will be a nice demonstration of "
"bilateral transformations in a database-agnostic way."
msgstr ""
"여기서는 대소문자를 구분하지 않는 변환을 살펴보겠습니다. 이러한 변환은 Django"
"가 이미 여러 개의 대소문자를 구분하지 않는 검색 기능을 제공하므로 실제로 유용"
"하지는 않습니다. 그러나 이는 데이터베이스에 구애받지 않는 방식으로 상호 변환"
"의 좋은 예가 될 것입니다."

msgid ""
"We define an ``UpperCase`` transformer which uses the SQL function "
"``UPPER()`` to transform the values before comparison. We define :attr:"
"`bilateral = True <django.db.models.Transform.bilateral>` to indicate that "
"this transformation should apply to both ``lhs`` and ``rhs``::"
msgstr ""
"우리는 SQL 함수 \"UPPER()\"를 사용하여 비교 전에 값을 변환하는 \"UpperCase\" "
"변압기를 정의한다. 우리는 다음과 같이 정의한다. :attr:`bilateral = True "
"<django.db.models.Transform.bilateral>` 은 이러한 변환이 ``lhs\"과 \"rhs\" 모"
"두에 적용되어야 함을 나타낸다."

msgid "Next, let's register it::"
msgstr "다음으로 등록하겠습니다::"

msgid ""
"Now, the queryset ``Author.objects.filter(name__upper=\"doe\")`` will "
"generate a case insensitive query like this:"
msgstr ""
"이제  ``Author.objects.filter(name__upper=\"doe\")``는 다음과 같은 대/소문자"
"를 구분하지 않는 쿼리를 생성합니다."

msgid "Writing alternative implementations for existing lookups"
msgstr "기존 룩업에 대한 대체 구현 쓰기"

msgid ""
"Sometimes different database vendors require different SQL for the same "
"operation. For this example we will rewrite a custom implementation for "
"MySQL for the NotEqual operator. Instead of ``<>`` we will be using ``!=`` "
"operator. (Note that in reality almost all databases support both, including "
"all the official databases supported by Django)."
msgstr ""
"데이터베이스 공급업체마다 동일한 작업을 수행하려면 서로 다른 SQL이 필요한 경"
"우가 있습니다. 이 예에서는 NotEqual 연산자를 위해 MySQL에 대한 사용자 지정 구"
"현을 다시 씁니다. 우리는 ``<>\" 대신에\"!=\"을 사용할 것이다. 피싱 오퍼레이"
"터. (실제로 Django가 지원하는 모든 공식 데이터베이스를 포함하여 거의 모든 데"
"이터베이스가 두 데이터베이스를 모두 지원합니다.)"

msgid ""
"We can change the behavior on a specific backend by creating a subclass of "
"``NotEqual`` with an ``as_mysql`` method::"
msgstr ""
"\"as_mysql\" 방식의 \"NotEqual\" 하위 클래스를 만들어 특정 백엔드에서 동작을 "
"변경할 수 있다."

msgid ""
"We can then register it with ``Field``. It takes the place of the original "
"``NotEqual`` class as it has the same ``lookup_name``."
msgstr ""
"그런 다음 \"Field\"에 등록할 수 있다. 그것은 동일한 \"lookup_name\"을 가지고 "
"있기 때문에 원래의 \"Not Equal\" 클래스를 대신한다."

msgid ""
"When compiling a query, Django first looks for ``as_%s % connection.vendor`` "
"methods, and then falls back to ``as_sql``. The vendor names for the in-"
"built backends are ``sqlite``, ``postgresql``, ``oracle`` and ``mysql``."
msgstr ""
"쿼리를 컴파일할 때, Django는 먼저 \"as_%s\" 연결을 찾는다.공급업체는 방법을 "
"채택한 다음 다시 \"as_sqlp\"로 돌아간다. 내장된 백엔드의 벤더 이름은 \"sqlite"
"\", \"postgresql\", \"oracle\" 및 \"mysql\"이다."

msgid "How Django determines the lookups and transforms which are used"
msgstr "Django가 사용되는 룩업 및 변환을 결정하는 방법"

msgid ""
"In some cases you may wish to dynamically change which ``Transform`` or "
"``Lookup`` is returned based on the name passed in, rather than fixing it. "
"As an example, you could have a field which stores coordinates or an "
"arbitrary dimension, and wish to allow a syntax like ``."
"filter(coords__x7=4)`` to return the objects where the 7th coordinate has "
"value 4. In order to do this, you would override ``get_lookup`` with "
"something like::"
msgstr ""
"어떤 경우에는 \"Transform\" 또는 \"Lookup\"이 반환되는 것을 고치는 것이 아니"
"라 그 이름에 따라 동적으로 바꾸기를 원할 수도 있다. 예를 들어 좌표나 임의 차"
"원을 저장하는 필드를 사용할 수 있으며,``.filter(coords__x7=4)``와 같은 구문"
"이 7번째 좌표 값이 4인 객체를 반환하도록 허용할 수 있습니다. 이를 위해 당신"
"은 다음과 같은 것으로 ``get_lookup\"을 재정의할 것이다::"

msgid ""
"You would then define ``get_coordinate_lookup`` appropriately to return a "
"``Lookup`` subclass which handles the relevant value of ``dimension``."
msgstr ""
"그런 다음 \"get_cordinate_lookup\"을 적절히 정의하여 \"dimension\"의 관련 가"
"치를 다루는 ``Lookup\" 하위 클래스를 반환하게 된다."

msgid ""
"There is a similarly named method called ``get_transform()``. "
"``get_lookup()`` should always return a ``Lookup`` subclass, and "
"``get_transform()`` a ``Transform`` subclass. It is important to remember "
"that ``Transform`` objects can be further filtered on, and ``Lookup`` "
"objects cannot."
msgstr ""
"``get_transform()\"\" ``get_lookup()\"\"은 항상 ``Lookup\" 하위 클래스를 반환"
"하고 ``get_transform()\"은 ``transform\" 하위 클래스를 반환해야 한다. "
"\"Transform\" 물체는 더 걸러질 수 있고 \"Lookup\" 물체는 걸러질 수 없다는 것"
"을 명심해야 한다."

msgid ""
"When filtering, if there is only one lookup name remaining to be resolved, "
"we will look for a ``Lookup``. If there are multiple names, it will look for "
"a ``Transform``. In the situation where there is only one name and a "
"``Lookup`` is not found, we look for a ``Transform`` and then the ``exact`` "
"lookup on that ``Transform``. All call sequences always end with a "
"``Lookup``. To clarify:"
msgstr ""
"필터링을 할 때 한 개의 룩업 이름만 남아 있으면 \"Lookup\"를 찾을 것이다. 이름"
"이 여러 개일 경우 'Transform'를 모색하게 된다. 이름이 하나밖에 없고 ``Lookup"
"\"이 없는 상황에서 우리는 ``Transform\"을 찾고 그 ``Transform\"에 대한 "
"``exact\" 조회를 찾는다. 모든 호출 순서는 항상 \"Lookup\"로 끝난다. 명확히 하"
"기 위해:"

msgid ""
"``.filter(myfield__mylookup)`` will call ``myfield.get_lookup('mylookup')``."
msgstr ""
"``.filter(myfield__mylookup)`` 는``myfield.get_lookup('mylookup')``을 호출할 "
"것이다."

msgid ""
"``.filter(myfield__mytransform__mylookup)`` will call ``myfield."
"get_transform('mytransform')``, and then ``mytransform."
"get_lookup('mylookup')``."
msgstr ""
"``.filter(myfield__mytransform__mylookup)`` 는``myfield."
"get_transform('mytransform')``, 을 호출하고 ``mytransform."
"get_lookup('mylookup')``을 호출할 것이다."

msgid ""
"``.filter(myfield__mytransform)`` will first call ``myfield."
"get_lookup('mytransform')``, which will fail, so it will fall back to "
"calling ``myfield.get_transform('mytransform')`` and then ``mytransform."
"get_lookup('exact')``."
msgstr ""
"``.filter(myfield__mytransform)`` 는 우선 ``myfield."
"get_lookup('mytransform')``, 을 호출하는데 실패할것이고, 그 후 ``myfield."
"get_transform('mytransform')`` 을 호출한 다음 ``mytransform."
"get_lookup('exact')``을 호출할 것이다."

msgid "How to create custom ``django-admin`` commands"
msgstr "커스텀 \"django-admin\" 명령을 만드는 방법"

msgid ""
"Applications can register their own actions with ``manage.py``. For example, "
"you might want to add a ``manage.py`` action for a Django app that you're "
"distributing. In this document, we will be building a custom ``closepoll`` "
"command for the ``polls`` application from the :doc:`tutorial</intro/"
"tutorial01>`."
msgstr ""
"신청서는 자체 조치를 ``manage.py\"에 등록할 수 있다. 예를 들어 \"manage.py"
"\"액션을 Django 앱을 사용하면서 추가하고 싶을수도 있을것이다.\n"
"\"이 문서에서는 \"조사\" 신청에 대한 사용자 정의 ``closepoll`` 명령어를 :"
"doc:'tutorial1에서 만들 것이다."

msgid ""
"To do this, add a ``management/commands`` directory to the application. "
"Django will register a ``manage.py`` command for each Python module in that "
"directory whose name doesn't begin with an underscore. For example::"
msgstr ""
"이를 위해 애플리케이션에  ``management/commands`` 디렉토리를 추가합니다. "
"django는이름이 밑줄로 시작하지 않는 ``manage.py\"를 각 디렉토리안에 있는  "
"Python 모듈에 대한 커멘드에 등록할 것이다."

msgid ""
"In this example, the ``closepoll`` command will be made available to any "
"project that includes the ``polls`` application in :setting:`INSTALLED_APPS`."
msgstr ""
"이 예에서 ``closepoll\" 명령어는 \"polls\" 적용을 포함하는 모든 프로젝트에서 "
"사용할 수 있게 된다  :setting:`INSTALLED_APPS`."

msgid ""
"The ``_private.py`` module will not be available as a management command."
msgstr "``_private.py\" 모듈은 관리 명령으로 사용할 수 없습니다."

msgid ""
"The ``closepoll.py`` module has only one requirement -- it must define a "
"class ``Command`` that extends :class:`BaseCommand` or one of its :ref:"
"`subclasses<ref-basecommand-subclasses>`."
msgstr ""
"``closepoll.py\" 모듈은 다음과 같이 확장되는 \"Command\" 등급을 정의해야 하"
"는 하나의 요건만 가지고 있다.Base Command 또는 그 중 하나인 ref:'subclasses."

msgid "Standalone scripts"
msgstr "독립 실행형 스크립트"

msgid ""
"Custom management commands are especially useful for running standalone "
"scripts or for scripts that are periodically executed from the UNIX crontab "
"or from Windows scheduled tasks control panel."
msgstr ""
"사용자 지정 관리 명령은 특히 독립 실행형 스크립트를 실행하거나 UNIX crontab "
"또는 윈도우즈 스케줄링된 태스크 제어판에서 정기적으로 실행되는 스크립트에 유"
"용합니다."

msgid ""
"To implement the command, edit ``polls/management/commands/closepoll.py`` to "
"look like this::"
msgstr ""
"명령을 구현하려면 ``polls/management/commands/closepoll.py`` 를 편집하십시오"

msgid ""
"When you are using management commands and wish to provide console output, "
"you should write to ``self.stdout`` and ``self.stderr``, instead of printing "
"to ``stdout`` and ``stderr`` directly. By using these proxies, it becomes "
"much easier to test your custom command. Note also that you don't need to "
"end messages with a newline character, it will be added automatically, "
"unless you specify the ``ending`` parameter::"
msgstr ""
"관리 명령을 사용하고 콘솔 출력을 제공하려면 \"stdout\"과 \"stderr\"로 직접 인"
"쇄하지 말고 \"self.stdout\"과 \"self.stderr\"로 써야 합니다. 이러한 프록시를 "
"사용하면 사용자 지정 명령을 훨씬 쉽게 테스트할 수 있습니다. 또한 다음과 같은 "
"\"ending\" 매개 변수를 지정하지 않으면 메시지를 새 줄 문자로 끝낼 필요가 없습"
"니다."

msgid ""
"The new custom command can be called using ``python manage.py closepoll "
"<poll_ids>``."
msgstr ""
"새로운 커스텀 커맨드는 ``python manage.py closepoll 1``.를 사용하여 부를 수 "
"있다"

msgid ""
"The ``handle()`` method takes one or more ``poll_ids`` and sets ``poll."
"opened`` to ``False`` for each one. If the user referenced any nonexistent "
"polls, a :exc:`CommandError` is raised. The ``poll.opened`` attribute does "
"not exist in the :doc:`tutorial</intro/tutorial02>` and was added to ``polls."
"models.Question`` for this example."
msgstr ""
"``handle()\" 방식은 하나 이상의 ``poll_ids\"를 가져다가 ``poll. opened\"를 각"
"각 \"False\"로 설정한다. 사용자가 존재하지 않는 폴링을 참조한 경우:exc:"
"Command Error가 발생합니다. \"poll.opened\" 속성은 :doc:\"tutorial\"에 존재하"
"지 않으며 이 예시에서는 \"polls.models.example'에 추가되었다"

msgid "Accepting optional arguments"
msgstr "선택적 인수 수락"

msgid ""
"The same ``closepoll`` could be easily modified to delete a given poll "
"instead of closing it by accepting additional command line options. These "
"custom options can be added in the :meth:`~BaseCommand.add_arguments` method "
"like this::"
msgstr ""
"동일한 ``closepoll\"를 쉽게 수정해 추가 명령줄 옵션을 수용함으로써 해당 여론"
"조사를 마감하는 대신 삭제할 수 있다. 이러한 사용자 지정 옵션은 다음과 같은 :"
"meth:'~BaseCommand.add_arguments 메서드에 추가할 수 있습니다."

msgid ""
"The option (``delete`` in our example) is available in the options dict "
"parameter of the handle method. See the :py:mod:`argparse` Python "
"documentation for more about ``add_argument`` usage."
msgstr ""
"핸들 방법의  dict 매개변수의 옵션('delete')을 사용할 수 있습니다. "
"\"add_argument\" 사용에 대한 자세한 내용은 :py:mod:'argparse' Python 문서를 "
"참조하십시오."

msgid ""
"In addition to being able to add custom command line options, all :doc:"
"`management commands</ref/django-admin>` can accept some default options "
"such as :option:`--verbosity` and :option:`--traceback`."
msgstr ""
"사용자 지정 명령줄 옵션을 추가할 수 있을 뿐만 아니라 모든 :doc:'관리 명"
"령'은 :option:'--verbity' 및 :option:'--traceback'과 같은 기본 옵션을 사용할 "
"수 있습니다."

msgid "Management commands and locales"
msgstr "관리 명령 및 로케일"

msgid ""
"By default, management commands are executed with the current active locale."
msgstr "기본적으로 관리 명령은 현재 활성 로케일로 실행됩니다."

msgid ""
"If, for some reason, your custom management command must run without an "
"active locale (for example, to prevent translated content from being "
"inserted into the database), deactivate translations using the "
"``@no_translations`` decorator on your :meth:`~BaseCommand.handle` method::"
msgstr ""
"어떤 이유로 사용자 지정 관리 명령이 활성 로케일 없이 실행되어야 하는 경우"
"(예: 변환된 콘텐츠가 데이터베이스에 삽입되지 않도록 하려면, 다음 방법:"
"meth:'~BaseCommand.handle'에서 \"@no_translations' decorator\"를 사용하여 변"
"환을 비활성화하십시오."

msgid ""
"Since translation deactivation requires access to configured settings, the "
"decorator can't be used for commands that work without configured settings."
msgstr ""
"변환 비활성화에는 구성된 설정에 대한 액세스 권한이 필요하므로 구성된 설정 없"
"이 작동하는 명령에는 장식자를 사용할 수 없습니다."

msgid "Testing"
msgstr "테스트중"

msgid ""
"Information on how to test custom management commands can be found in the :"
"ref:`testing docs <topics-testing-management-commands>`."
msgstr ""
"사용자 지정 관리 명령의 테스트 방법에 대한 정보는 :ref:'testing documents'에"
"서 확인할 수 있습니다."

msgid "Overriding commands"
msgstr "명령 재정의"

msgid ""
"Django registers the built-in commands and then searches for commands in :"
"setting:`INSTALLED_APPS` in reverse. During the search, if a command name "
"duplicates an already registered command, the newly discovered command "
"overrides the first."
msgstr ""
"Django는 내장 명령을 등록한 다음 :seting:'에서 명령어를 검색한다."
"`INSTALLED_APPs는 역방향입니다. 검색 중에 명령 이름이 이미 등록된 명령을 중복"
"하면 새로 검색된 명령이 첫 번째 명령을 재정의합니다."

msgid ""
"In other words, to override a command, the new command must have the same "
"name and its app must be before the overridden command's app in :setting:"
"`INSTALLED_APPS`."
msgstr ""
"즉, 명령을 재정의하려면 새 명령의 이름이 동일해야 하며 해당 앱은 재정의된 명"
"령의 앱 앞에 있어야 합니다. setting:'`INSTALLED_APPS`."

msgid ""
"Management commands from third-party apps that have been unintentionally "
"overridden can be made available under a new name by creating a new command "
"in one of your project's apps (ordered before the third-party app in :"
"setting:`INSTALLED_APPS`) which imports the ``Command`` of the overridden "
"command."
msgstr ""
"의도하지 않게 재정의된 타사 앱의 관리 명령은 오버라이드 커맨드의 \"Command\" "
"를 들여오는 프로젝트의 앱(:setting:`INSTALLED_APPS`으로 서드파티 앱 앞에 주문"
"된 ) 중 하나에 새 명령을 만들어 새 이름으로 사용할 수 있습니다"

msgid "Command objects"
msgstr "커맨드 개체"

msgid "The base class from which all management commands ultimately derive."
msgstr "모든 관리 명령이 궁극적으로 파생되는 기본 클래스입니다."

msgid ""
"Use this class if you want access to all of the mechanisms which parse the "
"command-line arguments and work out what code to call in response; if you "
"don't need to change any of that behavior, consider using one of its :ref:"
"`subclasses<ref-basecommand-subclasses>`."
msgstr ""
"명령줄 인수를 구문 분석하고 응답으로 호출할 코드를 알아내는 모든 메커니즘에 "
"액세스하려면 이 클래스를 사용합니다. 이러한 동작을 변경할 필요가 없으면 "
"ref:'subclasses' 중 하나를 사용하십시오."

msgid ""
"Subclassing the :class:`BaseCommand` class requires that you implement the :"
"meth:`~BaseCommand.handle` method."
msgstr ""
":클래스 하위 분류:'BaseCommand' 클래스는 :meth:'~BaseCommand.handle' 메소드"
"를 구현해야 합니다."

msgid "Attributes"
msgstr "속성"

msgid ""
"All attributes can be set in your derived class and can be used in :class:"
"`BaseCommand`’s :ref:`subclasses<ref-basecommand-subclasses>`."
msgstr ""
"모든 속성은 파생 클래스에서 설정할 수 있으며:class:`BaseCommand`’s :ref:"
"`subclasses1에서 사용할 수 있습니다."

msgid ""
"A short description of the command, which will be printed in the help "
"message when the user runs the command ``python manage.py help <command>``."
msgstr ""
"사용자가 ``python manage\" 명령을 실행할 때 도움말 메시지에 표시되는 명령어"
"에 대한 간단한 설명입니다 ``python manage.py help 1``."

msgid ""
"If your command defines mandatory positional arguments, you can customize "
"the message error returned in the case of missing arguments. The default is "
"output by :py:mod:`argparse` (\"too few arguments\")."
msgstr ""
"명령에서 필수 위치 인수를 정의하는 경우 인수가 누락된 경우 반환되는 메시지 오"
"류를 사용자 정의할 수 있습니다. 기본값은 :py:mod:'argparse'(\"너무 적은 인수"
"\") 출력입니다."

msgid ""
"A boolean indicating whether the command outputs SQL statements; if "
"``True``, the output will automatically be wrapped with ``BEGIN;`` and "
"``COMMIT;``. Default value is ``False``."
msgstr ""
"명령어가 SQL 문을 출력하는지 여부를 나타내는 부울로, \"True\"일 경우 출력은 "
"자동으로 \"BEGIN\"과 \"COMIT\"로 포장된다. 기본값은 \"False\"입니다."

msgid ""
"A boolean; if ``True``, the command prints a warning if the set of "
"migrations on disk don't match the migrations in the database. A warning "
"doesn't prevent the command from executing. Default value is ``False``."
msgstr ""
"불. \"True\"인 경우 명령은 디스크의 마이그레이션 집합이 데이터베이스의 마이그"
"레이션과 일치하지 않을 경우 경고를 인쇄합니다. 경고는 명령 실행을 차단하지 않"
"습니다. 기본값은 \"False\"입니다."

msgid ""
"A list or tuple of tags, e.g. ``[Tags.staticfiles, Tags.models]``. System "
"checks :ref:`registered in the chosen tags <registering-labeling-checks>` "
"will be checked for errors prior to executing the command. The value "
"``'__all__'`` can be used to specify that all system checks should be "
"performed. Default value is ``'__all__'``."
msgstr ""

msgid ""
"In older versions, the ``requires_system_checks`` attribute expects a "
"boolean value instead of a list or tuple of tags."
msgstr ""

msgid ""
"An instance attribute that helps create colored output when writing to "
"``stdout`` or ``stderr``. For example::"
msgstr ""
"\"stdout\" 또는 \"stderr\"에 쓸 때 컬러 출력을 생성하는 데 도움이 되는 인스턴"
"스 속성이다. 예를 들어:"

msgid ""
"See :ref:`syntax-coloring` to learn how to modify the color palette and to "
"see the available styles (use uppercased versions of the \"roles\" described "
"in that section)."
msgstr ""
"색상표를 수정하는 방법과 사용 가능한 스타일을 보려면  :ref:`syntax-coloring` "
"을 참조하십시오(이 절에서 설명하는 \"roles\"의 대문자 버전 사용)."

msgid ""
"If you pass the :option:`--no-color` option when running your command, all "
"``self.style()`` calls will return the original string uncolored."
msgstr ""
"명령을 실행할 때 \"-no-color\" 옵션을 통과하면 모든 ``self.style()\" 호출이 "
"원래 문자열을 무색하게 반환됩니다."

msgid ""
"The default command options to suppress in the help output. This should be a "
"set of option names (e.g. ``'--verbosity'``). The default values for the "
"suppressed options are still passed."
msgstr ""

msgid "Methods"
msgstr "메소드"

msgid ""
":class:`BaseCommand` has a few methods that can be overridden but only the :"
"meth:`~BaseCommand.handle` method must be implemented."
msgstr ""
":class:'BaseCommand'에는 무시할 수 있는 몇 가지 방법이 있지만 :"
"meth:'~BaseCommand.handle' 방법만 구현하면 됩니다."

msgid "Implementing a constructor in a subclass"
msgstr "하위 클래스에 생성자 구현"

msgid ""
"If you implement ``__init__`` in your subclass of :class:`BaseCommand`, you "
"must call :class:`BaseCommand`’s ``__init__``::"
msgstr ""
"__init__\"을(를) :class:'BaseCommand'의 하위 클래스에서 구현할 경우 :"
"classBaseCommand의 ``__init__\":를 호출해야 합니다."

msgid ""
"Returns a ``CommandParser`` instance, which is an :class:`~argparse."
"ArgumentParser` subclass with a few customizations for Django."
msgstr ""
"\"CommandParser\" 인스턴스를 반환하는데,  이 인스턴스는  Django에 대한 사용"
"자 지정이 몇 가지 있는:class::class:`~argparse.ArgumentParser` 서브클래스이다"

msgid ""
"You can customize the instance by overriding this method and calling "
"``super()`` with ``kwargs`` of :class:`~argparse.ArgumentParser` parameters."
msgstr ""
" \"kwargs\" 의 :class:`~argparse.ArgumentParser` 매개변수는 \"super()\" 를 호"
"출하고 매소드를 오버라이드하면서 인스턴스를 커스터마이즈할 수 있다."

msgid ""
"Entry point to add parser arguments to handle command line arguments passed "
"to the command. Custom commands should override this method to add both "
"positional and optional arguments accepted by the command. Calling "
"``super()`` is not needed when directly subclassing ``BaseCommand``."
msgstr ""
"명령에 전달된 명령줄 인수를 처리할 구문 분석기 인수를 추가하는 진입점입니다. "
"사용자 지정 명령은 이 메서드를 재정의하여 명령에서 수락한 위치 및 선택적 인수"
"를 모두 추가해야 합니다. \"BaseCommand\"를 직접 하위 분류할 때는 "
"\"super()\"라고 부를 필요가 없다."

msgid ""
"Returns the Django version, which should be correct for all built-in Django "
"commands. User-supplied commands can override this method to return their "
"own version."
msgstr ""
"내장된 모든 Django 명령에 대해 정확해야 하는 Django 버전을 반환합니다. 사용"
"자 제공 명령은 해당 버전을 반환하기 위해 이 방법을 재정의할 수 있습니다."

msgid ""
"Tries to execute this command, performing system checks if needed (as "
"controlled by the :attr:`requires_system_checks` attribute). If the command "
"raises a :exc:`CommandError`, it's intercepted and printed to stderr."
msgstr ""
"필요한 경우 시스템 검사를 수행하여 이 명령을 실행하시오( :"
"attr:'requires_system_checks' 속성에 의해 제어됨). 커맨드가  :exc:"
"`CommandError` 을 보여주는 경우, 중간에 가로채져 stderr에 출력될 것입니다."

msgid "Calling a management command in your code"
msgstr "코드에서 관리 명령 호출"

msgid ""
"``execute()`` should not be called directly from your code to execute a "
"command. Use :func:`~django.core.management.call_command` instead."
msgstr ""
"명령을 실행하기 위해 코드에서 직접 \"execute\"를 불러서는 안 된다. 대신 "
"func:'~django.core.management.call_command'를 사용합니다."

msgid "The actual logic of the command. Subclasses must implement this method."
msgstr "명령의 실제 논리입니다. 하위 클래스는 이 방법을 구현해야 합니다."

msgid ""
"It may return a string which will be printed to ``stdout`` (wrapped by "
"``BEGIN;`` and ``COMMIT;`` if :attr:`output_transaction` is ``True``)."
msgstr ""
"그것은 \"stdout\"으로 인쇄될 문자열을 반환할 수도 있다. ('BEGIN'과 "
"''COMIT''로 포장된 문자열:attr:'output_transaction'이 \"true\"일 경우)"

msgid ""
"Uses the system check framework to inspect the entire Django project for "
"potential problems. Serious problems are raised as a :exc:`CommandError`; "
"warnings are output to stderr; minor notifications are output to stdout."
msgstr ""
"시스템 검사 프레임워크를 사용하여 전체 Django 프로젝트에 잠재적인 문제가 있는"
"지 검사합니다. 심각한 문제는 다음과 같이 제기됩니다:exc:`CommandError`;경고"
"는 stderr로 출력되고 경미한 알림은 stdout으로 출력됩니다."

msgid ""
"If ``app_configs`` and ``tags`` are both ``None``, all system checks are "
"performed. ``tags`` can be a list of check tags, like ``compatibility`` or "
"``models``."
msgstr ""
"\"app_configs\"와 \"tags\"가 둘 다 \"None\"이면 모든 시스템 점검이 이루어진"
"다. \"'compatibility' 또는 ''models''과 같은 체크 태그의 목록이 될 수 있다."

msgid "``BaseCommand`` subclasses"
msgstr "``BaseCommand`` 하위 클래스"

msgid ""
"A management command which takes one or more installed application labels as "
"arguments, and does something with each of them."
msgstr ""
"하나 이상의 설치된 응용 프로그램 레이블을 인수로 사용하고 각 레이블로 작업을 "
"수행하는 관리 명령입니다."

msgid ""
"Rather than implementing :meth:`~BaseCommand.handle`, subclasses must "
"implement :meth:`~AppCommand.handle_app_config`, which will be called once "
"for each application."
msgstr ""
"서브클래스는 :meth:'~BaseCommand.handle'을 구현하기 보다는 :"
"meth:'~AppCommand.handle_app_config'를 구현해야 하며, 각 애플리케이션마다 한 "
"번씩 호출된다."

msgid ""
"Perform the command's actions for ``app_config``, which will be an :class:"
"`~django.apps.AppConfig` instance corresponding to an application label "
"given on the command line."
msgstr ""
"\"app_config\"에 대한 명령의 작업을 수행합니다. 이 작업은 :class가 됩니"
"다.'~django.the'AppConfig' 인스턴스는 명령줄에 지정된 애플리케이션 레이블에 "
"해당합니다."

msgid ""
"A management command which takes one or more arbitrary arguments (labels) on "
"the command line, and does something with each of them."
msgstr ""
"명령줄에서 하나 이상의 임의 인수(라벨)를 가져와 각 인수와 작업을 수행하는 관"
"리 명령입니다."

msgid ""
"Rather than implementing :meth:`~BaseCommand.handle`, subclasses must "
"implement :meth:`~LabelCommand.handle_label`, which will be called once for "
"each label."
msgstr ""
"서브클래스는 :meth:'~BaseCommand.handle'을 구현하기 보다는 :"
"meth:'~LabelCommand.handle_label'을 구현해야 하며, 각 레이블에 대해 한 번 호"
"출된다."

msgid ""
"A string describing the arbitrary arguments passed to the command. The "
"string is used in the usage text and error messages of the command. Defaults "
"to ``'label'``."
msgstr ""
"명령에 전달된 임의 인수를 설명하는 문자열입니다. 문자열은 명령의 사용 텍스트 "
"및 오류 메시지에 사용됩니다. 기본값은 \"'label'\"입니다."

msgid ""
"Perform the command's actions for ``label``, which will be the string as "
"given on the command line."
msgstr "명령줄에 지정된 문자열인 \"라벨\"에 대해 명령의 작업을 수행합니다."

msgid "Command exceptions"
msgstr "예외적 명령"

msgid ""
"Exception class indicating a problem while executing a management command."
msgstr "관리 명령을 실행하는 동안 문제를 나타내는 예외 클래스입니다."

msgid ""
"If this exception is raised during the execution of a management command "
"from a command line console, it will be caught and turned into a nicely-"
"printed error message to the appropriate output stream (i.e., stderr); as a "
"result, raising this exception (with a sensible description of the error) is "
"the preferred way to indicate that something has gone wrong in the execution "
"of a command. It accepts the optional ``returncode`` argument to customize "
"the exit status for the management command to exit with, using :func:`sys."
"exit`."
msgstr ""
"명령줄 콘솔에서 관리 명령을 실행하는 동안 이 예외가 발생하면 해당 명령이 캡처"
"되어 적절한 출력 스트림(예, stderr)으로 인쇄된 오류 메시지로 전환됩니다. 따라"
"서 오류에 대한 적절한 설명을 통해 이 예외를 발생시키는 것이 좋습니다.명령을 "
"잘못 실행하다 그것은 :func:'sys.exit'을 사용하여 관리 명령의 종료 상태를 사용"
"자 정의하기 위한 선택적인 ``returncode\" 주장을 수용한다."

msgid ""
"If a management command is called from code through :func:`~django.core."
"management.call_command`, it's up to you to catch the exception when needed."
msgstr ""
"코드에서 :func:'~django.core.management.call_command'까지 관리 명령이 호출되"
"면 필요할 때 예외를 잡는 것은 사용자의 몫입니다."

msgid "How to create custom model fields"
msgstr ""

msgid "Introduction"
msgstr "도입"

msgid ""
"The :doc:`model reference </topics/db/models>` documentation explains how to "
"use Django's standard field classes -- :class:`~django.db.models."
"CharField`, :class:`~django.db.models.DateField`, etc. For many purposes, "
"those classes are all you'll need. Sometimes, though, the Django version "
"won't meet your precise requirements, or you'll want to use a field that is "
"entirely different from those shipped with Django."
msgstr ""
":doc:'model reference' 설명서는 Django의 표준 필드 클래스 --:class:'~django."
"db.db.know.CharField', :class:'~django.db.db.know.날짜 필드' 등 여러 가지 목"
"적으로, 그 수업들이 여러분에게 필요한 전부입니다. 하지만 때로는 Django 버전"
"이 사용자의 정확한 요구 사항을 충족하지 못하거나 Django와 함께 제공된 필드와"
"는 완전히 다른 필드를 사용하고자 할 수 있습니다."

msgid ""
"Django's built-in field types don't cover every possible database column "
"type -- only the common types, such as ``VARCHAR`` and ``INTEGER``. For more "
"obscure column types, such as geographic polygons or even user-created types "
"such as `PostgreSQL custom types`_, you can define your own Django ``Field`` "
"subclasses."
msgstr ""
"django의 내장형 필드에는 \"VARCHAR\"과 \"INTER\"와 같은 일반적인 유형의 데이"
"터베이스 열만 포함하지는 않으며 지리적 다각형이나 사용자가 만든 포스트그레그 "
"등 사용자가 만든 열 유형도 포함된다.SQL custom type은 _ __ 사용자 고유의 "
"\"Field\" 하위 클래스를 정의할 수 있다."

msgid ""
"Alternatively, you may have a complex Python object that can somehow be "
"serialized to fit into a standard database column type. This is another case "
"where a ``Field`` subclass will help you use your object with your models."
msgstr ""
"또한, 표준 데이터베이스 열 유형에 맞게 직렬화할 수 있는 복잡한 Python 개체가 "
"있을 수 있습니다. 이것은 ``필드\" 서브클래스가 당신의 객체를 당신의 모델과 함"
"께 사용하는 데 도움을 줄 또 다른 경우이다."

msgid "Our example object"
msgstr "우리의 예제 객체"

msgid ""
"Creating custom fields requires a bit of attention to detail. To make things "
"easier to follow, we'll use a consistent example throughout this document: "
"wrapping a Python object representing the deal of cards in a hand of "
"Bridge_. Don't worry, you don't have to know how to play Bridge to follow "
"this example. You only need to know that 52 cards are dealt out equally to "
"four players, who are traditionally called *north*, *east*, *south* and "
"*west*.  Our class looks something like this::"
msgstr ""
"사용자 지정 필드를 만들려면 세부 정보에 약간 주의를 기울여야 합니다. 이 문서"
"에서는 Bridge_의 손에서 카드 거래를 나타내는 Python 개체를 감싸는 일관된 예"
"를 보여드리겠습니다. 걱정하지 마세요, 이 예를 따르기 위해 브리지 게임을 하는 "
"방법을 알 필요는 없어요. 52장의 카드가 전통적으로 *north*, *east*, *south* "
"및 *west*라고 불리는 네 명의 플레이어에 동일하게 배포된다는 것만 알면 됩니"
"다. 저희 클래스는 다음과 같습니다."

msgid ""
"This is an ordinary Python class, with nothing Django-specific about it. "
"We'd like to be able to do things like this in our models (we assume the "
"``hand`` attribute on the model is an instance of ``Hand``)::"
msgstr ""
"이것은 Django 특유의 것이 없는 평범한 Python 클래스이다. 우리는 우리의 모델에"
"서 이와 같은 것을 할 수 있기를 원한다(우리는 모델의 \"hand\" 속성은 \"hand"
"\"의 예라고 가정한다.)::"

msgid ""
"We assign to and retrieve from the ``hand`` attribute in our model just like "
"any other Python class. The trick is to tell Django how to handle saving and "
"loading such an object."
msgstr ""
"\"우리는 다른 파이썬 클래스처럼 우리 모델의 \"손\" 속성에 할당하고 이를 조회"
"한다. 요령은 Django에게 그러한 객체를 저장하고 적재하는  방법을 알려주는 것이"
"다."

msgid ""
"In order to use the ``Hand`` class in our models, we **do not** have to "
"change this class at all. This is ideal, because it means you can easily "
"write model support for existing classes where you cannot change the source "
"code."
msgstr ""
"모델에서 \"Hand\" 클래스를 사용하기 위해서는  이 클래스를 전혀 변경할 필요가 "
"없다. 소스 코드를 변경할 수 없는 기존 클래스에 대한 모델 지원을 쉽게 작성할 "
"수 있으므로 이상적입니다."

msgid ""
"You might only be wanting to take advantage of custom database column types "
"and deal with the data as standard Python types in your models; strings, or "
"floats, for example. This case is similar to our ``Hand`` example and we'll "
"note any differences as we go along."
msgstr ""
"사용자 지정 데이터베이스 열 유형을 활용하고 데이터를 모델에서 표준 Python 유"
"형으로 처리(예: 문자열 또는 부동)하는 것이 좋습니다. 이번 사건은 우리의 "
"``Hand\" 사례와 유사하며 우리는 진행하면서 어떤 차이도 주목하게 될 것이다."

msgid "Background theory"
msgstr "배경설"

msgid "Database storage"
msgstr "데이터베이스 저장"

msgid ""
"Let's start with model fields. If you break it down, a model field provides "
"a way to take a normal Python object -- string, boolean, ``datetime``, or "
"something more complex like ``Hand`` -- and convert it to and from a format "
"that is useful when dealing with the database. (Such a format is also useful "
"for serialization, but as we'll see later, that is easier once you have the "
"database side under control)."
msgstr ""
"먼저 모델 필드부터 살펴보겠습니다. 이를 세분화하면 모델 필드는 문자열, 부울, "
"\"datetime\" 또는 \"hand\"와 같은 일반적인 Python 개체를 가져와서 데이터베이"
"스를 처리할 때 유용한 형식으로 변환하거나 변환하는 방법을 제공한다. (이러한 "
"형식은 직렬화에도 유용하지만 나중에 볼 수 있듯이 데이터베이스를 제어하면 더 "
"쉽습니다.)"

msgid ""
"Fields in a model must somehow be converted to fit into an existing database "
"column type. Different databases provide different sets of valid column "
"types, but the rule is still the same: those are the only types you have to "
"work with. Anything you want to store in the database must fit into one of "
"those types."
msgstr ""
"모델의 필드는 기존 데이터베이스 열 유형에 맞게 변환되어야 합니다. 데이터베이"
"스마다 서로 다른 유효한 열 유형 집합을 제공하지만 규칙은 여전히 동일합니다. "
"즉, 이러한 유형만 사용해야 합니다. 데이터베이스에 저장할 항목은 해당 유형 중 "
"하나에 포함되어야 합니다."

msgid ""
"Normally, you're either writing a Django field to match a particular "
"database column type, or you will need a way to convert your data to, say, a "
"string."
msgstr ""
"일반적으로 특정 데이터베이스 열 유형과 일치하는 Django 필드를 작성하거나 데이"
"터를 문자열로 변환하는 방법이 필요합니다."

msgid ""
"For our ``Hand`` example, we could convert the card data to a string of 104 "
"characters by concatenating all the cards together in a pre-determined order "
"-- say, all the *north* cards first, then the *east*, *south* and *west* "
"cards. So ``Hand`` objects can be saved to text or character columns in the "
"database."
msgstr ""
"우리의 \"Hand\" 예에서는 모든 카드를 미리 정해진 순서대로 연결함으로써 104자 "
"문자열로 카드 데이터를 변환할 수 있습니다. 예를 들어 모든 *북* 카드, 그 다음 "
"*동*, *남* 및 *서* 카드). 따라서 \"Hand\" 개체를 데이터베이스의 텍스트 또는 "
"문자 열에 저장할 수 있습니다."

msgid "What does a field class do?"
msgstr "필드클래스가 무엇을 하나요?"

msgid ""
"All of Django's fields (and when we say *fields* in this document, we always "
"mean model fields and not :doc:`form fields </ref/forms/fields>`) are "
"subclasses of :class:`django.db.models.Field`. Most of the information that "
"Django records about a field is common to all fields -- name, help text, "
"uniqueness and so forth. Storing all that information is handled by "
"``Field``. We'll get into the precise details of what ``Field`` can do later "
"on; for now, suffice it to say that everything descends from ``Field`` and "
"then customizes key pieces of the class behavior."
msgstr ""
"Django의 모든 필드(그리고 이 문서에서 *fields*라고 말할 때, 우리는 항상 모델 "
"필드를 의미하며 :doc:'form fields'가 아님)는 :class:'django.db.models의 하위 "
"클래스이다. Django가 필드에 대해 기록하는 대부분의 정보는 이름, 도움말 텍스"
"트, 고유성 등 모든 필드에 공통적입니다. 그 모든 정보를 저장하는 일은 ``Field`"
"\"가 담당한다. 우리는 ``Field`\"가 나중에 무엇을 할 수 있는지 자세히 알아볼 "
"것이다. 현재로서는 모든 것이 ``Field`\"에서 비롯되었다고 말하고 나서 계급 행"
"동의 핵심 부분을 맞춤화한다고만 말해도 충분하다."

msgid ""
"It's important to realize that a Django field class is not what is stored in "
"your model attributes. The model attributes contain normal Python objects. "
"The field classes you define in a model are actually stored in the ``Meta`` "
"class when the model class is created (the precise details of how this is "
"done are unimportant here). This is because the field classes aren't "
"necessary when you're just creating and modifying attributes. Instead, they "
"provide the machinery for converting between the attribute value and what is "
"stored in the database or sent to the :doc:`serializer </topics/"
"serialization>`."
msgstr ""
"Django 필드 클래스는 모델 속성에 저장된 클래스가 아닙니다. 모델 속성은 일반 "
"Python 개체를 포함합니다. 사용자가 모델에 정의한 필드 클래스는 모델 클래스가 "
"생성될 때 \"메타\" 클래스에 저장됩니다(여기서는 자세한 작업 내용이 중요하지 "
"않음). 그 이유는 속성을 만들고 수정할 때는 필드 클래스가 필요하지 않기 때문입"
"니다. 대신, 그들은 속성 값과 데이터베이스에 저장되거나 :doc:'serializer'로 전"
"송되는 것 사이에서 변환하는 기계를 제공한다."

msgid ""
"Keep this in mind when creating your own custom fields. The Django ``Field`` "
"subclass you write provides the machinery for converting between your Python "
"instances and the database/serializer values in various ways (there are "
"differences between storing a value and using a value for lookups, for "
"example). If this sounds a bit tricky, don't worry -- it will become clearer "
"in the examples below. Just remember that you will often end up creating two "
"classes when you want a custom field:"
msgstr ""
"사용자 정의 필드를 작성할 때 이 점을 유념하십시오. 작성하는 Django \"Field\" "
"하위 클래스는 다양한 방법으로 Python 인스턴스와 데이터베이스/시리얼라이저 값"
"을 변환하는 기계를 제공합니다(예를 들어 값을 저장하는 것과 룩업에 값을 사용하"
"는 것 사이에는 차이점이 있음). 만약 이것이 좀 까다롭게 들린다면, 걱정하지 마"
"세요. 아래의 예에서 더 명확해질 것입니다. 사용자 지정 필드를 원할 때 두 개의 "
"클래스를 만드는 경우가 많습니다."

msgid ""
"The first class is the Python object that your users will manipulate. They "
"will assign it to the model attribute, they will read from it for displaying "
"purposes, things like that. This is the ``Hand`` class in our example."
msgstr ""
"첫 번째 클래스는 사용자가 조작할 Python 개체입니다. 그들은 그것을 모델 속성"
"에 할당하고, 그것을 보여주기 위해 읽게 될 것입니다. 이것이 우리의 예에서 볼 "
"수 있는 \"Hand\" 클래스이다."

msgid ""
"The second class is the ``Field`` subclass. This is the class that knows how "
"to convert your first class back and forth between its permanent storage "
"form and the Python form."
msgstr ""
"두 번째 클래스는 ``Field\" 하위 클래스다. 이 클래스는 퍼스트 클래스를 영구 스"
"토리지 폼과 Python 폼 사이에서 앞뒤로 변환하는 방법을 알고 있는 클래스입니다."

msgid "Writing a field subclass"
msgstr "필드상속 작성법"

msgid ""
"When planning your :class:`~django.db.models.Field` subclass, first give "
"some thought to which existing :class:`~django.db.models.Field` class your "
"new field is most similar to. Can you subclass an existing Django field and "
"save yourself some work? If not, you should subclass the :class:`~django.db."
"models.Field` class, from which everything is descended."
msgstr ""
"클래스 계획 시:'~django.db.db.know.필드의 하위 클래스는 먼저 기존의 :클래스 "
"중 어느 것을 생각하는지 제시합니다.'~django.db.db.know.필드 클래스는 새 필드"
"와 가장 유사합니다. 기존 Django 필드를 하위 분류하여 작업을 저장할 수 있습니"
"까? 그렇지 않으면 모든 것이 내려온 필드의 :class.'~django.db.db.know. 를 하"
"위 분류해야 합니다"

msgid ""
"Initializing your new field is a matter of separating out any arguments that "
"are specific to your case from the common arguments and passing the latter "
"to the ``__init__()`` method of :class:`~django.db.models.Field` (or your "
"parent class)."
msgstr ""
". :class'~django.db.db.know.Field(또는 부모 클래스)의 메소드는 당신의 새로운 "
"필드를 초기화하는 것은 당신의 경우에 특정한 어떤 주장과 공통적인 주장을 분리"
"해서 후자를 \"__init__()\" 방법에 전달하는 문제입니다"

msgid ""
"In our example, we'll call our field ``HandField``. (It's a good idea to "
"call your :class:`~django.db.models.Field` subclass ``<Something>Field``, so "
"it's easily identifiable as a :class:`~django.db.models.Field` subclass.) It "
"doesn't behave like any existing field, so we'll subclass directly from :"
"class:`~django.db.models.Field`::"
msgstr ""
"예를 들어, 우리는 우리의 분야를 \"HandField\"라고 부를 것이다.(\n"
" :class:`~django.db.models.Field` 의 서브클래스를 ``1Field``라고 부르는 것은 "
"좋은 생각인데, 이로 인해  :class:`~django.db.models.Field` 서브클래스 를 쉽"
"게 인식할 수 있습니다)이는  기존 필드와 다르게 동작하므로 :class:`~django.db."
"models.Field`:: 으로부터 직접적으로 상속해야 한다."

msgid ""
"Our ``HandField`` accepts most of the standard field options (see the list "
"below), but we ensure it has a fixed length, since it only needs to hold 52 "
"card values plus their suits; 104 characters in total."
msgstr ""
"우리의 \"HandField\"는 대부분의 표준 필드 옵션(아래 목록 참조)을 수용하지만 "
"52개의 카드 값과 그 정장, 총 104자만 보유하면 되기 때문에 길이가 고정되어 있"
"음을 보장한다."

msgid ""
"Many of Django's model fields accept options that they don't do anything "
"with. For example, you can pass both :attr:`~django.db.models.Field."
"editable` and :attr:`~django.db.models.DateField.auto_now` to a :class:"
"`django.db.models.DateField` and it will ignore the :attr:`~django.db.models."
"Field.editable` parameter (:attr:`~django.db.models.DateField.auto_now` "
"being set implies ``editable=False``). No error is raised in this case."
msgstr ""
"Django의 모델 분야 중 많은 부분은 그들이 아무것도 하지 않는 옵션을 받아들인"
"다. 예를 들어, :attr:`~django.db.models.Field.editable` and :attr:`~django."
"db.models.DateField.auto_now` 두 가지를 모두 :class:`django.db.models."
"DateField` 로 전달 할 수 있고  :attr:`~django.db.models.Field.editable`매개 "
"변수와(:attr:`~django.db.models.DateField.auto_now` being set implies "
"``editable=False``). 를 무시한다."

msgid ""
"This behavior simplifies the field classes, because they don't need to check "
"for options that aren't necessary. They pass all the options to the parent "
"class and then don't use them later on. It's up to you whether you want your "
"fields to be more strict about the options they select, or to use the more "
"permissive behavior of the current fields."
msgstr ""
"이 동작은 필요하지 않은 옵션을 확인할 필요가 없으므로 필드 클래스를 단순화합"
"니다. 모든 옵션을 부모 클래스에 전달한 다음 나중에 사용하지 않습니다. 선택한 "
"옵션에 대해 필드를 더 엄격하게 지정하거나 현재 필드의 더 관대한 동작을 사용할"
"지 여부는 사용자에게 달려 있습니다."

msgid "The ``Field.__init__()`` method takes the following parameters:"
msgstr "''`Field.__init__()' 방법은 다음과 같은 파라미터를 사용합니다."

msgid ":attr:`~django.db.models.Field.verbose_name`"
msgstr ":attr:`~django.db.models.Field.verbose_name`"

msgid "``name``"
msgstr "``name``"

msgid ":attr:`~django.db.models.Field.primary_key`"
msgstr ":attr:`~django.db.models.Field.primary_key`"

msgid ":attr:`~django.db.models.CharField.max_length`"
msgstr ":attr:`~django.db.models.CharField.max_length`"

msgid ":attr:`~django.db.models.Field.unique`"
msgstr ":attr:`~django.db.models.Field.unique`"

msgid ":attr:`~django.db.models.Field.blank`"
msgstr ":attr:`~django.db.models.Field.blank`"

msgid ":attr:`~django.db.models.Field.null`"
msgstr ":attr:`~django.db.models.Field.null`"

msgid ":attr:`~django.db.models.Field.db_index`"
msgstr ":attr:`~django.db.models.Field.db_index`"

msgid ""
"``rel``: Used for related fields (like :class:`ForeignKey`). For advanced "
"use only."
msgstr ""
"``rel``: Used for related fields (like :class:`ForeignKey`). 고급 사용시"

msgid ":attr:`~django.db.models.Field.default`"
msgstr ":attr:`~django.db.models.Field.default`"

msgid ":attr:`~django.db.models.Field.editable`"
msgstr ":attr:`~django.db.models.Field.editable`"

msgid ""
"``serialize``: If ``False``, the field will not be serialized when the model "
"is passed to Django's :doc:`serializers </topics/serialization>`. Defaults "
"to ``True``."
msgstr ""
"\"serialize\": \"False\"이라면, 모델이 장고 :doc :\"serializers\"에 전달될 "
"때 그 분야는직렬화되지 않을 것이다. 기본값은 \"TRUE\"입니다."

msgid ":attr:`~django.db.models.Field.unique_for_date`"
msgstr ":attr:`~django.db.models.Field.unique_for_date`"

msgid ":attr:`~django.db.models.Field.unique_for_month`"
msgstr ":attr:`~django.db.models.Field.unique_for_month`"

msgid ":attr:`~django.db.models.Field.unique_for_year`"
msgstr ":attr:`~django.db.models.Field.unique_for_year`"

msgid ":attr:`~django.db.models.Field.choices`"
msgstr ":attr:`~django.db.models.Field.choices`"

msgid ":attr:`~django.db.models.Field.help_text`"
msgstr ":attr:`~django.db.models.Field.help_text`"

msgid ":attr:`~django.db.models.Field.db_column`"
msgstr ":attr:`~django.db.models.Field.db_column`"

msgid ""
":attr:`~django.db.models.Field.db_tablespace`: Only for index creation, if "
"the backend supports :doc:`tablespaces </topics/db/tablespaces>`. You can "
"usually ignore this option."
msgstr ""
":attr:`~django.db.models.Field.db_tablespace`: 백엔드에서 :"
"doc:'tablespaces'를 지원하는 경우에만 인덱스 생성에 사용됩니다. 일반적으로 "
"이 옵션을 무시할 수 있습니다."

msgid ""
":attr:`~django.db.models.Field.auto_created`: ``True`` if the field was "
"automatically created, as for the :class:`~django.db.models.OneToOneField` "
"used by model inheritance. For advanced use only."
msgstr ""
"필드가 자동으로 생성된 경우,:class:`~django.db.models.OneToOneField` 가 모델 "
"상속으로 사용된 경우, :attr:`~django.db.models.Field.auto_created`: ``True``"
"이다. 고급 사용시"

msgid ""
"All of the options without an explanation in the above list have the same "
"meaning they do for normal Django fields. See the :doc:`field documentation "
"</ref/models/fields>` for examples and details."
msgstr ""
"위의 목록에 설명이 없는 모든 옵션은 일반 D장고 필드에 대해 동일한 의미를 가집"
"니다. 예시와 자세한 내용은 :doc:'field documentation'를 참조하십시오."

msgid "Field deconstruction"
msgstr "필드 해체"

msgid ""
"The counterpoint to writing your ``__init__()`` method is writing the :meth:"
"`~.Field.deconstruct` method. It's used during :doc:`model migrations </"
"topics/migrations>` to tell Django how to take an instance of your new field "
"and reduce it to a serialized form - in particular, what arguments to pass "
"to ``__init__()`` to re-create it."
msgstr ""
"당신의 ``__init__()\" 방식을 쓰는 것의 대척점은 :meth:\"를 쓰는 것이다.Field."
"deconstruction' 메서드입니다. 그것은 :doc:'model migration'에서 Django에게 당"
"신의 새로운 필드의 예를 들어 그것을 직렬화된 형태로 줄이는 방법, 특히 그것을 "
"재생성하기 위해 \"_init_()\"로 전달할 인수들을 말한다."

msgid ""
"If you haven't added any extra options on top of the field you inherited "
"from, then there's no need to write a new ``deconstruct()`` method. If, "
"however, you're changing the arguments passed in ``__init__()`` (like we are "
"in ``HandField``), you'll need to supplement the values being passed."
msgstr ""
"물려받은 분야 위에 별도의 옵션을 추가하지 않았다면 굳이 새로운 "
"```deconstruct()\" 방식을 쓸 필요가 없다. 그러나 만일 당신이 "
"``_init__()\" (우리가 \"HandField\"에 있는 것처럼)로 전달된 주장을 바꾼다면, "
"당신은 통과되는 값을 보완할 필요가 있을 것이다."

msgid ""
"``deconstruct()`` returns a tuple of four items: the field's attribute name, "
"the full import path of the field class, the positional arguments (as a "
"list), and the keyword arguments (as a dict). Note this is different from "
"the ``deconstruct()`` method :ref:`for custom classes <custom-deconstruct-"
"method>` which returns a tuple of three things."
msgstr ""
"``deconstruct()\" 는 4개의 아이템의 튜플을 반환합니다 :필드 속성 이름, 필드 "
"클래스의 전체 가져오기 경로, 위치 인수(목록으로) 및 키워드 인수(dict로)가 있"
"습니다. 이는 3개의 튜플을 반환하는 ``deconstruct()`` method :ref:` 과는 다릅"
"니다."

msgid ""
"As a custom field author, you don't need to care about the first two values; "
"the base ``Field`` class has all the code to work out the field's attribute "
"name and import path. You do, however, have to care about the positional and "
"keyword arguments, as these are likely the things you are changing."
msgstr ""
"사용자 지정 필드 작성자로서 기본 ``Field\" 클래스는 필드의 속성 이름과 가져오"
"기 경로를 결정하는 모든 코드를 가지고 있기 때문에 앞의 두 값에 신경 쓸 필요"
"가 없습니다. 그러나 위치 및 키워드 인수에 주의해야 합니다. 이러한 인수는 사용"
"자가 변경하는 것일 수 있기 때문입니다."

msgid ""
"For example, in our ``HandField`` class we're always forcibly setting "
"max_length in ``__init__()``. The ``deconstruct()`` method on the base "
"``Field`` class will see this and try to return it in the keyword arguments; "
"thus, we can drop it from the keyword arguments for readability::"
msgstr ""
"예를 들어 우리의 ``HandField\" 클래스에서 우리는 항상 max_length를 "
"``__init__()\"로 강제적으로 설정한다. \"Field\" 클래스의 ``deconstruct() \"방"
"식은 이것을 보고 키워드 논쟁에서 반환하려고 할 것이다. 따라서 우리는 이것을 "
"가독성을 위한 키워드 논쟁에서 빼놓을 수 있다."

msgid ""
"If you add a new keyword argument, you need to write code in "
"``deconstruct()`` that puts its value into ``kwargs`` yourself. You should "
"also omit the value from ``kwargs`` when it isn't necessary to reconstruct "
"the state of the field, such as when the default value is being used::"
msgstr ""
"새로운 키워드 논거를 추가하면 그 가치를 스스로 \"kwags\"에 넣는 "
"``decorruction()\"이라는 코드를 쓸 필요가 있다. 기본값이 사용되는 경우와 같"
"이 필드 상태를 재구성할 필요가 없는 경우 \"kwags\"에서 값을 생략해야 한다."

msgid ""
"More complex examples are beyond the scope of this document, but remember - "
"for any configuration of your Field instance, ``deconstruct()`` must return "
"arguments that you can pass to ``__init__`` to reconstruct that state."
msgstr ""
"좀 더 복잡한 예는 이 문서의 범위를 벗어나지만 기억하라. 즉, 필드 인스턴스의 "
"구성에 대해서는 \"`deconstruct()\"가 해당 상태를 재구성하기 위해 \"_init__"
"\"로 전달할 수 있는 인수를 반환해야 한다."

msgid ""
"Pay extra attention if you set new default values for arguments in the "
"``Field`` superclass; you want to make sure they're always included, rather "
"than disappearing if they take on the old default value."
msgstr ""
"\"Field\" 슈퍼클래스의 인수에 대해 새로운 기본값을 설정하는 경우 특히 주의를 "
"기울이십시오. 인수가 이전 기본값을 사용하는 경우 인수가 사라지더라도 항상 포"
"함되도록 하려는 경우입니다."

msgid ""
"In addition, try to avoid returning values as positional arguments; where "
"possible, return values as keyword arguments for maximum future "
"compatibility. If you change the names of things more often than their "
"position in the constructor's argument list, you might prefer positional, "
"but bear in mind that people will be reconstructing your field from the "
"serialized version for quite a while (possibly years), depending how long "
"your migrations live for."
msgstr ""
"또한 값을 위치 인수로 반환하지 않도록 하십시오. 가능한 경우 값을 키워드 인수"
"로 반환하여 미래의 호환성을 최대화합니다. 생성자의 인수 목록에서 위치보다 항"
"목의 이름을 더 자주 변경할 경우 위치 지정을 선호할 수 있지만 마이그레이션 기"
"간(년)에 따라 사람들이 직렬화된 버전에서 사용자 필드를 오랫동안 재구성할 수 "
"있습니다."

msgid ""
"You can see the results of deconstruction by looking in migrations that "
"include the field, and you can test deconstruction in unit tests by "
"deconstructing and reconstructing the field::"
msgstr ""
"필드를 포함하는 마이그레이션을 확인하여 재구성 결과를 확인할 수 있으며, 필드"
"를 재구성하고 재구성하여 단위 테스트에서 재구성을 테스트할 수 있습니다."

msgid "Changing a custom field's base class"
msgstr "사용자 맞춤 정의 필드의 기본 클래스 변경"

msgid ""
"You can't change the base class of a custom field because Django won't "
"detect the change and make a migration for it. For example, if you start "
"with::"
msgstr ""
"Django가 변경 내용을 검색하지 않고 해당 필드에 대해 마이그레이션을 수행하므"
"로 사용자 정의 필드의 기본 클래스를 변경할 수 없습니다. 예를 들어, 다음 항목"
"으로 시작하는 경우:"

msgid ""
"and then decide that you want to use ``TextField`` instead, you can't change "
"the subclass like this::"
msgstr ""
"대신 \"TextField\"를 사용하기로 결정하면 다음과 같이 하위 클래스를 변경할 수 "
"없습니다."

msgid ""
"Instead, you must create a new custom field class and update your models to "
"reference it::"
msgstr ""
"대신 새 사용자 지정 필드 클래스를 만들고 모델을 업데이트하여 참조해야 합니다."

msgid ""
"As discussed in :ref:`removing fields <migrations-removing-model-fields>`, "
"you must retain the original ``CustomCharField`` class as long as you have "
"migrations that reference it."
msgstr ""
"\"ref:'moving fields'에서 논했듯이, 당신은 그것을 참조하는 마이그레이션이 있"
"는 한 원래의 \"Custom CharField\" 클래스를 보유해야 한다."

msgid "Documenting your custom field"
msgstr "사용자 맞춤 정의 필드 문서화"

msgid ""
"As always, you should document your field type, so users will know what it "
"is. In addition to providing a docstring for it, which is useful for "
"developers, you can also allow users of the admin app to see a short "
"description of the field type via the :doc:`django.contrib.admindocs </ref/"
"contrib/admin/admindocs>` application. To do this provide descriptive text "
"in a :attr:`~Field.description` class attribute of your custom field. In the "
"above example, the description displayed by the ``admindocs`` application "
"for a ``HandField`` will be 'A hand of cards (bridge style)'."
msgstr ""
"사용자가 필드 유형을 알 수 있도록 항상 필드 유형을 문서화해야 합니다. 개발자"
"에게 유용한 docstring을 제공할 뿐만 아니라 admin 앱의 사용자가 :doc:'django."
"contrib.admindocs' 애플리케이션을 통해 필드 유형에 대한 간단한 설명을 볼 수 "
"있도록 할 수 있습니다. 이렇게 하려면 사용자 정의 필드의 :attr:'~Field."
"description' 클래스 속성에 설명 텍스트를 입력합니다. 위의 예에서 ``핸드필드"
"\"를 신청하는 ``애드민더스\"가 보여주는 묘사는 카드의 손(브리지 스타일)이 될 "
"것이다."

msgid ""
"In the :mod:`django.contrib.admindocs` display, the field description is "
"interpolated with ``field.__dict__`` which allows the description to "
"incorporate arguments of the field. For example, the description for :class:"
"`~django.db.models.CharField` is::"
msgstr ""
":mod:'django.contrib.admindocs' 디스플레이에서 필드 설명은 \"field\"로 보간된"
"다.__dict__''는 필드 인수를 포함할 수 있는 설명입니다. 예를 들어 :class에 대"
"한 설명:'~django.db.db.know.CharField'는 다음과 같다."

msgid "Useful methods"
msgstr "쓸모있는 메소드들"

msgid ""
"Once you've created your :class:`~django.db.models.Field` subclass, you "
"might consider overriding a few standard methods, depending on your field's "
"behavior. The list of methods below is in approximately decreasing order of "
"importance, so start from the top."
msgstr ""
":class를 생성했으면:'~django.db.db.know.필드의 하위 클래스는 필드 동작에 따"
"라 몇 가지 표준 방법을 재정의하는 것을 고려할 수 있습니다. 아래 방법 목록은 "
"중요도가 대략적으로 감소하는 순서이므로 맨 위에서부터 시작하십시오."

msgid "Custom database types"
msgstr "사용자 맞춤 정의 데이터베이스 유형"

msgid ""
"Say you've created a PostgreSQL custom type called ``mytype``. You can "
"subclass ``Field`` and implement the :meth:`~Field.db_type` method, like so::"
msgstr ""
"Postgre를 생성했다고 가정해 보십시오.SQL 사용자 정의 유형은 \"my type\"입니"
"다. 다음과 같이 \"Field\"를 하위 분류하고 :meth:'~Field.db_type\" 방법을 구현"
"할 수 있습니다."

msgid ""
"Once you have ``MytypeField``, you can use it in any model, just like any "
"other ``Field`` type::"
msgstr ""
"일단 \"MytypeField\"를 갖게 되면 다른 \"Field\" 타입과 마찬가지로 어떤 모델에"
"서도 사용할 수 있다."

msgid ""
"If you aim to build a database-agnostic application, you should account for "
"differences in database column types. For example, the date/time column type "
"in PostgreSQL is called ``timestamp``, while the same column in MySQL is "
"called ``datetime``. You can handle this in a :meth:`~Field.db_type` method "
"by checking the ``connection.vendor`` attribute. Current built-in vendor "
"names are: ``sqlite``, ``postgresql``, ``mysql``, and ``oracle``."
msgstr ""

msgid "For example::"
msgstr "예시::"

msgid ""
"The :meth:`~Field.db_type` and :meth:`~Field.rel_db_type` methods are called "
"by Django when the framework constructs the ``CREATE TABLE`` statements for "
"your application -- that is, when you first create your tables. The methods "
"are also called when constructing a ``WHERE`` clause that includes the model "
"field -- that is, when you retrieve data using QuerySet methods like "
"``get()``, ``filter()``, and ``exclude()`` and have the model field as an "
"argument. They are not called at any other time, so it can afford to execute "
"slightly complex code, such as the ``connection.settings_dict`` check in the "
"above example."
msgstr ""
":meth:'~Field.db_type' 및 :meth:'~Field.rel_db_type' 방법은 프레임워크가 당신"
"의 애플리케이션에 대한 ``CREATE TABLE\" 문을 구성할 때 즉, 당신이 당신의 테이"
"블을 처음 만들 때 Django에 의해 호출된다. 이 방법은 모델 필드를 포함하는 "
"``WHERE\" 조항 즉 ``필터()\"와 \"제외()\"와 같은 쿼리셋 방법을 사용하여 데이"
"터를 검색하고 모델 필드를 논쟁으로 삼을 때도 호출된다. 그들은 다른 때 호출되"
"지 않기 때문에 그것은 ``연결\"과 같은 약간 복잡한 코드를 실행할 여유가 있다."
"위의 예에서 settings_laints를 체크합니다."

msgid ""
"Some database column types accept parameters, such as ``CHAR(25)``, where "
"the parameter ``25`` represents the maximum column length. In cases like "
"these, it's more flexible if the parameter is specified in the model rather "
"than being hard-coded in the ``db_type()`` method. For example, it wouldn't "
"make much sense to have a ``CharMaxlength25Field``, shown here::"
msgstr ""
"일부 데이터베이스 열 유형에는 \"CHAR(25)\"과 같은 매개 변수가 최대 열 길이를 "
"나타내는 \"25\"와 같은 매개 변수가 허용된다. 이러한 경우 매개변수가 "
"\"db_type()\" 방식으로 하드 코딩되기 보다는 모델에 지정되면 더 유연하다. 예"
"를 들어 여기에 \"CharMaxlength25Field\"가 나와 있는 것은 말이 되지 않는다."

msgid ""
"The better way of doing this would be to make the parameter specifiable at "
"run time -- i.e., when the class is instantiated. To do that, implement "
"``Field.__init__()``, like so::"
msgstr ""
"이렇게 하는 더 좋은 방법은 런타임에 매개 변수를 지정할 수 있게 하는 것입니"
"다. 즉, 클래스가 인스턴스화된 경우입니다. 그러기 위해서는 ``필드\"를 실행하"
"라.__init__()는 다음과 같습니다."

msgid ""
"Finally, if your column requires truly complex SQL setup, return ``None`` "
"from :meth:`.db_type`. This will cause Django's SQL creation code to skip "
"over this field. You are then responsible for creating the column in the "
"right table in some other way, but this gives you a way to tell Django to "
"get out of the way."
msgstr ""
"마지막으로, 컬럼에 실제로 복잡한 SQL 설정이 필요한 경우 :meth:\"none\"에서 "
"\"none\"을 반환합니다. 이로 인해 Django의 SQL 생성 코드가 이 필드를 건너뜁니"
"다. 그러면 다른 방법으로 오른쪽 테이블에 열을 만들 책임이 있지만, 이것은 여러"
"분이 Django에게 해결방법을 제공합니다."

msgid ""
"The :meth:`~Field.rel_db_type` method is called by fields such as "
"``ForeignKey`` and ``OneToOneField`` that point to another field to "
"determine their database column data types. For example, if you have an "
"``UnsignedAutoField``, you also need the foreign keys that point to that "
"field to use the same data type::"
msgstr ""
":meth:'~Field.rel_db_type'은 다른 필드를 가리키는 \"ForeignKey\"와 "
"\"OneToOneField\"와 같은 분야로 불리며 데이터베이스 열 데이터 유형을 결정한"
"다. 예를 들어 \"미서명\"이 있는 경우AutoField'에서 동일한 데이터 유형을 사용"
"하려면 해당 필드를 가리키는 외래 키도 필요합니다."

msgid "Converting values to Python objects"
msgstr "값을 파이썬 개체로 변환"

msgid ""
"If your custom :class:`~Field` class deals with data structures that are "
"more complex than strings, dates, integers, or floats, then you may need to "
"override :meth:`~Field.from_db_value` and :meth:`~Field.to_python`."
msgstr ""
"사용자 정의:클래스:'~Field' 클래스는 문자열, 날짜, 정수 또는 부동보다 복잡한 "
"데이터 구조를 다루므로 meth:'~from_db_value' 및 :meth:'~Field'를 재정의해야 "
"할 수 있습니다."

msgid ""
"If present for the field subclass, ``from_db_value()`` will be called in all "
"circumstances when the data is loaded from the database, including in "
"aggregates and :meth:`~django.db.models.query.QuerySet.values` calls."
msgstr ""
"필드 서브클래스에 \"from_db_value()\"가 존재하면 aggregate 및 :meth:"
"\"~django.db.models.QuerySet.values를 포함하여 데이터베이스에서 데이터가 로드"
"되는 모든 상황에서 호출됩니다.의 호출입니다."

msgid ""
"``to_python()`` is called by deserialization and during the :meth:`~django."
"db.models.Model.clean` method used from forms."
msgstr ""
"``to_python()`` 는 역직렬화(deserialization)에 의해 호출되고 :meth:`~django."
"db.models.Model.clean`메소드가 폼 도중에 사용된다."

msgid ""
"As a general rule, ``to_python()`` should deal gracefully with any of the "
"following arguments:"
msgstr ""
"일반적으로 ``to_python()\"은 다음 주장 중 하나를 기품 있게 다루어야 한다."

msgid ""
"An instance of the correct type (e.g., ``Hand`` in our ongoing example)."
msgstr "올바른 유형의 예(예: 현재 진행 중인 예에서 \"Hand\")"

msgid "A string"
msgstr "문자열"

msgid "``None`` (if the field allows ``null=True``)"
msgstr "``None``(필드에서 \"null = True\"를 허용한다면)"

msgid ""
"In our ``HandField`` class, we're storing the data as a VARCHAR field in the "
"database, so we need to be able to process strings and ``None`` in the "
"``from_db_value()``. In ``to_python()``, we need to also handle ``Hand`` "
"instances::"
msgstr ""
"\"HandField`\" 클래스에서는 데이터를 데이터베이스에 VARCHAR 필드로 저장하므"
"로 \"from_db_value()\"에서 문자열과 \"`None\"을 처리할 수 있어야 한다. "
"``to_python()\"에서 우리는 또한 ```Hand\"의 인스턴스를 다룰 필요가 있다."

msgid ""
"Notice that we always return a ``Hand`` instance from these methods. That's "
"the Python object type we want to store in the model's attribute."
msgstr ""
"\"우리는 항상 이러한 방법에서 ``Hand\"의 예를 되돌려 놓는다는 것을 주목하라. "
"모델의 속성에 저장하려는 Python 개체 유형입니다."

msgid ""
"For ``to_python()``, if anything goes wrong during value conversion, you "
"should raise a :exc:`~django.core.exceptions.ValidationError` exception."
msgstr ""
" ``to_python()``에서, 만약 가치 변환 중에 잘못된 것이 있다면, 당신은  :exc:"
"`~django.core.exceptions.ValidationError`예외를 제기해야 한다."

msgid "Converting Python objects to query values"
msgstr "파이썬 개체를 질의 값으로 변환하는 중"

msgid ""
"Since using a database requires conversion in both ways, if you override :"
"meth:`~Field.from_db_value` you also have to override :meth:`~Field."
"get_prep_value` to convert Python objects back to query values."
msgstr ""
"데이터베이스를 사용하려면 두 가지 방식으로 변환해야 하므로 :meth:'~Field."
"from_value'를 재정의할 경우 :meth:'~Field.get_prep_value'도 재정의해야 "
"Python 개체를 다시 쿼리 값으로 변환할 수 있습니다."

msgid ""
"If your custom field uses the ``CHAR``, ``VARCHAR`` or ``TEXT`` types for "
"MySQL, you must make sure that :meth:`.get_prep_value` always returns a "
"string type. MySQL performs flexible and unexpected matching when a query is "
"performed on these types and the provided value is an integer, which can "
"cause queries to include unexpected objects in their results. This problem "
"cannot occur if you always return a string type from :meth:`.get_prep_value`."
msgstr ""
"사용자 지정 필드가 MySQL에 대해 \"CAR\", \"VARCHAR\" 또는 \"TEXT\" 유형을 사"
"용하는 경우 :meth:methget_prep_value\"가 항상 문자열 유형을 반환하는지 확인해"
"야 한다. 이러한 유형에 대해 쿼리가 수행되고 제공된 값이 정수인 경우 MySQL은 "
"유연하고 예상치 못한 일치를 수행하므로 쿼리에 예기치 않은 개체가 결과에 포함"
"될 수 있습니다. 문자열 유형을 항상 :meth:meth:>get_prep_value'에서 반환하는 "
"경우에는 이 문제가 발생할 수 없습니다."

msgid "Converting query values to database values"
msgstr "질의 값을 데이터베이스 값으로 변환하는 중"

msgid ""
"Some data types (for example, dates) need to be in a specific format before "
"they can be used by a database backend. :meth:`~Field.get_db_prep_value` is "
"the method where those conversions should be made. The specific connection "
"that will be used for the query is passed as the ``connection`` parameter. "
"This allows you to use backend-specific conversion logic if it is required."
msgstr ""
"일부 데이터 유형(예: 날짜)은 데이터베이스 백엔드에서 사용하려면 특정 형식이어"
"야 합니다. :meth:'~Field.get_db_prep_value'는 이러한 변환을 수행해야 하는 방"
"법입니다. 쿼리에 사용될 구체적인 연결은 \"연결\" 매개변수로 전달된다. 이렇게 "
"하면 필요한 경우 백엔드별 변환 로직을 사용할 수 있습니다."

msgid ""
"For example, Django uses the following method for its :class:`BinaryField`::"
msgstr ""
"예를 들어, Django는 다음 방법을 사용하여 다음을 수행합니다.:class:"
"`BinaryField`::"

msgid ""
"In case your custom field needs a special conversion when being saved that "
"is not the same as the conversion used for normal query parameters, you can "
"override :meth:`~Field.get_db_prep_save`."
msgstr ""
"저장 시 일반 쿼리 파라미터에 사용되는 변환과 다른 특수 변환이 필요한 경우 "
"meth:'~Field.db_prep_save'를 재정의할 수 있습니다."

msgid "Preprocessing values before saving"
msgstr "저장하기 전에 값 사전 처리"

msgid ""
"If you want to preprocess the value just before saving, you can use :meth:"
"`~Field.pre_save`. For example, Django's :class:`~django.db.models."
"DateTimeField` uses this method to set the attribute correctly in the case "
"of :attr:`~django.db.models.DateField.auto_now` or :attr:`~django.db.models."
"DateField.auto_now_add`."
msgstr ""
"저장하기 직전에 값을 사전 처리하려는 경우:meth:`~Field.pre_save`.을 사용할 "
"수 있다. 예를 들어, django 의 :class:`~django.db.models.DateTimeField는 이 메"
"소드를 사용하여 :attr:`~django.db.models.DateField.auto_now` or :attr:"
"`~django.db.models.DateField.auto_now_add`. 의 경우들의 속성을 알맞게 집합한"
"다."

msgid ""
"If you do override this method, you must return the value of the attribute "
"at the end. You should also update the model's attribute if you make any "
"changes to the value so that code holding references to the model will "
"always see the correct value."
msgstr ""
"이 메서드를 재정의하는 경우 속성 값을 마지막에 반환해야 합니다. 모델에 대한 "
"코드 유지 참조가 항상 올바른 값을 볼 수 있도록 값을 변경한 경우에도 모델의 속"
"성을 업데이트해야 합니다."

msgid "Specifying the form field for a model field"
msgstr "모델필드의 폼필드 명시"

msgid ""
"To customize the form field used by :class:`~django.forms.ModelForm`, you "
"can override :meth:`~Field.formfield`."
msgstr ""
":class:`~django.forms.ModelForm`, 의 사용할 양식 필드를 사용자 정의하려면:"
"meth:`~Field.formfield`. 오버라이드할수 있다."

msgid ""
"The form field class can be specified via the ``form_class`` and "
"``choices_form_class`` arguments; the latter is used if the field has "
"choices specified, the former otherwise. If these arguments are not "
"provided, :class:`~django.forms.CharField` or :class:`~django.forms."
"TypedChoiceField` will be used."
msgstr ""
"양식 필드 클래스는 \"form_class\"와 \"choices_form_class\" 인수를 통해 지정"
"할 수 있으며, 필드에는 선택사항이 있는 경우 후자를 사용하고, 그렇지 않은 경"
"우 전자를 사용한다. 이러한 인수가 제공되지 않은 경우 :class:'~django' 입니다."
"양식.CharField' 또는 :class:'~django' 입니다..TypeedChoiceField'가 사용됩니"
"다."

msgid ""
"All of the ``kwargs`` dictionary is passed directly to the form field's "
"``__init__()`` method. Normally, all you need to do is set up a good default "
"for the ``form_class`` (and maybe ``choices_form_class``) argument and then "
"delegate further handling to the parent class. This might require you to "
"write a custom form field (and even a form widget). See the :doc:`forms "
"documentation </topics/forms/index>` for information about this."
msgstr ""
"모든 ``kwags\" 사전은 양식장의 ``_init__()\" 방식에 직접 전달된다. 보통 당신"
"이 해야 할 일은 ``form_class\" (그리고 어쩌면 \"choices_form_class\") 논쟁에 "
"대한 좋은 디폴트를 설정한 다음 부모 계층에게 더 많은 처리를 위임하는 것이다. "
"사용자 정의 양식 필드 및 양식 위젯을 작성해야 할 수 있습니다. 자세한 내용은 :"
"doc:'양식 문서'를 참조하십시오."

msgid ""
"Continuing our ongoing example, we can write the :meth:`~Field.formfield` "
"method as::"
msgstr ""
"계속 예를 들면 :meth:'Field.formfield' 메소드를 다음과 같이 작성할 수 있습니"
"다."

msgid ""
"This assumes we've imported a ``MyFormField`` field class (which has its own "
"default widget). This document doesn't cover the details of writing custom "
"form fields."
msgstr ""
"이것은 우리가 (기본 위젯이 있는) ``MyFormField\" 필드 클래스를 수입했다고 가"
"정한다. 이 문서에서는 사용자 정의 양식 필드 작성에 대한 세부 정보를 다루지 않"
"습니다."

msgid "Emulating built-in field types"
msgstr "내장된 필드 유형 에뮬레이션"

msgid ""
"If you have created a :meth:`.db_type` method, you don't need to worry "
"about :meth:`.get_internal_type` -- it won't be used much. Sometimes, "
"though, your database storage is similar in type to some other field, so you "
"can use that other field's logic to create the right column."
msgstr ""
":meth:methdb_type' method를 생성했다면 :meth:meth:malget_internal_type'에 대"
"해 걱정할 필요가 없습니다. 많이 사용되지 않습니다. 그러나 데이터베이스 저장소"
"의 유형이 다른 필드와 비슷할 때도 있으므로 다른 필드의 논리를 사용하여 올바"
"른 열을 만들 수 있습니다"

msgid ""
"No matter which database backend we are using, this will mean that :djadmin:"
"`migrate` and other SQL commands create the right column type for storing a "
"string."
msgstr ""
"어떤 데이터베이스 백엔드를 사용하든, 이것은 :djadmin:'migrate'와 다른 SQL 명"
"령어가 문자열을 저장하기 위한 올바른 열 유형을 생성한다는 것을 의미한다."

msgid ""
"If :meth:`.get_internal_type` returns a string that is not known to Django "
"for the database backend you are using -- that is, it doesn't appear in "
"``django.db.backends.<db_name>.base.DatabaseWrapper.data_types`` -- the "
"string will still be used by the serializer, but the default :meth:`~Field."
"db_type` method will return ``None``. See the documentation of :meth:`~Field."
"db_type` for reasons why this might be useful. Putting a descriptive string "
"in as the type of the field for the serializer is a useful idea if you're "
"ever going to be using the serializer output in some other place, outside of "
"Django."
msgstr ""
":meth :meth:malcget_internal_type'이 사용 중인 데이터베이스 백엔드에 대해 "
"Django에 알 수 없는 문자열을 반환하는 경우 즉, \"django.db.backends\"에는 나"
"타나지 않습니다.base.DataWrapper.data_types' -- 이 문자열은 직렬화기에서 계"
"속 사용되지만 기본값인 meth:'~Field.db_type' 메서드는 \"없음\"을 반환합니다. "
"유용한 이유는 :meth:'~Field.db_type' 문서를 참조하십시오. 설명 문자열을 직렬"
"화기의 필드 유형으로 삽입하는 것은 Django 이외의 다른 위치에서 직렬화기 출력"
"을 사용할 경우에 유용합니다."

msgid "Converting field data for serialization"
msgstr "직렬화를 위한 필드 데이터 변환"

msgid ""
"To customize how the values are serialized by a serializer, you can "
"override :meth:`~Field.value_to_string`. Using :meth:`~Field."
"value_from_object` is the best way to get the field's value prior to "
"serialization. For example, since ``HandField`` uses strings for its data "
"storage anyway, we can reuse some existing conversion code::"
msgstr ""
"일련 번호에 의해 값이 직렬화되는 방식을 사용자 정의하기 위해 meth:'~Field."
"value_to_string'을 재정의할 수 있습니다. :meth:'~Field.value_from_object'를 "
"사용하면 직렬화 전에 필드 값을 얻을 수 있습니다. 예를 들어 \"핸드필드\"는 어"
"쨌든 데이터 스토리지에 문자열을 사용하기 때문에 다음과 같은 기존 변환 코드를 "
"재사용할 수 있다."

msgid "Some general advice"
msgstr "일반적인 조언"

msgid ""
"Writing a custom field can be a tricky process, particularly if you're doing "
"complex conversions between your Python types and your database and "
"serialization formats. Here are a couple of tips to make things go more "
"smoothly:"
msgstr ""
"특히 Python 유형과 데이터베이스 및 직렬화 형식 간에 복잡한 변환을 수행하는 경"
"우에는 사용자 지정 필드를 작성하는 작업이 까다로울 수 있습니다. 다음은 작업"
"을 보다 원활하게 진행할 수 있도록 하는 몇 가지 팁입니다."

msgid ""
"Look at the existing Django fields (in :file:`django/db/models/fields/"
"__init__.py`) for inspiration. Try to find a field that's similar to what "
"you want and extend it a little bit, instead of creating an entirely new "
"field from scratch."
msgstr ""
"기존의 Django 필드('django/db/models/fields/__init__py' 파일)를 보고 영감을 "
"얻습니다. 완전히 새로운 필드를 처음부터 새로 만드는 대신 원하는 필드와 유사"
"한 필드를 찾아서 약간 확장하십시오."

msgid ""
"Put a ``__str__()`` method on the class you're wrapping up as a field. There "
"are a lot of places where the default behavior of the field code is to call "
"``str()`` on the value. (In our examples in this document, ``value`` would "
"be a ``Hand`` instance, not a ``HandField``). So if your ``__str__()`` "
"method automatically converts to the string form of your Python object, you "
"can save yourself a lot of work."
msgstr ""
"필드로 마무리하는 수업에 \"__str__()\" 방식을 적용합니다. 필드 코드의 기본 동"
"작은 값에 대해 \"str()\"라고 부르는 경우가 많다. (이 문서의 예에서 \"가치"
"\"는 ``핸드필드\"가 아니라 \"손\"의 예일 것이다. 그래서 만약 당신의 "
"``_str__()\" 방법이 당신의 파이썬 객체의 문자열 형태로 자동 변환된다면, 당신"
"은 많은 작업을 절약할 수 있다."

msgid "Writing a ``FileField`` subclass"
msgstr "``FileField``의 하위 클래스 작성"

msgid ""
"In addition to the above methods, fields that deal with files have a few "
"other special requirements which must be taken into account. The majority of "
"the mechanics provided by ``FileField``, such as controlling database "
"storage and retrieval, can remain unchanged, leaving subclasses to deal with "
"the challenge of supporting a particular type of file."
msgstr ""
"위의 방법 외에도 파일을 처리하는 필드에는 몇 가지 다른 특수한 요구 사항이 고"
"려되어야 합니다. 데이터베이스 저장 및 검색 통제 등 ``파일 필드\"가 제공하는 "
"메커니즘의 대다수는 변하지 않을 수 있어 하위 클래스는 특정 유형의 파일을 지원"
"해야 하는 과제를 떠안게 된다."

msgid ""
"Django provides a ``File`` class, which is used as a proxy to the file's "
"contents and operations. This can be subclassed to customize how the file is "
"accessed, and what methods are available. It lives at ``django.db.models."
"fields.files``, and its default behavior is explained in the :doc:`file "
"documentation </ref/files/file>`."
msgstr ""
"django는 파일의 내용과 작업을 대신하는 \"파일\" 클래스를 제공한다. 파일 액세"
"스 방법과 사용 가능한 방법을 사용자 정의하기 위해 하위 분류할 수 있습니다. 그"
"것은 ``django.db.models.fields\"에 산다.files는 다음과 같이 처리되며, 기본 동"
"작은 :doc:'file docation'에 설명되어 있다."

msgid ""
"Once a subclass of ``File`` is created, the new ``FileField`` subclass must "
"be told to use it. To do so, assign the new ``File`` subclass to the special "
"``attr_class`` attribute of the ``FileField`` subclass."
msgstr ""
"일단 \"파일\"의 서브클래스가 만들어지면 새로운 \"파일필드\" 서브클래스는 그것"
"을 사용하라는 말을 들어야 한다. 그러기 위해서는 새로운 \"파일\" 하위 클래스"
"를 \"파일 필드\" 하위 클래스의 \"attr_class\" 특성의 \"파일\" 하위 클래스를 "
"할당해야 한다."

msgid "A few suggestions"
msgstr "몇 가지 제안들"

msgid ""
"In addition to the above details, there are a few guidelines which can "
"greatly improve the efficiency and readability of the field's code."
msgstr ""
"위의 세부 사항 외에도 필드 코드의 효율성과 가독성을 크게 개선할 수 있는 몇 가"
"지 지침이 있습니다."

msgid ""
"The source for Django's own ``ImageField`` (in ``django/db/models/fields/"
"files.py``) is a great example of how to subclass ``FileField`` to support a "
"particular type of file, as it incorporates all of the techniques described "
"above."
msgstr ""
"Django 자신의 \"ImageField\"의 출처(\"django/db/db/fields/files.py에 있음)는 "
"위에서 설명한 모든 기술을 포함하고 있기 때문에 특정 유형의 파일을 지원하기 위"
"해 \"FileField\"를 하위 분류하는 방법을 보여주는 좋은 예이다."

msgid ""
"Cache file attributes wherever possible. Since files may be stored in remote "
"storage systems, retrieving them may cost extra time, or even money, that "
"isn't always necessary. Once a file is retrieved to obtain some data about "
"its content, cache as much of that data as possible to reduce the number of "
"times the file must be retrieved on subsequent calls for that information."
msgstr ""
"가능한 경우 파일 특성을 캐시합니다. 파일을 원격 스토리지 시스템에 저장할 수 "
"있기 때문에 파일을 검색하는 데 추가 시간 또는 비용이 소요될 수 있습니다. 항"
"상 필요한 것은 아닙니다. 파일이 검색되어 콘텐츠에 대한 데이터를 얻으면 해당 "
"데이터를 가능한 많이 캐슁하여 이후 해당 정보를 호출할 때 파일을 검색해야 하"
"는 횟수를 줄이십시오."

msgid "How to implement a custom template backend"
msgstr ""

msgid "Custom backends"
msgstr "맞춤 백엔드 "

msgid ""
"Here's how to implement a custom template backend in order to use another "
"template system. A template backend is a class that inherits ``django."
"template.backends.base.BaseEngine``. It must implement ``get_template()`` "
"and optionally ``from_string()``. Here's an example for a fictional "
"``foobar`` template library::"
msgstr ""
"다른 템플릿 시스템을 사용하기 위해 사용자 지정 템플릿 백엔드를 구현하는 방법"
"은 다음과 같습니다. 템플릿 백엔드는 ``django.template.backends.base\"를 상속"
"하는 클래스입니다.Base Engine'입니다. \"get_template()\"과 "
"\"from_string()\"을 구현해야 한다. 가상의 ``푸바\" 템플릿 라이브러리의 예는 "
"다음과 같다."

msgid "See `DEP 182`_ for more information."
msgstr "자세한 내용은 'DEP 182'를 참조하십시오."

msgid "Debug integration for custom engines"
msgstr "사용자 지정 엔진을 위한 디버그 통합"

msgid ""
"The Django debug page has hooks to provide detailed information when a "
"template error arises. Custom template engines can use these hooks to "
"enhance the traceback information that appears to users. The following hooks "
"are available:"
msgstr ""
"Django 디버그 페이지에는 템플릿 오류가 발생할 때 자세한 정보를 제공하는 후크"
"가 있습니다. 사용자 정의 템플릿 엔진은 이러한 후크를 사용하여 사용자에게 표시"
"되는 추적 정보를 향상시킬 수 있습니다. 다음 후크를 사용할 수 있습니다."

msgid "Template postmortem"
msgstr "템플릿 사후검토"

msgid ""
"The postmortem appears when :exc:`~django.template.TemplateDoesNotExist` is "
"raised. It lists the template engines and loaders that were used when trying "
"to find a given template. For example, if two Django engines are configured, "
"the postmortem will appear like:"
msgstr ""
"다음 경우:exc:에 사후에:'~django.the'템플릿이 없습니다'가 발생합니다. 지정된 "
"템플릿을 찾을 때 사용된 템플릿 엔진 및 로더가 나열됩니다. 예를 들어 두 개의 "
"Django 엔진이 구성된 경우 사후에 다음과 같이 표시됩니다."

msgid ""
"Custom engines can populate the postmortem by passing the ``backend`` and "
"``tried`` arguments when raising :exc:`~django.template."
"TemplateDoesNotExist`. Backends that use the postmortem :ref:`should specify "
"an origin <template-origin-api>` on the template object."
msgstr ""
"커스텀엔진은 다음과 같은 문제를 제기할 때 ``백엔드\"와 \"시도한\" 주장을 통과"
"시킴으로써 사후에 채워질 수 있다.'~django.the'템플릿이 없습니다. 사후 처리:"
"ref:'를 사용하는 백엔드는 템플릿 개체에 원점을 지정해야 합니다."

msgid "Contextual line information"
msgstr "맥락선정보"

msgid ""
"If an error happens during template parsing or rendering, Django can display "
"the line the error happened on. For example:"
msgstr ""
"If an error happens during template parsing or rendering, Django can display "
"the line the error happened on. For example:"

msgid ""
"Custom engines can populate this information by setting a ``template_debug`` "
"attribute on exceptions raised during parsing and rendering. This attribute "
"is a :class:`dict` with the following values:"
msgstr ""
"사용자 지정 엔진은 구문 분석 및 렌더링 중에 발생하는 예외에 대해 "
"\"template_debug\" 속성을 설정하여 이 정보를 채울 수 있다. 이 속성은 다음 값"
"을 갖는 :class:'dict'입니다."

msgid "``'name'``: The name of the template in which the exception occurred."
msgstr "\"이름\": 예외가 발생한 템플릿의 이름입니다."

msgid "``'message'``: The exception message."
msgstr "``'message'``: 예외 메시지."

msgid ""
"``'source_lines'``: The lines before, after, and including the line the "
"exception occurred on. This is for context, so it shouldn't contain more "
"than 20 lines or so."
msgstr ""
"''source_lines'': 예외가 발생한 행의 이전, 이후 및 포함 선. 컨텍스트용이므로 "
"20개 이상의 라인을 포함할 수 없습니다."

msgid "``'line'``: The line number on which the exception occurred."
msgstr "\"라인\": 예외가 발생한 라인 번호입니다."

msgid ""
"``'before'``: The content on the error line before the token that raised the "
"error."
msgstr "\"'before'\": 오류를 발생시킨 토큰 앞의 내용입니다."

msgid "``'during'``: The token that raised the error."
msgstr "``'during'``: 오류를 발생시킨 토큰입니다."

msgid ""
"``'after'``: The content on the error line after the token that raised the "
"error."
msgstr "``'after'``: 오류를 발생시킨 토큰 뒤에 있는 오류 행의 내용입니다."

msgid "``'total'``: The number of lines in ``source_lines``."
msgstr "``'total'``: \"source_line\"의 줄 수는 다음과 같다."

msgid "``'top'``: The line number where ``source_lines`` starts."
msgstr "``'top'``: \"source_line\"이 시작되는 라인 번호이다."

msgid "``'bottom'``: The line number where ``source_lines`` ends."
msgstr "``'bottom'``: \"source_line\"이 끝나는 라인 번호이다."

msgid "Given the above template error, ``template_debug`` would look like::"
msgstr "위의 템플릿 오류로 인해 \"template_debug\"는 다음과 같이 표시됩니다."

msgid "Origin API and 3rd-party integration"
msgstr "오리진 API 및 타사 통합"

msgid ""
"Django templates have an :class:`~django.template.base.Origin` object "
"available through the ``template.origin`` attribute. This enables debug "
"information to be displayed in the :ref:`template postmortem <template-"
"postmortem>`, as well as in 3rd-party libraries, like the `Django Debug "
"Toolbar`_."
msgstr ""
"Django 템플릿의 :class:'~django.base.오리진 객체는 \"template.origin\" 속성"
"을 통해 사용할 수 있다. 디버그 정보를 ef:'템플릿 사후에'는 물론, 제3자 도서관"
"에서도 '장고 디버그 툴바'와 같은 디버그 정보를 표시할 수 있다."

msgid ""
"Custom engines can provide their own ``template.origin`` information by "
"creating an object that specifies the following attributes:"
msgstr ""
"커스텀 엔진은 다음과 같은 속성을 지정하는 객체를 만들어 자체 ``템플릿.오리진"
"\" 정보를 제공할 수 있다."

msgid "``'name'``: The full path to the template."
msgstr "``'name'``: 템플릿의 전체 경로입니다."

msgid ""
"``'template_name'``: The relative path to the template as passed into the "
"template loading methods."
msgstr ""
"``'template_name'``: 템플릿 로드 메서드에 전달된 템플릿에 대한 상대 경로입니"
"다."

msgid ""
"``'loader_name'``: An optional string identifying the function or class used "
"to load the template, e.g. ``django.template.loaders.filesystem.Loader``."
msgstr ""
"``'loader_name'``: 템플릿을 로드하는 데 사용되는 함수 또는 클래스를 식별하는 "
"선택적 문자열(예: \"django.template.loaders\")입니다.파일 시스템로더'."

msgid "How to create custom template tags and filters"
msgstr ""

msgid ""
"Django's template language comes with a wide variety of :doc:`built-in tags "
"and filters </ref/templates/builtins>` designed to address the presentation "
"logic needs of your application. Nevertheless, you may find yourself needing "
"functionality that is not covered by the core set of template primitives. "
"You can extend the template engine by defining custom tags and filters using "
"Python, and then make them available to your templates using the :ttag:`{% "
"load %}<load>` tag."
msgstr ""
"Django의 템플릿 언어는 애플리케이션의 프레젠테이션 논리 요구를 해결하도록 설"
"계된 다양한 :doc:'내장 태그 및 필터'와 함께 제공됩니다. 그럼에도 불구하고 템"
"플릿의 핵심 요소 집합에서 다루지 않는 기능이 필요할 수 있습니다. Python을 사"
"용하여 사용자 지정 태그와 필터를 정의하여 템플릿 엔진을 확장한 다음 :t 태"
"그:'{% load %}' 태그를 사용하여 템플릿에서 사용할 수 있도록 설정할 수 있습니"
"다."

msgid "Code layout"
msgstr "코드 레이아웃"

msgid ""
"The most common place to specify custom template tags and filters is inside "
"a Django app. If they relate to an existing app, it makes sense to bundle "
"them there; otherwise, they can be added to a new app. When a Django app is "
"added to :setting:`INSTALLED_APPS`, any tags it defines in the conventional "
"location described below are automatically made available to load within "
"templates."
msgstr ""
"사용자 정의 템플릿 태그 및 필터를 지정하는 가장 일반적인 장소는 Django 앱 내"
"부입니다. 기존 앱과 관련된 경우 해당 앱에 번들을 추가하는 것이 좋습니다. 그렇"
"지 않으면 새 앱에 추가할 수 있습니다. :seting:'에 Django 앱이 추가되면설치됨_"
"아래에 설명된 기존 위치에서 정의하는 모든 태그는 템플릿 내에서 자동으로 로드"
"됩니다."

msgid ""
"The app should contain a ``templatetags`` directory, at the same level as "
"``models.py``, ``views.py``, etc. If this doesn't already exist, create it - "
"don't forget the ``__init__.py`` file to ensure the directory is treated as "
"a Python package."
msgstr ""
"이 앱은 ``템플릿 태그\" 디렉토리를 ``모델\"과 동일한 수준으로 포함해야 한다."
"파이로, \"말하자면\"피클 등 만약 이것이 존재하지 않는다면, 그것을 만들어라 - "
"디렉토리가 파이썬 패키지로 취급되도록 하기 위해 \"_init__py\" 파일을 잊지 마"
"세요"

msgid "Development server won't automatically restart"
msgstr "개발 서버는 자동으로 다시 시작되지 않습니다"

msgid ""
"After adding the ``templatetags``  module, you will need to restart your "
"server before you can use the tags or filters in templates."
msgstr ""
"\"템플릿 태그\" 모듈을 추가한 후 서버를 재시작해야 템플릿에 태그 또는 필터를 "
"사용할 수 있습니다."

msgid ""
"Your custom tags and filters will live in a module inside the "
"``templatetags`` directory. The name of the module file is the name you'll "
"use to load the tags later, so be careful to pick a name that won't clash "
"with custom tags and filters in another app."
msgstr ""
"사용자 지정 태그와 필터는 ``템플릿 태그\" 디렉토리 내의 모듈에 상주하게 된"
"다. 모듈 파일의 이름은 나중에 태그를 로드하는 데 사용할 이름이므로 다른 앱의 "
"사용자 지정 태그 및 필터와 충돌하지 않는 이름을 선택하십시오."

msgid ""
"For example, if your custom tags/filters are in a file called ``poll_extras."
"py``, your app layout might look like this::"
msgstr ""
"예를 들어 사용자 지정 태그/필터가 ``poll_extras\"라는 파일에 있는 경우.py², "
"앱 레이아웃은 다음과 같을 수 있습니다."

msgid "And in your template you would use the following:"
msgstr "템플릿에서 다음을 사용합니다."

msgid ""
"The app that contains the custom tags must be in :setting:`INSTALLED_APPS` "
"in order for the :ttag:`{% load %}<load>` tag to work. This is a security "
"feature: It allows you to host Python code for many template libraries on a "
"single host machine without enabling access to all of them for every Django "
"installation."
msgstr ""
"사용자 지정 태그가 포함된 앱은 :seting:'에 있어야 합니다.설치됨_:t 태그의 경"
"우 APPS'는 '{% load %}' 태그가 작동합니다. 보안 기능은 다음과 같습니다. 이를 "
"통해 모든 Django 설치에 대해 모든 템플릿 라이브러리에 대한 액세스를 설정하지 "
"않고 단일 호스트 시스템의 여러 템플릿 라이브러리에 대해 Python 코드를 호스팅"
"할 수 있습니다."

msgid ""
"There's no limit on how many modules you put in the ``templatetags`` "
"package. Just keep in mind that a :ttag:`{% load %}<load>` statement will "
"load tags/filters for the given Python module name, not the name of the app."
msgstr ""
"\"템플릿 태그\" 패키지에 얼마나 많은 모듈을 넣었는지는 제한이 없다. :t태"
"그:'{%load %}' 문은 앱 이름이 아닌 지정된 Python 모듈 이름에 대한 태그/필터"
"를 로드한다는 점을 유념하십시오."

msgid ""
"To be a valid tag library, the module must contain a module-level variable "
"named ``register`` that is a ``template.Library`` instance, in which all the "
"tags and filters are registered. So, near the top of your module, put the "
"following::"
msgstr ""
"유효한 태그 라이브러리가 되려면 모듈 레벨 변수인 ``등록\"을 포함해야 한다.모"
"든 태그와 필터가 등록된 라이브러리 인스턴스. 따라서 모듈 상단 근처에 다음을 "
"배치합니다."

msgid ""
"Alternatively, template tag modules can be registered through the "
"``'libraries'`` argument to :class:`~django.template.backends.django."
"DjangoTemplates`. This is useful if you want to use a different label from "
"the template tag module name when loading template tags. It also enables you "
"to register tags without installing an application."
msgstr ""
"또는 \"라이브러리\" 인수를 통해 템플릿 태그 모듈을 :class에 등록할 수 있다."
"~django.backends.django장고사찰. 이 기능은 템플릿 태그를 로드할 때 템플릿 태"
"그 모듈 이름과 다른 레이블을 사용하려는 경우에 유용합니다. 또한 응용 프로그램"
"을 설치하지 않고도 태그를 등록할 수 있습니다."

msgid "Behind the scenes"
msgstr "배후"

msgid ""
"For a ton of examples, read the source code for Django's default filters and "
"tags. They're in :source:`django/template/defaultfilters.py` and :source:"
"`django/template/defaulttags.py`, respectively."
msgstr ""

msgid "For more information on the :ttag:`load` tag, read its documentation."
msgstr ":ttag:'load' 태그에 대한 자세한 내용은 설명서를 참조하십시오."

msgid "Writing custom template filters"
msgstr "사용자 정의 템플릿 필터 쓰기"

msgid "Custom filters are Python functions that take one or two arguments:"
msgstr ""
"사용자 정의 필터는 하나 또는 두 개의 인수를 사용하는 Python 함수입니다."

msgid "The value of the variable (input) -- not necessarily a string."
msgstr "변수 값(입력) - 반드시 문자열은 아닙니다."

msgid ""
"The value of the argument -- this can have a default value, or be left out "
"altogether."
msgstr "인수 값 - 기본값을 사용하거나 완전히 제외할 수 있습니다."

msgid ""
"For example, in the filter ``{{ var|foo:\"bar\" }}``, the filter ``foo`` "
"would be passed the variable ``var`` and the argument ``\"bar\"``."
msgstr ""
"예를 들어 필터 ``{var|foo:\"bar}\"에서 필터 ``foo\"는 변수 \"var\"와 변수 "
"\"bar\"라는 주장 \"bar\"가 전달된다."

msgid ""
"Since the template language doesn't provide exception handling, any "
"exception raised from a template filter will be exposed as a server error. "
"Thus, filter functions should avoid raising exceptions if there is a "
"reasonable fallback value to return. In case of input that represents a "
"clear bug in a template, raising an exception may still be better than "
"silent failure which hides the bug."
msgstr ""
"템플리트 언어는 예외 처리를 제공하지 않으므로, 템플리트 필터에서 발생하는 예"
"외는 서버 오류로 노출됩니다. 따라서 필터 기능은 반환할 적절한 예비 값이 있는 "
"경우 예외를 발생시키지 않아야 한다. 템플릿에서 명확한 버그를 나타내는 입력의 "
"경우 예외를 발생시키는 것이 버그를 숨기는 자동 장애보다 나을 수 있습니다."

msgid "Here's an example filter definition::"
msgstr "다음은 필터 정의 예제입니다."

msgid "And here's an example of how that filter would be used:"
msgstr "다음은 해당 필터를 사용하는 방법의 예입니다."

msgid ""
"Most filters don't take arguments. In this case, leave the argument out of "
"your function::"
msgstr ""
"대부분의 필터는 인수를 사용하지 않습니다. 이 경우 인수는 함수에서 제외합니다."

msgid "Registering custom filters"
msgstr "사용자 정의 필터 등록"

msgid ""
"Once you've written your filter definition, you need to register it with "
"your ``Library`` instance, to make it available to Django's template "
"language::"
msgstr ""
"일단 필터 정의를 작성했으면 \"라이브러리\" 인스턴스에 등록해야 django의 템플"
"릿 언어로 사용할 수 있습니다."

msgid "The ``Library.filter()`` method takes two arguments:"
msgstr " ``Library.filter()`` 메소드는 두 개의 인수를 사용합니다."

msgid "The name of the filter -- a string."
msgstr "필터의 이름 - 문자열."

msgid ""
"The compilation function -- a Python function (not the name of the function "
"as a string)."
msgstr "컴파일 함수 --파이썬 함수( 문자열로 함수 이름이 아님)입니다."

msgid "You can use ``register.filter()`` as a decorator instead::"
msgstr "``register.filter()``를 장식자 대신으로 사용할 수 있습니다."

msgid ""
"If you leave off the ``name`` argument, as in the second example above, "
"Django will use the function's name as the filter name."
msgstr ""
"위의 두 번째 예에서와 같이 \"name\" 인수를 생략하면 Django는 함수 이름을 필"
"터 이름으로 사용합니다."

msgid ""
"Finally, ``register.filter()`` also accepts three keyword arguments, "
"``is_safe``, ``needs_autoescape``, and ``expects_localtime``. These "
"arguments are described in :ref:`filters and auto-escaping <filters-auto-"
"escaping>` and :ref:`filters and time zones <filters-timezones>` below."
msgstr ""
"마지막으로 ``등록하십시오.필터'도 ``is_safe\", ``autoescape\", \"local time"
"\"의 세 가지 키워드 주장을 수용한다. 이러한 인수는 아래 ref:'필터 및 자동 이"
"스케이프' 및:ref:'필터 및 시간대'에 설명되어 있습니다."

msgid "Template filters that expect strings"
msgstr "문자열이 필요한 템플릿 필터"

msgid ""
"If you're writing a template filter that only expects a string as the first "
"argument, you should use the decorator ``stringfilter``. This will convert "
"an object to its string value before being passed to your function::"
msgstr ""
"첫 번째 인수로 문자열만 예상하는 템플릿 필터를 작성하려면 장식기 ``스트링 필"
"터\"를 사용해야 한다. 이렇게 하면 기능이 전달되기 전에 개체가 문자열 값으로 "
"변환됩니다."

msgid ""
"This way, you'll be able to pass, say, an integer to this filter, and it "
"won't cause an ``AttributeError`` (because integers don't have ``lower()`` "
"methods)."
msgstr ""
"이렇게 하면 정수 같은 것을 필터에 전달할 수 있고 정수에는 \"속성 오류\"가 발"
"생하지 않습니다(정수에는 \"낮은()\" 방법이 없기 때문입니다."

msgid "Filters and auto-escaping"
msgstr "필터 및 자동 이스케이프"

msgid ""
"When writing a custom filter, give some thought to how the filter will "
"interact with Django's auto-escaping behavior. Note that two types of "
"strings can be passed around inside the template code:"
msgstr ""
"사용자 정의 필터를 작성할 때 필터가 Django의 자동 이스케이핑 동작과 어떻게 상"
"호 작용하는지 생각해 보십시오. 템플릿 코드 내에서 두 가지 유형의 문자열을 전"
"달할 수 있습니다."

msgid ""
"**Raw strings** are the native Python strings. On output, they're escaped if "
"auto-escaping is in effect and presented unchanged, otherwise."
msgstr ""
"**원시 문자열*은(는) 기본 Python 문자열입니다. 출력 시 자동 이스케이프가 적용"
"되고 변경되지 않은 상태로 표시되는 경우, 그렇지 않은 경우 이 기능은 이스케이"
"프됩니다."

msgid ""
"**Safe strings** are strings that have been marked safe from further "
"escaping at output time. Any necessary escaping has already been done. "
"They're commonly used for output that contains raw HTML that is intended to "
"be interpreted as-is on the client side."
msgstr ""
"**safe strings**는 출력 시 추가 이스케이프로부터 안전한 것으로 표시된 문자열"
"입니다. 필요한 모든 탈출은 이미 이루어졌다. 일반적으로 클라이언트 측에서 있"
"는 그대로 해석할 원시 HTML을 포함하는 출력에 사용됩니다."

msgid ""
"Internally, these strings are of type :class:`~django.utils.safestring."
"SafeString`. You can test for them using code like::"
msgstr ""
"내부적으로 이러한 문자열은 다음과 같은 유형입니다.'~django.utils.tils.dring."
"SafeString'. 다음과 같은 코드를 사용하여 테스트할 수 있습니다."

msgid "Template filter code falls into one of two situations:"
msgstr "템플릿 필터 코드 두 가지 상황 중 하나에 속합니다:"

msgid ""
"Your filter does not introduce any HTML-unsafe characters (``<``, ``>``, "
"``'``, ``\"`` or ``&``) into the result that were not already present. In "
"this case, you can let Django take care of all the auto-escaping handling "
"for you. All you need to do is set the ``is_safe`` flag to ``True`` when you "
"register your filter function, like so::"
msgstr ""
"당신의 필터는 HTML이 안전하지 않은 문자(``<``, ``>``, ``'``, ``\"`` or ``&``)"
"를 아직 존재하지 않는 결과에 도입하지 않는다. 이 경우, Django가 당신을 위해 "
"모든 자동 대피 처리를 하도록 할 수 있습니다. 다음과 같이 필터 기능을 등록할 "
"때 \"is_safe\" 플래그를 \"true\"로 설정하면 된다."

msgid ""
"This flag tells Django that if a \"safe\" string is passed into your filter, "
"the result will still be \"safe\" and if a non-safe string is passed in, "
"Django will automatically escape it, if necessary."
msgstr ""
"이 플래그는 Django에게 \"안전한\" 문자열을 필터에 전달해도 결과는 \"안전\"하"
"며, 비안전 문자열이 전달되면 Django는 필요할 경우 자동으로 이 문자열을 이스케"
"이프할 것이라고 합니다."

msgid ""
"You can think of this as meaning \"this filter is safe -- it doesn't "
"introduce any possibility of unsafe HTML.\""
msgstr ""
"여러분은 이것을 \"이 필터가 안전하다 - 이것은 안전하지 않은 HTML의 가능성을 "
"전혀 유발하지 않는다\"라는 의미로 생각할 수 있습니다."

msgid ""
"The reason ``is_safe`` is necessary is because there are plenty of normal "
"string operations that will turn a ``SafeData`` object back into a normal "
"``str`` object and, rather than try to catch them all, which would be very "
"difficult, Django repairs the damage after the filter has completed."
msgstr ""
"``is_safe\"가 필요한 이유는 ``SafeData\" 물체를 정상적인 \"str\" 물체로 되돌"
"리고 그것들을 모두 잡으려고 하기보다는 필터 완료 후 손상을 Django가 수리하는 "
"정상적인 문자열 작업이 많기 때문이다."

msgid ""
"For example, suppose you have a filter that adds the string ``xx`` to the "
"end of any input. Since this introduces no dangerous HTML characters to the "
"result (aside from any that were already present), you should mark your "
"filter with ``is_safe``::"
msgstr ""
"예를 들어, 입력 끝에 문자열 \"xx\"를 추가하는 필터가 있다고 가정합시다. 이것"
"은 (이미 존재했던 어떤 것과도 별도로) 결과에 위험한 HTML 문자를 도입하지 않"
"기 때문에, 필터를 \"is_safe\"로 표시해야 한다."

msgid ""
"When this filter is used in a template where auto-escaping is enabled, "
"Django will escape the output whenever the input is not already marked as "
"\"safe\"."
msgstr ""
"자동 이스케이프가 활성화된 템플릿에서 이 필터를 사용할 경우 Django는 입력이 "
"\"안전\"으로 표시되지 않을 때마다 출력을 이스케이프합니다."

msgid ""
"By default, ``is_safe`` is ``False``, and you can omit it from any filters "
"where it isn't required."
msgstr ""
"기본적으로 \"is_safe\"는 \"False\"이며 필요하지 않은 모든 필터에서 제외할 수 "
"있습니다."

msgid ""
"Be careful when deciding if your filter really does leave safe strings as "
"safe. If you're *removing* characters, you might inadvertently leave "
"unbalanced HTML tags or entities in the result. For example, removing a "
"``>`` from the input might turn ``<a>`` into ``<a``, which would need to be "
"escaped on output to avoid causing problems. Similarly, removing a semicolon "
"(``;``) can turn ``&amp;`` into ``&amp``, which is no longer a valid entity "
"and thus needs further escaping. Most cases won't be nearly this tricky, but "
"keep an eye out for any problems like that when reviewing your code."
msgstr ""
"필터가 실제로 안전한 문자열을 남기는지 결정할 때 주의하십시오. 문자를 *제거*"
"하는 경우 결과에 불균형한 HTML 태그 또는 엔티티를 남길 수 있습니다. 예를 들"
"어 입력에서 \"\"를 제거하면 \"\"가 \"\"로 바뀔 수 있는데, 문제가 발생하지 않"
"도록 출력에서 \"a\"를 빼야 할 것이다. 마찬가지로 세미콜론(';')을 제거하면 "
"``&amp;\"이 ``&amp;\"로 바뀔 수 있는데, 이것은 더 이상 유효한 실체가 아니기 "
"때문에 더 이상의 탈출이 필요하다. 대부분의 경우 이렇게 까다롭지는 않겠지만 코"
"드를 검토할 때 이와 같은 문제를 주의 깊게 살펴보십시오."

msgid ""
"Marking a filter ``is_safe`` will coerce the filter's return value to a "
"string.  If your filter should return a boolean or other non-string value, "
"marking it ``is_safe`` will probably have unintended consequences (such as "
"converting a boolean False to the string 'False')."
msgstr ""
"필터를 \"is_safe\"로 표시하면 필터의 값을 문자열로 반환해야 합니다. 필터가 부"
"울 값이나 기타 문자열이 아닌 값을 반환해야 하는 경우 \"is_safe\"로 표시하면 "
"의도하지 않은 결과가 발생할 수 있습니다(예: 부울 False를 문자열 'False'로 변"
"환)."

msgid ""
"Alternatively, your filter code can manually take care of any necessary "
"escaping. This is necessary when you're introducing new HTML markup into the "
"result. You want to mark the output as safe from further escaping so that "
"your HTML markup isn't escaped further, so you'll need to handle the input "
"yourself."
msgstr ""
"또는 필터 코드가 필요한 이스케이프를 수동으로 처리할 수 있습니다. 이것은 결과"
"에 새 HTML 마크업을 도입할 때 필요합니다. HTML 마크업이 더 이상 유출되지 않도"
"록 출력을 안전한 것으로 표시하여 입력을 직접 처리해야 합니다."

msgid ""
"To mark the output as a safe string, use :func:`django.utils.safestring."
"mark_safe`."
msgstr ""
"출력을 안전한 문자열로 표시하려면 func:'django.utils.safeestring."
"mark_safe'를 사용합니다."

msgid ""
"Be careful, though. You need to do more than just mark the output as safe. "
"You need to ensure it really *is* safe, and what you do depends on whether "
"auto-escaping is in effect. The idea is to write filters that can operate in "
"templates where auto-escaping is either on or off in order to make things "
"easier for your template authors."
msgstr ""
"하지만 조심하세요. 출력을 안전한 것으로 표시하는 것 이상을 수행해야 합니다. "
"실제로 *안전성을 보장해야 하며, 자동 이스케이핑이 적용되는지 여부에 따라 작업"
"이 달라집니다. 자동 이스케이핑이 설정되거나 해제된 템플릿에서 작동할 수 있는 "
"필터를 작성하여 템플릿 작성자에게 보다 쉽게 제공할 수 있습니다."

msgid ""
"In order for your filter to know the current auto-escaping state, set the "
"``needs_autoescape`` flag to ``True`` when you register your filter "
"function. (If you don't specify this flag, it defaults to ``False``). This "
"flag tells Django that your filter function wants to be passed an extra "
"keyword argument, called ``autoescape``, that is ``True`` if auto-escaping "
"is in effect and ``False`` otherwise. It is recommended to set the default "
"of the ``autoescape`` parameter to ``True``, so that if you call the "
"function from Python code it will have escaping enabled by default."
msgstr ""
"필터가 현재의 자동 탈출 상태를 알기 위해서는 필터 기능을 등록할 때 "
"\"needs_autoscape\" 플래그를 \"true\"로 설정하십시오. (이 깃발을 지정하지 않"
"으면 기본값은 \"False\"입니다.) 이 깃발은 장고에게 당신의 필터 기능이 \"자동 "
"탈출\"이라는 추가적인 키워드 인수가 통과되기를 원한다는 것을 알려주고 있는"
"데, 그것은 자동 탈출이 유효하다면 \"참\"이고 그렇지 않으면 \"거짓\"이다. \"자"
"동탈출\" 파라미터의 디폴트를 \"트루\"로 설정하여 파이썬 코드에서 함수를 호출"
"할 경우 기본적으로 이스케이프가 활성화되도록 할 것을 권고한다."

msgid ""
"For example, let's write a filter that emphasizes the first character of a "
"string::"
msgstr "예를 들어 문자열의 첫 번째 문자를 강조하는 필터를 작성하겠습니다."

msgid ""
"The ``needs_autoescape`` flag and the ``autoescape`` keyword argument mean "
"that our function will know whether automatic escaping is in effect when the "
"filter is called. We use ``autoescape`` to decide whether the input data "
"needs to be passed through ``django.utils.html.conditional_escape`` or not. "
"(In the latter case, we use the identity function as the \"escape\" "
"function.) The ``conditional_escape()`` function is like ``escape()`` except "
"it only escapes input that is **not** a ``SafeData`` instance. If a "
"``SafeData`` instance is passed to ``conditional_escape()``, the data is "
"returned unchanged."
msgstr ""
"\"needs_autoscape\" 깃발과 \"autoscape\" 키워드 주장은 필터가 호출될 때 자동 "
"탈출이 유효한지 여부를 우리의 기능이 알게 된다는 것을 의미한다. 우리는 입력 "
"데이터가 ``django.utils.html.conditional_escape\"를 통과해야 하는지 여부를 결"
"정하기 위해 \"autoscape\"를 사용한다. (후자의 경우, 우리는 ID 기능을 \"scape"
"\" 기능으로 사용한다.) 조건부_탈출() 기능은 ***이 아닌 ``안전한 데이터\" 인스"
"턴스인 입력만 빠져나간다는 점을 제외하면 ``탈출()\"과 같다. \"안전한 데이터"
"\" 인스턴스가 ``조건적\"으로 넘어가면 데이터는 변경되지 않고 반환된다."

msgid ""
"Finally, in the above example, we remember to mark the result as safe so "
"that our HTML is inserted directly into the template without further "
"escaping."
msgstr ""
"마지막으로, 위의 예에서, 우리는 HTML이 더 이상 탈출하지 않고 템플릿에 직접 삽"
"입되도록 결과를 안전한 것으로 표시하는 것을 기억한다."

msgid ""
"There's no need to worry about the ``is_safe`` flag in this case (although "
"including it wouldn't hurt anything). Whenever you manually handle the auto-"
"escaping issues and return a safe string, the ``is_safe`` flag won't change "
"anything either way."
msgstr ""
"(이를 포함하더라도) 이 경우 \"안전하다\"는 깃발에 대해선 걱정할 필요가 없다. "
"당신이 수동으로 자동 탈출 문제를 처리하고 안전한 줄을 돌려줄 때마다 \"is_safe"
"\" 깃발은 어느 쪽도 변하지 않을 것이다."

msgid "Avoiding XSS vulnerabilities when reusing built-in filters"
msgstr "내장된 필터를 재사용할 때 XSS 취약성 방지"

msgid ""
"Django's built-in filters have ``autoescape=True`` by default in order to "
"get the proper autoescaping behavior and avoid a cross-site script "
"vulnerability."
msgstr ""
"django의 내장 필터에는 ``autoescape=True\"이 있다.올바른 자동 이스케이프 동작"
"을 취하고 사이트 간 스크립트의 취약성을 피하기 위해 기본적으로 True'를 선택합"
"니다."

msgid ""
"In older versions of Django, be careful when reusing Django's built-in "
"filters as ``autoescape`` defaults to ``None``. You'll need to pass "
"``autoescape=True`` to get autoescaping."
msgstr ""
"이전 버전의 장고에서는 장고의 내장 필터를 ``자동 탈출\" 디폴트로 재사용할 때 "
"주의해야 한다. ``자동 탈출\"을 통과해야 할 것이다.맞다'는 말은 자동 탈출을 하"
"는 것이다."

msgid ""
"For example, if you wanted to write a custom filter called "
"``urlize_and_linebreaks`` that combined the :tfilter:`urlize` and :tfilter:"
"`linebreaksbr` filters, the filter would look like::"
msgstr ""
"예를 들어 :t필터를 조합한 \"urlize_and_linebreaks\"라는 사용자 정의 필터를 작"
"성하려는 경우:urlize와 :tfilter:\"line breaksbr\" 필터의 모양은 다음과 같습니"
"다."

msgid "Then:"
msgstr "그러면"

msgid "would be equivalent to:"
msgstr "다음과 같습니다:"

msgid "Filters and time zones"
msgstr "필터 및 시간대"

msgid ""
"If you write a custom filter that operates on :class:`~datetime.datetime` "
"objects, you'll usually register it with the ``expects_localtime`` flag set "
"to ``True``::"
msgstr ""
"만일 Class: datetime.datetime 의 Object 에 적용되는 커스텀 필터를 사용할려면 "
"보통은 그것을 \"expects_localtime\" 이라는 플래그에 True 라고 세팅 해야합니"
"다."

msgid ""
"When this flag is set, if the first argument to your filter is a time zone "
"aware datetime, Django will convert it to the current time zone before "
"passing it to your filter when appropriate, according to :ref:`rules for "
"time zones conversions in templates <time-zones-in-templates>`."
msgstr ""
"플래그값이 세팅 되었을때 만일 필터의 첫번째 인자가 datetime 이 허용하는 time "
"zone 이라면 장고는 적절한 싯점에 time zone 에 대한 참조 규칙에 의거한 정형화"
"된 변경을 하도록 그 필터를 전달함으로서 현재의 time zone 으로 바꾸 도록 합니"
"다."

msgid "Writing custom template tags"
msgstr "커스텀 탬플릿 태그 만들기"

msgid ""
"Tags are more complex than filters, because tags can do anything. Django "
"provides a number of shortcuts that make writing most types of tags easier. "
"First we'll explore those shortcuts, then explain how to write a tag from "
"scratch for those cases when the shortcuts aren't powerful enough."
msgstr ""
"태그는 필터보다 더 복잡합니다, 그 이유는 태그가 그 어떤것도 할 수 있기 때문입"
"니다. 장고는 빠르고 쉬운 다양한 태그 작성법을 만들도록 합니다. 먼저 우리는 이"
"들 빠른 방법을 탐색 할 것 입니다.  그 다음에 그 빠른 방법이 충분하다고 생각되"
"지 않으면 태그 작성법을 스크래치(끄적거림)  부터 설명 할 겁니다."

msgid "Simple tags"
msgstr "간단한 태그"

msgid ""
"Many template tags take a number of arguments -- strings or template "
"variables -- and return a result after doing some processing based solely on "
"the input arguments and some external information. For example, a "
"``current_time`` tag might accept a format string and return the time as a "
"string formatted accordingly."
msgstr ""
"대부분의 템플릿 태그는 문자열 또는 템플릿 변수 등 여러 인수를 사용하고 입력 "
"인수와 일부 외부 정보만을 기반으로 일부 처리를 수행한 후 결과를 반환합니다. "
"예를 들어 \"current_time\" 태그는 형식 문자열을 허용하고 그에 따라 형식을 지"
"정한 문자열로 시간을 반환할 수 있다."

msgid ""
"To ease the creation of these types of tags, Django provides a helper "
"function, ``simple_tag``. This function, which is a method of ``django."
"template.Library``, takes a function that accepts any number of arguments, "
"wraps it in a ``render`` function and the other necessary bits mentioned "
"above and registers it with the template system."
msgstr ""
"이러한 유형의 태그를 쉽게 만들 수 있도록 Django는 \"simple_tag\"라는 도우미 "
"기능을 제공합니다. 이 기능은 ``django. template\"의 한 방법이다.라이브러"
"리'는 임의의 수의 인수를 수용하여 이를 \"렌더\" 기능과 위에서 언급한 다른 필"
"요한 비트로 감싸서 템플릿 시스템에 등록한다"

msgid "Our ``current_time`` function could thus be written like this::"
msgstr "따라서 우리의 ``current_time\" 기능은 다음과 같이 쓰여질 수 있다."

msgid "A few things to note about the ``simple_tag`` helper function:"
msgstr "\"단순_태그\" 도우미 기능에 대해 몇 가지 주목할 점은 다음과 같다."

msgid ""
"Checking for the required number of arguments, etc., has already been done "
"by the time our function is called, so we don't need to do that."
msgstr ""
"필요한 수의 인수 등을 확인하는 작업은 기능이 호출될 때까지 이미 수행되었으므"
"로 그렇게 할 필요가 없습니다."

msgid ""
"The quotes around the argument (if any) have already been stripped away, so "
"we receive a plain string."
msgstr "인수에 대한 따옴표가 이미 제거되었으므로 일반 문자열을 수신합니다."

msgid ""
"If the argument was a template variable, our function is passed the current "
"value of the variable, not the variable itself."
msgstr ""
"인수가 템플릿 변수였다면, 우리의 함수는 변수 자체가 아니라 변수의 현재 값을 "
"전달합니다."

msgid ""
"Unlike other tag utilities, ``simple_tag`` passes its output through :func:"
"`~django.utils.html.conditional_escape` if the template context is in "
"autoescape mode, to ensure correct HTML and protect you from XSS "
"vulnerabilities."
msgstr ""
"\"simple_tag\"는 다른 태그 유틸리티와 달리 템플릿 컨텍스트가 자동 이스케이프 "
"모드인 경우 출력을 func:'~django.utils.html.conditional_escape'를 통해 전달하"
"여 올바른 HTML을 보장하고 XSS 취약점으로부터 사용자를 보호합니다."

msgid ""
"If additional escaping is not desired, you will need to use :func:`~django."
"utils.safestring.mark_safe` if you are absolutely sure that your code does "
"not contain XSS vulnerabilities. For building small HTML snippets, use of :"
"func:`~django.utils.html.format_html` instead of ``mark_safe()`` is strongly "
"recommended."
msgstr ""
"추가 이스케이프가 필요하지 않은 경우 코드에서 XSS 취약성이 포함되지 않은 것"
"이 확실한 경우 func:'~django.utils.safeestring.mark_safe'를 사용해야 합니다. "
"작은 HTML 조각을 만들 때는 ``mark_safe()\" 대신 :func:'~django.utils.html."
"format_html'을 사용하는 것이 좋다."

msgid ""
"If your template tag needs to access the current context, you can use the "
"``takes_context`` argument when registering your tag::"
msgstr ""
"템플릿 태그가 현재 컨텍스트에 액세스해야 하는 경우 태그 등록 시 "
"\"takes_context\" 인수를 사용할 수 있습니다."

msgid "Note that the first argument *must* be called ``context``."
msgstr "첫 번째 논거를 *context*라고 해야 한다는 점에 유의하십시오."

msgid ""
"For more information on how the ``takes_context`` option works, see the "
"section on :ref:`inclusion tags<howto-custom-template-tags-inclusion-tags>`."
msgstr ""
"\"takes_context\" 옵션의 작동 방식에 대한 자세한 내용은 ref:\"포함 태그\" 섹"
"션을 참조하십시오."

msgid "If you need to rename your tag, you can provide a custom name for it::"
msgstr ""
"태그 이름을 변경해야 하는 경우 태그의 사용자 지정 이름을 제공할 수 있습니다."

msgid ""
"``simple_tag`` functions may accept any number of positional or keyword "
"arguments. For example::"
msgstr ""
"''단순_태그 함수들은 위치 또는 키워드 인수를 얼마든지 수용할 수 있다. 예:"

msgid ""
"Then in the template any number of arguments, separated by spaces, may be "
"passed to the template tag. Like in Python, the values for keyword arguments "
"are set using the equal sign (\"``=``\") and must be provided after the "
"positional arguments. For example:"
msgstr ""
"그런 다음 템플릿에서 공백으로 구분된 개수의 인수를 템플릿 태그에 전달할 수 있"
"습니다. Python에서처럼 키워드 인수의 값은 동일한 부호(\"' =를 사용하여 설정되"
"며, 위치 인수 뒤에 제공되어야 한다. 예:"

msgid ""
"It's possible to store the tag results in a template variable rather than "
"directly outputting it. This is done by using the ``as`` argument followed "
"by the variable name. Doing so enables you to output the content yourself "
"where you see fit:"
msgstr ""
"태그 결과를 직접 출력하지 않고 템플릿 변수에 저장할 수 있습니다. 이것은 변수 "
"이름 뒤에 나오는 \"as\"라는 논거를 사용하여 이루어진다. 이렇게 하면 다음과 같"
"은 상황에 맞는 컨텐츠를 직접 출력할 수 있습니다."

msgid "Inclusion tags"
msgstr "포함 태그"

msgid ""
"Another common type of template tag is the type that displays some data by "
"rendering *another* template. For example, Django's admin interface uses "
"custom template tags to display the buttons along the bottom of the \"add/"
"change\" form pages. Those buttons always look the same, but the link "
"targets change depending on the object being edited -- so they're a perfect "
"case for using a small template that is filled with details from the current "
"object. (In the admin's case, this is the ``submit_row`` tag.)"
msgstr ""
"템플릿 태그의 또 다른 일반적인 유형은 *다른* 템플릿을 렌더링하여 일부 데이터"
"를 표시하는 유형입니다. 예를 들어, Django의 관리 인터페이스는 사용자 정의 템"
"플릿 태그를 사용하여 \"추가/변경\" 양식 페이지의 아래쪽에 단추를 표시합니다. "
"이러한 버튼은 항상 동일하게 표시되지만 링크 대상은 편집 중인 개체에 따라 달라"
"지므로 현재 개체의 세부 정보가 채워진 작은 템플릿을 사용할 수 있습니다. (관리"
"자의 경우, 이것은 ``제출_행\" 태그이다.)"

msgid "These sorts of tags are called \"inclusion tags\"."
msgstr "이러한 종류의 태그를 \"포함 태그\"라고 합니다."

msgid ""
"Writing inclusion tags is probably best demonstrated by example. Let's write "
"a tag that outputs a list of choices for a given ``Poll`` object, such as "
"was created in the :ref:`tutorials <creating-models>`. We'll use the tag "
"like this:"
msgstr ""
"포함 태그를 작성하는 것이 가장 좋은 예일 수 있습니다. 자습서에서 만든 것과 같"
"이 주어진 \"Poll\" 객체에 대한 선택 목록을 출력하는 태그를 작성합시다. 태그"
"는 다음과 같습니다."

msgid "...and the output will be something like this:"
msgstr "...그리고 결과는 다음과 같습니다."

msgid ""
"First, define the function that takes the argument and produces a dictionary "
"of data for the result. The important point here is we only need to return a "
"dictionary, not anything more complex. This will be used as a template "
"context for the template fragment. Example::"
msgstr ""
"먼저 인수를 사용하고 결과에 대한 데이터 사전을 만드는 함수를 정의합니다. 여기"
"서 중요한 점은 더 복잡한 것이 아니라 사전만 돌려주면 된다는 것입니다. 템플릿 "
"조각의 템플릿 컨텍스트로 사용됩니다. 예:"

msgid ""
"Next, create the template used to render the tag's output. This template is "
"a fixed feature of the tag: the tag writer specifies it, not the template "
"designer. Following our example, the template is very short:"
msgstr ""
"그런 다음 태그의 출력을 렌더링하는 데 사용되는 템플릿을 만듭니다. 이 템플릿"
"은 태그의 고정 기능입니다. 태그 작성기는 템플릿 디자이너가 아니라 태그를 지정"
"합니다. 이 예에서는 템플릿이 매우 짧습니다."

msgid ""
"Now, create and register the inclusion tag by calling the "
"``inclusion_tag()`` method on a ``Library`` object. Following our example, "
"if the above template is in a file called ``results.html`` in a directory "
"that's searched by the template loader, we'd register the tag like this::"
msgstr ""
"이제 \"도서관 목적\"에 \"포함_태그()\" 방식을 \"도서관 목적\"이라고 부르며 포"
"함 태그를 만들고 등록해야 한다. 위의 템플릿이 템플릿 로더가 검색하는 디렉토리"
"의 \"results.html\" 파일에 있는 경우 다음과 같이 태그를 등록합니다."

msgid ""
"Alternatively it is possible to register the inclusion tag using a :class:"
"`django.template.Template` instance::"
msgstr ""
"또는 :class:'django.template를 사용하여 포함 태그를 등록할 수 있습니다.템플"
"릿 인스턴스:"

msgid "...when first creating the function."
msgstr "...처음 함수를 생성할 때 사용합니다."

msgid ""
"Sometimes, your inclusion tags might require a large number of arguments, "
"making it a pain for template authors to pass in all the arguments and "
"remember their order. To solve this, Django provides a ``takes_context`` "
"option for inclusion tags. If you specify ``takes_context`` in creating a "
"template tag, the tag will have no required arguments, and the underlying "
"Python function will have one argument -- the template context as of when "
"the tag was called."
msgstr ""
"때때로 포함 태그에 많은 인수가 필요할 수 있으므로 템플릿 작성자가 모든 인수"
"를 전달하고 순서를 기억하기가 어렵습니다. 이를 해결하기 위해 Django는 태그 포"
"함을 위한 \"takes_context\" 옵션을 제공한다. 템플릿 태그를 만들 때 "
"\"takes_context\"를 지정하면 태그에 필요한 인수가 없으며 기본 Python 함수에 "
"태그가 호출되었을 때 템플릿 컨텍스트라는 하나의 인수가 있게 됩니다."

msgid ""
"For example, say you're writing an inclusion tag that will always be used in "
"a context that contains ``home_link`` and ``home_title`` variables that "
"point back to the main page. Here's what the Python function would look "
"like::"
msgstr ""
"예를 들어 메인 페이지로 돌아가는 ``home_link\"와 \"home_title\" 변수를 포함하"
"는 컨텍스트에서 항상 사용되는 포함 태그를 작성한다고 하자. Python 기능은 다음"
"과 같습니다."

msgid ""
"Note that the first parameter to the function *must* be called ``context``."
msgstr "이 함수에 대한 첫 번째 매개 변수는 *\"context\"라고 해야 합니다."

msgid ""
"In that ``register.inclusion_tag()`` line, we specified "
"``takes_context=True`` and the name of the template. Here's what the "
"template ``link.html`` might look like:"
msgstr ""
"그 ``register.laught_tagles\" 라인으로 우리는 \"laf_laught =\"이라고 명기했"
"다.True'와 템플릿의 이름입니다. \"link.html\"이라는 템플릿은 다음과 같다."

msgid ""
"Then, any time you want to use that custom tag, load its library and call it "
"without any arguments, like so:"
msgstr ""
"그런 다음 언제든지 해당 사용자 지정 태그를 사용하려면 라이브러리를 로드하고 "
"다음과 같은 인수 없이 호출하십시오."

msgid ""
"Note that when you're using ``takes_context=True``, there's no need to pass "
"arguments to the template tag. It automatically gets access to the context."
msgstr ""
"참고: \"disclos_disclosen =\"을 사용할 때true'는 템플릿 태그에 인수를 전달할 "
"필요가 없습니다. 자동으로 컨텍스트에 액세스할 수 있습니다."

msgid ""
"The ``takes_context`` parameter defaults to ``False``. When it's set to "
"``True``, the tag is passed the context object, as in this example. That's "
"the only difference between this case and the previous ``inclusion_tag`` "
"example."
msgstr ""
"\"takes_context\"라는 매개변수는 기본적으로 \"False\"로 설정되어 있다. \"참"
"\"으로 설정하면 이 예에서와 같이 태그가 컨텍스트 객체를 통과합니다. 그것이 이"
"번 사건과 이전의 ``포함_태그\" 사례와의 유일한 차이점이다."

msgid ""
"``inclusion_tag`` functions may accept any number of positional or keyword "
"arguments. For example::"
msgstr ""
"\"filt_tagles 함수는 위치 또는 키워드 인수를 얼마든지 수용할 수 있다. 예:"

msgid "Advanced custom template tags"
msgstr "고급 사용자 지정 템플릿 태그"

msgid ""
"Sometimes the basic features for custom template tag creation aren't enough. "
"Don't worry, Django gives you complete access to the internals required to "
"build a template tag from the ground up."
msgstr ""
"사용자 지정 템플릿 태그를 만드는 기본 기능이 충분하지 않은 경우도 있습니다. "
"걱정하지 마십시오. Django는 처음부터 템플릿 태그를 만드는 데 필요한 내부 액세"
"스 권한을 제공합니다."

msgid "A quick overview"
msgstr "간략한 개요"

msgid ""
"The template system works in a two-step process: compiling and rendering. To "
"define a custom template tag, you specify how the compilation works and how "
"the rendering works."
msgstr ""
"템플릿 시스템은 컴파일 및 렌더링의 2단계 프로세스로 작동합니다. 사용자 정의 "
"템플릿 태그를 정의하려면 컴파일의 작동 방식과 렌더링 방식을 지정합니다."

msgid ""
"When Django compiles a template, it splits the raw template text into "
"''nodes''. Each node is an instance of ``django.template.Node`` and has a "
"``render()`` method. A compiled template is a list of ``Node`` objects. When "
"you call ``render()`` on a compiled template object, the template calls "
"``render()`` on each ``Node`` in its node list, with the given context.  The "
"results are all concatenated together to form the output of the template."
msgstr ""
"Django는 템플릿을 컴파일할 때 원시 템플릿 텍스트를 \"노드\"로 분할합니다. 각 "
"노드는 ``django.template\"의 인스턴스이다.노드'는 \"렌더()\" 방식을 가지고 있"
"다. 컴파일된 템플릿은 \"노드\" 개체의 목록입니다. 컴파일된 템플릿 객체의 \"렌"
"더()\"를 호출할 때 템플릿은 주어진 컨텍스트를 사용하여 노드 목록에 있는 각 "
"\"노드\"에 \"렌더()\"를 호출한다. 결과는 모두 함께 연결되어 템플릿 출력을 형"
"성합니다."

msgid ""
"Thus, to define a custom template tag, you specify how the raw template tag "
"is converted into a ``Node`` (the compilation function), and what the node's "
"``render()`` method does."
msgstr ""
"따라서 사용자 정의 템플릿 태그를 정의하려면 원시 템플릿 태그를 \"노드\"(컴파"
"일 기능)로 변환하는 방법과 노드의 \"렌더()\" 메서드가 수행하는 방법을 지정합"
"니다."

msgid "Writing the compilation function"
msgstr "컴파일 기능 쓰기"

msgid ""
"For each template tag the template parser encounters, it calls a Python "
"function with the tag contents and the parser object itself. This function "
"is responsible for returning a ``Node`` instance based on the contents of "
"the tag."
msgstr ""
"각 템플릿 태그에 대해 템플릿 파서가 발견하면 태그 내용 및 파서 개체 자체를 사"
"용하여 Python 함수를 호출합니다. 이 기능은 태그의 내용에 따라 \"노드\" 인스턴"
"스를 반환하는 역할을 한다."

msgid ""
"For example, let's write a full implementation of our template tag, ``{% "
"current_time %}``, that displays the current date/time, formatted according "
"to a parameter given in the tag, in :func:`~time.strftime` syntax. It's a "
"good idea to decide the tag syntax before anything else. In our case, let's "
"say the tag should be used like this:"
msgstr ""
"예를 들어, 태그에 지정된 매개 변수에 따라 포맷된 현재 날짜/시간을 표시하는 템"
"플릿 태그 \"{% current_time %}\"의 전체 구현을 :func:'~time.strftime' 구문으"
"로 작성해보자. 태그 구문은 다른 것보다 먼저 결정하는 것이 좋습니다. 이 경우 "
"태그는 다음과 같이 사용해야 합니다."

msgid ""
"The parser for this function should grab the parameter and create a ``Node`` "
"object::"
msgstr ""
"이 기능의 파서는 매개 변수를 잡고 다음과 같은 ``노드\" 개체를 만들어야 한다."

msgid "Notes:"
msgstr "각주:"

msgid ""
"``parser`` is the template parser object. We don't need it in this example."
msgstr "\"파서라는 것은 템플릿 파서 개체이다. 이 예에서는 필요하지 않습니다."

msgid ""
"``token.contents`` is a string of the raw contents of the tag. In our "
"example, it's ``'current_time \"%Y-%m-%d %I:%M %p\"'``."
msgstr ""
"\"알아두다.알아두다\"는 태그의 생색내기 내용물의 줄이다. 우리의 예에서 그것"
"은 \"'current_time %Y-%m- %I:%M\"이다."

msgid ""
"The ``token.split_contents()`` method separates the arguments on spaces "
"while keeping quoted strings together. The more straightforward ``token."
"contents.split()`` wouldn't be as robust, as it would naively split on *all* "
"spaces, including those within quoted strings. It's a good idea to always "
"use ``token.split_contents()``."
msgstr ""
"\"token.split_contents()\" 방식은 인용된 문자열을 함께 유지하면서 공간에 대"
"한 인수를 구분한다. 좀더 간단한 ``token.contents.split()\"는 인용된 문자열 내"
"의 공간을 포함하여 *모든* 공간에서 순진하게 분리되기 때문에 그렇게 강력하지"
"는 않을 것이다. 항상 ``token.split_contents()\"를 사용하는 것이 좋다."

msgid ""
"This function is responsible for raising ``django.template."
"TemplateSyntaxError``, with helpful messages, for any syntax error."
msgstr ""
"이 기능은 ``장고 템플릿\"을 올리는 데 책임이 있다.모든 구문 오류에 대해 유용"
"한 메시지가 포함된 TemplateSyntaxError'입니다."

msgid ""
"The ``TemplateSyntaxError`` exceptions use the ``tag_name`` variable. Don't "
"hard-code the tag's name in your error messages, because that couples the "
"tag's name to your function. ``token.contents.split()[0]`` will ''always'' "
"be the name of your tag -- even when the tag has no arguments."
msgstr ""
"\"템플릿 구문 오류\" 예외는 \"tag_name\" 변수를 사용한다. 오류 메시지에서 태"
"그 이름을 하드 코딩하지 마십시오. 태그 이름이 기능과 결합됩니다. \"항상\"은 "
"당신의 태그 이름이 될 것이다. 심지어 그 태그가 아무런 언쟁도 없을 때에도 말이"
"다."

msgid ""
"The function returns a ``CurrentTimeNode`` with everything the node needs to "
"know about this tag. In this case, it passes the argument -- ``\"%Y-%m-%d %I:"
"%M %p\"``. The leading and trailing quotes from the template tag are removed "
"in ``format_string[1:-1]``."
msgstr ""
"이 기능은 노드가 이 태그에 대해 알아야 할 모든 것을 포함한 \"Current TimeNode"
"\"를 반환합니다. 이 경우 이는 \"%Y-%m-%I:%M\"이라는 논리를 통과한다. 템플릿 "
"태그의 선행 및 후행 따옴표는 ``format_string[1:-1]\"에서 제거됩니다."

msgid ""
"The parsing is very low-level. The Django developers have experimented with "
"writing small frameworks on top of this parsing system, using techniques "
"such as EBNF grammars, but those experiments made the template engine too "
"slow. It's low-level because that's fastest."
msgstr ""
"구문 분석은 매우 낮은 수준입니다. Django 개발자들은 EBNF 문법과 같은 기술을 "
"사용하여 이 구문 분석 시스템 위에 작은 프레임워크를 쓰는 것을 실험했지만, 그"
"러한 실험들은 템플릿 엔진을 너무 느리게 만들었다. 가장 빠르기 때문에 낮은 수"
"준입니다."

msgid "Writing the renderer"
msgstr "렌더러 작성"

msgid ""
"The second step in writing custom tags is to define a ``Node`` subclass that "
"has a ``render()`` method."
msgstr ""
"The second step in writing custom tags is to define a ``Node`` subclass that "
"has a ``render()`` method."

msgid "Continuing the above example, we need to define ``CurrentTimeNode``::"
msgstr "위의 예를 계속하면서 우리는 ``Current TimeNode\"를 정의해야 한다."

msgid ""
"``__init__()`` gets the ``format_string`` from ``do_current_time()``. Always "
"pass any options/parameters/arguments to a ``Node`` via its ``__init__()``."
msgstr ""
"\"_init__()\"는 \"do_current_time\"로부터 \"format_string\"을 얻는다. 옵션/매"
"개변수/논란을 항상 \"_init__()\"를 통해 \"노드\"에 전달한다."

msgid "The ``render()`` method is where the work actually happens."
msgstr "\"렌더() 방식\"은 그 일이 실제로 일어나는 곳이다."

msgid ""
"``render()`` should generally fail silently, particularly in a production "
"environment. In some cases however, particularly if ``context.template."
"engine.debug`` is ``True``, this method may raise an exception to make "
"debugging easier. For example, several core tags raise ``django.template."
"TemplateSyntaxError`` if they receive the wrong number or type of arguments."
msgstr ""
"``고장\"은 일반적으로, 특히 생산 환경에서 묵묵히 실패해야 한다. 그러나 경우"
"에 따라서는 특히 ``context.template.engine.debug\"가 \"true\"인 경우 이 방법"
"은 디버깅을 쉽게 하기 위해 예외를 발생시킬 수 있다. 예를 들어 몇 개의 핵심 태"
"그가 ``django.template\"을 올린다.잘못된 인수 번호나 유형의 인수를 수신하는 "
"경우 'TemplateSyntaxError'를 선택합니다."

msgid ""
"Ultimately, this decoupling of compilation and rendering results in an "
"efficient template system, because a template can render multiple contexts "
"without having to be parsed multiple times."
msgstr ""
"결국, 컴파일과 렌더링의 이러한 디커플링은 효율적인 템플릿 시스템이 됩니다. 왜"
"냐하면 템플릿은 여러 번 구문 분석할 필요 없이 여러 컨텍스트를 렌더링할 수 있"
"기 때문입니다."

msgid "Auto-escaping considerations"
msgstr "자동 회피 고려 사항"

msgid ""
"The output from template tags is **not** automatically run through the auto-"
"escaping filters (with the exception of :meth:`~django.template.Library."
"simple_tag` as described above). However, there are still a couple of things "
"you should keep in mind when writing a template tag."
msgstr ""
"템플릿 태그의 출력은 ****가 아니며 자동 이스케이프 필터를 통해 자동으로 실행"
"됩니다( :meth:'~django.template 제외).위에서 설명한 Library.simple_tag'입니"
"다. 그러나 템플릿 태그를 작성할 때 기억해야 할 몇 가지 사항이 있습니다."

msgid ""
"If the ``render()`` method of your template tag stores the result in a "
"context variable (rather than returning the result in a string), it should "
"take care to call ``mark_safe()`` if appropriate. When the variable is "
"ultimately rendered, it will be affected by the auto-escape setting in "
"effect at the time, so content that should be safe from further escaping "
"needs to be marked as such."
msgstr ""
"템플릿 태그의 ''렌더()'' 방식이 결과를 문자열로 반환하는 것이 아니라 컨텍스"
"트 변수에 저장한다면 적절하다면 ``mark_safe()\"라고 부르는 것이 좋다. 변수가 "
"궁극적으로 렌더링될 때, 그것은 그 당시에 유효한 자동 탈출 설정의 영향을 받게 "
"되므로, 추가 탈출로부터 안전해야 하는 콘텐츠는 다음과 같이 표시해야 한다."

msgid ""
"Also, if your template tag creates a new context for performing some sub-"
"rendering, set the auto-escape attribute to the current context's value. The "
"``__init__`` method for the ``Context`` class takes a parameter called "
"``autoescape`` that you can use for this purpose. For example::"
msgstr ""
"또한 템플릿 태그가 일부 하위 렌더링을 수행하기 위한 새 컨텍스트를 만드는 경"
"우 자동 이스케이프 속성을 현재 컨텍스트 값으로 설정하십시오. ``_init__\"의 문"
"맥 계급 방법은 당신이 이 목적을 위해 사용할 수 있는 ``자동 탈출\"이라는 매개 "
"변수를 취한다. 예:"

msgid ""
"This is not a very common situation, but it's useful if you're rendering a "
"template yourself. For example::"
msgstr ""
"이는 매우 흔한 상황은 아니지만 만약 당신이 템플릿을 스스로 렌더링한다면 유용"
"하다. 예를 들어::"

msgid ""
"If we had neglected to pass in the current ``context.autoescape`` value to "
"our new ``Context`` in this example, the results would have *always* been "
"automatically escaped, which may not be the desired behavior if the template "
"tag is used inside a :ttag:`{% autoescape off %}<autoescape>` block."
msgstr ""
"만약 우리가 현재의 ``상황\"에서 통과를 소홀히 했다면 좋았을 것이다.이 예에서 "
"우리의 새로운 \"컨텍스트\"에 대한 자동 이스케이프' 값은 *항상* 자동으로 이스"
"케이프되었을 것이며, 템플릿 태그를 :ttag:'{% autoscape off %}' 블록 내에서 사"
"용할 경우 바람직하지 않은 동작일 수 있다."

msgid "Thread-safety considerations"
msgstr "나사산 안전 고려 사항"

msgid ""
"Once a node is parsed, its ``render`` method may be called any number of "
"times. Since Django is sometimes run in multi-threaded environments, a "
"single node may be simultaneously rendering with different contexts in "
"response to two separate requests. Therefore, it's important to make sure "
"your template tags are thread safe."
msgstr ""
"노드가 한번 구문 분석되면 \"렌더\" 방법은 얼마든지 호출할 수 있다. Django는 "
"때때로 다중 스레드 환경에서 실행되므로, 단일 노드는 두 개의 개별 요청에 대응"
"하여 서로 다른 컨텍스트로 동시에 렌더링될 수 있습니다. 따라서 템플릿 태그가 "
"스레드에 안전한지 확인하는 것이 중요합니다."

msgid ""
"To make sure your template tags are thread safe, you should never store "
"state information on the node itself. For example, Django provides a "
"builtin :ttag:`cycle` template tag that cycles among a list of given strings "
"each time it's rendered:"
msgstr ""
"템플릿 태그가 스레드 안전하도록 하려면 노드 자체에 상태 정보를 저장해서는 안 "
"됩니다. 예를 들어, Django는 다음을 렌더링할 때마다 주어진 문자열 목록을 순환"
"하는 내장 :ttag:'cycle' 템플릿 태그를 제공합니다."

msgid ""
"A naive implementation of ``CycleNode`` might look something like this::"
msgstr "\"CycleNode\"의 안일한 구현은 이와 같이 보일 것이다::"

msgid ""
"But, suppose we have two templates rendering the template snippet from above "
"at the same time:"
msgstr ""
"그러나 위에서 템플릿 조각을 렌더링하는 두 개의 템플릿이 동시에 있다고 가정합"
"니다."

msgid ""
"Thread 1 performs its first loop iteration, ``CycleNode.render()`` returns "
"'row1'"
msgstr ""
"스레드 1은 첫 번째 루프 반복 ''CycleNode.render()'' returns 'row1'을 수행합니"
"다."

msgid ""
"Thread 2 performs its first loop iteration, ``CycleNode.render()`` returns "
"'row2'"
msgstr ""
"스레드 2는 첫 번째 루프 반복 \"\"CycleNode.render()\"를 반환하는 'row2'를 수"
"행합니다."

msgid ""
"Thread 1 performs its second loop iteration, ``CycleNode.render()`` returns "
"'row1'"
msgstr ""
"스레드 1은 두 번째 루프 반복 \"\"CycleNode.render()\"\"는 '행1'을 반환합니다."

msgid ""
"Thread 2 performs its second loop iteration, ``CycleNode.render()`` returns "
"'row2'"
msgstr ""
"스레드 2는 두 번째 반복 \"CycleNode.render()\"'returns 'row2'를 수행합니다."

msgid ""
"The CycleNode is iterating, but it's iterating globally. As far as Thread 1 "
"and Thread 2 are concerned, it's always returning the same value. This is "
"not what we want!"
msgstr ""
"CycleNode는 반복되고 있지만 전 세계적으로 반복되고 있습니다. 스레드 1과 스레"
"드 2에 관한 한 항상 동일한 값을 반환합니다. 이건 우리가 원하는 게 아니야!"

msgid ""
"To address this problem, Django provides a ``render_context`` that's "
"associated with the ``context`` of the template that is currently being "
"rendered. The ``render_context`` behaves like a Python dictionary, and "
"should be used to store ``Node`` state between invocations of the ``render`` "
"method."
msgstr ""
"이 문제를 해결하기 위해 장고는 현재 렌더링되고 있는 템플릿의 \"컨텍스트\"와 "
"관련된 \"렌더_컨텍스트\"를 제공한다. \"render_context\"는 파이썬 사전처럼 동"
"작하며 \"node\" 상태를 \"render\" 방식의 호출 사이에 저장하는 데 사용해야 한"
"다."

msgid ""
"Let's refactor our ``CycleNode`` implementation to use the "
"``render_context``::"
msgstr ""
"우리의 ``CycleNode\" 구현을 \"render_context\"를 사용하기 위해 재구성해 보자."

msgid ""
"Note that it's perfectly safe to store global information that will not "
"change throughout the life of the ``Node`` as an attribute. In the case of "
"``CycleNode``, the ``cyclevars`` argument doesn't change after the ``Node`` "
"is instantiated, so we don't need to put it in the ``render_context``. But "
"state information that is specific to the template that is currently being "
"rendered, like the current iteration of the ``CycleNode``, should be stored "
"in the ``render_context``."
msgstr ""
"주의할 점은 \"노드\"의 수명 내내 변하지 않는 글로벌 정보를 속성으로 저장하는 "
"것이 매우 안전하다는 것이다. \"CycleNode\"의 경우 \"Node\"가 인스턴스화된 후"
"에도 \"Cyclevars\"의 주장은 변하지 않으므로 \"render_context\"에 넣을 필요가 "
"없다. 그러나 현재 ``CycleNode\"의 반복처럼 현재 렌더링되고 있는 템플릿에 특정"
"한 국가 정보는 \"render_context\"에 저장되어야 한다."

msgid ""
"Notice how we used ``self`` to scope the ``CycleNode`` specific information "
"within the ``render_context``. There may be multiple ``CycleNodes`` in a "
"given template, so we need to be careful not to clobber another node's state "
"information. The easiest way to do this is to always use ``self`` as the key "
"into ``render_context``. If you're keeping track of several state variables, "
"make ``render_context[self]`` a dictionary."
msgstr ""
"우리가 ``self\"를 어떻게 사용해서 ``render_context\" 내에서 ``CycleNode\"의 "
"구체적인 정보를 범위를 넓혔는지 주목하라. 주어진 템플릿에 \"CycleNode\"가 여"
"러 개 있을 수 있으므로 다른 노드의 상태 정보가 중복되지 않도록 주의해야 한"
"다. 가장 쉬운 방법은 항상 ``자기\"를 ``렌더_컨텍스트\"의 열쇠로 삼는 것이다. "
"여러 가지 국가 변수를 추적하고 있다면 ``render_context\"를 사전으로 만들어라."

msgid "Registering the tag"
msgstr "태그를 등록한다."

msgid ""
"Finally, register the tag with your module's ``Library`` instance, as "
"explained in :ref:`writing custom template tags<howto-writing-custom-"
"template-tags>` above. Example::"
msgstr ""
"마지막으로 위의 ref:\"사용자 정의 템플릿 태그 작성\"에서 설명한 대로 모듈의 "
"\"라이브러리\" 인스턴스에 태그를 등록합니다. 예:"

msgid "The ``tag()`` method takes two arguments:"
msgstr "\"태그()\" 방식은 두 가지 주장을 한다."

msgid ""
"The name of the template tag -- a string. If this is left out, the name of "
"the compilation function will be used."
msgstr ""
"템플릿 태그의 이름 - 문자열. 이 옵션을 제외하면 컴파일 기능의 이름이 사용됩니"
"다."

msgid ""
"As with filter registration, it is also possible to use this as a decorator::"
msgstr "필터 등록과 마찬가지로, 다음 구성 요소로 사용할 수도 있습니다."

msgid ""
"If you leave off the ``name`` argument, as in the second example above, "
"Django will use the function's name as the tag name."
msgstr ""
"위의 두 번째 예와 같이 \"name\" 인수를 생략하면 Django는 함수의 이름을 태그 "
"이름으로 사용합니다."

msgid "Passing template variables to the tag"
msgstr "태그에 템플릿 변수 전달"

msgid ""
"Although you can pass any number of arguments to a template tag using "
"``token.split_contents()``, the arguments are all unpacked as string "
"literals. A little more work is required in order to pass dynamic content (a "
"template variable) to a template tag as an argument."
msgstr ""
"``token.split_contents()\"를 사용하여 템플릿 태그에 원하는 수의 인수를 전달"
"할 수 있지만 인수는 모두 문자열 리터럴로 압축 해제됩니다. 동적 내용(템플릿 변"
"수)을 템플릿 태그에 인수로 전달하려면 조금 더 많은 작업이 필요합니다."

msgid ""
"While the previous examples have formatted the current time into a string "
"and returned the string, suppose you wanted to pass in a :class:`~django.db."
"models.DateTimeField` from an object and have the template tag format that "
"date-time:"
msgstr ""
"이전 예에서는 현재 시간을 문자열로 포맷하고 문자열을 반환했지만 :class에서 전"
"달하고자 한다고 가정합니다.'~django.db.db.know.개체에서 'DateTimeField'로, 날"
"짜-시간의 템플릿 태그 형식을 갖습니다."

msgid "Initially, ``token.split_contents()`` will return three values:"
msgstr "당초 ``token.split_contents()\"는 세 가지 값을 반환한다."

msgid "The tag name ``format_time``."
msgstr "태그 이름은 \"format_time\""

msgid ""
"The string ``'blog_entry.date_updated'`` (without the surrounding quotes)."
msgstr "''blog_entry.date_updated'' 문자열(주변 인용문 없음)"

msgid ""
"The formatting string ``'\"%Y-%m-%d %I:%M %p\"'``. The return value from "
"``split_contents()`` will include the leading and trailing quotes for string "
"literals like this."
msgstr ""
"형식 문자열 \"\"%Y-%m-%I:%M\"\"\" \"split_contents()\"에서 반환되는 값은 이"
"와 같은 문자열 리터럴의 선행 및 후행 인용을 포함한다."

msgid "Now your tag should begin to look like this::"
msgstr "이제 너의 태그는 이렇게 보이기 시작해야한다."

msgid ""
"You also have to change the renderer to retrieve the actual contents of the "
"``date_updated`` property of the ``blog_entry`` object.  This can be "
"accomplished by using the ``Variable()`` class in ``django.template``."
msgstr ""
"``blog_entry\" 개체의 ``날짜_업데이트\" 속성의 실제 내용을 검색하려면 렌더러"
"를 변경해야 한다. 이는 ``django. template\"에서 ``Variable()\" 클래스를 사용"
"하면 이룰 수 있다."

msgid ""
"To use the ``Variable`` class, instantiate it with the name of the variable "
"to be resolved, and then call ``variable.resolve(context)``. So, for "
"example::"
msgstr ""
"\"Variable\" 클래스를 사용하려면 해결할 변수의 이름으로 인스턴스화한 다음 "
"\"variable.resolve(컨텍스트)\"라고 부른다. 예를 들어 다음과 같습니다."

msgid ""
"Variable resolution will throw a ``VariableDoesNotExist`` exception if it "
"cannot resolve the string passed to it in the current context of the page."
msgstr ""
"가변 해상도는 페이지의 현재 컨텍스트에서 전달된 문자열을 해결할 수 없는 경우 "
"\"Variable DonsNot Exception."

msgid "Setting a variable in the context"
msgstr "컨텍스트에 변수를 설정"

msgid ""
"The above examples output a value. Generally, it's more flexible if your "
"template tags set template variables instead of outputting values. That way, "
"template authors can reuse the values that your template tags create."
msgstr ""
"위의 예제는 값을 출력합니다. 일반적으로 템플릿 태그가 값을 출력하는 대신 템플"
"릿 변수를 설정하는 것이 더 유연합니다. 이렇게 하면 템플릿 작성자는 템플릿 태"
"그가 생성한 값을 재사용할 수 있습니다."

msgid ""
"To set a variable in the context, use dictionary assignment on the context "
"object in the ``render()`` method. Here's an updated version of "
"``CurrentTimeNode`` that sets a template variable ``current_time`` instead "
"of outputting it::"
msgstr ""
"컨텍스트에서 변수를 설정하려면 컨텍스트 객체에 대한 사전 할당을 \"렌더()\" 방"
"법으로 사용하십시오. 여기 템플릿 변수를 출력하는 대신 \"current_time\"을 설정"
"하는 \"CurrentTimeNode\"의 업데이트된 버전이 있다."

msgid ""
"Note that ``render()`` returns the empty string. ``render()`` should always "
"return string output. If all the template tag does is set a variable, "
"``render()`` should return the empty string."
msgstr ""
"\"render()\"는 빈 문자열을 반환합니다. \"만들다\"는 항상 문자열 출력을 반환해"
"야 한다. 템플릿 태그가 변수를 설정하기만 하면 \"render()\"는 빈 문자열을 반환"
"해야 한다."

msgid "Here's how you'd use this new version of the tag:"
msgstr "새 버전의 태그를 사용하는 방법은 다음과 같습니다."

msgid "Variable scope in context"
msgstr "컨텍스트의 가변 범위"

msgid ""
"Any variable set in the context will only be available in the same ``block`` "
"of the template in which it was assigned. This behavior is intentional; it "
"provides a scope for variables so that they don't conflict with context in "
"other blocks."
msgstr ""
"컨텍스트에 설정된 변수는 할당된 템플릿의 동일한 \"블록\"에서만 사용할 수 있습"
"니다. 이 동작은 의도적인 것입니다. 다른 블록의 컨텍스트와 충돌하지 않도록 변"
"수에 대한 범위를 제공합니다."

msgid ""
"But, there's a problem with ``CurrentTimeNode2``: The variable name "
"``current_time`` is hard-coded. This means you'll need to make sure your "
"template doesn't use ``{{ current_time }}`` anywhere else, because the ``{% "
"current_time %}`` will blindly overwrite that variable's value. A cleaner "
"solution is to make the template tag specify the name of the output "
"variable, like so:"
msgstr ""
"그러나 ``Current TimeNode2\"에는 문제가 있다. 변수 이름 \"current_time\"은 하"
"드 코딩되어 있다. 이는 \"{% current_time }\"이 변수의 값을 무턱대고 덮어쓸 것"
"이기 때문에 템플릿이 \"{{current_time}\"을 다른 곳에 사용하지 않도록 해야 한"
"다는 것을 의미한다. 더 깨끗한 해결책은 템플릿 태그가 출력 변수의 이름을 다음"
"과 같이 지정하도록 하는 것입니다."

msgid ""
"To do that, you'll need to refactor both the compilation function and "
"``Node`` class, like so::"
msgstr ""
"그러기 위해서는 컴파일 기능과 ``노드\" 클래스를 모두 다음과 같이 리팩터링해"
"야 한다."

msgid ""
"The difference here is that ``do_current_time()`` grabs the format string "
"and the variable name, passing both to ``CurrentTimeNode3``."
msgstr ""
"여기서 다른 점은 \"do_current_time()\"이 형식 문자열과 변수 이름을 모두 "
"\"CurrentTimeNode3\"로 넘겨준다는 점이다."

msgid ""
"Finally, if you only need to have a simple syntax for your custom context-"
"updating template tag, consider using the :meth:`~django.template.Library."
"simple_tag` shortcut, which supports assigning the tag results to a template "
"variable."
msgstr ""
"마지막으로 사용자 정의 컨텍스트 업데이트 템플릿 태그에 대해 간단한 구문만 있"
"으면 되는 경우 :meth:'~django.template을 사용하는 것이 좋습니다.Library."
"simple_tag' 바로 가기이며, 템플릿 변수에 태그 결과를 할당할 수 있습니다."

msgid "Parsing until another block tag"
msgstr "다른 블록 태그까지 구문 분석"

msgid ""
"Template tags can work in tandem. For instance, the standard :ttag:`{% "
"comment %}<comment>` tag hides everything until ``{% endcomment %}``. To "
"create a template tag such as this, use ``parser.parse()`` in your "
"compilation function."
msgstr ""
"템플릿 태그는 함께 사용할 수 있습니다. 예를 들어 표준:ttag:'{% comment %}' 태"
"그는 \"{% end comment %}\"까지 모든 것을 숨깁니다. 이와 같은 템플릿 태그를 만"
"들려면 컴파일 기능에 \"parser.parse()\"를 사용하십시오."

msgid "Here's how a simplified ``{% comment %}`` tag might be implemented::"
msgstr "단순화된 ``{% comment %\" 태그를 구현하는 방법은 다음과 같다."

msgid ""
"The actual implementation of :ttag:`{% comment %}<comment>` is slightly "
"different in that it allows broken template tags to appear between ``{% "
"comment %}`` and ``{% endcomment %}``. It does so by calling ``parser."
"skip_past('endcomment')`` instead of ``parser.parse(('endcomment',))`` "
"followed by ``parser.delete_first_token()``, thus avoiding the generation of "
"a node list."
msgstr ""
":ttag:'{% comment %}'의 실제 구현은 깨진 템플릿 태그를 ``{% comment %\"와 "
"\"{% end comment %}\" 사이에 표시할 수 있다는 점에서 약간 다르다. 그것은 "
"``parser.delete_first_token('end comment')'이 아닌 ``parser.skip_past('end "
"comment')'\"라고 불러서 노드 리스트의 생성을 피한다."

msgid ""
"``parser.parse()`` takes a tuple of names of block tags ''to parse until''. "
"It returns an instance of ``django.template.NodeList``, which is a list of "
"all ``Node`` objects that the parser encountered ''before'' it encountered "
"any of the tags named in the tuple."
msgstr ""
"'파서.파서'는 '까지' 구문 분석하기 위해' 블록 태그의 이름 두 개를 사용한다. "
"그것은 ``django.template\"의 예를 반환한다.노드리스트'는 파서가 이전에 만났"
"던 모든 \"노드\" 오브젝트 목록이며 튜플에서 명명된 태그 중 하나를 발견했다."

msgid ""
"In ``\"nodelist = parser.parse(('endcomment',))\"`` in the above example, "
"``nodelist`` is a list of all nodes between the ``{% comment %}`` and ``{% "
"endcomment %}``, not counting ``{% comment %}`` and ``{% endcomment %}`` "
"themselves."
msgstr ""
"위의 예에서 \"'끝글리스트 ='에서 \"끝글리스트\"는 ``{% comment %\"와 \"{% "
"comment %\"를 세지 않는 ``{% comment %\"와 \"{% comment %}\" 사이의 모든 노드"
"를 나열한 것이다."

msgid ""
"After ``parser.parse()`` is called, the parser hasn't yet \"consumed\" the "
"``{% endcomment %}`` tag, so the code needs to explicitly call ``parser."
"delete_first_token()``."
msgstr ""
"``parser.parse()\"가 호출된 후 파서는 아직 \"{% end comment %\" 태그를 \"소비"
"\"하지 않았기 때문에 코드에서 \"parser.delete_first_token()\"이라고 명시적으"
"로 불러야 한다."

msgid ""
"``CommentNode.render()`` returns an empty string. Anything between ``{% "
"comment %}`` and ``{% endcomment %}`` is ignored."
msgstr ""
"\"commentNode.render()\"는 빈 문자열을 반환합니다. \"{% comment %\"와 \"{% "
"end comment %}\" 사이의 어떤 것도 무시된다."

msgid "Parsing until another block tag, and saving contents"
msgstr "다른 블록 태그까지 구문 분석하고 내용 저장"

msgid ""
"In the previous example, ``do_comment()`` discarded everything between ``{% "
"comment %}`` and ``{% endcomment %}``. Instead of doing that, it's possible "
"to do something with the code between block tags."
msgstr ""
"앞의 예에서 \"do_comment()\"는 \"{% comment %\"와 \"{% end comment %\" 사이"
"의 모든 것을 폐기했다. 대신 블록 태그 간에 코드를 사용하여 작업을 수행할 수 "
"있습니다."

msgid ""
"For example, here's a custom template tag, ``{% upper %}``, that capitalizes "
"everything between itself and ``{% endupper %}``."
msgstr ""
"예를 들어,여기 \"{% oper %}\"라는 사용자 정의 템플릿 태그가 있는데, 이 태그"
"는 자신들 사이의 모든 것을 대문자로 한다."

msgid "Usage:"
msgstr "용례"

msgid ""
"As in the previous example, we'll use ``parser.parse()``. But this time, we "
"pass the resulting ``nodelist`` to the ``Node``::"
msgstr ""
"앞의 예와 같이 \"파서.파스()\"를 사용할 것이다. 그러나 이번에는 ``노드 리스트"
"\"를 ``노드\"에게 넘겼다."

msgid ""
"The only new concept here is the ``self.nodelist.render(context)`` in "
"``UpperNode.render()``."
msgstr ""
"여기서 유일한 새로운 개념은 ``UpperNode.render()\"의 ``self.nodelist."
"render(컨텍스트)\"이다."

msgid ""
"For more examples of complex rendering, see the source code of :ttag:`{% for "
"%}<for>` in ``django/template/defaulttags.py`` and :ttag:`{% if %}<if>` in "
"``django/template/smartif.py``."
msgstr ""
"복잡한 렌더링의 자세한 예는 \"django/template/default 태그\"에서 :ttag:'{% "
"for %\"의 소스 코드를 참조하십시오.\"django/https/smartif.py\"의 pypad "
"및 :'{% if %}\"입니다."

msgid "How to use Django with Daphne"
msgstr "다프네와 함께 django를 사용하는 방법"

msgid ""
"Daphne_ is a pure-Python ASGI server for UNIX, maintained by members of the "
"Django project. It acts as the reference server for ASGI."
msgstr ""
"Daphne_는 UNIX용 Pure-Python ASGI 서버이며, Django 프로젝트의 멤버에 의해 유"
"지보수됩니다. ASGI의 참조 서버 역할을 합니다"

msgid "Installing Daphne"
msgstr "다프네 설치"

msgid "You can install Daphne with ``pip``::"
msgstr " ``pip``:으로 다프네를 설치할 수 있다"

msgid "Running Django in Daphne"
msgstr "다프네에서 djagno 작동"

msgid ""
"When Daphne is installed, a ``daphne`` command is available which starts the "
"Daphne server process. At its simplest, Daphne needs to be called with the "
"location of a module containing an ASGI application object, followed by what "
"the application is called (separated by a colon)."
msgstr ""
"다프네가 설치되면 다프네 서버 프로세스를 시작하는 ``다프네\" 명령이 나온다. "
"간단히 말해, 다프네는 ASGI 애플리케이션 개체를 포함하는 모듈의 위치로 호출되"
"어야 하며, 그 다음에 애플리케이션 이름이 콜론으로 구분됩니다."

msgid "For a typical Django project, invoking Daphne would look like::"
msgstr ""
"일반적인 Django 프로젝트의 경우 Daphne을 호출하는 방법은 다음과 같습니다."

msgid ""
"This will start one process listening on ``127.0.0.1:8000``. It requires "
"that your project be on the Python path; to ensure that run this command "
"from the same directory as your ``manage.py`` file."
msgstr ""
"이로써 \"127.0.0.1:8000\"에 대한 청취가 시작된다. 프로젝트가 Python 경로에 있"
"어야 합니다. ``관리\"와 동일한 디렉토리에서 이 명령을 실행해야 합니다."

msgid "How to use Django with Hypercorn"
msgstr "하이퍼콘과 함께 장고를 사용하는 방법"

msgid ""
"Hypercorn_ is an ASGI server that supports HTTP/1, HTTP/2, and HTTP/3 with "
"an emphasis on protocol support."
msgstr ""
"Hypercorn_은(는) 프로토콜 지원을 강조하여 HTTP/1, HTTP/2 및 HTTP/3을 지원하"
"는 ASGI 서버입니다."

msgid "Installing Hypercorn"
msgstr "하이퍼콘 설치"

msgid "You can install Hypercorn with ``pip``::"
msgstr "하이퍼콘은 \"pip\"로 설치할 수 있다."

msgid "Running Django in Hypercorn"
msgstr "하이퍼콘에서 Django 실행"

msgid ""
"When Hypercorn is installed, a ``hypercorn`` command is available which runs "
"ASGI applications. Hypercorn needs to be called with the location of a "
"module containing an ASGI application object, followed by what the "
"application is called (separated by a colon)."
msgstr ""
"하이퍼콘을 설치하면 ASGI 응용 프로그램을 실행하는 \"하이퍼콘\" 명령을 사용할 "
"수 있다. 하이퍼콘은 ASGI 애플리케이션 개체를 포함하는 모듈의 위치로 호출되어"
"야 하며 그 다음에 애플리케이션 이름이 콜론으로 구분됩니다."

msgid "For a typical Django project, invoking Hypercorn would look like::"
msgstr ""
"일반적인 Django 프로젝트의 경우 하이퍼콘을 호출하는 방법은 다음과 같습니다."

msgid ""
"For more advanced usage, please read the `Hypercorn documentation "
"<Hypercorn_>`_."
msgstr "좀 더 고급스러운 용법은 '하이퍼콘 설명서'를 읽어주세요."

msgid "How to deploy with ASGI"
msgstr "ASGI를 사용하여 배포하는 방법"

msgid ""
"As well as WSGI, Django also supports deploying on ASGI_, the emerging "
"Python standard for asynchronous web servers and applications."
msgstr ""
"WSGI뿐만 아니라, Django는 비동기 웹 서버와 애플리케이션을 위한 새로운 Python "
"표준인 ASGI_에 대한 배포도 지원합니다."

msgid ""
"Django's :djadmin:`startproject` management command sets up a default ASGI "
"configuration for you, which you can tweak as needed for your project, and "
"direct any ASGI-compliant application server to use."
msgstr ""
"Django의 :djadmin:'start project' 관리 명령은 프로젝트에 필요한 대로 수정할 "
"수 있는 기본 ASGI 구성을 설정하고 ASGI 호환 애플리케이션 서버를 사용하도록 지"
"시합니다."

msgid ""
"Django includes getting-started documentation for the following ASGI servers:"
msgstr "Django에는 다음 ASGI 서버에 대한 시작 설명서가 포함되어 있습니다."

msgid "The ``application`` object"
msgstr "애플리케이션 객체"

msgid ""
"Like WSGI, ASGI has you supply an ``application`` callable which the "
"application server uses to communicate with your code. It's commonly "
"provided as an object named ``application`` in a Python module accessible to "
"the server."
msgstr ""
"WSGI와 마찬가지로 ASGI는 애플리케이션 서버가 코드와 통신하기 위해 사용하는 "
"\"애플리케이션\" 호출 케이블을 제공합니다. 그것은 일반적으로 서버가 접근할 "
"수 있는 파이썬 모듈에서 \"애플리케이션\"이라는 이름의 객체로 제공된다."

msgid ""
"The :djadmin:`startproject` command creates a file :file:`<project_name>/"
"asgi.py` that contains such an ``application`` callable."
msgstr ""
":djadmin:'start project' 명령은 :file:'/asgi 파일을 생성합니다.그러한 ``응용"
"프로그램\"을 포함한 py는 호출할 수 있다."

msgid ""
"It's not used by the development server (``runserver``), but can be used by "
"any ASGI server either in development or in production."
msgstr ""
"개발 서버('runserver')에서 사용하는 것이 아니라 ASGI 서버가 개발 또는 프로덕"
"션에서 사용할 수 있습니다."

msgid ""
"ASGI servers usually take the path to the application callable as a string; "
"for most Django projects, this will look like ``myproject.asgi:application``."
msgstr ""
"ASGI 서버는 대개 문자열로 호출할 수 있는 응용 프로그램의 경로를 택하는데 대부"
"분의 Django 프로젝트에서 이것은 ``my project.asgi: application\"처럼 보일 것"
"이다."

msgid ""
"While Django's default ASGI handler will run all your code in a synchronous "
"thread, if you choose to run your own async handler you must be aware of "
"async-safety."
msgstr ""
"Django의 기본 ASGI 처리기는 모든 코드를 동기 스레드에서 실행하지만, 자신의 비"
"동기 처리기를 실행하도록 선택하는 경우에는 비동기 안전성을 알고 있어야 합니"
"다."

msgid ""
"Do not call blocking synchronous functions or libraries in any async code. "
"Django prevents you from doing this with the parts of Django that are not "
"async-safe, but the same may not be true of third-party apps or Python "
"libraries."
msgstr ""
"어떤 비동기 코드에서도 동기 함수나 라이브러리 차단을 호출하지 마십시오. "
"Django는 비동기식 안전이 아닌 Django 부분에서는 이 작업을 수행할 수 없도록 방"
"지하지만 타사 앱이나 Python 라이브러리에서는 그렇지 않을 수 있습니다."

msgid "Configuring the settings module"
msgstr "설정 모듈 구성"

msgid ""
"When the ASGI server loads your application, Django needs to import the "
"settings module — that's where your entire application is defined."
msgstr ""
"ASGI 서버가 응용프로그램을 로드할 때 Django는 전체 응용프로그램이 정의된 설"
"정 모듈을 가져와야 합니다."

msgid ""
"Django uses the :envvar:`DJANGO_SETTINGS_MODULE` environment variable to "
"locate the appropriate settings module. It must contain the dotted path to "
"the settings module. You can use a different value for development and "
"production; it all depends on how you organize your settings."
msgstr ""
"Django는 :envvar를 사용합니다.'DJANGO_SETTINGS_MODULE' 환경변수로서 적절한 설"
"정모듈을 찾을 수 있다. 설정 모듈에 대한 점선 경로를 포함해야 합니다. 개발 및 "
"프로덕션에 다른 값을 사용할 수 있습니다. 모든 값은 설정을 구성하는 방법에 따"
"라 다릅니다."

msgid ""
"If this variable isn't set, the default :file:`asgi.py` sets it to ``mysite."
"settings``, where ``mysite`` is the name of your project."
msgstr ""
"이 변수가 설정되지 않은 경우 기본값:file:'asgi'입니다.py는 그것을 ``내 사이트"
"\"로 설정한다.\"내 사이트\"가 프로젝트의 이름인 설정\"입니다."

msgid "Applying ASGI middleware"
msgstr "ASGI 미들웨어 적용"

msgid ""
"To apply ASGI middleware, or to embed Django in another ASGI application, "
"you can wrap Django's ``application`` object in the ``asgi.py`` file. For "
"example::"
msgstr ""
"ASGI 미들웨어를 적용하거나 Django를 다른 ASGI 애플리케이션에 포함시키려면 "
"Django의 ``응용\" 개체를 \"asgi\"에 포장하면 된다.파이브 파일 예:"

msgid "How to use Django with Uvicorn"
msgstr "django와 유비콘 사용방법"

msgid ""
"Uvicorn_ is an ASGI server based on ``uvloop`` and ``httptools``, with an "
"emphasis on speed."
msgstr ""
"Uvicorn은 속도를 중시하는 \"uvloop\"과 \"http tools\"에 기반을 둔 ASGI 서버이"
"다."

msgid "Installing Uvicorn"
msgstr "Uvicorn 설치"

msgid "You can install Uvicorn with ``pip``::"
msgstr "\"pip\"로 Uvicorn을 설치할 수 있다."

msgid "Running Django in Uvicorn"
msgstr "Uvicorn에서 django 실행"

msgid ""
"When Uvicorn is installed, a ``uvicorn`` command is available which runs "
"ASGI applications. Uvicorn needs to be called with the location of a module "
"containing an ASGI application object, followed by what the application is "
"called (separated by a colon)."
msgstr ""
"Uvicorn이 설치되면 ASGI 애플리케이션을 실행하는 \"uvicorn\" 명령을 사용할 수 "
"있다. Uvicorn은 ASGI 애플리케이션 개체가 포함된 모듈의 위치로 호출되어야 하"
"며 그 다음에 애플리케이션 이름이 콜론으로 구분됩니다."

msgid "For a typical Django project, invoking Uvicorn would look like::"
msgstr ""
"일반적인 Django 프로젝트의 경우 Uvicorn을 호출하는 방법은 다음과 같습니다."

msgid ""
"For more advanced usage, please read the `Uvicorn documentation <Uvicorn_>`_."
msgstr "고급 사용법은 Uvicorn document를 읽어주세요."

msgid "Deployment checklist"
msgstr "배포 전 체크리스트"

msgid ""
"The internet is a hostile environment. Before deploying your Django project, "
"you should take some time to review your settings, with security, "
"performance, and operations in mind."
msgstr ""

msgid ""
"Django includes many :doc:`security features </topics/security>`. Some are "
"built-in and always enabled. Others are optional because they aren't always "
"appropriate, or because they're inconvenient for development. For example, "
"forcing HTTPS may not be suitable for all websites, and it's impractical for "
"local development."
msgstr ""
"장고는 :doc:`보안 기능</topics/security>`\\을 많이 갖고 있습니다. 몇몇은 내장"
"된 기능으로 항상 켜져있습니다. 다른 몇몇은 선택할 수 있는데 그 이유는 항상 보"
"안 기능들이 적절하지 않거나 개발에 불편함을 가져올 수 있기 때문입니다. 예를 "
"들어 강제로 HTTPS를 활성화 하는 것은 모든 웹사이트에 적합하지 않을 수도 있"
"고, 로컬 개발환경에선 비실용적일 수도 있습니다."

msgid ""
"Performance optimizations are another category of trade-offs with "
"convenience. For instance, caching is useful in production, less so for "
"local development. Error reporting needs are also widely different."
msgstr ""
"성능 최적화는 편의를 위한 또다른 범주의 거래입니다. 예를 들어, 캐싱은 상용 환"
"경에서 유용할 수 있지만 로컬 개발 환경에서는 실용적이지 않을 수 있습니다. 오"
"류 보고의 필요성에도 큰 차이가 있습니다."

msgid "The following checklist includes settings that:"
msgstr "설정에 대한 체크리스트는 다음과 같습니다."

msgid ""
"must be set properly for Django to provide the expected level of security;"
msgstr "Django에서 예상되는 수준의 보안을 제공하도록 설정해야 합니다."

msgid "are expected to be different in each environment;"
msgstr "각 환경에 맞도록 설정해야 합니다."

msgid "enable optional security features;"
msgstr "선택적인 보안 기능들을 활성화시켜야 합니다."

msgid "enable performance optimizations;"
msgstr "성능 최적화가 적용돼야 합니다."

msgid "provide error reporting."
msgstr "에러 보고가 제공되어야 합니다."

msgid ""
"Many of these settings are sensitive and should be treated as confidential. "
"If you're releasing the source code for your project, a common practice is "
"to publish suitable settings for development, and to use a private settings "
"module for production."
msgstr ""
"이 설정들 중 대부분은 예민할 수 있고 감추어져야 합니다. 만약 여러분이 프로젝"
"트의 소스코드를 배포한다면, 대부분은 개발 환경에 최적화된 설정으로 배포하고 "
"상용 환경에서 사용할 별도의 설정을 사용할 것입니다."

msgid "Run ``manage.py check --deploy``"
msgstr "``manage.py check --deploy`` 명령 실행"

msgid ""
"Some of the checks described below can be automated using the :option:`check "
"--deploy` option. Be sure to run it against your production settings file as "
"described in the option's documentation."
msgstr ""
"문서아래에 설명된 일부 검사는 : 옵션을 사용하여 자동화할 수 있습니다.check --"
"deploy' 옵션을 선택하십시오. 옵션 설명서에 설명된 대로 프로덕션 설정 파일에 "
"대해 실행하십시오."

msgid "Critical settings"
msgstr "중요 설정"

msgid ":setting:`SECRET_KEY`"
msgstr ":설정:`SECRET_KEY`"

msgid ""
"**The secret key must be a large random value and it must be kept secret.**"
msgstr "**비밀 키는 큰 임의 값이어야 하며 기밀로 유지되어야 합니다.**"

msgid ""
"Make sure that the key used in production isn't used anywhere else and avoid "
"committing it to source control. This reduces the number of vectors from "
"which an attacker may acquire the key."
msgstr ""
"프로덕션에 사용된 키가 다른 곳에서 사용되지 않는지 확인하고 소스 제어에 커밋"
"하지 않도록 하십시오. 이렇게 하면 공격자가 키를 얻을 수 있는 벡터 수가 줄어듭"
"니다."

msgid ""
"Instead of hardcoding the secret key in your settings module, consider "
"loading it from an environment variable::"
msgstr ""
"설정 모듈의 비밀 키를 하드코딩하는 대신 환경 변수에서 로드하는 것을 고려하십"
"시오."

msgid "or from a file::"
msgstr "또는 파일로부터"

msgid ":setting:`DEBUG`"
msgstr ":설정:`DEBUG`"

msgid "**You must never enable debug in production.**"
msgstr "**프로덕션에서 디버그를 사용 가능으로 설정하지 않아야 합니다.**"

msgid ""
"You're certainly developing your project with :setting:`DEBUG = True "
"<DEBUG>`, since this enables handy features like full tracebacks in your "
"browser."
msgstr ""
"다음을 설정하여 프로젝트를 개발하고 있는 것이 확실합니다.브라우저의 전체 추적"
"과 같은 편리한 기능을 제공하므로 'DEBUG = True'입니다."

msgid ""
"For a production environment, though, this is a really bad idea, because it "
"leaks lots of information about your project: excerpts of your source code, "
"local variables, settings, libraries used, etc."
msgstr ""
"그러나 프로덕션 환경에서는 이 방법이 매우 좋지 않습니다. 프로젝트에 대한 많"
"은 정보(소스 코드, 로컬 변수, 설정, 사용된 라이브러리 등)를 유출하기 때문입니"
"다."

msgid "Environment-specific settings"
msgstr "특정한 환경 설정"

msgid ":setting:`ALLOWED_HOSTS`"
msgstr ":설정:`ALLOWED_HOSTS`"

msgid ""
"When :setting:`DEBUG = False <DEBUG>`, Django doesn't work at all without a "
"suitable value for :setting:`ALLOWED_HOSTS`."
msgstr ""
":설정:'DEBUG = False', Django는 : 설정에  :setting:`ALLOWED_HOSTS`. 의 적합"
"한 값이 없으면 전혀 작동하지 않습니다"

msgid ""
"This setting is required to protect your site against some CSRF attacks. If "
"you use a wildcard, you must perform your own validation of the ``Host`` "
"HTTP header, or otherwise ensure that you aren't vulnerable to this category "
"of attacks."
msgstr ""
"이 설정은 일부 CSRF 공격으로부터 사이트를 보호하는 데 필요합니다. 와일드카드"
"를 사용할 경우 \"Host\" HTTP 헤더에 대한 자체 검증을 수행하거나 그렇지 않을 "
"경우 이 공격 범주에 취약하지 않은지 확인해야 합니다."

msgid ""
"You should also configure the web server that sits in front of Django to "
"validate the host. It should respond with a static error page or ignore "
"requests for incorrect hosts instead of forwarding the request to Django. "
"This way you'll avoid spurious errors in your Django logs (or emails if you "
"have error reporting configured that way). For example, on nginx you might "
"set up a default server to return \"444 No Response\" on an unrecognized "
"host:"
msgstr ""

msgid ":setting:`CACHES`"
msgstr ":설정:`CACHES`"

msgid ""
"If you're using a cache, connection parameters may be different in "
"development and in production. Django defaults to per-process :ref:`local-"
"memory caching <local-memory-caching>` which may not be desirable."
msgstr ""
"캐시를 사용하는 경우 연결 매개 변수는 개발 및 운영에서 다를 수 있습니다. "
"Django의 기본값은 프로세스당:ref:로컬 메모리 캐싱 1은 바람직하지 않을 수 있"
"다."

msgid ""
"Cache servers often have weak authentication. Make sure they only accept "
"connections from your application servers."
msgstr ""
"캐시 서버의 인증확인은 약한 경우가 많습니다. 응용프로그램 서버로부터의 연결"
"만 허용하는지 확인합니다."

msgid ":setting:`DATABASES`"
msgstr ":설정:`DATABASES`"

msgid ""
"Database connection parameters are probably different in development and in "
"production."
msgstr "데이터베이스 연결 매개 변수는 개발 및 운영에서 서로 다를 수 있습니다."

msgid ""
"Database passwords are very sensitive. You should protect them exactly like :"
"setting:`SECRET_KEY`."
msgstr ""
"데이터베이스 암호는 매우 민감합니다. 당신은 :setting:`SECRET_KEY`.을 똑같이 "
"보호해야 한다."

msgid ""
"For maximum security, make sure database servers only accept connections "
"from your application servers."
msgstr ""
"보안을 최대화하려면 데이터베이스 서버가 응용프로그램 서버의 연결만 허용해야 "
"합니다."

msgid "If you haven't set up backups for your database, do it right now!"
msgstr "데이터베이스에 대한 백업을 설정하지 않은 경우 지금 바로 수행하십시오!"

msgid ":setting:`EMAIL_BACKEND` and related settings"
msgstr ":설정:`EMAIL_BACKEND` 과 관련된 설정들"

msgid "If your site sends emails, these values need to be set correctly."
msgstr "사이트에서 전자 메일을 보내는 경우 이 값을 올바르게 설정해야 합니다."

msgid ""
"By default, Django sends email from webmaster@localhost and root@localhost. "
"However, some mail providers reject email from these addresses. To use "
"different sender addresses, modify the :setting:`DEFAULT_FROM_EMAIL` and :"
"setting:`SERVER_EMAIL` settings."
msgstr ""
"기본적으로 Django는 webmaster@localhost 및 root@localhost에서 이메일을 전송합"
"니다. 그러나 일부 메일 공급자는 이러한 주소의 전자 메일을 거부합니다. 다른 발"
"신인 주소를 사용하려면 : 설정을 수정하십시오.'DEFAUT_FROM_EMAIL' 및 :설"
"정:'SERVER_EMail의 설정입니다."

msgid ":setting:`STATIC_ROOT` and :setting:`STATIC_URL`"
msgstr ":설정:`STATIC_ROOT`  그리고 :설정:`STATIC_URL`"

msgid ""
"Static files are automatically served by the development server. In "
"production, you must define a :setting:`STATIC_ROOT` directory where :"
"djadmin:`collectstatic` will copy them."
msgstr ""
"정적 파일은 개발 서버에서 자동으로 제공됩니다. 프로덕션에서 :seting:'를 정의"
"해야 합니다.STATIC_ROOT' 디렉토리. 여기서 :djadmin:'collectstatic'은 이들을 "
"복사한다."

msgid "See :doc:`/howto/static-files/index` for more information."
msgstr "더 많은 정보를 원하면  :doc:`/howto/static-files/index` 를 확인하세요"

msgid ":setting:`MEDIA_ROOT` and :setting:`MEDIA_URL`"
msgstr ":설정: `MEDIA_ROOT` 그리고 :설정`MEDIA_URL`"

msgid ""
"Media files are uploaded by your users. They're untrusted! Make sure your "
"web server never attempts to interpret them. For instance, if a user uploads "
"a ``.php`` file, the web server shouldn't execute it."
msgstr ""
"미디어 파일은 사용자가 업로드합니다. 그들은 믿을 수 없어요! 웹 서버가 해당 문"
"서를 해석하지 않도록 하십시오. 예를 들어 사용자가 \".php\" 파일을 업로드하면 "
"웹 서버가 실행하지 않아야 한다."

msgid "Now is a good time to check your backup strategy for these files."
msgstr "지금 바로 이러한 파일의 백업 전략을 확인해 보십시오."

msgid "HTTPS"
msgstr "HTTPS"

msgid ""
"Any website which allows users to log in should enforce site-wide HTTPS to "
"avoid transmitting access tokens in clear. In Django, access tokens include "
"the login/password, the session cookie, and password reset tokens. (You "
"can't do much to protect password reset tokens if you're sending them by "
"email.)"
msgstr ""
"사용자가 로그인할 수 있는 웹 사이트는 액세스 토큰을 명확하게 전송하지 않도록 "
"사이트 전체 HTTPS를 적용해야 합니다. Django에서 액세스 토큰에는 로그인/암호, "
"세션 쿠키 및 암호 재설정 토큰이 포함됩니다(이메일로 보내는 경우 암호 재설정 "
"토큰을 보호하는 데 많은 작업을 수행할 수 없습니다)."

msgid ""
"Protecting sensitive areas such as the user account or the admin isn't "
"sufficient, because the same session cookie is used for HTTP and HTTPS. Your "
"web server must redirect all HTTP traffic to HTTPS, and only transmit HTTPS "
"requests to Django."
msgstr ""
"HTTP 및 HTTPS에 동일한 세션 쿠키가 사용되므로 사용자 계정이나 관리자와 같은 "
"중요한 영역을 보호하는 것만으로는 충분하지 않습니다. 웹 서버는 모든 HTTP 트래"
"픽을 HTTPS로 리디렉션하고 HTTPS 요청만 Django로 전송해야 합니다."

msgid "Once you've set up HTTPS, enable the following settings."
msgstr "HTTPS를 설정한 후 다음 설정을 사용하도록 설정하십시오."

msgid ":setting:`CSRF_COOKIE_SECURE`"
msgstr ":설정:`CSRF_COOKIE_SECURE`"

msgid ""
"Set this to ``True`` to avoid transmitting the CSRF cookie over HTTP "
"accidentally."
msgstr ""
"실수로 HTTP를 통해 CSRF 쿠키가 전송되지 않도록 하려면 \"참\"으로 설정하십시"
"오."

msgid ":setting:`SESSION_COOKIE_SECURE`"
msgstr ":설정:`SESSION_COOKIE_SECURE`"

msgid ""
"Set this to ``True`` to avoid transmitting the session cookie over HTTP "
"accidentally."
msgstr ""
"실수로 HTTP를 통해 세션 쿠키가 전송되지 않도록 하려면 \"참\"으로 설정하십시"
"오."

msgid "Performance optimizations"
msgstr "성능 최적화"

msgid ""
"Setting :setting:`DEBUG = False <DEBUG>` disables several features that are "
"only useful in development. In addition, you can tune the following settings."
msgstr ""
"설정 :setting:`DEBUG = False  은 개발에만 유용한 여러 기능을 사용하지 않도록 "
"설정합니다. 또한 다음 설정을 조정할 수 있습니다."

msgid "Sessions"
msgstr "세션"

msgid ""
"Consider using :ref:`cached sessions <cached-sessions-backend>` to improve "
"performance."
msgstr "성능 향상을 위해 :ref:'캐시 세션'을 사용하는 것을 고려하십시오."

msgid ""
"If using database-backed sessions, regularly :ref:`clear old sessions "
"<clearing-the-session-store>` to avoid storing unnecessary data."
msgstr ""
"데이터베이스 지원 세션을 사용할 경우 정기적으로:ref:'이전 세션 지우기'를 수행"
"하여 불필요한 데이터를 저장하지 않도록 합니다."

msgid ":setting:`CONN_MAX_AGE`"
msgstr ":설정:`CONN_MAX_AGE`"

msgid ""
"Enabling :ref:`persistent database connections <persistent-database-"
"connections>` can result in a nice speed-up when connecting to the database "
"accounts for a significant part of the request processing time."
msgstr ""
"요청 처리 시간의 상당 부분을 데이터베이스 계정에 연결할 때 :ref:'영구 데이터"
"베이스 연결'을 활성화하면 속도가 상당히 빨라질 수 있습니다."

msgid "This helps a lot on virtualized hosts with limited network performance."
msgstr "따라서 네트워크 성능이 제한된 가상화된 호스트에서 많은 도움이 됩니다."

msgid ":setting:`TEMPLATES`"
msgstr ":설정:`TEMPLATES`"

msgid ""
"Enabling the cached template loader often improves performance drastically, "
"as it avoids compiling each template every time it needs to be rendered. See "
"the :ref:`template loaders docs <template-loaders>` for more information."
msgstr ""
"캐시된 템플리트 로더를 사용 가능으로 설정하면 렌더링할 때마다 각 템플리트가 "
"컴파일되지 않으므로 성능이 크게 향상됩니다. 자세한 내용은 :ref:'템플릿 로더 "
"문서'를 참조하십시오."

msgid "Error reporting"
msgstr "오류 알림"

msgid ""
"By the time you push your code to production, it's hopefully robust, but you "
"can't rule out unexpected errors. Thankfully, Django can capture errors and "
"notify you accordingly."
msgstr ""
"코드를 프로덕션으로 푸시할 때쯤이면 강력한 기능이 발휘되지만 예기치 않은 오류"
"를 배제할 수는 없습니다. 고맙게도, Django는 오류를 포착하고 그에 따라 통지할 "
"수 있습니다."

msgid ":setting:`LOGGING`"
msgstr ":설정:`LOGGING`"

msgid ""
"Review your logging configuration before putting your website in production, "
"and check that it works as expected as soon as you have received some "
"traffic."
msgstr ""
"웹 사이트를 프로덕션 상태로 전환하기 전에 로깅 구성을 검토하고 일부 트래픽이 "
"수신되는 즉시 해당 구성이 제대로 작동하는지 확인합니다."

msgid "See :doc:`/topics/logging` for details on logging."
msgstr "로깅에 관한 자세한 내용은 :doc:`/topics/logging`을 참조하세요"

msgid ":setting:`ADMINS` and :setting:`MANAGERS`"
msgstr ":설정:`ADMINS`  그리고 :설정:`MANAGERS`"

msgid ":setting:`ADMINS` will be notified of 500 errors by email."
msgstr "이메일에 의한 500 에러는  :설정:`ADMINS`에게 알려질 것입니다"

msgid ""
":setting:`MANAGERS` will be notified of 404 errors. :setting:"
"`IGNORABLE_404_URLS` can help filter out spurious reports."
msgstr ""
":설정:`MANAGERS` 오류 404가  표시됩니다.\n"
":설정:`IGNORABLE_404_URLS` 가짜 보고서를 필터링하는 데 도움이 될 수 있습니다."

msgid ""
"See :doc:`/howto/error-reporting` for details on error reporting by email."
msgstr ""
"이메일로 에러를 알리는 방법에 대한 자세한 내용은  :doc:`/howto/error-"
"reporting` 을 참조하세요"

msgid "Error reporting by email doesn't scale very well"
msgstr "메일로 에러를 알려주는것은 좋지 않을수도 있습니다"

msgid ""
"Consider using an error monitoring system such as Sentry_ before your inbox "
"is flooded by reports. Sentry can also aggregate logs."
msgstr ""
"보고서에 의해 받은 편지함이 플러시되기 전에 Sentry_와 같은 오류 모니터링 시스"
"템을 사용하는 것이 좋습니다. Sentry는 로그를 집계할 수도 있습니다."

msgid "Customize the default error views"
msgstr "기본 오류 보기 사용자 지정"

msgid ""
"Django includes default views and templates for several HTTP error codes. "
"You may want to override the default templates by creating the following "
"templates in your root template directory: ``404.html``, ``500.html``, ``403."
"html``, and ``400.html``. The :ref:`default error views <error-views>` that "
"use these templates should suffice for 99% of web applications, but you can :"
"ref:`customize them <customizing-error-views>` as well."
msgstr ""

msgid "How to deploy Django"
msgstr ""

msgid ""
"Django is full of shortcuts to make web developers' lives easier, but all "
"those tools are of no use if you can't easily deploy your sites. Since "
"Django's inception, ease of deployment has been a major goal."
msgstr ""

msgid ""
"There are many options for deploying your Django application, based on your "
"architecture or your particular business needs, but that discussion is "
"outside the scope of what Django can give you as guidance."
msgstr ""
"아키텍처 또는 특정 비즈니스 요구 사항에 따라 Django 애플리케이션을 배포하는 "
"방법에는 여러 가지가 있지만 이러한 논의는 Django가 지침으로 제공할 수 있는 범"
"위를 벗어납니다."

msgid ""
"Django, being a web framework, needs a web server in order to operate. And "
"since most web servers don't natively speak Python, we need an interface to "
"make that communication happen."
msgstr ""
"웹 프레임워크인 Django는 작동하기 위해 웹 서버가 필요합니다. 그리고 대부분의 "
"웹 서버는 기본적으로 Python을 사용하지 않기 때문에, 우리는 그러한 커뮤니케이"
"션이 이루어지도록 인터페이스가 필요합니다."

msgid "Django currently supports two interfaces: WSGI and ASGI."
msgstr "Django는 현재 WSGI와 ASGI의 두 가지 인터페이스를 지원합니다."

msgid ""
"`WSGI`_ is the main Python standard for communicating between web servers "
"and applications, but it only supports synchronous code."
msgstr ""

msgid ""
"`ASGI`_ is the new, asynchronous-friendly standard that will allow your "
"Django site to use asynchronous Python features, and asynchronous Django "
"features as they are developed."
msgstr ""
"ASGI는 당신의 Django 사이트에서 비동기 Python 기능과 비동기 Django 기능을 개"
"발하면서 사용할 수 있게 해주는 새로운 비동기 친화적인 표준이다."

msgid ""
"You should also consider how you will handle :doc:`static files </howto/"
"static-files/deployment>` for your application, and how to handle :doc:"
"`error reporting</howto/error-reporting>`."
msgstr ""
"응용 프로그램에 대해 :doc:'static files'를 어떻게 처리할 것인지와 :"
"doc:'error reporting'을 어떻게 처리할 것인지도 고려해야 한다."

msgid ""
"Finally, before you deploy your application to production, you should run "
"through our :doc:`deployment checklist<checklist>` to ensure that your "
"configurations are suitable."
msgstr ""
"마지막으로 애플리케이션을 운영 환경에 배포하기 전에 :doc: '배포 체크리스"
"트'를 실행하여 구성이 적합한지 확인해야 합니다."

msgid "How to authenticate against Django's user database from Apache"
msgstr ""

msgid ""
"Since keeping multiple authentication databases in sync is a common problem "
"when dealing with Apache, you can configure Apache to authenticate against "
"Django's :doc:`authentication system </topics/auth/index>` directly. This "
"requires Apache version >= 2.2 and mod_wsgi >= 2.0. For example, you could:"
msgstr ""
"Apache를 처리할 때는 여러 인증 데이터베이스를 동기화하는 것이 일반적인 문제이"
"므로 Django의 :doc:'인증 시스템'에 대해 직접 인증하도록 Apache를 구성할 수 있"
"습니다. 이를 위해서는 Apache 버전 > > 2.2 및 mod_wsgi > > 2.0이 필요합니다. "
"예를 들어 다음과 같은 작업을 수행할 수 있습니다."

msgid ""
"Serve static/media files directly from Apache only to authenticated users."
msgstr "정적/미디어 파일을 Apache에서 인증된 사용자에게만 직접 제공합니다."

msgid ""
"Authenticate access to a Subversion_ repository against Django users with a "
"certain permission."
msgstr ""
"특정 사용 권한을 가진 Django 사용자에 대해 Subversion_repository에 대한 액세"
"스를 인증합니다."

msgid "Allow certain users to connect to a WebDAV share created with mod_dav_."
msgstr "특정 사용자가 mod_dav_로 생성된 WebDAV 공유에 연결할 수 있습니다."

msgid ""
"If you have installed a :ref:`custom user model <auth-custom-user>` and want "
"to use this default auth handler, it must support an ``is_active`` "
"attribute. If you want to use group based authorization, your custom user "
"must have a relation named 'groups', referring to a related object that has "
"a 'name' field. You can also specify your own custom mod_wsgi auth handler "
"if your custom cannot conform to these requirements."
msgstr ""
":ref:'custom user model'을 설치한 경우 이 기본 인증 핸들러를 사용하려면 "
"\"is_active\" 속성을 지원해야 합니다. 그룹 기반 인증을 사용하려면 사용자 지"
"정 사용자에게 'name' 필드가 있는 관련 개체를 참조하는 'groups'라는 관계가 있"
"어야 합니다. 또한 사용자 지정이 이러한 요구 사항을 충족할 수 없는 경우 사용"
"자 지정 mod_wsgi 인증 처리기를 직접 지정할 수도 있습니다."

msgid "Authentication with ``mod_wsgi``"
msgstr "\"mod_wsgi\"로 인증"

msgid ""
"The use of ``WSGIApplicationGroup %{GLOBAL}`` in the configurations below "
"presumes that your Apache instance is running only one Django application. "
"If you are running more than one Django application, please refer to the "
"`Defining Application Groups`_ section of the mod_wsgi docs for more "
"information about this setting."
msgstr ""
"아래 구성에서 \"WSGA 애플리케이션 그룹 %{GLOGL\"을 사용하면 Apache 인스턴스"
"가 Django 애플리케이션을 하나만 실행 중인 것으로 가정합니다. 둘 이상의 "
"Django 응용 프로그램을 실행 중인 경우 이 설정에 대한 자세한 내용은 mod_wsgi "
"문서의 '응용 프로그램 그룹 정의' 섹션을 참조하십시오."

msgid ""
"Make sure that mod_wsgi is installed and activated and that you have "
"followed the steps to set up :doc:`Apache with mod_wsgi </howto/deployment/"
"wsgi/modwsgi>`."
msgstr ""

msgid ""
"Next, edit your Apache configuration to add a location that you want only "
"authenticated users to be able to view:"
msgstr ""
"그런 다음 인증된 사용자만 볼 수 있는 위치를 추가하려면 Apache 구성을 편집하십"
"시오."

msgid ""
"The ``WSGIAuthUserScript`` directive tells mod_wsgi to execute the "
"``check_password`` function in specified wsgi script, passing the user name "
"and password that it receives from the prompt. In this example, the "
"``WSGIAuthUserScript`` is the same as the ``WSGIScriptAlias`` that defines "
"your application :doc:`that is created by django-admin startproject </howto/"
"deployment/wsgi/index>`."
msgstr ""
"''WSGIAuthUserScript'' 지시문은 mod_wsgi에 지정된 wsgi 스크립트에서 "
"\"check_password\" 기능을 실행하라고 지시하고 프롬프트에서 수신하는 사용자 이"
"름과 암호를 전달한다. 이 예에서 ``WSGAuthUserScript\"는 당신의 애플리케이션"
"을 정의하는 ``WSGIScriptAlias\"와 동일하며 이는 django-admin start project에"
"서 만들어진 doc:\"이다."

msgid "Using Apache 2.2 with authentication"
msgstr "Apache 2.2 인증 사용법"

msgid "Make sure that ``mod_auth_basic`` and ``mod_authz_user`` are loaded."
msgstr "\"mod_auth_basic\"과 \"mod_authz_user\"가 로드되었는지 확인합니다."

msgid ""
"These might be compiled statically into Apache, or you might need to use "
"LoadModule to load them dynamically in your ``httpd.conf``:"
msgstr ""
"이는 정적으로 Apache로 컴파일되거나 \"httpd.conf\"에 로드 모듈을 사용하여 동"
"적으로 로드해야 할 수 있습니다."

msgid ""
"Finally, edit your WSGI script ``mysite.wsgi`` to tie Apache's "
"authentication to your site's authentication mechanisms by importing the "
"``check_password`` function::"
msgstr ""
"마지막으로 WSGI 스크립트 ``내 사이트\"를 편집하십시오.wsgi는 다음과 같은 "
"\"check_password\" 기능을 가져와 아파치의 인증을 사이트의 인증 메커니즘과 연"
"결한다."

msgid ""
"Requests beginning with ``/secret/`` will now require a user to authenticate."
msgstr "`/secret/``로 시작하는 요청은 이제 사용자가 인증해야 한다."

msgid ""
"The mod_wsgi `access control mechanisms documentation`_ provides additional "
"details and information about alternative methods of authentication."
msgstr ""
"mod_wsgi '액세스 제어 메커니즘 설명서'는 다른 인증 방법에 대한 추가 세부 정보"
"와 정보를 제공한다."

msgid "Authorization with ``mod_wsgi`` and Django groups"
msgstr "\"mod_wsgi\"와 \"django\" 그룹의 승인"

msgid ""
"mod_wsgi also provides functionality to restrict a particular location to "
"members of a group."
msgstr "mod_wsgi는 또한 특정 위치를 그룹의 멤버로 제한하는 기능을 제공한다."

msgid "In this case, the Apache configuration should look like this:"
msgstr "이 경우 Apache 구성은 다음과 같아야 합니다."

msgid ""
"To support the ``WSGIAuthGroupScript`` directive, the same WSGI script "
"``mysite.wsgi`` must also import the ``groups_for_user`` function which "
"returns a list groups the given user belongs to."
msgstr ""
"``WSGAuthGroupScript\"의 지시를 지지하기 위해 동일한 WSGI 스크립트는 \"내 사"
"이트\"이다.wsgij는 또한 주어진 사용자가 속한 목록 그룹을 반환하는 "
"``groups_for_userstitute\" 함수를 가져와야 한다."

msgid ""
"Requests for ``/secret/`` will now also require user to be a member of the "
"\"secret-agents\" group."
msgstr ""
"\"``/secret/`` 에 대한 요청도 이제 사용자가 \"secret-agents\"그룹의 구성원이"
"어야 할 것이다."

msgid "How to use Django with Gunicorn"
msgstr " Gunicorn과 함께 django 사용방법"

msgid ""
"Gunicorn_ ('Green Unicorn') is a pure-Python WSGI server for UNIX. It has no "
"dependencies and can be installed using ``pip``."
msgstr ""
"Gunicorn_('Green Unicon')는 UNIX용 Pure-Python WSGI 서버입니다. 종속성이 없으"
"며 \"파이프\"를 사용하여 설치할 수 있다."

msgid "Installing Gunicorn"
msgstr " Gunicorn 설치법"

msgid ""
"Install gunicorn by running ``python -m pip install gunicorn``. For more "
"details, see the `gunicorn documentation`_."
msgstr ""
"\"python-mp install gunicorn\"을 실행하여 gunicorn을 설치한다. 자세한 내용은"
"`gunicorn documentation`_. 참조."

msgid "Running Django in Gunicorn as a generic WSGI application"
msgstr "일반적인 WSGI 애플리케이션으로 Gunicorn에서 Django 실행"

msgid ""
"When Gunicorn is installed, a ``gunicorn`` command is available which starts "
"the Gunicorn server process. The simplest invocation of gunicorn is to pass "
"the location of a module containing a WSGI application object named "
"``application``, which for a typical Django project would look like::"
msgstr ""
"귀니콘이 설치되면 귀니콘 서버 프로세스를 시작하는 ``귀니콘\" 명령이 나온다. "
"가장 간단한 gunicorn의 호출은 일반적인 Django 프로젝트의 경우 다음과 같이 보"
"이는 \"application\"이라는 WSGI 애플리케이션 객체가 있는 모듈의 위치를 통과하"
"는 것이다."

msgid ""
"This will start one process running one thread listening on "
"``127.0.0.1:8000``. It requires that your project be on the Python path; the "
"simplest way to ensure that is to run this command from the same directory "
"as your ``manage.py`` file."
msgstr ""
"이는 \"127.0.0.1:8000\"에서 하나의 스레드를 청취하는 하나의 과정을 시작할 것"
"이다. 프로젝트가 Python 경로에 있어야 합니다. 이 명령을 ``관리\"와 동일한 디"
"렉토리에서 실행하는 가장 간단한 방법입니다."

msgid "See Gunicorn's `deployment documentation`_ for additional tips."
msgstr "자세한 내용은 Gunicorn의 '배치 설명서'를 참조하십시오."

msgid "How to deploy with WSGI"
msgstr "WSGI를 사용하여 배포하는 방법"

msgid ""
"Django's primary deployment platform is WSGI_, the Python standard for web "
"servers and applications."
msgstr ""
"Django의 기본 배포 플랫폼은 웹 서버 및 애플리케이션을 위한 Python 표준인 "
"WSGI_입니다."

msgid ""
"Django's :djadmin:`startproject` management command sets up a minimal "
"default WSGI configuration for you, which you can tweak as needed for your "
"project, and direct any WSGI-compliant application server to use."
msgstr ""
"Django의 :djadmin:'start project' 관리 명령은 프로젝트에 필요한 대로 수정할 "
"수 있는 최소 기본 WSGI 구성을 설정하고 WSGI 호환 애플리케이션 서버를 사용하도"
"록 지시합니다."

msgid ""
"Django includes getting-started documentation for the following WSGI servers:"
msgstr "Django에는 다음 WSGI 서버에 대한 시작 설명서가 포함되어 있습니다."

msgid ""
"The key concept of deploying with WSGI is the ``application`` callable which "
"the application server uses to communicate with your code. It's commonly "
"provided as an object named ``application`` in a Python module accessible to "
"the server."
msgstr ""
"WSGI와 함께 배치하는 핵심 개념은 애플리케이션 서버가 코드와 통신하기 위해 사"
"용하는 \"애플리케이션\" 호출 가능이다. 그것은 일반적으로 서버가 접근할 수 있"
"는 파이썬 모듈에서 \"애플리케이션\"이라는 이름의 객체로 제공된다"

msgid ""
"The :djadmin:`startproject` command creates a file :file:`<project_name>/"
"wsgi.py` that contains such an ``application`` callable."
msgstr ""
":djadmin:'start project' 명령은 :file:'/wsgi 파일을 생성합니다.그러한 ``응용"
"프로그램\"을 포함한 py는 호출할 수 있다."

msgid ""
"It's used both by Django's development server and in production WSGI "
"deployments."
msgstr "Django의 개발 서버와 프로덕션 WSGI 배포에서 모두 사용됩니다."

msgid ""
"WSGI servers obtain the path to the ``application`` callable from their "
"configuration. Django's built-in server, namely the :djadmin:`runserver` "
"command, reads it from the :setting:`WSGI_APPLICATION` setting. By default, "
"it's set to ``<project_name>.wsgi.application``, which points to the "
"``application`` callable in :file:`<project_name>/wsgi.py`."
msgstr ""
"WSGI 서버는 구성에서 호출 가능한 \"애플리케이션\"의 경로를 얻는다. Django의 "
"내장 서버, 즉 :djadmin:'runserver' 명령어는 :set 에서 읽는"
"다.'WSGI_APPLICATION' 설정. 기본적으로 이 프로그램은 \".wsgi.application\"으"
"로 설정되어 있는데, 이는 \":file:\"/wsgi.py으로 호출 가능한 애플리케이션\"을 "
"가리킵니다."

msgid ""
"When the WSGI server loads your application, Django needs to import the "
"settings module — that's where your entire application is defined."
msgstr ""
"WSGI 서버가 응용프로그램을 로드할 때 Django는 전체 응용프로그램이 정의된 설"
"정 모듈을 가져와야 합니다."

msgid ""
"If this variable isn't set, the default :file:`wsgi.py` sets it to ``mysite."
"settings``, where ``mysite`` is the name of your project. That's how :"
"djadmin:`runserver` discovers the default settings file by default."
msgstr ""
"이 변수가 설정되지 않은 경우 기본값:file:'wsgi'입니다.py는 그것을 ``내 사이트"
"\"로 설정한다.\"내 사이트\"가 프로젝트의 이름인 설정\"입니다. 이렇게 하면 :"
"djadmin:'runserver'는 기본적으로 기본 설정 파일을 검색합니다."

msgid ""
"Since environment variables are process-wide, this doesn't work when you run "
"multiple Django sites in the same process. This happens with mod_wsgi."
msgstr ""
"환경 변수가 공정 범위이기 때문에 동일한 공정에서 여러 D장고 사이트를 실행하"
"는 경우에는 이 작업이 수행되지 않습니다. mod_wsgi에서는 이러한 현상이 발생합"
"니다."

msgid ""
"To avoid this problem, use mod_wsgi's daemon mode with each site in its own "
"daemon process, or override the value from the environment by enforcing ``os."
"environ[\"DJANGO_SETTINGS_MODULE\"] = \"mysite.settings\"`` in your :file:"
"`wsgi.py`."
msgstr ""
"이 문제를 방지하려면 mod_wsgi의 데몬 모드를 자체 데몬 프로세스에서 사용하거"
"나 ``os.viron[\"를 적용하여 환경에서 값을 재정의하십시오."
"DJANGO_SETTINGS_MODULE\"] \" \"my site\".설정'은 : 파일에서:'wsgi'입니다."

msgid "Applying WSGI middleware"
msgstr "WSGI 미들웨어 적용방법"

msgid ""
"To apply :pep:`WSGI middleware <3333#middleware-components-that-play-both-"
"sides>` you can wrap the application object. For instance you could add "
"these lines at the bottom of :file:`wsgi.py`::"
msgstr ""
"적용 방법:pep:WSGI 미들웨어 <333# 미들웨어-구성 요소-저 양면 재생>은 애플리케"
"이션 객체를 포장할 수 있습니다. 예를 들어 :file:'wsgi'의 맨 아래에 이러한 줄"
"을 추가할 수 있습니다."

msgid ""
"You could also replace the Django WSGI application with a custom WSGI "
"application that later delegates to the Django WSGI application, if you want "
"to combine a Django application with a WSGI application of another framework."
msgstr ""
"또한 Django WSGI 응용 프로그램을 다른 프레임워크의 WSGI 응용 프로그램과 결합"
"하려면 Django WSGI 응용 프로그램을 나중에 Django WSGI 응용 프로그램으로 위임"
"하는 사용자 지정 WSGI 응용 프로그램으로 대체할 수 있습니다."

msgid "How to use Django with Apache and ``mod_wsgi``"
msgstr "django와 아파치 사용법, mod_wsgi 사용법"

msgid ""
"Deploying Django with Apache_ and `mod_wsgi`_ is a tried and tested way to "
"get Django into production."
msgstr ""
"django를 Apache_와 'mod_wsgi'와 함께 배치하는 것은 장고를 생산하기 위해 시도"
"되고 시험된 방법이다."

msgid ""
"mod_wsgi is an Apache module which can host any Python WSGI_ application, "
"including Django. Django will work with any version of Apache which supports "
"mod_wsgi."
msgstr ""
"mod_wsgi는 Django를 포함한 모든 Python WSGI_ 애플리케이션을 호스팅할 수 있는 "
"Apache 모듈입니다. Django는 mod_wsgi를 지원하는 Apache의 모든 버전에서 작동합"
"니다."

msgid ""
"The `official mod_wsgi documentation`_ is your source for all the details "
"about how to use mod_wsgi. You'll probably want to start with the "
"`installation and configuration documentation`_."
msgstr ""
"'공식 mod_wsgi 설명서'는 mod_wsgi 사용 방법에 대한 모든 세부 정보를 제공하는 "
"자료이다. 설치 및 구성 설명서부터 시작해 보십시오."

msgid "Basic configuration"
msgstr "기본 구성"

msgid ""
"Once you've got mod_wsgi installed and activated, edit your Apache server's "
"`httpd.conf`_ file and add the following."
msgstr ""
"mod_wsgi가 설치되어 활성화되면 Apache 서버의 'httpd.conf'_ 파일을 편집하고 다"
"음을 추가합니다."

msgid ""
"The first bit in the ``WSGIScriptAlias`` line is the base URL path you want "
"to serve your application at (``/`` indicates the root url), and the second "
"is the location of a \"WSGI file\" -- see below -- on your system, usually "
"inside of your project package (``mysite`` in this example). This tells "
"Apache to serve any request below the given URL using the WSGI application "
"defined in that file."
msgstr ""
"\"WSGIScriptAlias\" 라인에 있는 첫 번째 비트는 애플리케이션을 서비스하려는 기"
"본 URL 경로('/'는 루트 URL을 나타냄)이며, 두 번째 비트는 아래에서 참조하는 "
"WSGI 파일의 위치(일반적으로 프로젝트 패키지 내 \"my site\")입니다. 그러면 "
"Apache가 해당 파일에 정의된 WSGI 응용 프로그램을 사용하여 지정된 URL 아래의 "
"모든 요청을 처리하라는 메시지가 표시됩니다."

msgid ""
"If you install your project's Python dependencies inside a :mod:`virtual "
"environment <venv>`, add the path using ``WSGIPythonHome``. See the "
"`mod_wsgi virtual environment guide`_ for more details."
msgstr ""
"프로젝트의 Python 종속성을 :mod:'가상 환경'에 설치할 경우 \"WSGiPython Home"
"\"을 사용하여 경로를 추가하십시오. 자세한 내용은 'mod_wsgi 가상 환경 가이"
"드'를 참조하십시오."

msgid ""
"The ``WSGIPythonPath`` line ensures that your project package is available "
"for import on the Python path; in other words, that ``import mysite`` works."
msgstr ""
"\"WSG 파이톤 경로\" 라인은 당신의 프로젝트 패키지를 파이썬 경로에서 가져올 "
"수 있도록 보장하며, 다시 말해 \"내 사이트 가져오기\"는 효과가 있다."

msgid ""
"The ``<Directory>`` piece ensures that Apache can access your :file:`wsgi."
"py` file."
msgstr ""
"\"1'\"는 아파치가 당신의 :file:'wsgi에 접근할 수 있도록 보장한다.파이 파일"

msgid ""
"Next we'll need to ensure this :file:`wsgi.py` with a WSGI application "
"object exists. As of Django version 1.4, :djadmin:`startproject` will have "
"created one for you; otherwise, you'll need to create it. See the :doc:`WSGI "
"overview documentation</howto/deployment/wsgi/index>` for the default "
"contents you should put in this file, and what else you can add to it."
msgstr ""
"다음에는 파일:'wsgi'를 확인해야 합니다.WSGI 애플리케이션 객체가 있는 py가 존"
"재합니다. Django 버전 1.4부터는 :djadmin:'start project'가 사용자를 위해 생성"
"되며, 그렇지 않으면 사용자가 생성해야 합니다. :doc 참조:이 파일에 넣어야 할 "
"기본 콘텐츠에 대한 WSGI 개요 문서와 그 밖에 추가할 수 있는 콘텐츠를 보기위해"
"서는 :doc:`WSGI overview documentation 를 참조하세요"

msgid ""
"If multiple Django sites are run in a single mod_wsgi process, all of them "
"will use the settings of whichever one happens to run first. This can be "
"solved by changing::"
msgstr ""
"여러 개의 Django 사이트가 단일 mod_wsgi 프로세스에서 실행되는 경우, 이들 사이"
"트 모두 먼저 실행되는 사이트의 설정을 사용합니다. 이 문제는 다음을 변경하여 "
"해결할 수 있습니다."

msgid "in ``wsgi.py``, to::"
msgstr " ``wsgi.py``,를 어디로"

msgid ""
"or by :ref:`using mod_wsgi daemon mode<daemon-mode>` and ensuring that each "
"site runs in its own daemon process."
msgstr ""
"또는 :ref:'mod_wsgi 데몬 모드 사용'을 통해 각 사이트가 자체 데몬 프로세스로 "
"실행되도록 합니다."

msgid "Fixing ``UnicodeEncodeError`` for file uploads"
msgstr "파일 업로드를 위한 \"유니코드 인코딩 오류\" 수정"

msgid ""
"If you get a ``UnicodeEncodeError`` when uploading or writing files with "
"file names or content that contains non-ASCII characters, make sure Apache "
"is configured to support UTF-8 encoding::"
msgstr ""

msgid ""
"A common location to put this configuration is ``/etc/apache2/envvars``."
msgstr ""
"이 구성을 배치하는 공통 위치는 다음과 같습니다.``/etc/apache2/envvars``."

msgid ""
"Alternatively, if you are :ref:`using mod_wsgi daemon mode<daemon-mode>` you "
"can add ``lang`` and ``locale`` options to the ``WSGIDaemonProcess`` "
"directive::"
msgstr ""

msgid ""
"See the :ref:`unicode-files` section of the Unicode reference guide for "
"details."
msgstr ""
"자세한 내용은 유니코드 참조 안내서  :ref:`unicode-files` 의 섹션을 참조하십시"
"오."

msgid "Using ``mod_wsgi`` daemon mode"
msgstr "``mod_wsgi`` 데몬모드 사용법"

msgid ""
"\"Daemon mode\" is the recommended mode for running mod_wsgi (on non-Windows "
"platforms). To create the required daemon process group and delegate the "
"Django instance to run in it, you will need to add appropriate "
"``WSGIDaemonProcess`` and ``WSGIProcessGroup`` directives. A further change "
"required to the above configuration if you use daemon mode is that you can't "
"use ``WSGIPythonPath``; instead you should use the ``python-path`` option to "
"``WSGIDaemonProcess``, for example:"
msgstr ""
"\"데몬 모드\"는 Windows가 아닌 다른 플랫폼에서 mod_wsgi를 실행하는 데 권장되"
"는 모드입니다. 필요한 데몬 프로세스 그룹을 만들고 이를 실행할 Django 인스턴스"
"를 위임하려면 적절한 ``WSG DaemonProcess\"와 \"WSGIP ProcessGroup\" 지침을 추"
"가해야 한다. 데몬 모드를 사용할 경우 위의 구성에 추가로 필요한 변경 사항은 "
"``WSGiPythonPath\"를 사용할 수 없고 \"WSGidaemonProcess\"에 대한 \"python-"
"path\" 옵션을 사용해야 한다는 것이다."

msgid ""
"If you want to serve your project in a subdirectory (``https://example.com/"
"mysite`` in this example), you can add ``WSGIScriptAlias`` to the "
"configuration above:"
msgstr ""
"만약 당신이 당신의 프로젝트를 서브디렉토리(이 예에서 https://example.com/"
"mysite로 제공하기를 원한다면, 당신은 위의 구성에 \"WSGIScriptAlias\"를 추가"
"할 수 있다."

msgid ""
"See the official mod_wsgi documentation for `details on setting up daemon "
"mode`_."
msgstr ""
"'데몬 모드 설정에 대한 세부 정보'는 공식 mod_wsgi 설명서를 참조하십시오."

msgid "Serving files"
msgstr "파일 저장법"

msgid ""
"Django doesn't serve files itself; it leaves that job to whichever web "
"server you choose."
msgstr ""

msgid ""
"We recommend using a separate web server -- i.e., one that's not also "
"running Django -- for serving media. Here are some good choices:"
msgstr ""

msgid "Nginx_"
msgstr "Nginx_"

msgid "A stripped-down version of Apache_"
msgstr "Apache_의 stripped-down 버전"

msgid ""
"If, however, you have no option but to serve media files on the same Apache "
"``VirtualHost`` as Django, you can set up Apache to serve some URLs as "
"static media, and others using the mod_wsgi interface to Django."
msgstr ""
"그러나 만약 당신이 Django와 같은 Apache \"VirtualHost\"에서 미디어 파일을 제"
"공하는 것 외에 다른 방법이 없다면, 당신은 Django에 mod_wsgi 인터페이스를 사용"
"하여 일부 URL을 정적 미디어로 서비스하도록 Apache를 설정할 수 있다."

msgid ""
"This example sets up Django at the site root, but serves ``robots.txt``, "
"``favicon.ico``, and anything in the ``/static/`` and ``/media/`` URL space "
"as a static file. All other URLs will be served using mod_wsgi:"
msgstr ""
"이 예는 현지의 뿌리에 장고를 세우지만 ``로봇\"을 취급한다.txt, ``favicon.ico"
"\" 그리고 ``/staticon/\" 그리고 ``/media/\" URL 공간에 있는 모든 것을 정적 파"
"일로 저장한다. 다른 모든 URL은 mod_wsgi를 사용하여 제공됩니다."

msgid "Serving the admin files"
msgstr "관리자파일 제공"

msgid ""
"When :mod:`django.contrib.staticfiles` is in :setting:`INSTALLED_APPS`, the "
"Django development server automatically serves the static files of the admin "
"app (and any other installed apps). This is however not the case when you "
"use any other server arrangement. You're responsible for setting up Apache, "
"or whichever web server you're using, to serve the admin files."
msgstr ""

msgid ""
"The admin files live in (:file:`django/contrib/admin/static/admin`) of the "
"Django distribution."
msgstr ""
"admin 파일은 django 배포판의 (:file:'django/contrib/admin/static/admin')에 있"
"습니다."

msgid ""
"We **strongly** recommend using :mod:`django.contrib.staticfiles` to handle "
"the admin files (along with a web server as outlined in the previous "
"section; this means using the :djadmin:`collectstatic` management command to "
"collect the static files in :setting:`STATIC_ROOT`, and then configuring "
"your web server to serve :setting:`STATIC_ROOT` at :setting:`STATIC_URL`), "
"but here are three other approaches:"
msgstr ""

msgid ""
"Create a symbolic link to the admin static files from within your document "
"root (this may require ``+FollowSymLinks`` in your Apache configuration)."
msgstr ""
"문서 루트 내에서 관리 정적 파일에 대한 심볼 링크를 생성합니다(이 링크를 사용"
"하려면 Apache 구성에서 \"+FollowSymLinks\"가 필요할 수 있음)."

msgid ""
"Use an ``Alias`` directive, as demonstrated above, to alias the appropriate "
"URL (probably :setting:`STATIC_URL` + ``admin/``) to the actual location of "
"the admin files."
msgstr ""
"위에서 설명한 대로 \"Alias\" 지시문을 사용하여 적절한 URL(아마도 : setting: "
"설정)을 별칭으로 지정한다.STATIC_URL' + 관리 파일의 실제 위치에 \"admin/\"."

msgid ""
"Copy the admin static files so that they live within your Apache document "
"root."
msgstr "관리 정적 파일이 Apache 문서 루트 내에 있도록 복사합니다."

msgid "Authenticating against Django's user database from Apache"
msgstr "Apache에서 Django의 사용자 데이터베이스에 대해 인증"

msgid ""
"Django provides a handler to allow Apache to authenticate users directly "
"against Django's authentication backends. See the :doc:`mod_wsgi "
"authentication documentation </howto/deployment/wsgi/apache-auth>`."
msgstr ""
"Django는 Apache가 Django의 인증 백엔드에 대해 사용자를 직접 인증할 수 있도록 "
"하는 핸들러를 제공합니다. :doc:'mod_wsgi 인증확인 문서'를 참조하십시오."

msgid "How to use Django with uWSGI"
msgstr "uWSGI와 함께 django를 사용하는 방법"

msgid ""
"uWSGI_ is a fast, self-healing and developer/sysadmin-friendly application "
"container server coded in pure C."
msgstr ""
"uWSGI_은(는) 빠르고 자가 치료 및 개발/sysadmin 친화적인 애플리케이션 컨테이"
"너 서버로, 순수 C로 코딩되어 있습니다."

msgid ""
"The uWSGI docs offer a `tutorial`_ covering Django, nginx, and uWSGI (one "
"possible deployment setup of many). The docs below are focused on how to "
"integrate Django with uWSGI."
msgstr ""
"uWSGI 문서는 Django, nginx 및 uWSGI(다수의 배포 설정 중 하나)를 포함하는 '자"
"습서'를 제공한다. 아래 문서는 Django를 uWSGI와 통합하는 방법에 초점을 맞추고 "
"있습니다."

msgid "Prerequisite: uWSGI"
msgstr "전제 조건  : uWSGI"

msgid ""
"The uWSGI wiki describes several `installation procedures`_. Using pip, the "
"Python package manager, you can install any uWSGI version with a single "
"command. For example:"
msgstr ""
"uWSGI 위키에는 여러 설치 절차가 설명되어 있다. Python 패키지 관리자 pip을 사"
"용하면 단일 명령으로 uWSGI 버전을 설치할 수 있습니다. 예:"

msgid "uWSGI model"
msgstr "uWSGI 모델"

msgid ""
"uWSGI operates on a client-server model. Your web server (e.g., nginx, "
"Apache) communicates with a ``django-uwsgi`` \"worker\" process to serve "
"dynamic content."
msgstr ""

msgid "Configuring and starting the uWSGI server for Django"
msgstr "Django용 uWSGI 서버 구성 및 시작"

msgid ""
"uWSGI supports multiple ways to configure the process. See uWSGI's "
"`configuration documentation`_."
msgstr ""
"uWSGI는 프로세스를 구성하는 다양한 방법을 지원합니다. uWSGI의 '구성 설명"
"서'를 참조하십시오."

msgid "Here's an example command to start a uWSGI server::"
msgstr "다음은 uWSGI 서버를 시작하는 예제 명령입니다."

msgid ""
"This assumes you have a top-level project package named ``mysite``, and "
"within it a module :file:`mysite/wsgi.py` that contains a WSGI "
"``application`` object. This is the layout you'll have if you ran ``django-"
"admin startproject mysite`` (using your own project name in place of "
"``mysite``) with a recent version of Django. If this file doesn't exist, "
"you'll need to create it. See the :doc:`/howto/deployment/wsgi/index` "
"documentation for the default contents you should put in this file and what "
"else you can add to it."
msgstr ""
"이것은 당신이 \"mysite\"라는 이름의 최고 수준의 프로젝트 패키지를 가지고 있"
"고 그 안에 파일:mysite/wsgi라는 모듈이 있다고 가정한다.WSGI의 \"응용프로그램"
"\"을 담고 있는 py. 최신 버전의 장고와 함께 ``장고 관리 시작 프로젝트 my site"
"\" (내 사이트 대신 자신의 프로젝트 이름을 사용함)를 실행하면 이렇게 배치된"
"다. 이 파일이 없으면 파일을 만들어야 합니다. 이 파일에 넣어야 하는 기본 내용"
"과 파일에 추가할 수 있는 내용은 :doc:'/how to/deploy/wsgi/index' 문서를 참조"
"하십시오."

msgid "The Django-specific options here are:"
msgstr "여기서 Django별 옵션은 다음과 같습니다."

msgid ""
"``chdir``: The path to the directory that needs to be on Python's import "
"path -- i.e., the directory containing the ``mysite`` package."
msgstr ""
"\"치디르: Python의 가져오기 경로에 있어야 하는 디렉터리(즉, \"mysite\" 패키지"
"를 포함하는 디렉터리)의 경로입니다."

msgid ""
"``module``: The WSGI module to use -- probably the ``mysite.wsgi`` module "
"that :djadmin:`startproject` creates."
msgstr ""
"\"말하자면: 사용할 WSGI 모듈 - 아마도 \"내 사이트\"일 것이다.假admin:'start "
"project'가 만드는 wsgi² 모듈."

msgid ""
"``env``: Should probably contain at least :envvar:`DJANGO_SETTINGS_MODULE`."
msgstr "``env``: 최소한은  :envvar:`DJANGO_SETTINGS_MODULE`. 을 포함해야 한다."

msgid "``home``: Optional path to your project virtual environment."
msgstr "\"홈\": 프로젝트 가상 환경에 대한 옵션 경로입니다."

msgid "Example ini configuration file::"
msgstr "ini 구성 파일의 예:"

msgid "Example ini configuration file usage::"
msgstr "ini 구성 파일 사용 예:"

msgid ""
"If you get a ``UnicodeEncodeError`` when uploading files with file names "
"that contain non-ASCII characters, make sure uWSGI is configured to accept "
"non-ASCII file names by adding this to your ``uwsgi.ini``::"
msgstr ""
"비ASC 파일 이름을 가진 파일을 업로드할 때 \"유니코드 인코딩 오류\"가 발생하"
"는 경우II 문자, \"uwsgi\"에 추가하여 uWSGI가 ASCII가 아닌 파일 이름을 허용하"
"도록 구성되었는지 확인하십시오.이니:"

msgid ""
"See the uWSGI docs on `managing the uWSGI process`_ for information on "
"starting, stopping and reloading the uWSGI workers."
msgstr ""
"uWSGI 작업자의 시작, 중지 및 재로드에 대한 내용은 uWSGI 프로세스 관리(uWSGI "
"프로세스 관리) 문서를 참조하십시오."

msgid "How to manage error reporting"
msgstr ""

msgid ""
"When you're running a public site you should always turn off the :setting:"
"`DEBUG` setting. That will make your server run much faster, and will also "
"prevent malicious users from seeing details of your application that can be "
"revealed by the error pages."
msgstr ""
"공용 사이트를 실행할 때는 항상 :설정 기능을 해제해야 합니다.'DEBUG' 설정입니"
"다. 이렇게 하면 서버가 훨씬 더 빨리 실행될 수 있으며, 악성 사용자가 오류 페이"
"지에서 나타날 수 있는 응용프로그램의 세부 정보를 볼 수 없게 됩니다."

msgid ""
"However, running with :setting:`DEBUG` set to ``False`` means you'll never "
"see errors generated by your site -- everyone will instead see your public "
"error pages. You need to keep track of errors that occur in deployed sites, "
"so Django can be configured to create reports with details about those "
"errors."
msgstr ""
"그러나 :설정으로 실행:디버그가 \"거짓\"으로 설정된 것은 당신의 사이트에서 발"
"생한 오류를 절대 보지 못한다는 것을 의미하며, 그 대신 모든 사람이 당신의 공"
"개 오류 페이지를 보게 될 것이다. 배포된 사이트에서 발생하는 오류를 추적해야 "
"하므로 Django가 이러한 오류에 대한 세부 정보가 포함된 보고서를 생성하도록 구"
"성할 수 있습니다."

msgid "Email reports"
msgstr "이메일 보고"

msgid "Server errors"
msgstr "서버 오류"

msgid ""
"When :setting:`DEBUG` is ``False``, Django will email the users listed in "
"the :setting:`ADMINS` setting whenever your code raises an unhandled "
"exception and results in an internal server error (strictly speaking, for "
"any response with an HTTP status code of 500 or greater). This gives the "
"administrators immediate notification of any errors. The :setting:`ADMINS` "
"will get a description of the error, a complete Python traceback, and "
"details about the HTTP request that caused the error."
msgstr ""
"시기:설정:DEBUG는 \"False\"이며, Django는 다음과 같은 설정에 나열된 사용자에"
"게 e-메일을 보낼 것이다.코드가 처리되지 않은 예외를 발생시키고 내부 서버 오류"
"가 발생할 때마다 'ADMIN'을 설정합니다( 엄밀히 말하면 HTTP 상태 코드가 500 이"
"상인 응답의 경우). 이렇게 하면 관리자는 오류를 즉시 알 수 있습니다. :설"
"정:'ADMIN'은 오류에 대한 설명, 완전한 Python 추적, 오류를 발생시킨 HTTP 요청"
"에 대한 세부 정보를 얻을 것이다."

msgid ""
"In order to send email, Django requires a few settings telling it how to "
"connect to your mail server. At the very least, you'll need to specify :"
"setting:`EMAIL_HOST` and possibly :setting:`EMAIL_HOST_USER` and :setting:"
"`EMAIL_HOST_PASSWORD`, though other settings may be also required depending "
"on your mail server's configuration. Consult :doc:`the Django settings "
"documentation </ref/settings>` for a full list of email-related settings."
msgstr ""
"전자 메일을 보내기 위해 Django는 메일 서버에 연결하는 방법을 알려주는 몇 가"
"지 설정이 필요합니다. 최소한 설정:을 지정해야 합니다.'E-MAIL_HOST' 및 가능한 "
"설정:'EMAIL_HOST_USER' 및 :설정:메일 서버의 구성에 따라 다른 설정이 필요할 수"
"도 있지만 'EMAIL_HOST_PASSWORD'입니다. 이메일 관련 설정의 전체 목록은 :"
"doc:'Django 설정 설명서'를 참조하십시오."

msgid ""
"By default, Django will send email from root@localhost. However, some mail "
"providers reject all email from this address. To use a different sender "
"address, modify the :setting:`SERVER_EMAIL` setting."
msgstr ""
"기본적으로 Django는 root@localhost에서 이메일을 전송합니다. 그러나 일부 메일 "
"공급자는 이 주소의 모든 전자 메일을 거부합니다. 다른 발송인 주소를 사용하려"
"면 :seting:'을 수정하십시오.SERVER_EMail' 설정입니다."

msgid ""
"To activate this behavior, put the email addresses of the recipients in the :"
"setting:`ADMINS` setting."
msgstr ""
"이 동작을 활성화하려면 수신자의 전자 메일 주소를 : 설정에 입력하십시"
"오.'ADMIN' 설정."

msgid ""
"Server error emails are sent using the logging framework, so you can "
"customize this behavior by :doc:`customizing your logging configuration </"
"topics/logging>`."
msgstr ""
"서버 오류 전자 메일은 로깅 프레임워크를 사용하여 전송되므로 :doc:'로그 구성 "
"사용자 지정'을 통해 이 동작을 사용자 지정할 수 있습니다."

msgid "404 errors"
msgstr "404 오류"

msgid ""
"Django can also be configured to email errors about broken links (404 \"page "
"not found\" errors). Django sends emails about 404 errors when:"
msgstr ""
"끊어진 링크에 대한 전자 메일 오류(404 \"페이지 없음\" 오류)로 Django를 구성"
"할 수도 있습니다. Django는 다음과 같은 경우 약 404개의 오류를 이메일로 전송합"
"니다."

msgid ":setting:`DEBUG` is ``False``;"
msgstr ":설정:`DEBUG` 는 \"거짓\"이다"

msgid ""
"Your :setting:`MIDDLEWARE` setting includes :class:`django.middleware.common."
"BrokenLinkEmailsMiddleware`."
msgstr ""
"설정:`MIDDLEWARE` 설정은 :class:`django.middleware.common."
"BrokenLinkEmailsMiddleware`.을 포함된다"

msgid ""
"If those conditions are met, Django will email the users listed in the :"
"setting:`MANAGERS` setting whenever your code raises a 404 and the request "
"has a referer. It doesn't bother to email for 404s that don't have a referer "
"-- those are usually people typing in broken URLs or broken web bots. It "
"also ignores 404s when the referer is equal to the requested URL, since this "
"behavior is from broken web bots too."
msgstr ""

msgid ""
":class:`~django.middleware.common.BrokenLinkEmailsMiddleware` must appear "
"before other middleware that intercepts 404 errors, such as :class:`~django."
"middleware.locale.LocaleMiddleware` or :class:`~django.contrib.flatpages."
"middleware.FlatpageFallbackMiddleware`. Put it toward the top of your :"
"setting:`MIDDLEWARE` setting."
msgstr ""

msgid ""
"You can tell Django to stop reporting particular 404s by tweaking the :"
"setting:`IGNORABLE_404_URLS` setting. It should be a list of compiled "
"regular expression objects. For example::"
msgstr ""
": setting을 수정하여 Django에게 특정 404s에 대한 보고를 중지하라고 지시할 수 "
"있습니다.IGNORABLE_404_URL의 설정입니다. 컴파일된 정규식 개체의 목록이어야 합"
"니다. "

msgid ""
"In this example, a 404 to any URL ending with ``.php`` or ``.cgi`` will "
"*not* be reported. Neither will any URL starting with ``/phpmyadmin/``."
msgstr ""
": 설정을 수정하여 Django에게 특정 404에 대한 보고를 중지하도록 지시할 수 있습"
"니다.IGNERGABLE_404_URL에 대한 설정. 컴파일된 정규식 개체 목록이어야 합니다. "
"예:"

msgid ""
"The following example shows how to exclude some conventional URLs that "
"browsers and crawlers often request::"
msgstr ""
"다음 예에서는 브라우저 및 크롤러가 자주 요청하는 일부 기존 URL을 제외하는 방"
"법을 보여 줍니다."

msgid ""
"(Note that these are regular expressions, so we put a backslash in front of "
"periods to escape them.)"
msgstr ""
"(참고로 이것들은 정규 표현식입니다. 그래서 우리는 그것들을 피하기 위해 기간 "
"앞에 역슬래시를 붙였습니다.)"

msgid ""
"If you'd like to customize the behavior of :class:`django.middleware.common."
"BrokenLinkEmailsMiddleware` further (for example to ignore requests coming "
"from web crawlers), you should subclass it and override its methods."
msgstr ""
":class:`django.middleware.common의 동작을 사용자 지정하려면끊어진 링크 이메"
"일 미들웨어의 추가(예: 웹 크롤러에서 오는 요청을 무시하려면)를 하위 분류하고 "
"메소드를 재정의해야 합니다."

msgid ""
"404 errors are logged using the logging framework. By default, these log "
"records are ignored, but you can use them for error reporting by writing a "
"handler and :doc:`configuring logging </topics/logging>` appropriately."
msgstr ""
"404개의 오류는 로깅 프레임워크를 사용하여 기록됩니다. 기본적으로 이러한 로그 "
"레코드는 무시되지만, 처리기와 :doc:'로그 구성'을 적절하게 작성하여 오류 보고"
"에 사용할 수 있습니다."

msgid "Filtering error reports"
msgstr "오류 보고서 필터링"

msgid ""
"Filtering sensitive data is a hard problem, and it's nearly impossible to "
"guarantee that sensitive data won't leak into an error report. Therefore, "
"error reports should only be available to trusted team members and you "
"should avoid transmitting error reports unencrypted over the internet (such "
"as through email)."
msgstr ""

msgid "Filtering sensitive information"
msgstr "중요한 정보 필터링"

msgid ""
"Error reports are really helpful for debugging errors, so it is generally "
"useful to record as much relevant information about those errors as "
"possible. For example, by default Django records the `full traceback`_ for "
"the exception raised, each `traceback frame`_’s local variables, and the :"
"class:`~django.http.HttpRequest`’s :ref:`attributes<httprequest-attributes>`."
msgstr ""
"오류 보고서는 오류를 디버깅하는 데 매우 유용하므로 일반적으로 이러한 오류에 "
"대한 관련 정보를 가능한 많이 기록하는 것이 유용합니다. 예를 들어, 기본적으로 "
"Django는 제기된 예외에 대해 'full traceback'_, 각 'traceback frame'_의 로컬 "
"변수 및 :class를 기록합니다.'~django.the'HttpRequest's:ref:'attributes1'입니"
"다."

msgid ""
"However, sometimes certain types of information may be too sensitive and "
"thus may not be appropriate to be kept track of, for example a user's "
"password or credit card number. So in addition to filtering out settings "
"that appear to be sensitive as described in the :setting:`DEBUG` "
"documentation, Django offers a set of function decorators to help you "
"control which information should be filtered out of error reports in a "
"production environment (that is, where :setting:`DEBUG` is set to "
"``False``): :func:`sensitive_variables` and :func:"
"`sensitive_post_parameters`."
msgstr ""
"그러나 때로는 특정 유형의 정보가 너무 민감하여 사용자의 암호 또는 신용 카드 "
"번호와 같이 추적하기에 적절하지 않을 수 있다. 따라서 :설정의 설명에 따라 중요"
"한 설정을 필터링하는 것 외에도 다음과 같은 작업을 수행할 수 있습니다.'DEBUG' "
"설명서인 Django는 실운영 환경에서 오류 보고서(여기서: setting: setting:디버그"
"는 func:'sensitive_variables'와 func:'sensitive_post_parameters'로 설정되어 "
"있다."

msgid ""
"If a function (either a view or any regular callback) in your code uses "
"local variables susceptible to contain sensitive information, you may "
"prevent the values of those variables from being included in error reports "
"using the ``sensitive_variables`` decorator::"
msgstr ""
"코드의 함수(보기 또는 일반 콜백)가 중요한 정보를 포함할 수 있는 로컬 변수를 "
"사용하는 경우 \"sensitive_variables\" decorator를 사용하여 해당 변수 값이 오"
"류 보고서에 포함되지 않도록 방지할 수 있습니다."

msgid ""
"In the above example, the values for the ``user``, ``pw`` and ``cc`` "
"variables will be hidden and replaced with stars (``**********``) in the "
"error reports, whereas the value of the ``name`` variable will be disclosed."
msgstr ""
"위의 예에서 \"user\", \"pw\" 및 \"cc\" 변수의 값은 오류 보고에 숨겨져 별"
"('*************)로 대체되며 \"name\" 변수의 값은 공개된다."

msgid ""
"To systematically hide all local variables of a function from error logs, do "
"not provide any argument to the ``sensitive_variables`` decorator::"
msgstr ""
"오류 로그에서 함수의 모든 로컬 변수를 체계적으로 숨기려면 "
"\"sensitive_variables\" decorator에 어떤 인수도 제공하지 마십시오."

msgid "When using multiple decorators"
msgstr "여러 개의 장식자를 사용하는 경우"

msgid ""
"If the variable you want to hide is also a function argument (e.g. "
"'``user``’ in the following example), and if the decorated function has "
"multiple decorators, then make sure to place ``@sensitive_variables`` at the "
"top of the decorator chain. This way it will also hide the function argument "
"as it gets passed through the other decorators::"
msgstr ""
"숨기려는 변수가 함수 인수(예: 다음 예에서는 'user' user')이고, 장식된 함수에 "
"여러 개의 장식기가 있는 경우, 반드시 \"@sensitive_variables\"를 장식자 체인"
"의 맨 위에 놓아야 한다. 이렇게 하면 다른 장식자를 통과할 때 함수 인수도 숨겨"
"집니다."

msgid ""
"If one of your views receives an :class:`~django.http.HttpRequest` object "
"with :attr:`POST parameters<django.http.HttpRequest.POST>` susceptible to "
"contain sensitive information, you may prevent the values of those "
"parameters from being included in the error reports using the "
"``sensitive_post_parameters`` decorator::"
msgstr ""
"만약 당신의 견해를 피력하는을 받는다:수업:`~django.http.HttpRequest` 개체:항"
"목을 보강:`POSTparameters<django.http.HttpRequest.POST>`민감한 정보를 담아 취"
"약해 당신은 예방할 수 있다.이런 변수들의 오류 보고서도"
"``sensitive_post_parameters\"실내 장식가를 사용하여 포함되는에서 값::."

msgid ""
"In the above example, the values for the ``pass_word`` and "
"``credit_card_number`` POST parameters will be hidden and replaced with "
"stars (``**********``) in the request's representation inside the error "
"reports, whereas the value of the ``name`` parameter will be disclosed."
msgstr ""
"위의 예에서 \"pass_word\"와 \"credit_card_number\" POST 매개 변수의 값은 오"
"류 보고 내 요청 표현에 숨겨져 별('********')로 대체되며, \"이름\" 매개 변수"
"의 값은 공개된다."

msgid ""
"To systematically hide all POST parameters of a request in error reports, do "
"not provide any argument to the ``sensitive_post_parameters`` decorator::"
msgstr ""
"오류 보고서에서 요청의 모든 POST 매개 변수를 체계적으로 숨기려면 "
"``sensitive_post_parameters\" 장식자에게 어떤 인수도 제공하지 마십시오."

msgid ""
"All POST parameters are systematically filtered out of error reports for "
"certain :mod:`django.contrib.auth.views` views (``login``, "
"``password_reset_confirm``, ``password_change``, and ``add_view`` and "
"``user_change_password`` in the ``auth`` admin) to prevent the leaking of "
"sensitive information such as user passwords."
msgstr ""
"모든 POST 매개 변수는 특정:mod:'django.contrib에 대한 오류 보고서에서 체계적"
"으로 필터링됩니다.auth.password, ``password_reset_password\", "
"\"password_changes\", \"add_view\" 및 \"user_change_password in ``auth 관리자"
"\"에서 보기 때문에 사용자 암호와 같은 중요한 정보가 유출되는 것을 방지할 수 "
"있다."

msgid "Custom error reports"
msgstr "사용자 정의 오류 리포트"

msgid ""
"All :func:`sensitive_variables` and :func:`sensitive_post_parameters` do is, "
"respectively, annotate the decorated function with the names of sensitive "
"variables and annotate the ``HttpRequest`` object with the names of "
"sensitive POST parameters, so that this sensitive information can later be "
"filtered out of reports when an error occurs. The actual filtering is done "
"by Django's default error reporter filter: :class:`django.views.debug."
"SafeExceptionReporterFilter`. This filter uses the decorators' annotations "
"to replace the corresponding values with stars (``**********``) when the "
"error reports are produced. If you wish to override or customize this "
"default behavior for your entire site, you need to define your own filter "
"class and tell Django to use it via the :setting:"
"`DEFAULT_EXCEPTION_REPORTER_FILTER` setting::"
msgstr ""
"func:'sensitive_variables'와 :func:'sensitive_post_parameters' do는 각각 민감"
"한 변수의 이름으로 장식된 함수에 주석을 달고 \"HttpRequest\" 객체에 민감한 "
"POST 매개 변수의 이름으로 주석을 달기 때문에 오류가 발생할 때 이러한 민감한 "
"정보가 보고서에서 필터링될 수 있다. 실제 필터링은 Django의 기본 오류 리포터 "
"필터 :class:'django에 의해 수행됩니다.경치, 경치,경치"
"SafeExceptionReporterFilter'. 이 필터는 오류 보고가 생성될 때 장식자의 주석"
"을 사용하여 해당 값을 별('********')로 바꿉니다. 전체 사이트에 대해 이 기본 "
"동작을 재정의하거나 사용자 지정하려면 사용자 고유의 필터 클래스를 정의하고 "
"Django에게 :seting:을 통해 사용하도록 지시해야 합니"
"다.'DEFAULT_EXTECTION_REPORTER_FILTER' 설정:"

msgid ""
"You may also control in a more granular way which filter to use within any "
"given view by setting the ``HttpRequest``’s ``exception_reporter_filter`` "
"attribute::"
msgstr ""
"또한 ``HttpRequest\"의 ``exception_reporter_filter\" 속성을 설정하여 어떤 필"
"터를 어떤 뷰에서 사용할지 보다 세밀하게 제어할 수도 있다."

msgid ""
"Your custom filter class needs to inherit from :class:`django.views.debug."
"SafeExceptionReporterFilter` and may override the following attributes and "
"methods:"
msgstr ""
"사용자 지정 필터 클래스는 :class:'django'에서 상속해야 합니다.경치, 경치,경치"
"SafeExceptionReporterFilter'는 다음과 같은 특성 및 방법을 재정의할 수 있습니"
"다."

msgid ""
"The string value to replace sensitive value with. By default it replaces the "
"values of sensitive variables with stars (``**********``)."
msgstr ""
"중요한 값을 대체할 문자열 값입니다. 기본적으로 이것은 민감한 변수의 값을 별"
"('**********')로 바꿉니다."

msgid ""
"A compiled regular expression object used to match settings and ``request."
"META`` values considered as sensitive. By default equivalent to::"
msgstr ""
"설정 및 ``요청\"을 일치시키는 데 사용되는 컴파일된 정규식 개체입니다.META의 "
"가치는 민감한 것으로 간주되고 있습니다. 기본적으로 다음과 같습니다."

msgid ""
"Returns ``True`` to activate the filtering in :meth:`get_post_parameters` "
"and :meth:`get_traceback_frame_variables`. By default the filter is active "
"if :setting:`DEBUG` is ``False``. Note that sensitive ``request.META`` "
"values are always filtered along with sensitive setting values, as described "
"in the :setting:`DEBUG` documentation."
msgstr ""
":meth:'get_post_parameters' 및 :meth:'get_traceback_frame_variables'에서 필터"
"링을 활성화하기 위해 \"True\"를 반환합니다. 다음과 같은 경우 필터는 기본적으"
"로 활성화됩니다.디버그는 거짓입니다. 민감한 ``요청\"에 주목하십시오.META의 값"
"은 :설정에서 설명한 대로 항상 민감한 설정값과 함께 필터링됩니다.'DEBUG' 설명"
"서입니다."

msgid ""
"Returns the filtered dictionary of POST parameters. Sensitive values are "
"replaced with :attr:`cleansed_substitute`."
msgstr ""
"POST 매개 변수의 필터링된 사전을 반환합니다. 중요한 값은 다음과 같이 대체됩니"
"다. attr:'cleaned_substitute'."

msgid ""
"Returns the filtered dictionary of local variables for the given traceback "
"frame. Sensitive values are replaced with :attr:`cleansed_substitute`."
msgstr ""
"지정된 추적 프레임에 대해 필터링된 로컬 변수 사전을 반환합니다. 중요한 값은 "
"다음과 같이 대체됩니다. attr:'cleaned_substitute'."

msgid ""
"If you need to customize error reports beyond filtering you may specify a "
"custom error reporter class by defining the :setting:"
"`DEFAULT_EXCEPTION_REPORTER` setting::"
msgstr ""
"필터링 이외의 오류 보고서를 사용자 정의해야 하는 경우 :setup을 정의하여 사용"
"자 정의 오류 보고자 클래스를 지정할 수 있습니다.'DEF_EXPECTION_REPORT' 설정"
"은 다음과 같습니다."

msgid ""
"The exception reporter is responsible for compiling the exception report "
"data, and formatting it as text or HTML appropriately. (The exception "
"reporter uses :setting:`DEFAULT_EXCEPTION_REPORTER_FILTER` when preparing "
"the exception report data.)"
msgstr ""
"예외 리포터는 예외 리포트 데이터를 컴파일하여 텍스트 또는 HTML로 적절하게 포"
"맷할 책임이 있습니다. (예외 리포터는 : setting:예외 리포트 데이터를 준비할 "
"때 'DEFAT_REPORTER_FILTER'를 입력하세요.)"

msgid ""
"Your custom reporter class needs to inherit from :class:`django.views.debug."
"ExceptionReporter`."
msgstr ""
"사용자 정의 리포터 클래스는 :class:`django.views.debug.ExceptionReporter`.에"
"서 상속해야 합니다."

msgid ""
"Property that returns a :class:`pathlib.Path` representing the absolute "
"filesystem path to a template for rendering the HTML representation of the "
"exception. Defaults to the Django provided template."
msgstr ""

msgid ""
"Property that returns a :class:`pathlib.Path` representing the absolute "
"filesystem path to a template for rendering the plain-text representation of "
"the exception. Defaults to the Django provided template."
msgstr ""

msgid "Return a dictionary containing traceback information."
msgstr "추적 정보가 들어 있는 사전을 반환합니다."

msgid ""
"This is the main extension point for customizing exception reports, for "
"example::"
msgstr "예외 보고서를 사용자 지정하기 위한 기본 확장 지점입니다. 예:"

msgid "Return HTML version of exception report."
msgstr "예외 보고서의 HTML 버전을 반환합니다."

msgid "Used for HTML version of debug 500 HTTP error page."
msgstr "디버그 500 HTTP 오류 페이지의 HTML 버전에 사용됩니다."

msgid "Return plain text version of exception report."
msgstr "예외 보고서의 일반 텍스트 버전을 반환합니다."

msgid ""
"Used for plain text version of debug 500 HTTP error page and email reports."
msgstr ""
"디버그 500 HTTP 오류 페이지 및 전자 메일 보고서의 일반 텍스트 버전에 사용됩니"
"다."

msgid ""
"As with the filter class, you may control which exception reporter class to "
"use within any given view by setting the ``HttpRequest``’s "
"``exception_reporter_class`` attribute::"
msgstr ""
"필터 클래스와 마찬가지로 \"HttpRequest\"의 \"exception_reporter_class\" 속성"
"을 설정하여 지정된 보기 내에서 사용할 예외 리포터 클래스를 제어할 수 있습니"
"다."

msgid ""
"You can also set up custom error reporting by writing a custom piece of :ref:"
"`exception middleware <exception-middleware>`. If you do write custom error "
"handling, it's a good idea to emulate Django's built-in error handling and "
"only report/log errors if :setting:`DEBUG` is ``False``."
msgstr ""
"또한 :ref의 사용자 정의 부분을 작성하여 사용자 정의 오류 보고를 설정할 수도 "
"있습니다.'중략 미들웨어'입니다. 사용자 정의 오류 처리를 작성하는 경우 다음과 "
"같은 경우 Django의 기본 오류 처리를 에뮬레이트하는 것이 좋습니다.디버그는 거"
"짓입니다."

msgid "\"How-to\" guides"
msgstr "\"How-to\" 가이드"

msgid ""
"Here you'll find short answers to \"How do I....?\" types of questions. "
"These how-to guides don't cover topics in depth -- you'll find that material "
"in the :doc:`/topics/index` and the :doc:`/ref/index`. However, these guides "
"will help you quickly accomplish common tasks."
msgstr ""
"\"...을 어떻게 해야 하나요?\"에 대한 짧은 대답을 여기서 찾을 수 있습니다. 이 "
"how-to 가이드는 주제를 깊이 있게 다루지 않으며, :doc:`/topics/index`\\와 :"
"doc:`/ref/index`\\에서 관련 자료를 얻을 수 있습니다. 이 가이드는 일반적인 작"
"업을 재빨리 완수하는 데 도움이 될 것입니다."

msgid ""
"The `Django community aggregator`_, where we aggregate content from the "
"global Django community. Many writers in the aggregator write this sort of "
"how-to material."
msgstr ""
"`Django community aggregator`_\\는 전세계 Django 커뮤니티의 콘텐츠를 모으는 "
"곳입니다. 많은 저자들이 이러한 how-to 자료를 작성하고 있습니다."

msgid "How to provide initial data for models"
msgstr ""

msgid ""
"It's sometimes useful to pre-populate your database with hard-coded data "
"when you're first setting up an app. You can provide initial data with "
"migrations or fixtures."
msgstr ""
"응용프로그램을 처음 설정할 때 하드 코딩된 데이터로 데이터베이스를 미리 채우"
"는 것이 유용합니다. 마이그레이션 또는 고정 장치와 함께 초기 데이터를 제공할 "
"수 있습니다."

msgid "Providing initial data with migrations"
msgstr "마이그레이션으로 초기 데이터 제공하기."

msgid ""
"If you want to automatically load initial data for an app, create a :ref:"
"`data migration <data-migrations>`. Migrations are run when setting up the "
"test database, so the data will be available there, subject to :ref:`some "
"limitations <test-case-serialized-rollback>`."
msgstr ""
"앱의 초기 데이터를 자동으로 로드하려면 :ref:'데이터 마이그레이션'을 생성하십"
"시오. 마이그레이션은 테스트 데이터베이스를 설정할 때 실행되므로:ref:'일부 제"
"한 사항'에 따라 데이터를 사용할 수 있습니다."

msgid "Providing data with fixtures"
msgstr "고정 장치를 통해 데이터를 제공합니다."

msgid ""
"You can also provide data using fixtures, however, this data isn't loaded "
"automatically, except if you use :attr:`.TransactionTestCase.fixtures`."
msgstr ""
"고정 장치를 사용하여 데이터를 제공할 수도 있지만 이 데이터는 :attr:`."
"TransactionTestCase.fixtures`. 를  사용하는 경우를 제외하고 자동으로 로드되"
"지 않습니다."

msgid ""
"A fixture is a collection of data that Django knows how to import into a "
"database. The most straightforward way of creating a fixture if you've "
"already got some data is to use the :djadmin:`manage.py dumpdata <dumpdata>` "
"command. Or, you can write fixtures by hand; fixtures can be written as "
"JSON, XML or YAML (with PyYAML_ installed) documents. The :doc:"
"`serialization documentation </topics/serialization>` has more details about "
"each of these supported :ref:`serialization formats <serialization-formats>`."
msgstr ""
"고정 장치는 Django가 데이터베이스로 가져오는 방법을 알고 있는 데이터의 모음입"
"니다. 데이터가 이미 있는 경우 고정장치를 만드는 가장 간단한 방법은 :"
"tembadmin:'manage.py dumpdata' 명령을 사용하는 것입니다. 또는 수동으로 고정장"
"치를 작성할 수 있으며 고정장치는 JSON, XML 또는 YAML(PyYAML_installed) 문서"
"로 작성할 수 있습니다. :doc:'직렬화 설명서'는 지원되는 각:ref:'직렬화 형"
"식'에 대한 자세한 정보를 제공합니다."

msgid ""
"As an example, though, here's what a fixture for a ``Person`` model might "
"look like in JSON:"
msgstr "그러나 한 예로 JSON에서 \"사람\" 모델의 고정장치는 다음과 같습니다."

msgid "And here's that same fixture as YAML:"
msgstr "그리고 YAML로 된 동일한 fixture 가 있습니다."

msgid "You'll store this data in a ``fixtures`` directory inside your app."
msgstr "이 데이터는 앱 안에 있는 \"고정장치\" 디렉토리에 저장됩니다."

msgid ""
"You can load data by calling :djadmin:`manage.py loaddata <loaddata>` "
"``<fixturename>``, where ``<fixturename>`` is the name of the fixture file "
"you've created. Each time you run :djadmin:`loaddata`, the data will be read "
"from the fixture and re-loaded into the database. Note this means that if "
"you change one of the rows created by a fixture and then run :djadmin:"
"`loaddata` again, you'll wipe out any changes you've made."
msgstr ""
":djadmin:'manage'를 호출하여 데이터를 로드할 수 있습니다.pyload data ``\"는 "
"당신이 만든 fixture 파일의 이름입니다. 실행할 때마다:djadmin:load data(로드 "
"데이터)는 고정장치에서 데이터를 읽고 데이터베이스에 다시 로드됩니다. 이는 고"
"정 장치에 의해 생성된 행 중 하나를 변경한 후 다음을 실행하는 경우입니다.데이"
"터를 다시 로드하면 변경 내용이 모두 지워집니다."

msgid "Where Django finds fixture files"
msgstr "Django가 고정 파일을 찾는 위치입니다."

msgid ""
"By default, Django looks in the ``fixtures`` directory inside each app for "
"fixtures. You can set the :setting:`FIXTURE_DIRS` setting to a list of "
"additional directories where Django should look."
msgstr ""
"기본적으로 Django는 각 앱에 있는 \"fixtures\" 디렉토리에서 고정 장치를 찾습니"
"다. : 설정을 설정할 수 있습니다.FIXT_DIRS는 Django가 찾아야 할 추가 디렉토리 "
"목록으로 설정됩니다."

msgid ""
"When running :djadmin:`manage.py loaddata <loaddata>`, you can also specify "
"a path to a fixture file, which overrides searching the usual directories."
msgstr ""
"실행 시 :djadmin:'manage'입니다.py load data'. 고정 파일 경로를 지정할 수도 "
"있습니다. 이 경로는 일반적인 디렉터리 검색을 재정의합니다"

msgid ""
"Fixtures are also used by the :ref:`testing framework <topics-testing-"
"fixtures>` to help set up a consistent test environment."
msgstr ""
"또한 :ref:'testing framework'에서는 고정장치를 사용하여 일관된 테스트 환경을 "
"설정할 수 있습니다."

msgid "How to integrate Django with a legacy database"
msgstr ""

msgid ""
"While Django is best suited for developing new applications, it's quite "
"possible to integrate it into legacy databases. Django includes a couple of "
"utilities to automate as much of this process as possible."
msgstr ""
"Django는 새로운 애플리케이션을 개발하는 데 가장 적합하지만, 기존 데이터베이스"
"에 통합하는 것이 가능합니다. Django에는 이 프로세스를 최대한 자동화하기 위한 "
"몇 가지 유틸리티가 포함되어 있습니다."

msgid ""
"This document assumes you know the Django basics, as covered in the :doc:"
"`tutorial </intro/tutorial01>`."
msgstr ""
"이 문서에서는 :doc:'tutorial'에서 설명한 대로 Django 기본 사항을 알고 있다고 "
"가정합니다."

msgid ""
"Once you've got Django set up, you'll follow this general process to "
"integrate with an existing database."
msgstr ""
"Django를 설정하면 이 일반 프로세스에 따라 기존 데이터베이스와 통합됩니다."

msgid "Give Django your database parameters"
msgstr "Django에게 데이터베이스 매개 변수를 제공하십시오."

msgid ""
"You'll need to tell Django what your database connection parameters are, and "
"what the name of the database is. Do that by editing the :setting:"
"`DATABASES` setting and assigning values to the following keys for the "
"``'default'`` connection:"
msgstr ""
"데이터베이스 연결 매개 변수가 무엇이고 데이터베이스 이름이 무엇인지 Django에"
"게 알려야 합니다. 다음과 같은 설정을 편집하여 작업을 수행합니다.'데이터베이"
"스' 설정 및 \"기본값\" 연결을 위해 다음 키에 값을 할당합니다."

msgid ":setting:`NAME`"
msgstr "설정:`NAME`"

msgid ":setting:`ENGINE <DATABASE-ENGINE>`"
msgstr ":설정:`ENGINE 1`"

msgid ":setting:`USER`"
msgstr ":설정:`USER`"

msgid ":setting:`PASSWORD`"
msgstr ":설정:`PASSWORD`"

msgid ":setting:`HOST`"
msgstr ":설정:`HOST`"

msgid ":setting:`PORT`"
msgstr ":설정:`PORT`"

msgid "Auto-generate the models"
msgstr "자동으로 생성된 모델"

msgid ""
"Django comes with a utility called :djadmin:`inspectdb` that can create "
"models by introspecting an existing database. You can view the output by "
"running this command::"
msgstr ""
"Django는 기존 데이터베이스를 검사하여 모델을 만들 수 있는 :"
"djadmin:'inspectdb'라는 유틸리티와 함께 제공됩니다. 다음 명령을 실행하여 출력"
"을 볼 수 있습니다."

msgid "Save this as a file by using standard Unix output redirection::"
msgstr "표준 Unix 출력 리디렉션을 사용하여 다음을 파일로 저장합니다."

msgid ""
"This feature is meant as a shortcut, not as definitive model generation. See "
"the :djadmin:`documentation of inspectdb <inspectdb>` for more information."
msgstr ""
"이 기능은 결정적인 모델 생성이 아닌 바로 가기 기능을 의미합니다. 자세한 내용"
"은 :djadmin:'inspectdb' 설명서를 참조하십시오."

msgid ""
"Once you've cleaned up your models, name the file ``models.py`` and put it "
"in the Python package that holds your app. Then add the app to your :setting:"
"`INSTALLED_APPS` setting."
msgstr ""
"모델을 정리했으면 파일의 이름을 \"모델\"로 지정하십시오.py'를 앱이 들어 있는 "
"python 패키지에 넣어주세요. 그런 다음 앱을 :seting:'에 추가합니다.설치되었습"
"니다.APPs의 설정입니다."

msgid ""
"By default, :djadmin:`inspectdb` creates unmanaged models. That is, "
"``managed = False`` in the model's ``Meta`` class tells Django not to manage "
"each table's creation, modification, and deletion::"
msgstr ""
"기본적으로 :djadmin:'inspectdb'는 관리되지 않는 모델을 생성합니다. 즉, 모델"
"의 ``메타\" 클래스에 있는 ``관리된 = False\"는 Django에게 각 테이블의 생성, "
"수정 및 삭제를 관리하지 말라고 말합니다."

msgid ""
"If you do want to allow Django to manage the table's lifecycle, you'll need "
"to change the :attr:`~django.db.models.Options.managed` option above to "
"``True`` (or remove it because ``True`` is its default value)."
msgstr ""
"Django가 테이블의 라이프사이클을 관리하도록 허용하려면 :attr:'~django.db."
"models를 변경해야 합니다.위의 옵션.managed는 \"True\"에 대한 옵션(또는 \"True"
"\"가 기본값이기 때문에 제거)을 의미합니다."

msgid "Install the core Django tables"
msgstr "코어 Django 테이블을 설치합니다"

msgid ""
"Next, run the :djadmin:`migrate` command to install any extra needed "
"database records such as admin permissions and content types::"
msgstr ""
"그런 다음 :djadmin:'migrate' 명령을 실행하여 관리자 권한 및 컨텐츠 유형과 같"
"이 추가로 필요한 데이터베이스 레코드를 설치합니다."

msgid "Test and tweak"
msgstr "테스트 및 조정하십시오."

msgid ""
"Those are the basic steps -- from here you'll want to tweak the models "
"Django generated until they work the way you'd like. Try accessing your data "
"via the Django database API, and try editing objects via Django's admin "
"site, and edit the models file accordingly."
msgstr ""
"이것이 기본 단계입니다. 여기서 Django가 만든 모델을 원하는 방식으로 작동할 때"
"까지 수정해야 합니다. Django 데이터베이스 API를 통해 데이터에 액세스하고 "
"Django의 관리 사이트를 통해 개체를 편집한 다음 그에 따라 모델 파일을 편집하십"
"시오."

msgid "How to configure and use logging"
msgstr ""

msgid ":ref:`Django logging reference <logging-ref>`"
msgstr ""

msgid ":ref:`Django logging overview <logging-explanation>`"
msgstr ""

msgid ""
"Django provides a working :ref:`default logging configuration <default-"
"logging-configuration>` that is readily extended."
msgstr ""

msgid "Make a basic logging call"
msgstr ""

msgid ""
"To send a log message from within your code, you place a logging call into "
"it."
msgstr ""

msgid "Don't be tempted to use logging calls in ``settings.py``."
msgstr ""

msgid ""
"The way that Django logging is configured as part of the ``setup()`` "
"function means that logging calls placed in ``settings.py`` may not work as "
"expected, because *logging will not be set up at that point*. To explore "
"logging, use a view function as suggested in the example below."
msgstr ""

msgid ""
"First, import the Python logging library, and then obtain a logger instance "
"with :py:func:`logging.getLogger`. Provide the ``getLogger()`` method with a "
"name to identify it and the records it emits. A good option is to use "
"``__name__`` (see :ref:`naming-loggers` below for more on this) which will "
"provide the name of the current Python module as a dotted path::"
msgstr ""

msgid "It's a good convention to perform this declaration at module level."
msgstr ""

msgid ""
"And then in a function, for example in a view, send a record to the logger::"
msgstr ""

msgid ""
"When this code is executed, a :py:class:`~logging.LogRecord` containing that "
"message will be sent to the logger. If you're using Django's default logging "
"configuration, the message will appear in the console."
msgstr ""

msgid ""
"The ``WARNING`` level used in the example above is one of several :ref:"
"`logging severity levels <topic-logging-parts-loggers>`: ``DEBUG``, "
"``INFO``, ``WARNING``, ``ERROR``, ``CRITICAL``. So, another example might "
"be::"
msgstr ""

msgid ""
"Records with a level lower than ``WARNING`` will not appear in the console "
"by default. Changing this behavior requires additional configuration."
msgstr ""

msgid "Customize logging configuration"
msgstr ""

msgid ""
"Although Django's logging configuration works out of the box, you can "
"control exactly how your logs are sent to various destinations - to log "
"files, external services, email and so on - with some additional "
"configuration."
msgstr ""

msgid "You can configure:"
msgstr ""

msgid "logger mappings, to determine which records are sent to which handlers"
msgstr ""

msgid "handlers, to determine what they do with the records they receive"
msgstr ""

msgid ""
"filters, to provide additional control over the transfer of records, and "
"even modify records in-place"
msgstr ""

msgid ""
"formatters, to convert :class:`~logging.LogRecord` objects to a string or "
"other form for consumption by human beings or another system"
msgstr ""

msgid ""
"There are various ways of configuring logging. In Django, the :setting:"
"`LOGGING` setting is most commonly used. The setting uses the :ref:"
"`dictConfig format <logging-config-dictschema>`, and extends the :ref:"
"`default logging configuration <default-logging-definition>`."
msgstr ""

msgid ""
"See :ref:`configuring-logging` for an explanation of how your custom "
"settings are merged with Django's defaults."
msgstr ""

msgid ""
"See the :mod:`Python logging documentation <python:logging.config>` for "
"details of other ways of configuring logging. For the sake of simplicity, "
"this documentation will only consider configuration via the ``LOGGING`` "
"setting."
msgstr ""

msgid "Basic logging configuration"
msgstr ""

msgid "When configuring logging, it makes sense to"
msgstr ""

msgid "Create a ``LOGGING`` dictionary"
msgstr ""

msgid "In your ``settings.py``::"
msgstr ""

msgid ""
"It nearly always makes sense to retain and extend the default logging "
"configuration by setting ``disable_existing_loggers`` to ``False``."
msgstr ""

msgid "Configure a handler"
msgstr ""

msgid ""
"This example configures a single handler named ``file``, that uses Python's :"
"class:`~logging.FileHandler` to save logs of level ``DEBUG`` and higher to "
"the file ``general.log`` (at the project root):"
msgstr ""

msgid ""
"Different handler classes take different configuration options. For more "
"information on available handler classes, see the :class:`~django.utils.log."
"AdminEmailHandler` provided by Django and the various :py:mod:`handler "
"classes <logging.handlers>` provided by Python."
msgstr ""

msgid ""
"Logging levels can also be set on the handlers (by default, they accept log "
"messages of all levels). Using the example above, adding:"
msgstr ""

msgid ""
"would define a handler configuration that only accepts records of level "
"``DEBUG`` and higher."
msgstr ""

msgid "Configure a logger mapping"
msgstr ""

msgid ""
"To send records to this handler, configure a logger mapping to use it for "
"example:"
msgstr ""

msgid ""
"The mapping's name determines which log records it will process. This "
"configuration (``''``) is *unnamed*. That means that it will process records "
"from *all* loggers (see :ref:`naming-loggers` below on how to use the "
"mapping name to determine the loggers for which it will process records)."
msgstr ""

msgid ""
"It will forward messages of levels ``DEBUG`` and higher to the handler named "
"``file``."
msgstr ""

msgid ""
"Note that a logger can forward messages to multiple handlers, so the "
"relation between loggers and handlers is many-to-many."
msgstr ""

msgid "If you execute::"
msgstr ""

msgid ""
"in your code, you will find that message in the file ``general.log`` in the "
"root of the project."
msgstr ""

msgid "Configure a formatter"
msgstr ""

msgid ""
"By default, the final log output contains the message part of each :class:"
"`log record <logging.LogRecord>`. Use a formatter if you want to include "
"additional data. First name and define your formatters - this example "
"defines formatters named ``verbose`` and ``simple``:"
msgstr ""

msgid ""
"The ``style`` keyword allows you to specify ``{`` for :meth:`str.format` or "
"``$`` for :class:`string.Template` formatting; the default is ``$``."
msgstr ""

msgid ""
"See :ref:`logrecord-attributes` for the :class:`~logging.LogRecord` "
"attributes you can include."
msgstr ""

msgid ""
"To apply a formatter to a handler, add a ``formatter`` entry to the "
"handler's dictionary referring to the formatter by name, for example:"
msgstr ""

msgid "Use logger namespacing"
msgstr ""

msgid ""
"The unnamed logging configuration ``''`` captures logs from any Python "
"application. A named logging configuration will capture logs only from "
"loggers with matching names."
msgstr ""

msgid ""
"The namespace of a logger instance is defined using :py:func:`~logging."
"getLogger`. For example in ``views.py`` of ``my_app``::"
msgstr ""

msgid ""
"will create a logger in the ``my_app.views`` namespace. ``__name__`` allows "
"you to organize log messages according to their provenance within your "
"project's applications automatically. It also ensures that you will not "
"experience name collisions."
msgstr ""

msgid ""
"A logger mapping named ``my_app.views`` will capture records from this "
"logger:"
msgstr ""

msgid ""
"A logger mapping named ``my_app`` will be more permissive, capturing records "
"from loggers anywhere within the ``my_app`` namespace (including ``my_app."
"views``, ``my_app.utils``, and so on):"
msgstr ""

msgid "You can also define logger namespacing explicitly::"
msgstr ""

msgid "and set up logger mappings accordingly."
msgstr ""

msgid "Using logger hierarchies and propagation"
msgstr ""

msgid ""
"Logger naming is *hierarchical*. ``my_app`` is the parent of ``my_app."
"views``, which is the parent of ``my_app.views.private``. Unless specified "
"otherwise, logger mappings will propagate the records they process to their "
"parents - a record from a logger in the ``my_app.views.private`` namespace "
"will be handled by a mapping for both ``my_app`` and ``my_app.views``."
msgstr ""

msgid ""
"To manage this behavior, set the propagation key on the mappings you define::"
msgstr ""

msgid ""
"``propagate`` defaults to ``True``. In this example, the logs from ``my_app."
"views.private`` will not be handled by the parent, but logs from ``my_app."
"views`` will."
msgstr ""

msgid "Configure responsive logging"
msgstr ""

msgid ""
"Logging is most useful when it contains as much information as possible, but "
"not information that you don't need - and how much you need depends upon "
"what you're doing. When you're debugging, you need a level of information "
"that would be excessive and unhelpful if you had to deal with it in "
"production."
msgstr ""

msgid ""
"You can configure logging to provide you with the level of detail you need, "
"when you need it. Rather than manually change configuration to achieve this, "
"a better way is to apply configuration automatically according to the "
"environment."
msgstr ""

msgid ""
"For example, you could set an environment variable ``DJANGO_LOG_LEVEL`` "
"appropriately in your development and staging environments, and make use of "
"it in a logger mapping thus::"
msgstr ""

msgid ""
"\\- so that unless the environment specifies a lower log level, this "
"configuration will only forward records of severity ``WARNING`` and above to "
"its handler."
msgstr ""

msgid ""
"Other options in the configuration (such as the ``level`` or ``formatter`` "
"option of handlers) can be similarly managed."
msgstr ""

msgid "How to create CSV output"
msgstr ""

msgid ""
"This document explains how to output CSV (Comma Separated Values) "
"dynamically using Django views. To do this, you can either use the Python "
"CSV library or the Django template system."
msgstr ""
"이 문서에서는 Django 보기를 사용하여 CSV(Comma Separated Values)를 동적으로 "
"출력하는 방법에 대해 설명합니다. 이를 위해 Python CSV 라이브러리 또는 Django "
"템플릿 시스템을 사용할 수 있습니다."

msgid "Using the Python CSV library"
msgstr "파이썬 CSV 라이브러리 사용하기"

msgid ""
"Python comes with a CSV library, :mod:`csv`. The key to using it with Django "
"is that the :mod:`csv` module's CSV-creation capability acts on file-like "
"objects, and Django's :class:`~django.http.HttpResponse` objects are file-"
"like objects."
msgstr ""
"Python은 CSV 라이브러리인 :mod:'csv'와 함께 제공됩니다. Django와 함께 사용하"
"기 위한 핵심은 :mod:'csv' 모듈의 CSV-생성 기능이 파일 같은 개체에 작용하고 "
"Django의 :class는 다음과 같습니다.'~django.the' 입니다.HttpResponse' 객체는 "
"파일 유사 객체입니다."

msgid "Here's an example::"
msgstr "여기 예제가 있습니다::"

msgid ""
"The code and comments should be self-explanatory, but a few things deserve a "
"mention:"
msgstr "코드와 코멘트는 자명해야 하지만 몇 가지 사항은 언급할 가치가 있습니다."

msgid ""
"The response gets a special MIME type, :mimetype:`text/csv`. This tells "
"browsers that the document is a CSV file, rather than an HTML file. If you "
"leave this off, browsers will probably interpret the output as HTML, which "
"will result in ugly, scary gobbledygook in the browser window."
msgstr ""
"응답에는 특수 MIME 유형인 :mimtype:'text/csv'가 있습니다. 이것은 문서가 HTML "
"파일이 아닌 CSV 파일임을 브라우저에 알려줍니다. 이 기능을 해제하면 브라우저"
"가 출력을 HTML로 해석하여 브라우저 창에서 보기 흉하고 무서운 단어를 만들 수 "
"있습니다."

msgid ""
"The response gets an additional ``Content-Disposition`` header, which "
"contains the name of the CSV file. This filename is arbitrary; call it "
"whatever you want. It'll be used by browsers in the \"Save as...\" dialog, "
"etc."
msgstr ""
"이 응답에는 CSV 파일의 이름이 포함된 \"Content-Disposition\" 헤더가 추가됩니"
"다. 이 파일 이름은 임의이므로 원하는 대로 불러 주십시오. 브라우저가 \"다른 이"
"름으로 저장...\"에서 사용합니다.대화 상자 등입니다."

msgid ""
"You can hook into the CSV-generation API by passing ``response`` as the "
"first argument to ``csv.writer``. The ``csv.writer`` function expects a file-"
"like object, and :class:`~django.http.HttpResponse` objects fit the bill."
msgstr ""
"\"csv.writer\"에 대한 첫 번째 논거로 \"대응\"을 전달함으로써 CSV 세대 API에 "
"연결할 수 있습니다. \"csv.writer\" 기능은 파일 같은 객체를 기대하며 :class는 "
"다음과 같습니다.'~django.the' 입니다.HttpResponse' 객체가 빌에 맞습니다."

msgid ""
"For each row in your CSV file, call ``writer.writerow``, passing it an :term:"
"`iterable`."
msgstr ""
"CSV 파일의 각 행에 대해 ''writer''로 전화하십시오.\"글쓴다\"는 뜻으로 \"표절"
"할 수 있다\"라는 말을 씁니다."

msgid ""
"The CSV module takes care of quoting for you, so you don't have to worry "
"about escaping strings with quotes or commas in them. Pass ``writerow()`` "
"your raw strings, and it'll do the right thing."
msgstr ""
"CSV 모듈은 견적을 처리하므로 따옴표 또는 쉼표가 포함된 문자열을 이스케이프할 "
"필요가 없습니다. \"원래의 조건\"을 넘기면 옳은 일을 할 수 있을 것입니다."

msgid "Streaming large CSV files"
msgstr "대용량 CSV 파일들을 스트리밍하기"

msgid ""
"When dealing with views that generate very large responses, you might want "
"to consider using Django's :class:`~django.http.StreamingHttpResponse` "
"instead. For example, by streaming a file that takes a long time to generate "
"you can avoid a load balancer dropping a connection that might have "
"otherwise timed out while the server was generating the response."
msgstr ""
"매우 큰 응답을 생성하는 보기를 처리할 때 Django의 :class:를 사용하는 것을 고"
"려할 수 있습니다.'~django.the' 입니다.대신 스트리밍HttpResponse'입니다. 예를 "
"들어, 생성하는 데 시간이 오래 걸리는 파일을 스트리밍하면 서버가 응답을 생성하"
"는 동안 시간 초과되었을 수 있는 연결을 로드 밸런서가 삭제하지 않도록 방지할 "
"수 있습니다."

msgid ""
"In this example, we make full use of Python generators to efficiently handle "
"the assembly and transmission of a large CSV file::"
msgstr ""
"이 예에서는 Python 생성기를 최대한 활용하여 대형 CSV 파일의 어셈블리 및 전송"
"을 효율적으로 처리합니다."

msgid "Using the template system"
msgstr "템플릿 시스템 사용하기"

msgid ""
"Alternatively, you can use the :doc:`Django template system </topics/"
"templates>` to generate CSV. This is lower-level than using the convenient "
"Python :mod:`csv` module, but the solution is presented here for "
"completeness."
msgstr ""
"또는 :doc을 사용할 수 있습니다.CSV를 생성하기 위한 '장고 템플릿 시스템'입니"
"다. 이는 편리한 Python:mod:'csv' 모듈을 사용하는 것보다 낮은 수준이지만, 완벽"
"함을 위해 솔루션을 제공합니다."

msgid ""
"The idea here is to pass a list of items to your template, and have the "
"template output the commas in a :ttag:`for` loop."
msgstr ""
"여기서의 아이디어는 템플릿에 항목 목록을 전달하고 템플릿이 쉼표를 :"
"ttag:'for' 루프에 출력하도록 하는 것입니다."

msgid "Here's an example, which generates the same CSV file as above::"
msgstr "다음은 위와 동일한 CSV 파일을 생성하는 예입니다."

msgid ""
"The only difference between this example and the previous example is that "
"this one uses template loading instead of the CSV module. The rest of the "
"code -- such as the ``content_type='text/csv'`` -- is the same."
msgstr ""
"이 예와 이전 예와의 유일한 차이점은 이 예에서는 CSV 모듈 대신 템플릿 로드를 "
"사용한다는 것입니다. \"content_type type'text/csv\"와 같은 나머지 코드는 동일"
"합니다."

msgid ""
"Then, create the template ``my_template_name.txt``, with this template code:"
msgstr ""
"그런 다음 ''my_template_name' 템플릿을 생성합니다.txt², 이 템플릿 코드로 다음"
"을 수행합니다."

msgid ""
"This short template iterates over the given data and displays a line of CSV "
"for each row. It uses the :tfilter:`addslashes` template filter to ensure "
"there aren't any problems with quotes."
msgstr ""
"이 짧은 템플릿은 지정된 데이터에 대해 반복되고 각 행에 대해 CSV 줄을 표시합니"
"다. :t filter:'addslash' 템플릿 필터를 사용하여 따옴표에 문제가 없도록 합니"
"다."

msgid "Other text-based formats"
msgstr "기타 텍스트 기반 형식입니다."

msgid ""
"Notice that there isn't very much specific to CSV here -- just the specific "
"output format. You can use either of these techniques to output any text-"
"based format you can dream of. You can also use a similar technique to "
"generate arbitrary binary data; see :doc:`/howto/outputting-pdf` for an "
"example."
msgstr ""
"CSV에 대한 구체적인 내용은 없고 특정 출력 형식만 있습니다. 이러한 기술 중 하"
"나를 사용하여 원하는 텍스트 기반 형식을 출력할 수 있습니다. 유사한 기술을 사"
"용하여 임의 이진 데이터를 생성할 수도 있습니다. 예제는 :doc:'/howto/output-"
"pdf'를 참조하십시오."

msgid "How to create PDF files"
msgstr ""

msgid ""
"This document explains how to output PDF files dynamically using Django "
"views. This is made possible by the excellent, open-source ReportLab_ Python "
"PDF library."
msgstr ""
"이 문서에서는 Django 보기를 사용하여 PDF 파일을 동적으로 출력하는 방법을 설명"
"합니다. 이는 우수한 오픈 소스 ReportLab_Python PDF 라이브러리를 통해 가능합니"
"다."

msgid ""
"The advantage of generating PDF files dynamically is that you can create "
"customized PDFs for different purposes -- say, for different users or "
"different pieces of content."
msgstr ""
"PDF 파일을 동적으로 생성할 수 있는 이점은 사용자나 컨텐츠의 다양한 용도로 사"
"용자 정의된 PDF를 생성할 수 있다는 것입니다."

msgid ""
"For example, Django was used at kusports.com_ to generate customized, "
"printer-friendly NCAA tournament brackets, as PDF files, for people "
"participating in a March Madness contest."
msgstr ""
"예를 들어, Django는 kusports.com_에서 3월 Madness 대회에 참가하는 사람들을 위"
"해 PDF 파일로 사용자 정의되고 프린터 친화적인 NCAA 토너먼트 브래킷을 생성하"
"는 데 사용되었습니다."

msgid "Install ReportLab"
msgstr "ReportLab을 설치합니다."

msgid ""
"The ReportLab library is `available on PyPI`_. A `user guide`_ (not "
"coincidentally, a PDF file) is also available for download. You can install "
"ReportLab with ``pip``:"
msgstr ""
"ReportLab 라이브러리는 PyPI에서 사용할 수 있습니다. 사용자 가이드(PDF 파일)"
"도 다운로드할 수 있습니다. \"pip\"로 ReportLab을 설치할 수 있습니다."

msgid ""
"Test your installation by importing it in the Python interactive "
"interpreter::"
msgstr "Python 대화형 인터프리터를 사용하여 설치를 테스트합니다."

msgid "If that command doesn't raise any errors, the installation worked."
msgstr "해당 명령으로 인해 오류가 발생하지 않으면 설치가 작동했습니다."

msgid "Write your view"
msgstr "당신의 견해를 쓰시오."

msgid ""
"The key to generating PDFs dynamically with Django is that the ReportLab API "
"acts on file-like objects, and Django's :class:`~django.http.FileResponse` "
"objects accept file-like objects."
msgstr ""
"Django를 사용하여 PDF를 동적으로 생성하기 위한 핵심은 ReportLab API가 파일과 "
"유사한 개체에 대해 작동하고 Django의 :class:'~django.the' 입니다.파일 응답' "
"개체는 파일 유사 개체를 수락합니다."

msgid "Here's a \"Hello World\" example::"
msgstr "다음은 \"Hello World\"의 예입니다."

msgid ""
"The response will automatically set the MIME type :mimetype:`application/"
"pdf` based on the filename extension. This tells browsers that the document "
"is a PDF file, rather than an HTML file or a generic :mimetype:`application/"
"octet-stream` binary content."
msgstr ""
"응답은 파일 이름 확장자에 따라 자동으로 MIME 유형:mimtype:'application/"
"pdf'를 설정합니다. 이것은 브라우저에게 문서가 HTML 파일이나 일반적인 :"
"mimetype:'application/octet-stream' 바이너리 콘텐츠가 아닌 PDF 파일임을 알려"
"줍니다."

msgid ""
"When ``as_attachment=True`` is passed to ``FileResponse``, it sets the "
"appropriate ``Content-Disposition`` header and that tells web browsers to "
"pop-up a dialog box prompting/confirming how to handle the document even if "
"a default is set on the machine. If the ``as_attachment`` parameter is "
"omitted, browsers will handle the PDF using whatever program/plugin they've "
"been configured to use for PDFs."
msgstr ""

msgid ""
"You can provide an arbitrary ``filename`` parameter. It'll be used by "
"browsers in the \"Save as...\" dialog."
msgstr ""
"임의의 \"파일 이름\" 매개 변수를 제공할 수 있습니다. 브라우저가 \"다른 이름으"
"로 저장...\"에서 사용합니다.\" 대화 상자입니다."

msgid ""
"You can hook into the ReportLab API: The same buffer passed as the first "
"argument to ``canvas.Canvas`` can be fed to the :class:`~django.http."
"FileResponse` class."
msgstr ""
"ReportLab API에 연결할 수 있습니다. \"캔버스\"에 대한 첫 번째 주장과 같은 완"
"충장치가 통과되었습니다.캔버스'는 :class에 제공할 수 있습니다.'~django.the' "
"입니다.파일 응답 클래스입니다."

msgid ""
"Note that all subsequent PDF-generation methods are called on the PDF object "
"(in this case, ``p``) -- not on ``buffer``."
msgstr ""
"이후의 모든 PDF 생성 방법은 \"버퍼\"가 아닌 PDF 객체(이 경우 \"p\")로 호출됩"
"니다."

msgid ""
"Finally, it's important to call ``showPage()`` and ``save()`` on the PDF "
"file."
msgstr ""
"마지막으로 PDF 파일로 ``쇼 페이지\"와 \"저장(save)\"을 부르는 것이 중요합니"
"다."

msgid ""
"ReportLab is not thread-safe. Some of our users have reported odd issues "
"with building PDF-generating Django views that are accessed by many people "
"at the same time."
msgstr ""
"ReportLab은 스레드 세이프가 아닙니다. 일부 사용자가 PDF 생성 Django 뷰를 구축"
"하는 과정에서 여러 사용자가 동시에 액세스할 수 있는 이상한 문제가 발생했다고 "
"보고했습니다."

msgid "Other formats"
msgstr "다른 포맷"

msgid ""
"Notice that there isn't a lot in these examples that's PDF-specific -- just "
"the bits using ``reportlab``. You can use a similar technique to generate "
"any arbitrary format that you can find a Python library for. Also see :doc:`/"
"howto/outputting-csv` for another example and some techniques you can use "
"when generated text-based formats."
msgstr ""
"이러한 예에서는 PDF에 특정한 것이 많지 않으며 단지 \"보고서 실험실\"을 사용"
"한 일부입니다. 유사한 기술을 사용하여 Python 라이브러리를 찾을 수 있는 임의 "
"형식을 생성할 수 있습니다. 또한 다른 예와 텍스트 기반 형식을 생성할 때 사용"
"할 수 있는 몇 가지 기법은 :doc:'/how to/outputing-csv'를 참조하십시오."

msgid ""
"Django Packages provides a `comparison of packages <https://djangopackages."
"org/grids/g/pdf/>`_ that help generate PDF files from Django."
msgstr ""
"Django Package는 Django에서 PDF 파일을 생성하는 데 도움이 되는 'packages "
"https://djangopackages.org/grids/g/pdf/'을 제공합니다."

msgid "How to override templates"
msgstr ""

msgid ""
"In your project, you might want to override a template in another Django "
"application, whether it be a third-party application or a contrib "
"application such as ``django.contrib.admin``. You can either put template "
"overrides in your project's templates directory or in an application's "
"templates directory."
msgstr ""
"프로젝트에서 타사 애플리케이션이든 ``django.contrib.admin\"과 같은 기여 애플"
"리케이션이든 다른 Django 애플리케이션의 템플릿을 재정의하는 것이 좋습니다. 프"
"로젝트의 템플릿 디렉토리 또는 응용프로그램의 템플리트 디렉토리에 템플리트 재"
"정의를 넣을 수 있습니다."

msgid ""
"If you have app and project templates directories that both contain "
"overrides, the default Django template loader will try to load the template "
"from the project-level directory first. In other words, :setting:`DIRS "
"<TEMPLATES-DIRS>` is searched before :setting:`APP_DIRS <TEMPLATES-"
"APP_DIRS>`."
msgstr ""
"앱 및 프로젝트 템플릿 디렉터리에 모두 재정의가 포함된 경우 기본 Django 템플"
"릿 로더가 먼저 프로젝트 수준 디렉터리에서 템플릿을 로드하려고 시도합니다. "
"즉, :설정:'입니다.DIRS'가 다음 설정 전에 검색됩니다.'APP_DIRS'입니다."

msgid ""
"Read :ref:`overriding-built-in-widget-templates` if you're looking to do "
"that."
msgstr "ref:를 읽습니다.그렇게 하려면 붙박이장 같은 것도 있어야죠."

msgid "Overriding from the project's templates directory"
msgstr "프로젝트의 템플릿 디렉터리에서 재정의합니다."

msgid ""
"First, we'll explore overriding templates by creating replacement templates "
"in your project's templates directory."
msgstr ""
"먼저 프로젝트의 템플릿 디렉터리에 교체 템플릿을 생성하여 템플릿을 재정의하는 "
"방법에 대해 알아봅니다."

msgid ""
"Let's say you're trying to override the templates for a third-party "
"application called ``blog``, which provides the templates ``blog/post.html`` "
"and ``blog/list.html``. The relevant settings for your project would look "
"like::"
msgstr ""
"당신이 ``blog/post.html\"과 \"blog/list.html\"을 제공하는 \"blog\"라는 제3자 "
"애플리케이션의 템플릿을 재정의하려고 한다고 가정해 보겠습니다. 프로젝트의 관"
"련 설정은 다음과 같습니다."

msgid ""
"The :setting:`TEMPLATES` setting and ``BASE_DIR`` will already exist if you "
"created your project using the default project template. The setting that "
"needs to be modified is :setting:`DIRS<TEMPLATES-DIRS>`."
msgstr ""
":설정:입니다.기본 프로젝트 템플릿을 사용하여 프로젝트를 생성했다면 템플릿 설"
"정과 ``BASE_DIR\"이 이미 존재하게 됩니다. 수정해야 할 설정은 : setting:'입니"
"다.DIRS입니다."

msgid ""
"These settings assume you have a ``templates`` directory in the root of your "
"project. To override the templates for the ``blog`` app, create a folder in "
"the ``templates`` directory, and add the template files to that folder:"
msgstr ""
"이러한 설정은 프로젝트의 루트에 \"템플릿\" 디렉토리를 가지고 있다고 가정합니"
"다. \"블로그\" 앱의 템플릿을 재정의하려면 \"템플릿\" 디렉터리에 폴더를 생성"
"한 다음 템플릿 파일을 해당 폴더에 추가하십시오."

msgid ""
"The template loader first looks for templates in the ``DIRS`` directory. "
"When the views in the ``blog`` app ask for the ``blog/post.html`` and ``blog/"
"list.html`` templates, the loader will return the files you just created."
msgstr ""
"템플릿 로더는 먼저 \"DIRS\" 디렉토리에서 템플릿을 찾습니다. \"blog\" 앱의 뷰"
"가 \"blog/post.html\"과 \"blog/list.html\" 템플릿을 요청하면 로더는 방금 만"
"든 파일을 반환합니다."

msgid "Overriding from an app's template directory"
msgstr "앱의 템플릿 디렉토리에서 재정의합니다."

msgid ""
"Since you're overriding templates located outside of one of your project's "
"apps, it's more common to use the first method and put template overrides in "
"a project's templates folder. If you prefer, however, it's also possible to "
"put the overrides in an app's template directory."
msgstr ""
"프로젝트의 앱 외부에 위치한 템플릿을 재정의하기 때문에 프로젝트의 템플릿 폴더"
"에 템플릿 재정의를 넣고 첫 번째 방법을 사용하는 것이 더 일반적입니다. 그러나 "
"원하는 경우 앱의 템플릿 디렉터리에 재정의를 넣을 수도 있습니다."

msgid ""
"First, make sure your template settings are checking inside app directories::"
msgstr "먼저 템플릿 설정이 앱 디렉터리 내에서 확인 중인지 확인합니다."

msgid ""
"If you want to put the template overrides in an app called ``myapp`` and the "
"templates to override are named ``blog/list.html`` and ``blog/post.html``, "
"then your directory structure will look like:"
msgstr ""
"\"myapp\"이라는 앱에 템플릿 재정의를 넣고 재정의할 템플릿 이름을 \"blog/list."
"html\"과 \"blog/post.html\"로 지정하면 디렉터리 구조는 다음과 같습니다."

msgid ""
"With :setting:`APP_DIRS<TEMPLATES-APP_DIRS>` set to ``True``, the template "
"loader will look in the app's templates directory and find the templates."
msgstr ""
"설정:을(설정):APP_DIRS가 \"참\"으로 설정되면 템플릿 로더가 앱의 템플릿 디렉토"
"리를 검색하여 템플릿을 찾습니다."

msgid "Extending an overridden template"
msgstr "재정의된 템플릿을 확장합니다."

msgid ""
"With your template loaders configured, you can extend a template using the :"
"ttag:`{% extends %}<extends>` template tag whilst at the same time "
"overriding it. This can allow you to make small customizations without "
"needing to reimplement the entire template."
msgstr ""
"템플릿 로더를 구성한 경우 :ttag:'{% extenses %}' 템플릿 태그를 사용하여 템플"
"릿을 확장하는 동시에 재정의할 수 있습니다. 이렇게 하면 전체 템플릿을 다시 구"
"현할 필요 없이 소규모 사용자 지정을 수행할 수 있습니다."

msgid ""
"For example, you can use this technique to add a custom logo to the ``admin/"
"base_site.html`` template:"
msgstr ""
"예를 들어 이 기술을 사용하여 ''admin/base_site.html' 템플릿에 사용자 정의 로"
"고를 추가할 수 있습니다."

msgid "templates/admin/base_site.html"
msgstr "templates/admin/base_site.html"

msgid "Key points to note:"
msgstr "주요 내용은 다음과 같습니다."

msgid ""
"The example creates a file at ``templates/admin/base_site.html`` that uses "
"the configured project-level ``templates`` directory to override ``admin/"
"base_site.html``."
msgstr ""
"이 예에서는 구성된 프로젝트 수준의 ``템플릿\" 디렉토리를 사용하여 ``admin/"
"base_site.html\"을 재정의하는 \"templates/admin/base_site.html\"에 파일을 생"
"성합니다."

msgid ""
"The new template extends ``admin/base_site.html``, which is the same "
"template as is being overridden."
msgstr ""
"새 템플릿은 \"admin/base_site.html\"을 확장하며, 이는 재정의되는 템플릿과 동"
"일합니다."

msgid ""
"The template replaces just the ``branding`` block, adding a custom logo, and "
"using ``block.super`` to retain the prior content."
msgstr ""
"템플릿은 단지 \"브랜드\" 블록을 대체하고 맞춤형 로고를 추가하고 \"블록\"을 사"
"용합니다.이전 내용을 보존할 수 있습니다."

msgid ""
"The rest of the template is inherited unchanged from ``admin/base_site."
"html``."
msgstr ""
"템플릿의 나머지 부분은``admin/base_site.html``.에서 변경되지 않은 상태로 상속"
"됩니다."

msgid ""
"This technique works because the template loader does not consider the "
"already loaded override template (at ``templates/admin/base_site.html``) "
"when resolving the ``extends`` tag. Combined with ``block.super`` it is a "
"powerful technique to make small customizations."
msgstr ""
"이 기술은 템플릿 로더가 ``확장\" 태그를 결정할 때 이미 로드된 오버라이드 템플"
"릿(\"templates/admin/base_site.html\")을 고려하지 않기 때문에 작동합니다. "
"\"블록\"과 결합합니다.Superdown은 작은 커스터마이징을 만드는 강력한 기술입니"
"다."

msgid "How to deploy static files"
msgstr ""

msgid ""
"For an introduction to the use of :mod:`django.contrib.staticfiles`, see :"
"doc:`/howto/static-files/index`."
msgstr ""
":mod:'django.contrib.static files'의 사용에 대한 자세한 내용은 :doc:'/how to/"
"static files/index'를 참조하십시오."

msgid "Serving static files in production"
msgstr "프로덕션에서 정적파일 제공하기"

msgid ""
"The basic outline of putting static files into production consists of two "
"steps: run the :djadmin:`collectstatic` command when static files change, "
"then arrange for the collected static files directory (:setting:"
"`STATIC_ROOT`) to be moved to the static file server and served. Depending "
"on :setting:`STATICFILES_STORAGE`, files may need to be moved to a new "
"location manually or the :func:`post_process <django.contrib.staticfiles."
"storage.StaticFilesStorage.post_process>` method of the ``Storage`` class "
"might take care of that."
msgstr ""
"정적 파일을 프로덕션에 넣는 기본 개요는 두 단계로 구성됩니다. 정적 파일이 변"
"경될 때 :djadmin:'collectstatic' 명령을 실행한 다음 수집된 정적 파일 디렉토리"
"(:seting:').STATIC_ROOT')를 정적 파일 서버로 이동하여 제공합니다. : 설정에 따"
"라 달라집니다.STATICFILES_STORY'에서 파일을 수동으로 새 위치로 이동하거나 :"
"func:'post_process <django.contrib.staticfiles.staticfiles.storage로 이동해"
"야 할 수 있습니다.정적 파일 저장소입니다.포스트_프로세스' 방식의 스토리지 클"
"래스가 이를 해결할 수도 있습니다."

msgid ""
"As with all deployment tasks, the devil's in the details. Every production "
"setup will be a bit different, so you'll need to adapt the basic outline to "
"fit your needs. Below are a few common patterns that might help."
msgstr ""
"모든 배포 작업과 마찬가지로 세부 사항도 중요합니다. 모든 프로덕션 설정은 약"
"간 다르므로 필요에 맞게 기본 개요를 조정해야 합니다. 다음은 도움이 될 수 있"
"는 몇 가지 일반적인 패턴입니다."

msgid "Serving the site and your static files from the same server"
msgstr "같은 서버에서 정적파일과 사이트를 제공하기"

msgid ""
"If you want to serve your static files from the same server that's already "
"serving your site, the process may look something like:"
msgstr ""
"사이트에 이미 서비스를 제공하고 있는 서버와 동일한 서버에서 정적 파일을 제공"
"하려는 경우 프로세스는 다음과 같을 수 있습니다."

msgid "Push your code up to the deployment server."
msgstr "개발서버로 코드 올리기"

msgid ""
"On the server, run :djadmin:`collectstatic` to copy all the static files "
"into :setting:`STATIC_ROOT`."
msgstr ""
"서버에서 :djadmin:'collectstatic'을 실행하여 모든 정적 파일을 :seting:'에 복"
"사합니다.STATIC_ROOT'입니다."

msgid ""
"Configure your web server to serve the files in :setting:`STATIC_ROOT` under "
"the URL :setting:`STATIC_URL`. For example, here's :ref:`how to do this with "
"Apache and mod_wsgi <serving-files>`."
msgstr ""
":seting:'에서 파일을 서비스하도록 웹 서버를 구성합니다.URL의 STATIC_ROOT' 아"
"래에 있습니다. 설정:':'STATIC_URL'입니다. 예를 들어 다음과 같습니다.Apache "
"및 mod_wsgi로 이 작업을 수행하는 방법입니다."

msgid ""
"You'll probably want to automate this process, especially if you've got "
"multiple web servers."
msgstr "특히 웹 서버가 여러 개인 경우 이 프로세스를 자동화할 수 있습니다."

msgid "Serving static files from a dedicated server"
msgstr "특정 서버에서 정적파일 제공하기"

msgid ""
"Most larger Django sites use a separate web server -- i.e., one that's not "
"also running Django -- for serving static files. This server often runs a "
"different type of web server -- faster but less full-featured. Some common "
"choices are:"
msgstr ""

msgid ""
"Configuring these servers is out of scope of this document; check each "
"server's respective documentation for instructions."
msgstr ""
"이 서버 구성은 이 문서의 범위를 벗어납니다. 각 서버의 해당 문서에서 지침을 확"
"인하십시오."

msgid ""
"Since your static file server won't be running Django, you'll need to modify "
"the deployment strategy to look something like:"
msgstr ""
"정적 파일 서버가 Django를 실행하지 않으므로 다음과 같이 배포 전략을 수정해야 "
"합니다."

msgid "When your static files change, run :djadmin:`collectstatic` locally."
msgstr ""
"정적 파일이 수정되었다면, 로컬에서 :djadmin:`collectstatic` 를 실행하세요."

msgid ""
"Push your local :setting:`STATIC_ROOT` up to the static file server into the "
"directory that's being served. `rsync <https://rsync.samba.org/>`_ is a "
"common choice for this step since it only needs to transfer the bits of "
"static files that have changed."
msgstr ""
"로컬:설정:'를 누릅니다.STATIC_ROOT'을(를) 정적 파일 서버에 올려서 서비스 중"
"인 디렉토리에 넣습니다. 'rsync https://rsync.samba.org/'_은(는) 변경된 정적 "
"파일의 비트만 전송하면 되기 때문에 이 단계에서 흔히 선택할 수 있습니다."

msgid "Serving static files from a cloud service or CDN"
msgstr "클라우드 서비스나 CDN으로 정적 파일 제공하기"

msgid ""
"Another common tactic is to serve static files from a cloud storage provider "
"like Amazon's S3 and/or a CDN (content delivery network). This lets you "
"ignore the problems of serving static files and can often make for faster-"
"loading web pages (especially when using a CDN)."
msgstr ""

msgid ""
"When using these services, the basic workflow would look a bit like the "
"above, except that instead of using ``rsync`` to transfer your static files "
"to the server you'd need to transfer the static files to the storage "
"provider or CDN."
msgstr ""
"이러한 서비스를 사용할 때 기본 워크플로우는 위와 약간 비슷하지만 서버에 정적 "
"파일을 전송하기 위해 \"rsync\"를 사용하는 대신 정적 파일을 스토리지 공급자 또"
"는 CDN으로 전송해야 한다는 점을 제외하면 그렇습니다."

msgid ""
"There's any number of ways you might do this, but if the provider has an "
"API, you can use a :doc:`custom file storage backend </howto/custom-file-"
"storage>` to integrate the CDN with your Django project. If you've written "
"or are using a 3rd party custom storage backend, you can tell :djadmin:"
"`collectstatic` to use it by setting :setting:`STATICFILES_STORAGE` to the "
"storage engine."
msgstr ""
"여러 가지 방법을 사용할 수 있지만 제공자에 API가 있는 경우 :doc:'사용자 정의 "
"파일 스토리지 백엔드를 사용하여 CDN을 Django 프로젝트와 통합할 수 있습니다. "
"타사 사용자 지정 스토리지 백엔드를 작성했거나 사용 중인 경우 :"
"djadmin:'collectstatic'을 설정하여 사용할 수 있습니다.static "
"files_storage'를 저장 엔진에 연결합니다."

msgid ""
"For example, if you've written an S3 storage backend in ``myproject.storage."
"S3Storage`` you could use it with::"
msgstr ""
"예를 들어 \"myproject.storage\"에 S3 스토리지 백엔드를 작성한 경우입니다."
"S3Storage는 다음과 같은 용도로 사용할 수 있습니다."

msgid ""
"Once that's done, all you have to do is run :djadmin:`collectstatic` and "
"your static files would be pushed through your storage package up to S3. If "
"you later needed to switch to a different storage provider, you may only "
"have to change your :setting:`STATICFILES_STORAGE` setting."
msgstr ""
"작업이 완료되면 djadmin:'collectstatic'만 실행하면 정적 파일이 스토리지 패키"
"지를 통해 S3까지 푸시됩니다. 나중에 다른 스토리지 제공자로 전환해야 하는 경"
"우 :seting:'만 변경하면 됩니다.정적 파일_저장소' 설정입니다."

msgid ""
"For details on how you'd write one of these backends, see :doc:`/howto/"
"custom-file-storage`. There are 3rd party apps available that provide "
"storage backends for many common file storage APIs. A good starting point is "
"the `overview at djangopackages.org <https://djangopackages.org/grids/g/"
"storage-backends/>`_."
msgstr ""
"백엔드를 작성하는 방법에 대한 자세한 내용은:doc:'/how to/custom-file-"
"storage'를 참조하십시오. 많은 공통 파일 스토리지 API에 대한 스토리지 백엔드"
"를 제공하는 타사 앱이 있습니다. 좋은 출발점이 바로 djangopackages.org입니다."

msgid "Learn more"
msgstr "추가사항"

msgid ""
"For complete details on all the settings, commands, template tags, and other "
"pieces included in :mod:`django.contrib.staticfiles`, see :doc:`the "
"staticfiles reference </ref/contrib/staticfiles>`."
msgstr ""
":mod:'django.contrib.static files'에 포함된 모든 설정, 명령, 템플릿 태그 및 "
"기타 항목에 대한 자세한 내용은 :doc:'static files reference'를 참조하십시오."

msgid "How to manage static files (e.g. images, JavaScript, CSS)"
msgstr ""

msgid ""
"Websites generally need to serve additional files such as images, "
"JavaScript, or CSS. In Django, we refer to these files as \"static files\".  "
"Django provides :mod:`django.contrib.staticfiles` to help you manage them."
msgstr ""
"웹 사이트는 일반적으로 이미지, JavaScript 또는 CSS와 같은 추가 파일을 제공해"
"야 합니다. Django에서는 이러한 파일을 \"static files\"라고 합니다. Django는 :"
"mod:'django.contrib.static files'를 제공하여 파일 관리를 도와줍니다."

msgid "This page describes how you can serve these static files."
msgstr "이 페이지에서는 이러한 정적 파일을 서비스하는 방법에 대해 설명합니다."

msgid "Configuring static files"
msgstr "정적 파일을 구성하는 중입니다."

msgid ""
"Make sure that ``django.contrib.staticfiles`` is included in your :setting:"
"`INSTALLED_APPS`."
msgstr ""
"\"django.contrib.static files\"가 다음 설정에 포함되도록 하십시오. :setting:"
"`INSTALLED_APPS`."

msgid "In your settings file, define :setting:`STATIC_URL`, for example::"
msgstr "설정 파일에서 다음을 정의합니다.:setting:`STATIC_URL`,  예를 들어::"

msgid ""
"In your templates, use the :ttag:`static` template tag to build the URL for "
"the given relative path using the configured :setting:`STATICFILES_STORAGE`."
msgstr ""
"템플릿에서 :ttag:'static' 템플릿 태그를 사용하여 구성된 를 사용하여 지정된:"
"setting:`STATICFILES_STORAGE`.에 대한 URL을 빌드합니다."

msgid ""
"Store your static files in a folder called ``static`` in your app. For "
"example ``my_app/static/my_app/example.jpg``."
msgstr ""
"정적 파일을 앱의 \"static\" 폴더에 저장합니다. 예를 들어 다음과 같습니다."
"``my_app/static/my_app/example.jpg``."

msgid "Serving the files"
msgstr "파일을 제공합니다."

msgid ""
"In addition to these configuration steps, you'll also need to actually serve "
"the static files."
msgstr "이러한 구성 단계 외에도 정적 파일도 실제로 서비스해야 합니다."

msgid ""
"During development, if you use :mod:`django.contrib.staticfiles`, this will "
"be done automatically by :djadmin:`runserver` when :setting:`DEBUG` is set "
"to ``True`` (see :func:`django.contrib.staticfiles.views.serve`)."
msgstr ""
"개발 중에 :mod:'django.contrib.static files'를 사용할 경우 :설정::"
"djadmin:'runserver'에 의해 자동으로 수행됩니다.DEBUG는 \"True\"로 설정되어 있"
"습니다(func:\"django.contrib.static files\" 참조).view.serve')를 입력합니다."

msgid ""
"This method is **grossly inefficient** and probably **insecure**, so it is "
"**unsuitable for production**."
msgstr ""
"이 방법은 **총적으로 비효율적**이며 아마도 **불안한**이므로 **운영에 적합하"
"지 않습니다*."

msgid ""
"See :doc:`/howto/static-files/deployment` for proper strategies to serve "
"static files in production environments."
msgstr ""
"프로덕션 환경에서 정적 파일을 서비스하기 위한 적절한 전략은 :doc:'/how to/"
"static files/deployment'를 참조하십시오."

msgid ""
"Your project will probably also have static assets that aren't tied to a "
"particular app. In addition to using a ``static/`` directory inside your "
"apps, you can define a list of directories (:setting:`STATICFILES_DIRS`) in "
"your settings file where Django will also look for static files. For "
"example::"
msgstr ""
"프로젝트에 특정 앱에 연결되지 않은 정적 자산도 있을 수 있습니다. 앱 내에서 "
"\"static/\" 디렉토리를 사용하는 것 외에도 디렉토리 목록(:seting:\")을 정의할 "
"수 있습니다.Django가 정적 파일도 찾을 수 있는 설정 파일의 STATICFILES_DIRS)입"
"니다. 예를 들어 다음과 같습니다."

msgid ""
"See the documentation for the :setting:`STATICFILES_FINDERS` setting for "
"details on how ``staticfiles`` finds your files."
msgstr ""
":설정:'에 대한 설명서를 참조하십시오.정적 파일_입니다.\"정적 파일\"이 당신의 "
"파일을 어떻게 찾는지에 대한 자세한 내용은 FINDER의 설정입니다."

msgid "Static file namespacing"
msgstr "정적 파일 네임스페이싱"

msgid ""
"Now we *might* be able to get away with putting our static files directly in "
"``my_app/static/`` (rather than creating another ``my_app`` subdirectory), "
"but it would actually be a bad idea. Django will use the first static file "
"it finds whose name matches, and if you had a static file with the same name "
"in a *different* application, Django would be unable to distinguish between "
"them. We need to be able to point Django at the right one, and the best way "
"to ensure this is by *namespacing* them. That is, by putting those static "
"files inside *another* directory named for the application itself."
msgstr ""
"이제 정적 파일을 ``my_app/static/\"에 직접 넣어도 (또 다른 ``my_app\" 서브디"
"렉토리가 아니라) 벗어날 수 있을지 모르지만, 실제로는 좋지 않은 생각일 것입니"
"다. Django는 이름이 일치하는 첫 번째 정적 파일을 사용하며, *different* 애플리"
"케이션에서 동일한 이름의 정적 파일이 있는 경우 Django는 이 파일을 구별할 수 "
"없습니다. 우리는 Django를 제대로 가리킬 수 있어야 하며, 이것을 확실히 하기 위"
"한 최선의 방법은 *이름 간격*을 정하는 것입니다. 즉, 이러한 정적 파일을 애플리"
"케이션 자체용으로 명명된 *또 다른* 디렉토리에 넣습니다."

msgid ""
"You can namespace static assets in :setting:`STATICFILES_DIRS` by "
"specifying :ref:`prefixes <staticfiles-dirs-prefixes>`."
msgstr ""
":seting:'에서 정적 자산의 네임스페이스를 지정할 수 있습니다."
"staticfiles_DIRS'는 다음과 같이 지정합니다.ref:'prefixs'."

msgid "Serving static files during development"
msgstr "개발 중에 정적 파일을 제공합니다."

msgid ""
"If you use :mod:`django.contrib.staticfiles` as explained above, :djadmin:"
"`runserver` will do this automatically when :setting:`DEBUG` is set to "
"``True``. If you don't have ``django.contrib.staticfiles`` in :setting:"
"`INSTALLED_APPS`, you can still manually serve static files using the :func:"
"`django.views.static.serve` view."
msgstr ""
"위에서 설명한 바와 같이 :mod:'django.contrib.static files'를 사용하는 경우 :"
"설정: :djadmin:'runserver'는 자동으로 이 작업을 수행합니다.DEBUG는 \"True"
"\"로 설정되어 있습니다. \"django.contrib.static files\"가 없는 경우 : "
"setting:\"으로 설정합니다.설치되었습니다.APPs'에서는 :func:'django'를 사용하"
"여 정적 파일을 수동으로 제공할 수 있습니다.정적이죠.의견을 제시합니다."

msgid ""
"This is not suitable for production use! For some common deployment "
"strategies, see :doc:`/howto/static-files/deployment`."
msgstr ""
"이것은 생산용으로 적합하지 않습니다! 일반적인 배포 전략은 :doc:'/how to/"
"static-files/deploy'를 참조하십시오."

msgid ""
"For example, if your :setting:`STATIC_URL` is defined as ``static/``, you "
"can do this by adding the following snippet to your urls.py::"
msgstr ""

msgid ""
"This helper function works only in debug mode and only if the given prefix "
"is local (e.g. ``static/``) and not a URL (e.g. ``http://static.example.com/"
"``)."
msgstr ""

msgid ""
"Also this helper function only serves the actual :setting:`STATIC_ROOT` "
"folder; it doesn't perform static files discovery like :mod:`django.contrib."
"staticfiles`."
msgstr ""
"또한 이 도우미 기능은 실제 :seting:'만 제공합니다.STATIC_ROOT' 폴더. :"
"mod:'django.contrib.static files'와 같은 정적 파일 검색을 수행하지 않습니다."

msgid ""
"Finally, static files are served via a wrapper at the WSGI application "
"layer. As a consequence, static files requests do not pass through the "
"normal :doc:`middleware chain </topics/http/middleware>`."
msgstr ""

msgid "Serving files uploaded by a user during development"
msgstr "개발 중에 사용자가 업로드한 파일을 제공합니다."

msgid ""
"During development, you can serve user-uploaded media files from :setting:"
"`MEDIA_ROOT` using the :func:`django.views.static.serve` view."
msgstr ""
"개발 중에:설정:에서 사용자가 업로드한 미디어 파일을 제공할 수 있습니"
"다.'MEDIA_ROOT'는 :func:'django'를 사용합니다.정적이죠.의견을 제시합니다."

msgid ""
"For example, if your :setting:`MEDIA_URL` is defined as ``media/``, you can "
"do this by adding the following snippet to your :setting:`ROOT_URLCONF`::"
msgstr ""

msgid ""
"This helper function works only in debug mode and only if the given prefix "
"is local (e.g. ``media/``) and not a URL (e.g. ``http://media.example.com/"
"``)."
msgstr ""

msgid ""
"When running tests that use actual HTTP requests instead of the built-in "
"testing client (i.e. when using the built-in :class:`LiveServerTestCase "
"<django.test.LiveServerTestCase>`) the static assets need to be served along "
"the rest of the content so the test environment reproduces the real one as "
"faithfully as possible, but ``LiveServerTestCase`` has only very basic "
"static file-serving functionality: It doesn't know about the finders feature "
"of the ``staticfiles`` application and assumes the static content has "
"already been collected under :setting:`STATIC_ROOT`."
msgstr ""
"내장된 테스트 클라이언트 대신 실제 HTTP 요청을 사용하는 테스트를 실행하는 경"
"우(즉, 내장된 :class를 사용하는 경우):\"LiveServerTestCase >django.test입니"
"다.'라이브서버 테스트 사례') 정적 자산은 콘텐츠의 나머지 부분에 제공되어야 테"
"스트 환경이 가능한 한 충실하게 실제 데이터를 재현할 수 있지만 ``라이브서버 테"
"스트 사례\"는 매우 기본적인 정적 파일 서비스 기능만 갖추고 있습니다. 정적인 "
"파일(static files) 애플리케이션의 파인더 기능에 대해서는 알지 못하며 정적인 "
"내용은 이미 다음과 같은 설정으로 수집되었다고 가정합니다.STATIC_ROOT'입니다."

msgid ""
"Because of this, ``staticfiles`` ships its own :class:`django.contrib."
"staticfiles.testing.StaticLiveServerTestCase`, a subclass of the built-in "
"one that has the ability to transparently serve all the assets during "
"execution of these tests in a way very similar to what we get at development "
"time with ``DEBUG = True``, i.e. without having to collect them using :"
"djadmin:`collectstatic` first."
msgstr ""
"이 때문에 \"정적 파일\"은 자체 클래스인 \"django.contrib.static files.testing"
"\"을 제공합니다.StaticLiveServer TestCase'는 이러한 테스트를 실행하는 동안 모"
"든 자산을 \"DEBUG @ True\"로 개발 시 얻은 것과 매우 유사한 방식으로 투명하게 "
"처리할 수 있는 내장형 테스트 사례의 하위 클래스로서, 즉 \"staticadmin:"
"\"collectstatic\"을 먼저 사용할 필요가 없습니다."

msgid "Deployment"
msgstr "배치"

msgid ""
":mod:`django.contrib.staticfiles` provides a convenience management command "
"for gathering static files in a single directory so you can serve them "
"easily."
msgstr ""
":mod:'django.static files'는 정적 파일을 한 디렉토리로 수집하여 쉽게 제공할 "
"수 있도록 편리한 관리 명령을 제공합니다."

msgid ""
"Set the :setting:`STATIC_ROOT` setting to the directory from which you'd "
"like to serve these files, for example::"
msgstr ""
": setting:'을 설정합니다.STATIC_ROOT' 설정은 다음과 같이 이러한 파일을 제공"
"할 디렉토리로 설정합니다."

msgid "Run the :djadmin:`collectstatic` management command::"
msgstr ":djadmin:'collectstatic' 관리 명령을 실행합니다."

msgid ""
"This will copy all files from your static folders into the :setting:"
"`STATIC_ROOT` directory."
msgstr ""
"그러면 정적 폴더의 모든 파일이 :seting:'로 복사됩니다.STATIC_ROOT' 디렉토리입"
"니다."

msgid ""
"Use a web server of your choice to serve the files. :doc:`/howto/static-"
"files/deployment` covers some common deployment strategies for static files."
msgstr ""
"선택한 웹 서버를 사용하여 파일을 제공합니다. :doc:'/how to/static files/"
"deployment'에서는 정적 파일에 대한 몇 가지 일반적인 배포 전략을 다룹니다."

msgid ""
"This document has covered the basics and some common usage patterns. For "
"complete details on all the settings, commands, template tags, and other "
"pieces included in :mod:`django.contrib.staticfiles`, see :doc:`the "
"staticfiles reference </ref/contrib/staticfiles>`."
msgstr ""
"이 문서에서는 기본 사항 및 몇 가지 일반적인 사용 패턴을 다룹니다. :"
"mod:'django.contrib.static files'에 포함된 모든 설정, 명령, 템플릿 태그 및 기"
"타 항목에 대한 자세한 내용은 :doc:'static files reference'를 참조하십시오."

msgid "How to upgrade Django to a newer version"
msgstr ""

msgid ""
"While it can be a complex process at times, upgrading to the latest Django "
"version has several benefits:"
msgstr ""
"때로는 복잡한 프로세스일 수도 있지만 최신 Django 버전으로 업그레이드하면 다음"
"과 같은 여러 가지 이점이 있습니다."

msgid "New features and improvements are added."
msgstr "새로운 기능과 향상된 기능이 추가되었습니다."

msgid "Bugs are fixed."
msgstr "버그 수정되었습니다."

msgid ""
"Older version of Django will eventually no longer receive security updates. "
"(see :ref:`supported-versions-policy`)."
msgstr ""
"이전 버전의 Django는 결국 더 이상 보안 업데이트를 받지 않습니다. (ref:'지원-"
"포함-정책' 참조)"

msgid ""
"Upgrading as each new Django release is available makes future upgrades less "
"painful by keeping your code base up to date."
msgstr ""
"새로운 Django 릴리스가 출시될 때마다 업그레이드하면 코드베이스를 최신 상태로 "
"유지하여 향후 업그레이드의 부담을 줄일 수 있습니다."

msgid ""
"Here are some things to consider to help make your upgrade process as smooth "
"as possible."
msgstr ""
"다음은 업그레이드 프로세스를 최대한 원활하게 수행하기 위해 고려해야 할 몇 가"
"지 사항입니다."

msgid "Required Reading"
msgstr "읽는 것이 요구됩니다."

msgid ""
"If it's your first time doing an upgrade, it is useful to read the :doc:"
"`guide on the different release processes </internals/release-process>`."
msgstr ""
"업그레이드를 처음 하는 경우에는 다른 릴리스 프로세스에 대한 :doc:'가이드'를 "
"읽어보는 것이 유용합니다."

msgid ""
"Afterward, you should familiarize yourself with the changes that were made "
"in the new Django version(s):"
msgstr ""

msgid ""
"Read the :doc:`release notes </releases/index>` for each 'final' release "
"from the one after your current Django version, up to and including the "
"version to which you plan to upgrade."
msgstr ""
"업그레이드하려는 버전을 포함하여 현재 Django 버전 이후 버전에서 \"final\" 릴"
"리스별로 \":doc:'release note\"를 읽어보십시오."

msgid ""
"Look at the :doc:`deprecation timeline</internals/deprecation>` for the "
"relevant versions."
msgstr "관련 버전에 대한 :doc:'감소 시간표'를 보십시오."

msgid ""
"Pay particular attention to backwards incompatible changes to get a clear "
"idea of what will be needed for a successful upgrade."
msgstr ""
"이전 버전과 호환되지 않는 변경 사항에 특히 주의를 기울여 성공적인 업그레이드"
"에 무엇이 필요한지 명확하게 파악합니다."

msgid ""
"If you're upgrading through more than one feature version (e.g. 2.0 to 2.2), "
"it's usually easier to upgrade through each feature release incrementally "
"(2.0 to 2.1 to 2.2) rather than to make all the changes for each feature "
"release at once. For each feature release, use the latest patch release (e."
"g. for 2.1, use 2.1.15)."
msgstr ""
"둘 이상의 기능 버전(예: 2.0에서 2.2로)을 통해 업그레이드하는 경우 일반적으로 "
"각 기능 릴리스에 대한 모든 내용을 한 번에 변경하는 것보다 각 기능 릴리스(2.0"
"에서 2.1에서 2.2)를 통해 업그레이드하는 것이 더 쉽습니다. 각 기능 릴리스에 대"
"해 최신 패치 릴리스(예: 2.1의 경우 2.1.15 사용)를 사용합니다."

msgid ""
"The same incremental upgrade approach is recommended when upgrading from one "
"LTS to the next."
msgstr ""
"한 LTS에서 다음 LTS로 업그레이드할 때도 동일한 증분 업그레이드 방법을 사용하"
"는 것이 좋습니다."

msgid "Dependencies"
msgstr "의존성"

msgid ""
"In most cases it will be necessary to upgrade to the latest version of your "
"Django-related dependencies as well. If the Django version was recently "
"released or if some of your dependencies are not well-maintained, some of "
"your dependencies may not yet support the new Django version. In these cases "
"you may have to wait until new versions of your dependencies are released."
msgstr ""
"대부분의 경우 Django 관련 종속성의 최신 버전으로 업그레이드해야 합니다. 최근"
"에 Django 버전이 릴리스되었거나 일부 종속성이 제대로 유지되지 않은 경우 일부 "
"종속성이 새 Django 버전을 아직 지원하지 않을 수 있습니다. 이러한 경우 종속성"
"의 새 버전이 릴리스될 때까지 기다려야 할 수도 있습니다."

msgid "Resolving deprecation warnings"
msgstr "사용 중지 경고를 해결하는 중입니다."

msgid ""
"Before upgrading, it's a good idea to resolve any deprecation warnings "
"raised by your project while using your current version of Django. Fixing "
"these warnings before upgrading ensures that you're informed about areas of "
"the code that need altering."
msgstr ""
"업그레이드하기 전에 현재 버전의 Django를 사용하는 동안 프로젝트에서 발생하는 "
"모든 사용 중단 경고를 해결하는 것이 좋습니다. 업그레이드하기 전에 이러한 경고"
"를 수정하면 변경해야 하는 코드 영역에 대한 정보를 얻을 수 있습니다."

msgid ""
"In Python, deprecation warnings are silenced by default. You must turn them "
"on using the ``-Wa`` Python command line option or the :envvar:"
"`PYTHONWARNINGS` environment variable. For example, to show warnings while "
"running tests:"
msgstr ""
"Python에서는 기본적으로 사용되지 않음 경고가 표시되지 않습니다. \"-Wa' "
"Python 명령줄 옵션 또는 :envvar:\"PYthon WARINGS\" 환경 변수를 사용하여 이 옵"
"션을 켜야 합니다. 예를 들어 테스트를 실행하는 동안 경고를 표시하려면 다음을 "
"수행합니다."

msgid ""
"If you're not using the Django test runner, you may need to also ensure that "
"any console output is not captured which would hide deprecation warnings. "
"For example, if you use `pytest <https://pytest.org/>`__:"
msgstr ""
"Django 테스트 러너를 사용하지 않는 경우, 사용되지 않는 경고를 숨기기 위해 콘"
"솔 출력이 캡처되지 않았는지 확인해야 할 수도 있습니다. 예를 들어 'pytest "
"https://pytest.org/'__을(를) 사용하는 경우 다음을 수행합니다."

msgid ""
"Resolve any deprecation warnings with your current version of Django before "
"continuing the upgrade process."
msgstr ""
"업그레이드 프로세스를 계속하기 전에 현재 버전의 Django를 사용하여 더 이상 사"
"용되지 않는 경고를 해결하십시오."

msgid ""
"Third party applications might use deprecated APIs in order to support "
"multiple versions of Django, so deprecation warnings in packages you've "
"installed don't necessarily indicate a problem. If a package doesn't support "
"the latest version of Django, consider raising an issue or sending a pull "
"request for it."
msgstr ""
"타사 응용 프로그램은 여러 버전의 Django를 지원하기 위해 사용되지 않는 API를 "
"사용할 수 있으므로 설치한 패키지의 사용되지 않음 경고가 반드시 문제를 나타내"
"는 것은 아닙니다. 패키지가 최신 버전의 Django를 지원하지 않는 경우 문제를 제"
"기하거나 Django에 대한 꺼내기 요청을 보내는 것을 고려하십시오."

msgid "Installation"
msgstr "설치, 설치본"

msgid ""
"Once you're ready, it is time to :doc:`install the new Django version </"
"topics/install>`. If you are using a :mod:`virtual environment <venv>` and "
"it is a major upgrade, you might want to set up a new environment with all "
"the dependencies first."
msgstr ""
"준비가 되면 :doc:'새 Django 버전을 설치해야 합니다. :mod:'가상 환경'을 사용하"
"는 경우 주요 업그레이드인 경우 먼저 모든 종속성을 포함하는 새 환경을 설정할 "
"수 있습니다."

msgid ""
"If you installed Django with pip_, you can use the ``--upgrade`` or ``-U`` "
"flag:"
msgstr ""
"ip_와 함께 django를 설치했다면 \"--upgrade\" 또는 \"-U\" 플래그를 사용할 수 "
"있습니다."

msgid ""
"When the new environment is set up, :doc:`run the full test suite </topics/"
"testing/overview>` for your application. Again, it's useful to turn on "
"deprecation warnings on so they're shown in the test output (you can also "
"use the flag if you test your app manually using ``manage.py runserver``):"
msgstr ""
"새 환경이 설정되면 :doc:'전체 테스트 스위트'를 실행합니다. 다시 말해, 사용되"
"지 않는 경고를 테스트 출력에 표시하도록 켜는 것이 유용합니다. ``manage.py "
"runserver\"를 사용하여 앱을 수동으로 테스트하는 경우에도 플래그를 사용할 수 "
"있습니다."

msgid ""
"After you have run the tests, fix any failures. While you have the release "
"notes fresh in your mind, it may also be a good time to take advantage of "
"new features in Django by refactoring your code to eliminate any deprecation "
"warnings."
msgstr ""
"테스트를 실행한 후 오류를 수정하십시오. 릴리스 노트를 새로이 마음에 두고 있지"
"만 사용 중인 코드를 리팩터링하여 더 이상 사용하지 않도록 함으로써 Django의 새"
"로운 기능을 활용할 수도 있습니다."

msgid ""
"When you are sufficiently confident your app works with the new version of "
"Django, you're ready to go ahead and :doc:`deploy </howto/deployment/index>` "
"your upgraded Django project."
msgstr ""
"당신의 앱이 새로운 버전의 Django와 잘 작동한다고 확신하면, 당신은 당신의 업그"
"레이드된 Django 프로젝트를 진행할 준비가 되어 있습니다."

msgid ""
"If you are using caching provided by Django, you should consider clearing "
"your cache after upgrading. Otherwise you may run into problems, for "
"example, if you are caching pickled objects as these objects are not "
"guaranteed to be pickle-compatible across Django versions. A past instance "
"of incompatibility was caching pickled :class:`~django.http.HttpResponse` "
"objects, either directly or indirectly via the :func:`~django.views."
"decorators.cache.cache_page` decorator."
msgstr ""
"Django에서 제공하는 캐시를 사용하는 경우 업그레이드 후 캐시 지우기를 고려해"
"야 합니다. 그렇지 않으면 예를 들어 절인 개체를 캐싱하는 경우 문제가 발생할 "
"수 있습니다. 이러한 개체는 Django 버전에서 피클 호환이 보장되지 않기 때문입니"
"다. 과거 비호환성의 인스턴스는 caching peilt:class였습니다.'~django.the' 입니"
"다.HttpResponse' 객체는 :func:'~django를 통해 직접 또는 간접적으로 생성됩니"
"다.inviews.incache.cache_page' decorator입니다."

msgid "How to install Django on Windows"
msgstr "윈도우즈에 Django 설치하기"

msgid ""
"This document will guide you through installing Python 3.8 and Django on "
"Windows. It also provides instructions for setting up a virtual environment, "
"which makes it easier to work on Python projects. This is meant as a "
"beginner's guide for users working on Django projects and does not reflect "
"how Django should be installed when developing patches for Django itself."
msgstr ""
"이 문서는 Windows에 Python 3.8 및 Django를 설치하는 과정을 안내합니다. 또한 "
"Python 프로젝트에서 보다 쉽게 작업할 수 있도록 가상 환경 설정에 대한 지침을 "
"제공합니다. 이것은 Django 프로젝트를 하는 사용자들을 위한 초보자 가이드로서 "
"의미되며, Django 자체에 대한 패치를 개발할 때 Django가 어떻게 설치되어야 하는"
"지 반영하지 않습니다."

msgid ""
"The steps in this guide have been tested with Windows 10. In other versions, "
"the steps would be similar. You will need to be familiar with using the "
"Windows command prompt."
msgstr ""
"이 가이드의 단계는 Windows 10에서 테스트되었습니다. 다른 버전에서는 단계가 비"
"슷합니다. Windows(윈도우) 명령 프롬프트를 사용하는 방법을 숙지해야 합니다."

msgid "Install Python"
msgstr "파이썬 설치"

msgid ""
"Django is a Python web framework, thus requiring Python to be installed on "
"your machine. At the time of writing, Python 3.8 is the latest version."
msgstr ""
"Django는 Python 웹 프레임워크이므로 Python을 컴퓨터에 설치해야 합니다. 현재 "
"Python 3.8은 최신 버전입니다."

msgid ""
"To install Python on your machine go to https://www.python.org/downloads/. "
"The website should offer you a download button for the latest Python "
"version. Download the executable installer and run it. Check the boxes next "
"to \"Install launcher for all users (recommended)\" then click \"Install Now"
"\"."
msgstr ""

msgid ""
"After installation, open the command prompt and check that the Python "
"version matches the version you installed by executing::"
msgstr ""
"설치 후에는 커맨드 프롬프트를 열어서 설치된 파이썬 버전과 방금 설치한 파이썬 "
"버전이 같은지 확인하세요."

msgid "For more details, see :doc:`python:using/windows` documentation."
msgstr "자세한 내용은:doc:'python:using/window' 설명서를 참조하십시오."

msgid "About ``pip``"
msgstr "``pip``\\에 대하여"

msgid ""
"`pip`_ is a package manager for Python and is included by default with the "
"Python installer. It helps to install and uninstall Python packages (such as "
"Django!). For the rest of the installation, we'll use ``pip`` to install "
"Python packages from the command line."
msgstr ""
"pip_은(는) Python용 패키지 관리자이며 기본적으로 Python 설치 관리자에 포함되"
"어 있습니다. Python 패키지(예: Django!)를 설치하고 제거하는 데 도움이 됩니"
"다. 나머지 설치 시에는 \"pip\"을 사용하여 명령줄에서 Python 패키지를 설치할 "
"것입니다."

msgid "Setting up a virtual environment"
msgstr "가상 환경을 설정합니다."

msgid ""
"It is best practice to provide a dedicated environment for each Django "
"project you create. There are many options to manage environments and "
"packages within the Python ecosystem, some of which are recommended in the "
"`Python documentation <https://packaging.python.org/guides/tool-"
"recommendations/>`_. Python itself comes with :doc:`venv <python:tutorial/"
"venv>` for managing environments which we will use for this guide."
msgstr ""
"생성하는 각 Django 프로젝트에 전용 환경을 제공하는 것이 좋습니다. 파이썬 생태"
"계 내 환경 및 패키지를 관리할 수 있는 여러 가지 옵션이 있으며 이 중 일부는 파"
"이썬 설명서(https://packaging.python.org/guides/tool-recommendations/)에 나"
"와 있습니다. Python 자체는 우리가 이 가이드에 사용할 환경을 관리하기 위한 :"
"doc:'venv <python:tutorial/venv'와 함께 제공됩니다."

msgid ""
"To create a virtual environment for your project, open a new command prompt, "
"navigate to the folder where you want to create your project and then enter "
"the following::"
msgstr ""
"프로젝트의 가상 환경을 생성하려면 새 명령 프롬프트를 열고 프로젝트를 생성할 "
"폴더로 이동한 다음 다음을 입력합니다."

msgid ""
"This will create a folder called 'project-name' if it does not already exist "
"and set up the virtual environment. To activate the environment, run::"
msgstr ""

msgid ""
"The virtual environment will be activated and you'll see \"(project-name)\" "
"next to the command prompt to designate that. Each time you start a new "
"command prompt, you'll need to activate the environment again."
msgstr ""
"가상 환경이 활성화되고 명령 프롬프트 옆에 \"(프로젝트 이름)\"이 표시되어 가"
"상 환경을 지정합니다. 새 명령 프롬프트를 시작할 때마다 환경을 다시 활성화해"
"야 합니다."

msgid "Install Django"
msgstr "장고 설치"

msgid ""
"Django can be installed easily using ``pip`` within your virtual environment."
msgstr "Django는 가상 환경 내에서 \"pip\"을 사용하여 쉽게 설치할 수 있습니다."

msgid ""
"In the command prompt, ensure your virtual environment is active, and "
"execute the following command::"
msgstr ""
"명령 프롬프트에서 가상 환경이 활성 상태인지 확인하고 다음 명령을 실행합니다."

msgid "This will download and install the latest Django release."
msgstr "그러면 최신 Django 릴리스가 다운로드되고 설치됩니다."

msgid ""
"After the installation has completed, you can verify your Django "
"installation by executing ``django-admin --version`` in the command prompt."
msgstr ""
"설치가 완료되면 명령 프롬프트에서 \"django-admin --version\"을 실행하여 "
"Django 설치를 확인할 수 있습니다."

msgid ""
"See :ref:`database-installation` for information on database installation "
"with Django."
msgstr ""
"Django와의 데이터베이스 설치에 대한 자세한 내용은:ref:'데이터베이스 설치'를 "
"참조하십시오."

msgid "Colored terminal output"
msgstr ""

msgid ""
"A quality-of-life feature adds colored (rather than monochrome) output to "
"the terminal. In modern terminals this should work for both CMD and "
"PowerShell. If for some reason this needs to be disabled, set the "
"environmental variable :envvar:`DJANGO_COLORS` to ``nocolor``."
msgstr ""

msgid ""
"On older Windows versions, or legacy terminals, colorama_ must be installed "
"to enable syntax coloring::"
msgstr ""

msgid "See :ref:`syntax-coloring` for more information on color settings."
msgstr ""

msgid "Common pitfalls"
msgstr "공통적인 함정"

msgid ""
"If ``django-admin`` only displays the help text no matter what arguments it "
"is given, there is probably a problem with the file association in Windows. "
"Check if there is more than one environment variable set for running Python "
"scripts in ``PATH``. This usually occurs when there is more than one Python "
"version installed."
msgstr ""
"만약 \"django-admin\"이 어떤 주장이 주어지더라도 도움말 텍스트만 표시한다면, "
"윈도우의 파일 연결에 문제가 있을 것입니다. \"PATH\"에서 Python 스크립트를 실"
"행하기 위해 둘 이상의 환경 변수가 설정되어 있는지 확인합니다. 일반적으로 "
"Python 버전이 두 개 이상 설치된 경우 이러한 문제가 발생합니다."

msgid ""
"If you are connecting to the internet behind a proxy, there might be "
"problems in running the command ``py -m pip install Django``. Set the "
"environment variables for proxy configuration in the command prompt as "
"follows::"
msgstr ""
"만일 당신이 대리인을 통해 인터넷에 접속한다면 ``py-mp install Django\"라는 명"
"령어를 실행하는 데 문제가 있을 수 있습니다. 명령 프롬프트에서 다음과 같이 프"
"록시 구성에 대한 환경 변수를 설정합니다."

msgid ""
"In general, Django assumes that ``UTF-8`` encoding is used for I/O. This may "
"cause problems if your system is set to use a different encoding. Recent "
"versions of Python allow setting the :envvar:`PYTHONUTF8` environment "
"variable in order to force a ``UTF-8`` encoding. Windows 10 also provides a "
"system-wide setting by checking ``Use Unicode UTF-8 for worldwide language "
"support`` in :menuselection:`Language --> Administrative Language Settings --"
"> Change system locale` in system settings."
msgstr ""

msgid "How to create database migrations"
msgstr ""

msgid ""
"This document explains how to structure and write database migrations for "
"different scenarios you might encounter. For introductory material on "
"migrations, see :doc:`the topic guide </topics/migrations>`."
msgstr ""
"이 문서에서는 발생할 수 있는 다양한 시나리오에 대해 데이터베이스 마이그레이션"
"을 구성하고 쓰는 방법을 설명합니다. 마이그레이션에 대한 소개 자료는 :doc: '주"
"제 가이드'를 참조하십시오."

msgid "Data migrations and multiple databases"
msgstr "데이터 마이그레이션 및 여러 데이터베이스를 사용합니다."

msgid ""
"When using multiple databases, you may need to figure out whether or not to "
"run a migration against a particular database. For example, you may want to "
"**only** run a migration on a particular database."
msgstr ""
"여러 데이터베이스를 사용할 때 특정 데이터베이스에 대해 마이그레이션을 실행할"
"지 여부를 결정해야 할 수도 있습니다. 예를 들어 특정 데이터베이스에서 **만* 마"
"이그레이션을 실행할 수 있습니다."

msgid ""
"In order to do that you can check the database connection's alias inside a "
"``RunPython`` operation by looking at the ``schema_editor.connection.alias`` "
"attribute::"
msgstr ""
"그러기 위해서 당신은 ``schema_editor.connection\"을 보면 ``RunPython\" 운영 "
"내에서 데이터베이스 연결의 별칭을 확인할 수 있습니다.별칭 속성:입니다."

msgid ""
"You can also provide hints that will be passed to the :meth:"
"`allow_migrate()` method of database routers as ``**hints``:"
msgstr "<div></div>"

msgid "myapp/dbrouters.py"
msgstr "myapp/dbrouters.py"

msgid "Then, to leverage this in your migrations, do the following::"
msgstr "마이그레이션 시 이 기능을 활용하려면 다음을 수행하십시오."

msgid ""
"If your ``RunPython`` or ``RunSQL`` operation only affects one model, it's "
"good practice to pass ``model_name`` as a hint to make it as transparent as "
"possible to the router. This is especially important for reusable and third-"
"party apps."
msgstr ""
"만일 당신의 ``RunPython\" 또는 \"RunSQL\" 작업이 하나의 모델에만 영향을 준다"
"면, 가능한 한 투명하게 라우터에 알리기 위해 \"model_name\"을 힌트로 전달하는 "
"것이 좋은 관행입니다. 이는 재사용 가능한 앱과 타사 앱에서 특히 중요합니다."

msgid "Migrations that add unique fields"
msgstr "고유한 필드를 추가하는 마이그레이션입니다."

msgid ""
"Applying a \"plain\" migration that adds a unique non-nullable field to a "
"table with existing rows will raise an error because the value used to "
"populate existing rows is generated only once, thus breaking the unique "
"constraint."
msgstr ""
"기존 행이 있는 테이블에 null이 아닌 고유한 필드를 추가하는 \"일반\" 마이그레"
"이션을 적용하면 기존 행을 채우는 데 사용되는 값이 한 번만 생성되므로 고유한 "
"제약 조건이 해제되기 때문에 오류가 발생합니다."

msgid ""
"Therefore, the following steps should be taken. In this example, we'll add a "
"non-nullable :class:`~django.db.models.UUIDField` with a default value. "
"Modify the respective field according to your needs."
msgstr ""
"따라서 다음 단계를 수행해야 합니다. 이 예에서는 Null이 아닌 :class를 추가합니"
"다.'~django.db.db.class입니다.기본값인 UUIDField'입니다. 필요에 따라 각 필드"
"를 수정합니다."

msgid ""
"Add the field on your model with ``default=uuid.uuid4`` and ``unique=True`` "
"arguments (choose an appropriate default for the type of the field you're "
"adding)."
msgstr ""
"``default = uuid\"를 사용하여 모델에 필드를 추가합니다.uuid4와 \"hydp*\"로 구"
"성됩니다.True' 인수(추가하려는 필드 유형에 적합한 기본값 선택)를 선택합니다."

msgid ""
"Run the :djadmin:`makemigrations` command. This should generate a migration "
"with an ``AddField`` operation."
msgstr ""
":djadmin:'make migration' 명령을 실행합니다. 이는 ``Add Field\" 작전으로 이주"
"를 창출해야 합니다."

msgid ""
"Generate two empty migration files for the same app by running "
"``makemigrations myapp --empty`` twice. We've renamed the migration files to "
"give them meaningful names in the examples below."
msgstr ""
"동일한 앱에 대해 \"마이 앱으로 마이그레이션 -- 비우기\"를 두 번 실행하여 두 "
"개의 빈 마이그레이션 파일을 생성합니다. 아래의 예에서 의미 있는 이름을 지정하"
"기 위해 마이그레이션 파일의 이름을 변경했습니다."

msgid ""
"Copy the ``AddField`` operation from the auto-generated migration (the first "
"of the three new files) to the last migration, change ``AddField`` to "
"``AlterField``, and add imports of ``uuid`` and ``models``. For example:"
msgstr ""
"\"AddField\" 작업을 자동 생성 마이그레이션(새 파일 3개 중 첫 번째 파일)에서 "
"마지막 마이그레이션으로 복사하고 \"AddField\"를 \"AlterField\"로 변경하고 "
"\"uuid\" 및 \"model\" 수입을 추가합니다. 예를 들어 다음과 같습니다."

msgid "0006_remove_uuid_null.py"
msgstr "0006_remove_uuid_null.py"

msgid ""
"Edit the first migration file. The generated migration class should look "
"similar to this:"
msgstr ""
"첫 번째 마이그레이션 파일을 편집합니다. 생성된 마이그레이션 클래스는 다음과 "
"유사하게 표시되어야 합니다."

msgid "0004_add_uuid_field.py"
msgstr "0004_add_uuid_field.py"

msgid ""
"Change ``unique=True`` to ``null=True`` -- this will create the intermediary "
"null field and defer creating the unique constraint until we've populated "
"unique values on all the rows."
msgstr ""
"''변신''을 하세요.True' to \"null ull True\" -- 이렇게 하면 중간 null 필드가 "
"생성되고 모든 행에 고유 값을 채울 때까지 고유한 제약 조건 생성이 지연됩니다."

msgid ""
"In the first empty migration file, add a :class:`~django.db.migrations."
"operations.RunPython` or :class:`~django.db.migrations.operations.RunSQL` "
"operation to generate a unique value (UUID in the example) for each existing "
"row. Also add an import of ``uuid``. For example:"
msgstr ""
"첫 번째 빈 마이그레이션 파일에서 :class를 추가하십시오.'~django.db."
"migrations.operations입니다.Python' 또는 :class를 실행합니다.'~django.db."
"migrations.operations입니다.SQL 작업을 실행하여 각 기존 행에 대해 고유한 값"
"(예제의 UUID)을 생성합니다. 또한 \"uuid\"의 가져오기를 추가합니다. 예를 들어 "
"다음과 같습니다."

msgid "0005_populate_uuid_values.py"
msgstr "0005_populate_uuid_values.py"

msgid ""
"Now you can apply the migrations as usual with the :djadmin:`migrate` "
"command."
msgstr ""
"이제 :djadmin:'migrate' 명령을 사용하여 평소와 같이 마이그레이션을 적용할 수 "
"있습니다."

msgid ""
"Note there is a race condition if you allow objects to be created while this "
"migration is running. Objects created after the ``AddField`` and before "
"``RunPython`` will have their original ``uuid``’s overwritten."
msgstr ""
"마이그레이션이 실행되는 동안 개체를 만들 수 있는 경우 경합 조건이 있습니다. "
"\"AddField\" 이후와 \"Run Python\" 이전에 만들어진 물체들은 원래의 \"uuid"
"\"를 덮어쓸 것입니다."

msgid "Non-atomic migrations"
msgstr "비원자성 마이그레이션입니다."

msgid ""
"On databases that support DDL transactions (SQLite and PostgreSQL), "
"migrations will run inside a transaction by default. For use cases such as "
"performing data migrations on large tables, you may want to prevent a "
"migration from running in a transaction by setting the ``atomic`` attribute "
"to ``False``::"
msgstr ""
"DDL 트랜잭션을 지원하는 데이터베이스(SQLite 및 Postgre)입니다.SQL) 마이그레이"
"션은 기본적으로 트랜잭션 내에서 실행됩니다. 대형 테이블에서 데이터 마이그레이"
"션을 수행하는 경우와 같은 사용 사례의 경우 \"원자\" 속성을 \"거짓\"으로 설정"
"하여 트랜잭션에서 마이그레이션이 실행되지 않도록 할 수 있습니다."

msgid ""
"Within such a migration, all operations are run without a transaction. It's "
"possible to execute parts of the migration inside a transaction using :func:"
"`~django.db.transaction.atomic()` or by passing ``atomic=True`` to "
"``RunPython``."
msgstr ""
"이러한 마이그레이션 내에서 모든 작업은 트랜잭션 없이 실행됩니다. "
"func:'~django.db.transaction.transaction.transaction.transaction'을 사용하거"
"나 \"transaction\"을 전달하여 트랜잭션 내 마이그레이션의 일부를 실행할 수 있"
"습니다.\"피톤을 운영하라\"는 말은 사실입니다."

msgid ""
"Here's an example of a non-atomic data migration that updates a large table "
"in smaller batches::"
msgstr ""
"다음은 더 작은 배치로 큰 테이블을 업데이트하는 비원자 데이터 마이그레이션의 "
"예입니다."

msgid ""
"The ``atomic`` attribute doesn't have an effect on databases that don't "
"support DDL transactions (e.g. MySQL, Oracle). (MySQL's `atomic DDL "
"statement support <https://dev.mysql.com/doc/refman/en/atomic-ddl.html>`_ "
"refers to individual statements rather than multiple statements wrapped in a "
"transaction that can be rolled back.)"
msgstr ""
"\"원자\" 특성은 DDL 트랜잭션을 지원하지 않는 데이터베이스(예: MySQL, Oracle)"
"에는 영향을 미치지 않습니다. (MySQL의 'dsl statement support https://dev."
"mysql.com/doc/refman/en/atomic-ddl.html'_은(는) 롤백할 수 있는 트랜잭션에 포"
"함된 여러 개의 문이 아닌 개별 문을 말합니다.)"

msgid "Controlling the order of migrations"
msgstr "마이그레이션 순서 제어"

msgid ""
"Django determines the order in which migrations should be applied not by the "
"filename of each migration, but by building a graph using two properties on "
"the ``Migration`` class: ``dependencies`` and ``run_before``."
msgstr ""
"Django는 각 마이그레이션의 파일 이름이 아니라 \"이민\" 클래스의 ``dependency"
"\"와 \"run_before\"라는 두 가지 속성을 사용하여 마이그레이션이 적용되어야 하"
"는 순서를 결정합니다."

msgid ""
"If you've used the :djadmin:`makemigrations` command you've probably already "
"seen ``dependencies`` in action because auto-created migrations have this "
"defined as part of their creation process."
msgstr ""
"\"djadmin:\"make migration\" 명령을 사용했다면 자동 생성된 마이그레이션은 생"
"성 과정의 일부로 정의되기 때문에 \"dependency\"가 이미 실행 중인 것을 보았을 "
"것입니다."

msgid "The ``dependencies`` property is declared like this::"
msgstr "\"의존성\" 재산은 다음과 같이 선언됩니다."

msgid ""
"Usually this will be enough, but from time to time you may need to ensure "
"that your migration runs *before* other migrations. This is useful, for "
"example, to make third-party apps' migrations run *after* your :setting:"
"`AUTH_USER_MODEL` replacement."
msgstr ""
"일반적으로 이 정도면 충분하지만 때때로 마이그레이션이 *다른 마이그레이션 전에"
"* 실행되도록 해야 할 수도 있습니다. 예를 들어, 이 기능은 타사 앱의 마이그레이"
"션을 *다음* 이후에 실행하도록 하는 데 유용합니다. 설정:'AUTH_USER_MODEL을 대"
"체합니다."

msgid ""
"To achieve this, place all migrations that should depend on yours in the "
"``run_before`` attribute on your ``Migration`` class::"
msgstr ""
"이를 위해 귀사에 의존해야 할 모든 마이그레이션을 귀국의 ``이민\" 등급의 ``실"
"행 전\" 속성으로 배치하십시오."

msgid ""
"Prefer using ``dependencies`` over ``run_before`` when possible. You should "
"only use ``run_before`` if it is undesirable or impractical to specify "
"``dependencies`` in the migration which you want to run after the one you "
"are writing."
msgstr ""
"가능하면 ``실행 전\"보다 \"의존적\"을 사용하는 것을 선호합니다. 작성 중인 마"
"이그레이션 이후에 실행할 마이그레이션에 ``의존성\"을 지정하는 것이 바람직하"
"지 않거나 비실용적인 경우에만 \"run_before\"를 사용해야 합니다."

msgid "Migrating data between third-party apps"
msgstr "타사 앱 간에 데이터를 마이그레이션하고 있습니다."

msgid ""
"You can use a data migration to move data from one third-party application "
"to another."
msgstr ""
"데이터 마이그레이션을 사용하여 한 타사 응용 프로그램에서 다른 응용 프로그램으"
"로 데이터를 이동할 수 있습니다."

msgid ""
"If you plan to remove the old app later, you'll need to set the "
"``dependencies`` property based on whether or not the old app is installed. "
"Otherwise, you'll have missing dependencies once you uninstall the old app. "
"Similarly, you'll need to catch :exc:`LookupError` in the ``apps."
"get_model()`` call that retrieves models from the old app. This approach "
"allows you to deploy your project anywhere without first installing and then "
"uninstalling the old app."
msgstr ""
"나중에 기존 앱을 제거할 계획이라면 기존 앱의 설치 여부에 따라 \"의존성\" 속성"
"을 설정해야 합니다. 그렇지 않으면 이전 앱을 제거한 후 종속성이 누락됩니다. 마"
"찬가지로 exc를 확인해야 합니다.기존 앱에서 모델을 검색하는 ``apps."
"get_model()\" 통화에서 \"Lookup Error\"가 발생합니다. 이 방법을 사용하면 먼"
"저 이전 앱을 설치한 다음 제거하지 않고도 프로젝트를 아무 곳에나 배포할 수 있"
"습니다."

msgid "Here's a sample migration:"
msgstr "다음은 마이그레이션 예 입니다:"

msgid "myapp/migrations/0124_move_old_app_to_new_app.py"
msgstr "myapp/migrations/0124_move_old_app_to_new_app.py"

msgid ""
"Also consider what you want to happen when the migration is unapplied. You "
"could either do nothing (as in the example above) or remove some or all of "
"the data from the new application. Adjust the second argument of the :mod:"
"`~django.db.migrations.operations.RunPython` operation accordingly."
msgstr ""
"또한 마이그레이션이 적용되지 않을 때 수행할 작업도 고려하십시오. 위의 예와 같"
"이 아무 작업도 수행하지 않거나 새 응용 프로그램에서 일부 또는 모든 데이터를 "
"제거할 수 있습니다. :mod의 두 번째 인수를 조정합니다.'~django.db.migrations."
"operations입니다.이에 따라 파이썬을 실행합니다."

msgid "Changing a ``ManyToManyField`` to use a ``through`` model"
msgstr "``ManyToManyField`` 를 바꾸어 ``through``  모델을 사용합니다."

msgid ""
"If you change a :class:`~django.db.models.ManyToManyField` to use a "
"``through`` model, the default migration will delete the existing table and "
"create a new one, losing the existing relations. To avoid this, you can use :"
"class:`.SeparateDatabaseAndState` to rename the existing table to the new "
"table name while telling the migration autodetector that the new model has "
"been created. You can check the existing table name through :djadmin:"
"`sqlmigrate` or :djadmin:`dbshell`. You can check the new table name with "
"the through model's ``_meta.db_table`` property. Your new ``through`` model "
"should use the same names for the ``ForeignKey``\\s as Django did. Also if "
"it needs any extra fields, they should be added in operations after :class:`."
"SeparateDatabaseAndState`."
msgstr ""

msgid ""
"For example, if we had a ``Book`` model with a ``ManyToManyField`` linking "
"to ``Author``, we could add a through model ``AuthorBook`` with a new field "
"``is_primary``, like so::"
msgstr ""
"예를 들어 우리가 ``다수로\"를 ``저자\"로 연결한 ``책\" 모델을 가지고 있다면 "
"다음과 같이 새로운 분야의 \"is_primary\"를 가진 ``저자책\"을 추가할 수 있을 "
"것입니다."

msgid "Changing an unmanaged model to managed"
msgstr "관리되지 않는 모델을 관리 대상으로 변경합니다."

msgid ""
"If you want to change an unmanaged model (:attr:`managed=False <django.db."
"models.Options.managed>`) to managed, you must remove ``managed=False`` and "
"generate a migration before making other schema-related changes to the "
"model, since schema changes that appear in the migration that contains the "
"operation to change ``Meta.managed`` may not be applied."
msgstr ""
"관리되지 않는 모델(:attr:'managed >False <django.db.db.closed)을 변경하려는 "
"경우입니다.관리 대상인 Options.managed>'에서는 \"Meta.managed\" 변경 작업을 "
"포함하는 마이그레이션에 표시되는 스키마 변경 사항이 적용되지 않을 수 있으므"
"로 모델을 변경하기 전에 \"Managed =\"을 제거하고 마이그레이션을 생성해야 합니"
"다."
